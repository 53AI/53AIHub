import { y as defineComponent, r as ref, Y as watch, g as withDirectives, v as vShow, b as openBlock, c as createElementBlock, Z as renderSlot, e as createCommentVNode, o as onMounted, a as onUnmounted, z as resolveComponent, d as createBaseVNode, n as normalizeClass, f as createVNode, t as toDisplayString, h as createBlock, i as withCtx, B as createTextVNode, O as unref, cU as download_default, aj as arrow_down_default, aL as zoom_out_default, aM as zoom_in_default, bk as copy_document_default, T as Transition$1, a3 as ElMessage, a4 as ElIcon, Q as _export_sfc, cV as createStaticVNode, bm as refresh_default, cW as share_default, cX as star_default, H as Fragment$1, I as renderList } from "./main-zTjO05wq.js";
import { E as ElDropdownItem, a as ElDropdownMenu, b as ElDropdown } from "./el-dropdown-item-NOVRjZ1y.js";
import "./el-scrollbar-Ngsny-f4.js";
import { c as commonjsGlobal$1 } from "./_commonjsHelpers-jUUCeJQL.js";
const _hoisted_1$6 = { key: 0 };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    value: { default: "" },
    name: { default: "" },
    cache: { type: Boolean, default: true }
  },
  emits: ["load", "show"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const loaded = ref(false);
    watch(
      () => props.value,
      (val2) => {
        if (val2 === props.name) {
          if (!loaded.value) {
            loaded.value = true;
            emits("load");
          }
          emits("show");
        } else {
          if (!props.cache)
            loaded.value = false;
        }
      },
      { immediate: true }
    );
    __expose({
      async reset() {
        loaded.value = false;
      }
    });
    return (_ctx, _cache) => {
      return loaded.value ? withDirectives((openBlock(), createElementBlock("div", _hoisted_1$6, [
        renderSlot(_ctx.$slots, "default")
      ], 512)), [
        [vShow, _ctx.name === _ctx.value]
      ]) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$5 = ["innerHTML"];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "html",
  props: {
    content: { default: "" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "w-4/5 min-h-full mx-auto bg-white p-5 shadow-lg moz-reader-content",
        innerHTML: _ctx.content
      }, null, 8, _hoisted_1$5);
    };
  }
});
const libs = {
  "vditor": {
    id: "vditor-lib",
    src: window.$getPublicPath("/libs/vditor/dist/index.min.js"),
    callback() {
      const css2 = document.createElement("link");
      css2.rel = "stylesheet";
      css2.href = window.$getPublicPath("/libs/vditor/dist/index.css");
      document.head.appendChild(css2);
    }
  }
};
const loadLib = (name2) => {
  if (!libs[name2])
    return Promise.reject();
  if (!libs[name2]._promise) {
    libs[name2]._promise = new Promise((resolve2, reject2) => {
      const { src, id: id2, callback } = libs[name2];
      const script = document.createElement("script");
      script.src = src;
      script.id = id2;
      if (src.endsWith(".mjs"))
        script.type = "module";
      script.onload = () => {
        callback && callback();
        setTimeout(() => {
          resolve2();
        }, 100);
      };
      script.onerror = () => {
        reject2();
      };
      document.body.appendChild(script);
    });
  }
  return libs[name2]._promise;
};
const markdownEditor = async (element, options = {}) => {
  if (!element) {
    element = document.createElement("div");
  }
  await loadLib("vditor");
  return new window.Vditor(element, {
    toolbar: [
      "undo",
      "redo",
      "|",
      "headings",
      "bold",
      "italic",
      "strike",
      "line",
      "quote",
      "|",
      "list",
      "ordered-list",
      "check"
    ],
    mode: "ir",
    // 设置默认的编辑模式
    preview: {},
    cache: {
      enable: false
    },
    cdn: window.$isElectron ? "http://chat53dev.53ai.com/libs/js/vditor" : window.$chat53ai.getPublicPath("/libs/vditor"),
    ...options
  });
};
const _hoisted_1$4 = { class: "h-full relative" };
const _hoisted_2$4 = { class: "absolute right-5 top-1" };
const _hoisted_3$3 = { class: "size-4 flex-center" };
const _hoisted_4$3 = { class: "text-sm" };
const _hoisted_5$2 = { class: "size-4 flex-center" };
const _hoisted_6$2 = { class: "text-sm" };
const _hoisted_7$2 = { class: "size-4 flex-center" };
const _hoisted_8$2 = { class: "text-sm" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "editor",
  props: {
    modelValue: { default: `# Markdown 示例

## 二级标题
这是一个简单的 Markdown 示例

### 三级标题
- 列表项1
- 列表项2
- 列表项3

**加粗文本** 和 *斜体文本*

[链接示例](https://example.com)

\`\`\`javascript
// 代码块示例
function hello() {
  console.log('Hello World')
}
\`\`\`
` }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const menuRef = ref(null);
    const vditor = ref(null);
    const currentMode = ref("wysiwyg");
    const setVditor = () => {
      if (vditor.value) {
        vditor.value.destroy();
      }
      const options = {
        after: () => {
          vditor.value.setValue(props.modelValue);
        },
        input: (value) => {
          emit("update:modelValue", value);
        }
      };
      if (currentMode.value === "wysiwyg") {
        options.mode = "wysiwyg";
      } else if (currentMode.value === "ir") {
        options.mode = "sv";
        options.preview = {
          mode: "both"
        };
      } else if (currentMode.value === "sv") {
        options.mode = "sv";
        options.preview = {
          mode: "editor"
        };
      }
      options.preview = options.preview || {};
      options.preview.actions = [];
      setTimeout(() => {
        vditor.value = markdownEditor("vditor", options);
      }, 100);
    };
    watch(
      () => props.modelValue,
      (newValue) => {
        if (vditor.value && newValue !== vditor.value.getValue()) {
          vditor.value.setValue(newValue);
        }
      }
    );
    const switchMode = (mode) => {
      if (vditor.value && currentMode.value !== mode) {
        currentMode.value = mode;
        setVditor();
      }
    };
    onMounted(() => {
      setVditor();
    });
    onUnmounted(() => {
      if (vditor.value) {
        vditor.value.destroy();
      }
    });
    return (_ctx, _cache) => {
      const _component_svg_icon = resolveComponent("svg-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        _cache[3] || (_cache[3] = createBaseVNode("div", {
          class: "w-full !h-full vditor-custom",
          id: "vditor",
          style: { "--toolbar-background-color": "white" }
        }, null, -1)),
        createBaseVNode("div", _hoisted_2$4, [
          createBaseVNode("div", {
            class: "h-10 flex items-center border rounded px-2",
            ref_key: "menuRef",
            ref: menuRef
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["text-[#4F5052] flex-center gap-2 px-2 cursor-pointer", { "text-[#1e80ff]": currentMode.value === "wysiwyg" }]),
              onClick: _cache[0] || (_cache[0] = ($event) => switchMode("wysiwyg"))
            }, [
              createBaseVNode("div", _hoisted_3$3, [
                createVNode(_component_svg_icon, { name: "edit" })
              ]),
              createBaseVNode("span", _hoisted_4$3, toDisplayString(_ctx.$t("common.preview")), 1)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(["text-[#4F5052] flex-center gap-2 px-2 cursor-pointer border-l", { "text-[#1e80ff]": currentMode.value === "ir" }]),
              onClick: _cache[1] || (_cache[1] = ($event) => switchMode("ir"))
            }, [
              createBaseVNode("div", _hoisted_5$2, [
                createVNode(_component_svg_icon, { name: "layout-split" })
              ]),
              createBaseVNode("span", _hoisted_6$2, toDisplayString(_ctx.$t("common.split")), 1)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(["text-[#4F5052] flex-center gap-2 px-2 cursor-pointer border-l", { "text-[#1e80ff]": currentMode.value === "sv" }]),
              onClick: _cache[2] || (_cache[2] = ($event) => switchMode("sv"))
            }, [
              createBaseVNode("div", _hoisted_7$2, [
                createVNode(_component_svg_icon, {
                  name: "preview",
                  size: "16"
                })
              ]),
              createBaseVNode("span", _hoisted_8$2, toDisplayString(_ctx.$t("common.code")), 1)
            ], 2)
          ], 512)
        ])
      ]);
    };
  }
});
function extend$2(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string2) {
  return string2.replace(/^\n*/, "");
}
function trimTrailingNewlines(string2) {
  var indexEnd = string2.length;
  while (indexEnd > 0 && string2[indexEnd - 1] === "\n")
    indexEnd--;
  return string2.substring(0, indexEnd);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock$1(node2) {
  return is$3(node2, blockElements);
}
var voidElements$1 = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node2) {
  return is$3(node2, voidElements$1);
}
function hasVoid(node2) {
  return has$3(node2, voidElements$1);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node2) {
  return is$3(node2, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node2) {
  return has$3(node2, meaningfulWhenBlankElements);
}
function is$3(node2, tagNames) {
  return tagNames.indexOf(node2.nodeName) >= 0;
}
function has$3(node2, tagNames) {
  return node2.getElementsByTagName && tagNames.some(function(tagName) {
    return node2.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node2, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node2, options) {
    var hLevel = Number(node2.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node2) {
    var parent2 = node2.parentNode;
    if (parent2.nodeName === "LI" && parent2.lastElementChild === node2) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node2, options) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options.bulletListMarker + "   ";
    var parent2 = node2.parentNode;
    if (parent2.nodeName === "OL") {
      var start2 = parent2.getAttribute("start");
      var index2 = Array.prototype.indexOf.call(parent2.children, node2);
      prefix = (start2 ? Number(start2) + index2 : index2 + 1) + ".  ";
    }
    return prefix + content + (node2.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node2, options) {
    return options.codeBlockStyle === "indented" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options) {
    return "\n\n    " + node2.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node2, options) {
    return options.codeBlockStyle === "fenced" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options) {
    var className = node2.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code2 = node2.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match3;
    while (match3 = fenceInCodeRegex.exec(code2)) {
      if (match3[0].length >= fenceSize) {
        fenceSize = match3[0].length + 1;
      }
    }
    var fence2 = repeat(fenceChar, fenceSize);
    return "\n\n" + fence2 + language + "\n" + code2.replace(/\n$/, "") + "\n" + fence2 + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node2, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node2, options) {
    return options.linkStyle === "inlined" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2) {
    var href = node2.getAttribute("href");
    if (href)
      href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title)
      title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node2, options) {
    return options.linkStyle === "referenced" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2, options) {
    var href = node2.getAttribute("href");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement2;
    var reference2;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement2 = "[" + content + "][]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement2 = "[" + content + "]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      default:
        var id2 = this.references.length + 1;
        replacement2 = "[" + content + "][" + id2 + "]";
        reference2 = "[" + id2 + "]: " + href + title;
    }
    this.references.push(reference2);
    return replacement2;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node2, options) {
    if (!content.trim())
      return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node2, options) {
    if (!content.trim())
      return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node2) {
    var hasSiblings = node2.previousSibling || node2.nextSibling;
    var isCodeBlock = node2.parentNode.nodeName === "PRE" && !hasSiblings;
    return node2.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter2 = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter2) !== -1)
      delimiter2 = delimiter2 + "`";
    return delimiter2 + extraSpace + content + extraSpace + delimiter2;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node2) {
    var alt = cleanAttribute(node2.getAttribute("alt"));
    var src = node2.getAttribute("src") || "";
    var title = cleanAttribute(node2.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute2) {
  return attribute2 ? attribute2.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules)
    this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter3) {
    this._keep.unshift({
      filter: filter3,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter3) {
    this._remove.unshift({
      filter: filter3,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node2) {
    if (node2.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node2, this.options))
      return rule;
    if (rule = findRule(this._keep, node2, this.options))
      return rule;
    if (rule = findRule(this._remove, node2, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++)
      fn(this.array[i], i);
  }
};
function findRule(rules2, node2, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node2, options))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node2, options) {
  var filter3 = rule.filter;
  if (typeof filter3 === "string") {
    if (filter3 === node2.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter3)) {
    if (filter3.indexOf(node2.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter3 === "function") {
    if (filter3.call(rule, node2, options))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node3) {
    return node3.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev2 = null;
  var node2 = next$2(prev2, element, isPre);
  while (node2 !== element) {
    if (node2.nodeType === 3 || node2.nodeType === 4) {
      var text2 = node2.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text2[0] === " ") {
        text2 = text2.substr(1);
      }
      if (!text2) {
        node2 = remove$2(node2);
        continue;
      }
      node2.data = text2;
      prevText = node2;
    } else if (node2.nodeType === 1) {
      if (isBlock2(node2) || node2.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node2) || isPre(node2)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node2 = remove$2(node2);
      continue;
    }
    var nextNode = next$2(prev2, node2, isPre);
    prev2 = node2;
    node2 = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove$2(prevText);
    }
  }
}
function remove$2(node2) {
  var next3 = node2.nextSibling || node2.parentNode;
  node2.parentNode.removeChild(node2);
  return next3;
}
function next$2(prev2, current, isPre) {
  if (prev2 && prev2.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root$2 = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser3 = root$2.DOMParser;
  var canParse = false;
  try {
    if (new Parser3().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser3 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser3.prototype.parseFromString = function(string2) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string2);
        doc.close();
        return doc;
      };
    } else {
      Parser3.prototype.parseFromString = function(string2) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string2);
        doc.close();
        return doc;
      };
    }
  }
  return Parser3;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root$2.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root$2.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock: isBlock$1,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node2) {
  return node2.nodeName === "PRE" || node2.nodeName === "CODE";
}
function Node$3(node2, options) {
  node2.isBlock = isBlock$1(node2);
  node2.isCode = node2.nodeName === "CODE" || node2.parentNode.isCode;
  node2.isBlank = isBlank(node2);
  node2.flankingWhitespace = flankingWhitespace(node2, options);
  return node2;
}
function isBlank(node2) {
  return !isVoid(node2) && !isMeaningfulWhenBlank(node2) && /^\s*$/i.test(node2.textContent) && !hasVoid(node2) && !hasMeaningfulWhenBlank(node2);
}
function flankingWhitespace(node2, options) {
  if (node2.isBlock || options.preformattedCode && node2.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node2.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node2, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node2, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string2) {
  var m = string2.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node2, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node2.previousSibling;
    regExp = / $/;
  } else {
    sibling = node2.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock$1(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce$4 = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options);
  var defaults2 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + node2.outerHTML + "\n\n" : node2.outerHTML;
    },
    defaultReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend$2({}, defaults2, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "")
      return "";
    var output = process$4.call(this, new RootNode(input, this.options));
    return postProcess$2.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin2) {
    if (Array.isArray(plugin2)) {
      for (var i = 0; i < plugin2.length; i++)
        this.use(plugin2[i]);
    } else if (typeof plugin2 === "function") {
      plugin2(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter3) {
    this.rules.keep(filter3);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter3) {
    this.rules.remove(filter3);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string2) {
    return escapes.reduce(function(accumulator, escape2) {
      return accumulator.replace(escape2[0], escape2[1]);
    }, string2);
  }
};
function process$4(parentNode) {
  var self2 = this;
  return reduce$4.call(parentNode.childNodes, function(output, node2) {
    node2 = new Node$3(node2, self2.options);
    var replacement2 = "";
    if (node2.nodeType === 3) {
      replacement2 = node2.isCode ? node2.nodeValue : self2.escape(node2.nodeValue);
    } else if (node2.nodeType === 1) {
      replacement2 = replacementForNode.call(self2, node2);
    }
    return join$1(output, replacement2);
  }, "");
}
function postProcess$2(output) {
  var self2 = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join$1(output, rule.append(self2.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node2) {
  var rule = this.rules.forNode(node2);
  var content = process$4.call(this, node2);
  var whitespace2 = node2.flankingWhitespace;
  if (whitespace2.leading || whitespace2.trailing)
    content = content.trim();
  return whitespace2.leading + rule.replacement(content, node2, this.options) + whitespace2.trailing;
}
function join$1(output, replacement2) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement2);
  var nls = Math.max(output.length - s1.length, replacement2.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "markdown",
  props: {
    content: { default: "" },
    type: { default: "markdown" }
  },
  setup(__props) {
    const props = __props;
    const markdown = ref("");
    const turndownService = new TurndownService({
      headingStyle: "atx"
    });
    onMounted(() => {
      markdown.value = props.type === "html" ? turndownService.turndown(props.content) : props.content;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$5, {
        modelValue: markdown.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => markdown.value = $event)
      }, null, 8, ["modelValue"]);
    };
  }
});
const testPath = "npm2url/dist/index.cjs";
const defaultProviders = {
  jsdelivr: (path2) => `https://cdn.jsdelivr.net/npm/${path2}`,
  unpkg: (path2) => `https://unpkg.com/${path2}`
};
async function checkUrl(url, signal) {
  const res = await fetch(url, {
    signal
  });
  if (!res.ok) {
    throw res;
  }
  await res.text();
}
class UrlBuilder {
  constructor() {
    this.providers = { ...defaultProviders };
    this.provider = "jsdelivr";
  }
  /**
   * Get the fastest provider name.
   * If none of the providers returns a valid response within `timeout`, an error will be thrown.
   */
  async getFastestProvider(timeout2 = 5e3, path2 = testPath) {
    const controller = new AbortController();
    let timer2 = 0;
    try {
      return await new Promise((resolve2, reject2) => {
        Promise.all(
          Object.entries(this.providers).map(async ([name2, factory]) => {
            try {
              await checkUrl(factory(path2), controller.signal);
              resolve2(name2);
            } catch {
            }
          })
        ).then(() => reject2(new Error("All providers failed")));
        timer2 = setTimeout(reject2, timeout2, new Error("Timed out"));
      });
    } finally {
      controller.abort();
      clearTimeout(timer2);
    }
  }
  /**
   * Set the current provider to the fastest provider found by `getFastestProvider`.
   */
  async findFastestProvider(timeout2, path2) {
    this.provider = await this.getFastestProvider(timeout2, path2);
    return this.provider;
  }
  setProvider(name2, factory) {
    if (factory) {
      this.providers[name2] = factory;
    } else {
      delete this.providers[name2];
    }
  }
  getFullUrl(path2, provider = this.provider) {
    if (path2.includes("://")) {
      return path2;
    }
    const factory = this.providers[provider];
    if (!factory) {
      throw new Error(`Provider ${provider} not found`);
    }
    return factory(path2);
  }
}
class Hook {
  constructor() {
    this.listeners = [];
  }
  tap(fn) {
    this.listeners.push(fn);
    return () => this.revoke(fn);
  }
  revoke(fn) {
    const i = this.listeners.indexOf(fn);
    if (i >= 0)
      this.listeners.splice(i, 1);
  }
  revokeAll() {
    this.listeners.splice(0);
  }
  call(...args) {
    for (const fn of this.listeners) {
      fn(...args);
    }
  }
}
const uniqId = Math.random().toString(36).slice(2, 8);
let globalIndex = 0;
function getId() {
  globalIndex += 1;
  return `mm-${uniqId}-${globalIndex}`;
}
function noop$2() {
}
function walkTree(tree, callback) {
  const walk = (item, parent2) => callback(
    item,
    () => {
      var _a2;
      return (_a2 = item.children) == null ? void 0 : _a2.map((child) => walk(child, item));
    },
    parent2
  );
  return walk(tree);
}
function addClass$1(className, ...rest) {
  const classList2 = (className || "").split(" ").filter(Boolean);
  rest.forEach((item) => {
    if (item && classList2.indexOf(item) < 0)
      classList2.push(item);
  });
  return classList2.join(" ");
}
function wrapFunction(fn, wrapper2) {
  return (...args) => wrapper2(fn, ...args);
}
function defer$1() {
  const obj = {};
  obj.promise = new Promise((resolve2, reject2) => {
    obj.resolve = resolve2;
    obj.reject = reject2;
  });
  return obj;
}
function memoize(fn) {
  const cache = {};
  return function memoized(...args) {
    const key = `${args[0]}`;
    let data2 = cache[key];
    if (!data2) {
      data2 = {
        value: fn(...args)
      };
      cache[key] = data2;
    }
    return data2.value;
  };
}
function debounce(fn, time) {
  const state = {
    timer: 0
  };
  function reset() {
    if (state.timer) {
      window.clearTimeout(state.timer);
      state.timer = 0;
    }
  }
  function run2() {
    reset();
    if (state.args)
      state.result = fn(...state.args);
  }
  return function debounced(...args) {
    reset();
    state.args = args;
    state.timer = window.setTimeout(run2, time);
    return state.result;
  };
}
/*! @gera2ld/jsx-dom v2.2.2 | ISC License */
const VTYPE_ELEMENT = 1;
const VTYPE_FUNCTION = 2;
const SVG_NS = "http://www.w3.org/2000/svg";
const XLINK_NS = "http://www.w3.org/1999/xlink";
const NS_ATTRS = {
  show: XLINK_NS,
  actuate: XLINK_NS,
  href: XLINK_NS
};
const isLeaf = (c2) => typeof c2 === "string" || typeof c2 === "number";
const isElement = (c2) => (c2 == null ? void 0 : c2.vtype) === VTYPE_ELEMENT;
const isRenderFunction = (c2) => (c2 == null ? void 0 : c2.vtype) === VTYPE_FUNCTION;
function h(type, props, ...children2) {
  props = Object.assign({}, props, {
    children: children2.length === 1 ? children2[0] : children2
  });
  return jsx(type, props);
}
function jsx(type, props) {
  let vtype;
  if (typeof type === "string")
    vtype = VTYPE_ELEMENT;
  else if (typeof type === "function")
    vtype = VTYPE_FUNCTION;
  else
    throw new Error("Invalid VNode type");
  return {
    vtype,
    type,
    props
  };
}
function Fragment(props) {
  return props.children;
}
const DEFAULT_ENV = {
  isSvg: false
};
function insertDom(parent2, nodes) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  nodes = nodes.filter(Boolean);
  if (nodes.length)
    parent2.append(...nodes);
}
function mountAttributes(domElement, props, env) {
  for (const key in props) {
    if (key === "key" || key === "children" || key === "ref")
      continue;
    if (key === "dangerouslySetInnerHTML") {
      domElement.innerHTML = props[key].__html;
    } else if (key === "innerHTML" || key === "textContent" || key === "innerText" || key === "value" && ["textarea", "select"].includes(domElement.tagName)) {
      const value = props[key];
      if (value != null)
        domElement[key] = value;
    } else if (key.startsWith("on")) {
      domElement[key.toLowerCase()] = props[key];
    } else {
      setDOMAttribute(domElement, key, props[key], env.isSvg);
    }
  }
}
const attrMap = {
  className: "class",
  labelFor: "for"
};
function setDOMAttribute(el, attr2, value, isSVG) {
  attr2 = attrMap[attr2] || attr2;
  if (value === true) {
    el.setAttribute(attr2, "");
  } else if (value === false) {
    el.removeAttribute(attr2);
  } else {
    const namespace2 = isSVG ? NS_ATTRS[attr2] : void 0;
    if (namespace2 !== void 0) {
      el.setAttributeNS(namespace2, attr2, value);
    } else {
      el.setAttribute(attr2, value);
    }
  }
}
function flatten(arr) {
  return arr.reduce((prev2, item) => prev2.concat(item), []);
}
function mountChildren(children2, env) {
  return Array.isArray(children2) ? flatten(children2.map((child) => mountChildren(child, env))) : mount(children2, env);
}
function mount(vnode, env = DEFAULT_ENV) {
  if (vnode == null || typeof vnode === "boolean") {
    return null;
  }
  if (vnode instanceof Node) {
    return vnode;
  }
  if (isRenderFunction(vnode)) {
    const {
      type,
      props
    } = vnode;
    if (type === Fragment) {
      const node2 = document.createDocumentFragment();
      if (props.children) {
        const children2 = mountChildren(props.children, env);
        insertDom(node2, children2);
      }
      return node2;
    }
    const childVNode = type(props);
    return mount(childVNode, env);
  }
  if (isLeaf(vnode)) {
    return document.createTextNode(`${vnode}`);
  }
  if (isElement(vnode)) {
    let node2;
    const {
      type,
      props
    } = vnode;
    if (!env.isSvg && type === "svg") {
      env = Object.assign({}, env, {
        isSvg: true
      });
    }
    if (!env.isSvg) {
      node2 = document.createElement(type);
    } else {
      node2 = document.createElementNS(SVG_NS, type);
    }
    mountAttributes(node2, props, env);
    if (props.children) {
      let childEnv = env;
      if (env.isSvg && type === "foreignObject") {
        childEnv = Object.assign({}, childEnv, {
          isSvg: false
        });
      }
      const children2 = mountChildren(props.children, childEnv);
      if (children2 != null)
        insertDom(node2, children2);
    }
    const {
      ref: ref2
    } = props;
    if (typeof ref2 === "function")
      ref2(node2);
    return node2;
  }
  throw new Error("mount: Invalid Vnode!");
}
function mountDom(vnode) {
  return mount(vnode);
}
function hm(...args) {
  return mountDom(h(...args));
}
const memoizedPreloadJS = memoize((url) => {
  document.head.append(
    hm("link", {
      rel: "preload",
      as: "script",
      href: url
    })
  );
});
const jsCache = {};
const cssCache = {};
async function loadJSItem(item, context) {
  var _a2;
  const src = item.type === "script" && ((_a2 = item.data) == null ? void 0 : _a2.src) || "";
  item.loaded || (item.loaded = jsCache[src]);
  if (!item.loaded) {
    const deferred = defer$1();
    item.loaded = deferred.promise;
    if (item.type === "script") {
      document.head.append(
        hm("script", {
          ...item.data,
          onLoad: () => deferred.resolve(),
          onError: deferred.reject
        })
      );
      if (!src) {
        deferred.resolve();
      } else {
        jsCache[src] = item.loaded;
      }
    }
    if (item.type === "iife") {
      const { fn, getParams } = item.data;
      fn(...(getParams == null ? void 0 : getParams(context)) || []);
      deferred.resolve();
    }
  }
  await item.loaded;
}
async function loadCSSItem(item) {
  const url = item.type === "stylesheet" && item.data.href || "";
  item.loaded || (item.loaded = cssCache[url]);
  if (!item.loaded) {
    const deferred = defer$1();
    item.loaded = deferred.promise;
    if (url)
      cssCache[url] = item.loaded;
    if (item.type === "style") {
      document.head.append(
        hm("style", {
          textContent: item.data
        })
      );
      deferred.resolve();
    } else if (url) {
      document.head.append(
        hm("link", {
          rel: "stylesheet",
          ...item.data
        })
      );
      fetch(url).then((res) => {
        if (res.ok)
          return res.text();
        throw res;
      }).then(() => deferred.resolve(), deferred.reject);
    }
  }
  await item.loaded;
}
async function loadJS(items, context) {
  items.forEach((item) => {
    var _a2;
    if (item.type === "script" && ((_a2 = item.data) == null ? void 0 : _a2.src)) {
      memoizedPreloadJS(item.data.src);
    }
  });
  context = {
    getMarkmap: () => window.markmap,
    ...context
  };
  for (const item of items) {
    await loadJSItem(item, context);
  }
}
async function loadCSS(items) {
  await Promise.all(items.map((item) => loadCSSItem(item)));
}
function buildJSItem(path2) {
  return {
    type: "script",
    data: {
      src: path2
    }
  };
}
function buildCSSItem(path2) {
  return {
    type: "stylesheet",
    data: {
      href: path2
    }
  };
}
class InternMap extends Map {
  constructor(entries2, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries2 != null)
      for (const [key2, value] of entries2)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function max$4(values2, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index2, values2)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min$3(values2, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index2, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function minIndex(values2, valueof) {
  let min2;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value, minIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof(value, ++index2, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}
var noop$1 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch$1.prototype = dispatch.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._, T2 = parseTypenames$1(typename + "", _), t, i = -1, n = T2.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T2[i]).type) && (t = get$9(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T2[i]).type)
        _[t] = set$7(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$7(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch$1(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$9(type, name2) {
  for (var i = 0, n = type.length, c2; i < n; ++i) {
    if ((c2 = type[i]).name === name2) {
      return c2.value;
    }
  }
}
function set$7(type, name2, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name2) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name: name2, value: callback });
  return type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name2) {
  var prefix = name2 += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name2 } : name2;
}
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name2) {
  var fullname = namespace(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array$1(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty$2() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$2 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents2.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, parents2);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find$4 = Array.prototype.find;
function childFind(match3) {
  return function() {
    return find$4.call(this.children, match3);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match3) {
  return this.select(match3 == null ? childFirst : childFind(typeof match3 === "function" ? match3 : childMatcher(match3)));
}
var filter$5 = Array.prototype.filter;
function children$1() {
  return Array.from(this.children);
}
function childrenFilter(match3) {
  return function() {
    return filter$5.call(this.children, match3);
  };
}
function selection_selectChildren(match3) {
  return this.selectAll(match3 == null ? children$1 : childrenFilter(typeof match3 === "function" ? match3 : childMatcher(match3)));
}
function selection_filter(match3) {
  if (typeof match3 !== "function")
    match3 = matcher(match3);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match3.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update2) {
  return new Array(update2.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent2, datum2) {
  this.ownerDocument = parent2.ownerDocument;
  this.namespaceURI = parent2.namespaceURI;
  this._next = null;
  this._parent = parent2;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next3) {
    return this._parent.insertBefore(child, next3);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent2, group, enter, update2, exit, data2) {
  var i = 0, node2, groupLength = group.length, dataLength = data2.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data2[i];
      update2[i] = node2;
    } else {
      enter[i] = new EnterNode(parent2, data2[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey(parent2, group, enter, update2, exit, data2, key) {
  var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent2, data2[i], i, data2) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update2[i] = node2;
      node2.__data__ = data2[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent2, data2[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
      exit[i] = node2;
    }
  }
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind3 = key ? bindKey : bindIndex, parents2 = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$3(value);
  for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j2 = 0; j2 < m; ++j2) {
    var parent2 = parents2[j2], group = groups[j2], groupLength = group.length, data2 = arraylike(value.call(parent2, parent2 && parent2.__data__, j2, parents2)), dataLength = data2.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update2[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind3(parent2, group, enterGroup, updateGroup, exitGroup, data2, key);
    for (var i0 = 0, i1 = 0, previous, next3; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next3 = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next3 || null;
      }
    }
  }
  update2 = new Selection$1(update2, parents2);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data2) {
  return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2)
      update2 = update2.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m = groups.length; ++j2 < m; ) {
    for (var group = groups[j2], i = group.length - 1, next3 = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next3 && node2.compareDocumentPosition(next3) ^ 4)
          next3.parentNode.insertBefore(node2, next3);
        next3 = node2;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, sortgroup = sortgroups[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
    for (var group = groups[j2], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node2 of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
    for (var group = groups[j2], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v2);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name2, value) {
  var fullname = namespace(name2);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant$1(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction$1(name2, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v2, priority);
  };
}
function selection_style(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node2, name2) {
  return node2.style.getPropertyValue(name2) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name2);
}
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null)
      delete this[name2];
    else
      this[name2] = v2;
  };
}
function selection_property(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.add(names[i]);
}
function classedRemove(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list2 = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list2.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name2) {
  var create5 = typeof name2 === "function" ? name2 : creator(name2);
  return this.select(function() {
    return this.appendChild(create5.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name2, before2) {
  var create5 = typeof name2 === "function" ? name2 : creator(name2), select2 = before2 == null ? constantNull : typeof before2 === "function" ? before2 : selector(before2);
  return this.select(function() {
    return this.insertBefore(create5.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove$1() {
  var parent2 = this.parentNode;
  if (parent2)
    parent2.removeChild(this);
}
function selection_remove() {
  return this.each(remove$1);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j2 = 0, i = -1, m = on.length, o; j2 < m; ++j2) {
      if (o = on[j2], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j2 = 0, m = on.length; j2 < m; ++j2) {
        if ((o = on[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j2 = 0, m = on.length, o; j2 < m; ++j2) {
        for (i = 0, o = on[j2]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent$1(node2, type, params) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
    for (var group = groups[j2], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        yield node2;
    }
  }
}
var root$1 = [null];
function Selection$1(groups, parents2) {
  this._groups = groups;
  this._parents = parents2;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function xt(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$1);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  event = sourceEvent(event);
  if (node2 === void 0)
    node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node2.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassivecapture = { capture: true, passive: false };
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = xt(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = xt(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$1(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend$1(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s, l, a) {
  if (a <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl(h2, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h2 = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h2 = (b - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s, l, o.opacity);
}
function hsl(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend$1(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end2) {
    var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q2 = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q2.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q2[0] ? one(q2[0].x) : zero(b) : (b = q2.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q2[i2]).i] = o.x(t);
    return s.join("");
  });
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c2, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c2 + b * d)
    c2 -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c2)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$1;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q2) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q2) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q2.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q2) {
    if (a !== b) {
      q2.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q2) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q2.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q2 = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q2);
    rotate(a.rotate, b.rotate, s, q2);
    skewX(a.skewX, b.skewX, s, q2);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q2);
    a = b = null;
    return function(t) {
      var i = -1, n = q2.length, o;
      while (++i < n)
        s[(o = q2[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now$4() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now$4() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now$4();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node2, name2, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules)
    node2.__transition = {};
  else if (id2 in schedules)
    return;
  create$c(node2, id2, {
    name: name2,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get$8(node2, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$6(node2, id2) {
  var schedule2 = get$8(node2, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get$8(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create$c(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j2, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j2 = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
        tween[++j2] = o;
      }
    }
    tween.length = j2 + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node2.__transition;
  }
}
function interrupt(node2, name2) {
  var schedules = node2.__transition, schedule2, active, empty2 = true, i;
  if (!schedules)
    return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name2) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node2.__transition;
}
function selection_interrupt(name2) {
  return this.each(function() {
    interrupt(this, name2);
  });
}
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$6(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$6(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get$8(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name2) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition, name2, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set$6(this, id2);
    (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node2) {
    return get$8(node2, id2).value[name2];
  };
}
function interpolate(a, b) {
  var c2;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name2, value) {
  var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name2, i) {
  return function(t) {
    this.setAttribute(name2, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name2, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$8(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$6(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$6(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$8(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$6(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$8(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function")
      throw new Error();
    set$6(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match3) {
  if (typeof match3 !== "function")
    match3 = matcher(match3);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match3.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start(name2) ? init : set$6;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name2, listener);
    schedule2.on = on1;
  };
}
function transition_on(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$8(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}
function removeFunction(id2) {
  return function() {
    var parent2 = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent2)
      parent2.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name2, id2, i, subgroup, get$8(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}
function transition_selectAll(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children2 = select2.call(node2, node2.__data__, i, group), child, inherit2 = get$8(node2, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name2, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents2.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents2, name2, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name2, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$6(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value), priority).on("end.style." + name2, null);
}
function styleInterpolate(name2, i, priority) {
  return function(t) {
    this.style.setProperty(name2, i.call(this, t), priority);
  };
}
function styleTween(name2, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name2, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get$8(node2, id0);
        schedule(node2, name2, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name2, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve2, reject2) {
    var cancel = { value: reject2 }, end2 = { value: function() {
      if (--size === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule2 = set$6(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve2();
  });
}
var id$3 = 0;
function Transition(groups, parents2, name2, id2) {
  this._groups = groups;
  this._parents = parents2;
  this._name = name2;
  this._id = id2;
}
function newId() {
  return ++id$3;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit$1(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now$4(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule(node2, name2, id2, i, group, timing || inherit$1(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name2, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append$2(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append$2;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append$2 : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h2}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range = [], unknown = implicit;
  function scale(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function colors(specifier) {
  var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
  while (i < n)
    colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors2;
}
const mt = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
function constant$1(x2) {
  return function constant2() {
    return x2;
  };
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}
var slice$8 = Array.prototype.slice;
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
class Bump {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line)
          this._context.lineTo(x2, y2);
        else
          this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x)
          this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else
          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
}
function bumpX(context) {
  return new Bump(context, true);
}
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link$1(curve) {
  let source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null, output = null, path2 = withPath(link2);
  function link2() {
    let buffer;
    const argv = slice$8.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null)
      output = curve(buffer = path2());
    output.lineStart();
    argv[0] = s, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
    argv[0] = t, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
    output.lineEnd();
    if (buffer)
      return output = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), link2) : x$1;
  };
  link2.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link2) : y$1;
  };
  link2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
  };
  return link2;
}
function linkHorizontal() {
  return link$1(bumpX);
}
const constant = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform(k, x2, y2) {
  this.k = k;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  while (!node2.__zoom)
    if (!(node2 = node2.parentNode))
      return identity;
  return node2.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function yt() {
  var filter3 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection2, transform2, point, event) {
    var selection2 = collection2.selection ? collection2.selection() : collection2;
    selection2.property("__zoom", defaultTransform);
    if (collection2 !== selection2) {
      schedule2(collection2, transform2, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x2, y2, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x2, y2, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate2(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = xt(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }
    noevent(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = xt(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();
    function mousemoved(event2) {
      noevent(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent(event);
    if (duration > 0)
      xt(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else
      xt(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = xt(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant(!!_), zoom) : filter3;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom) : interpolate2;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}
const Z$1 = typeof navigator < "u" && navigator.userAgent.includes("Macintosh"), bt = ordinal(mt), q = (e = 1, t = 3, i = 2) => (n) => e + t / i ** n.state.depth, J = {
  autoFit: false,
  duration: 500,
  embedGlobalCSS: true,
  fitRatio: 0.95,
  maxInitialScale: 2,
  scrollForPan: Z$1,
  initialExpandLevel: -1,
  zoom: true,
  pan: true,
  toggleRecursively: false,
  color: (e) => {
    var t;
    return bt(`${((t = e.state) == null ? void 0 : t.path) || ""}`);
  },
  lineWidth: q(),
  maxWidth: 0,
  nodeMinHeight: 16,
  paddingX: 8,
  spacingHorizontal: 80,
  spacingVertical: 5
};
function ke(e) {
  const t = {}, i = { ...e }, { color: n, colorFreezeLevel: s, lineWidth: a } = i;
  if ((n == null ? void 0 : n.length) === 1) {
    const l = n[0];
    t.color = () => l;
  } else if (n != null && n.length) {
    const l = ordinal(n);
    t.color = (h2) => l(`${h2.state.path}`);
  }
  if (s) {
    const l = t.color || J.color;
    t.color = (h2) => (h2 = {
      ...h2,
      state: {
        ...h2.state,
        path: h2.state.path.split(".").slice(0, s).join(".")
      }
    }, l(h2));
  }
  if (a) {
    const l = Array.isArray(a) ? a : [a, 0, 1];
    t.lineWidth = q(
      ...l
    );
  }
  return [
    "duration",
    "fitRatio",
    "initialExpandLevel",
    "maxInitialScale",
    "maxWidth",
    "nodeMinHeight",
    "paddingX",
    "spacingHorizontal",
    "spacingVertical"
  ].forEach((l) => {
    const h2 = i[l];
    typeof h2 == "number" && (t[l] = h2);
  }), ["zoom", "pan"].forEach((l) => {
    const h2 = i[l];
    h2 != null && (t[l] = !!h2);
  }), t;
}
function Et(e) {
  let t = 0;
  for (let i = 0; i < e.length; i++)
    t = (t << 5) - t + e.charCodeAt(i) | 0;
  return (t >>> 0).toString(36);
}
function v(e) {
  if (typeof e == "string") {
    const i = e;
    e = (n) => n.matches(i);
  }
  const t = e;
  return function() {
    let n = Array.from(this.childNodes);
    return t && (n = n.filter((s) => t(s))), n;
  };
}
function zt(e) {
  var t = 0, i = e.children, n = i && i.length;
  if (!n)
    t = 1;
  else
    for (; --n >= 0; )
      t += i[n].value;
  e.value = t;
}
function wt() {
  return this.eachAfter(zt);
}
function Ct(e) {
  var t = this, i, n = [t], s, a, c2;
  do
    for (i = n.reverse(), n = []; t = i.pop(); )
      if (e(t), s = t.children, s)
        for (a = 0, c2 = s.length; a < c2; ++a)
          n.push(s[a]);
  while (n.length);
  return this;
}
function St(e) {
  for (var t = this, i = [t], n, s; t = i.pop(); )
    if (e(t), n = t.children, n)
      for (s = n.length - 1; s >= 0; --s)
        i.push(n[s]);
  return this;
}
function Rt(e) {
  for (var t = this, i = [t], n = [], s, a, c2; t = i.pop(); )
    if (n.push(t), s = t.children, s)
      for (a = 0, c2 = s.length; a < c2; ++a)
        i.push(s[a]);
  for (; t = n.pop(); )
    e(t);
  return this;
}
function Xt(e) {
  return this.eachAfter(function(t) {
    for (var i = +e(t.data) || 0, n = t.children, s = n && n.length; --s >= 0; )
      i += n[s].value;
    t.value = i;
  });
}
function jt(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function _t(e) {
  for (var t = this, i = Ot(t, e), n = [t]; t !== i; )
    t = t.parent, n.push(t);
  for (var s = n.length; e !== i; )
    n.splice(s, 0, e), e = e.parent;
  return n;
}
function Ot(e, t) {
  if (e === t)
    return e;
  var i = e.ancestors(), n = t.ancestors(), s = null;
  for (e = i.pop(), t = n.pop(); e === t; )
    s = e, e = i.pop(), t = n.pop();
  return s;
}
function Mt() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function At() {
  var e = [];
  return this.each(function(t) {
    e.push(t);
  }), e;
}
function Tt() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function Ht() {
  var e = this, t = [];
  return e.each(function(i) {
    i !== e && t.push({ source: i.parent, target: i });
  }), t;
}
function H(e, t) {
  var i = new j(e), n = +e.value && (i.value = e.value), s, a = [i], c2, o, l, h2;
  for (t == null && (t = Ft); s = a.pop(); )
    if (n && (s.value = +s.data.value), (o = t(s.data)) && (h2 = o.length))
      for (s.children = new Array(h2), l = h2 - 1; l >= 0; --l)
        a.push(c2 = s.children[l] = new j(o[l])), c2.parent = s, c2.depth = s.depth + 1;
  return i.eachBefore(Dt);
}
function Bt() {
  return H(this).eachBefore(Lt);
}
function Ft(e) {
  return e.children;
}
function Lt(e) {
  e.data = e.data.data;
}
function Dt(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function j(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
j.prototype = H.prototype = {
  constructor: j,
  count: wt,
  each: Ct,
  eachAfter: Rt,
  eachBefore: St,
  sum: Xt,
  sort: jt,
  path: _t,
  ancestors: Mt,
  descendants: At,
  leaves: Tt,
  links: Ht,
  copy: Bt
};
const $t = "d3-flextree", Nt = "2.1.2", Wt = "build/d3-flextree.js", It = "index", Pt = { name: "Chris Maloney", url: "http://chrismaloney.org" }, Kt = "Flexible tree layout algorithm that allows for variable node sizes.", Gt = ["d3", "d3-module", "layout", "tree", "hierarchy", "d3-hierarchy", "plugin", "d3-plugin", "infovis", "visualization", "2d"], Vt = "https://github.com/klortho/d3-flextree", Ut = "WTFPL", Yt = { type: "git", url: "https://github.com/klortho/d3-flextree.git" }, Zt = { clean: "rm -rf build demo test", "build:demo": "rollup -c --environment BUILD:demo", "build:dev": "rollup -c --environment BUILD:dev", "build:prod": "rollup -c --environment BUILD:prod", "build:test": "rollup -c --environment BUILD:test", build: "rollup -c", lint: "eslint index.js src", "test:main": "node test/bundle.js", "test:browser": "node test/browser-tests.js", test: "npm-run-all test:*", prepare: "npm-run-all clean build lint test" }, qt = { "d3-hierarchy": "^1.1.5" }, Jt = { "babel-plugin-external-helpers": "^6.22.0", "babel-preset-es2015-rollup": "^3.0.0", d3: "^4.13.0", "d3-selection-multi": "^1.0.1", eslint: "^4.19.1", jsdom: "^11.6.2", "npm-run-all": "^4.1.2", rollup: "^0.55.3", "rollup-plugin-babel": "^2.7.1", "rollup-plugin-commonjs": "^8.0.2", "rollup-plugin-copy": "^0.2.3", "rollup-plugin-json": "^2.3.0", "rollup-plugin-node-resolve": "^3.0.2", "rollup-plugin-uglify": "^3.0.0", "uglify-es": "^3.3.9" }, Qt = {
  name: $t,
  version: Nt,
  main: Wt,
  module: It,
  "jsnext:main": "index",
  author: Pt,
  description: Kt,
  keywords: Gt,
  homepage: Vt,
  license: Ut,
  repository: Yt,
  scripts: Zt,
  dependencies: qt,
  devDependencies: Jt
}, { version: te } = Qt, ee = Object.freeze({
  children: (e) => e.children,
  nodeSize: (e) => e.data.size,
  spacing: 0
});
function tt(e) {
  const t = Object.assign({}, ee, e);
  function i(o) {
    const l = t[o];
    return typeof l == "function" ? l : () => l;
  }
  function n(o) {
    const l = c2(a(), o, (h2) => h2.children);
    return l.update(), l.data;
  }
  function s() {
    const o = i("nodeSize"), l = i("spacing");
    return class Q extends H.prototype.constructor {
      constructor(d) {
        super(d);
      }
      copy() {
        const d = c2(this.constructor, this, (g) => g.children);
        return d.each((g) => g.data = g.data.data), d;
      }
      get size() {
        return o(this);
      }
      spacing(d) {
        return l(this, d);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const d = this.ancestors();
        return d[d.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (d, g) => Q.maxExtents(d, g.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(d, g) {
        return {
          top: Math.min(d.top, g.top),
          bottom: Math.max(d.bottom, g.bottom),
          left: Math.min(d.left, g.left),
          right: Math.max(d.right, g.right)
        };
      }
    };
  }
  function a() {
    const o = s(), l = i("nodeSize"), h2 = i("spacing");
    return class extends o {
      constructor(d) {
        super(d), Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return l(this.data);
      }
      spacing(d) {
        return h2(this.data, d.data);
      }
      get x() {
        return this.data.x;
      }
      set x(d) {
        this.data.x = d;
      }
      get y() {
        return this.data.y;
      }
      set y(d) {
        this.data.y = d;
      }
      update() {
        return et(this), rt(this), this;
      }
    };
  }
  function c2(o, l, h2) {
    const d = (g, u) => {
      const m = new o(g);
      Object.assign(m, {
        parent: u,
        depth: u === null ? 0 : u.depth + 1,
        height: 0,
        length: 1
      });
      const x2 = h2(g) || [];
      return m.children = x2.length === 0 ? null : x2.map((y2) => d(y2, m)), m.children && Object.assign(m, m.children.reduce(
        (y2, k) => ({
          height: Math.max(y2.height, k.height + 1),
          length: y2.length + k.length
        }),
        m
      )), m;
    };
    return d(l, null);
  }
  return Object.assign(n, {
    nodeSize(o) {
      return arguments.length ? (t.nodeSize = o, n) : t.nodeSize;
    },
    spacing(o) {
      return arguments.length ? (t.spacing = o, n) : t.spacing;
    },
    children(o) {
      return arguments.length ? (t.children = o, n) : t.children;
    },
    hierarchy(o, l) {
      const h2 = typeof l > "u" ? t.children : l;
      return c2(s(), o, h2);
    },
    dump(o) {
      const l = i("nodeSize"), h2 = (d) => (g) => {
        const u = d + "  ", m = d + "    ", { x: x2, y: y2 } = g, k = l(g), b = g.children || [], z = b.length === 0 ? " " : `,${u}children: [${m}${b.map(h2(m)).join(m)}${u}],${d}`;
        return `{ size: [${k.join(", ")}],${u}x: ${x2}, y: ${y2}${z}},`;
      };
      return h2(`
`)(o);
    }
  }), n;
}
tt.version = te;
const et = (e, t = 0) => (e.y = t, (e.children || []).reduce((i, n) => {
  const [s, a] = i;
  et(n, e.y + e.ySize);
  const c2 = (s === 0 ? n.lExt : n.rExt).bottom;
  s !== 0 && ne(e, s, a);
  const o = de$1(c2, s, a);
  return [s + 1, o];
}, [0, null]), re(e), he(e), e), rt = (e, t, i) => {
  typeof t > "u" && (t = -e.relX - e.prelim, i = 0);
  const n = t + e.relX;
  return e.relX = n + e.prelim - i, e.prelim = 0, e.x = i + e.relX, (e.children || []).forEach((s) => rt(s, n, e.x)), e;
}, re = (e) => {
  (e.children || []).reduce((t, i) => {
    const [n, s] = t, a = n + i.shift, c2 = s + a + i.change;
    return i.relX += c2, [a, c2];
  }, [0, 0]);
}, ne = (e, t, i) => {
  const n = e.children[t - 1], s = e.children[t];
  let a = n, c2 = n.relX, o = s, l = s.relX, h2 = true;
  for (; a && o; ) {
    a.bottom > i.lowY && (i = i.next);
    const d = c2 + a.prelim - (l + o.prelim) + a.xSize / 2 + o.xSize / 2 + a.spacing(o);
    (d > 0 || d < 0 && h2) && (l += d, ie(s, d), se(e, t, i.index, d)), h2 = false;
    const g = a.bottom, u = o.bottom;
    g <= u && (a = ae(a), a && (c2 += a.relX)), g >= u && (o = oe(o), o && (l += o.relX));
  }
  !a && o ? le(e, t, o, l) : a && !o && ce(e, t, a, c2);
}, ie = (e, t) => {
  e.relX += t, e.lExtRelX += t, e.rExtRelX += t;
}, se = (e, t, i, n) => {
  const s = e.children[t], a = t - i;
  if (a > 1) {
    const c2 = n / a;
    e.children[i + 1].shift += c2, s.shift -= c2, s.change -= n - c2;
  }
}, oe = (e) => e.hasChildren ? e.firstChild : e.lThr, ae = (e) => e.hasChildren ? e.lastChild : e.rThr, le = (e, t, i, n) => {
  const s = e.firstChild, a = s.lExt, c2 = e.children[t];
  a.lThr = i;
  const o = n - i.relX - s.lExtRelX;
  a.relX += o, a.prelim -= o, s.lExt = c2.lExt, s.lExtRelX = c2.lExtRelX;
}, ce = (e, t, i, n) => {
  const s = e.children[t], a = s.rExt, c2 = e.children[t - 1];
  a.rThr = i;
  const o = n - i.relX - s.rExtRelX;
  a.relX += o, a.prelim -= o, s.rExt = c2.rExt, s.rExtRelX = c2.rExtRelX;
}, he = (e) => {
  if (e.hasChildren) {
    const t = e.firstChild, i = e.lastChild, n = (t.prelim + t.relX - t.xSize / 2 + i.relX + i.prelim + i.xSize / 2) / 2;
    Object.assign(e, {
      prelim: n,
      lExt: t.lExt,
      lExtRelX: t.lExtRelX,
      rExt: i.rExt,
      rExtRelX: i.rExtRelX
    });
  }
}, de$1 = (e, t, i) => {
  for (; i !== null && e >= i.lowY; )
    i = i.next;
  return {
    lowY: e,
    index: t,
    next: i
  };
}, nt = ".markmap{--markmap-max-width: 9999px;--markmap-a-color: #0097e6;--markmap-a-hover-color: #00a8ff;--markmap-code-bg: #f0f0f0;--markmap-code-color: #555;--markmap-highlight-bg: #ffeaa7;--markmap-table-border: 1px solid currentColor;--markmap-font: 300 16px/20px sans-serif;--markmap-circle-open-bg: #fff;--markmap-text-color: #333;--markmap-highlight-node-bg: #ff02;font:var(--markmap-font);color:var(--markmap-text-color)}.markmap-link{fill:none}.markmap-node>circle{cursor:pointer}.markmap-foreign{display:inline-block}.markmap-foreign p{margin:0}.markmap-foreign a{color:var(--markmap-a-color)}.markmap-foreign a:hover{color:var(--markmap-a-hover-color)}.markmap-foreign code{padding:.25em;font-size:calc(1em - 2px);color:var(--markmap-code-color);background-color:var(--markmap-code-bg);border-radius:2px}.markmap-foreign pre{margin:0}.markmap-foreign pre>code{display:block}.markmap-foreign del{text-decoration:line-through}.markmap-foreign em{font-style:italic}.markmap-foreign strong{font-weight:700}.markmap-foreign mark{background:var(--markmap-highlight-bg)}.markmap-foreign table,.markmap-foreign th,.markmap-foreign td{border-collapse:collapse;border:var(--markmap-table-border)}.markmap-foreign img{display:inline-block}.markmap-foreign svg{fill:currentColor}.markmap-foreign>div{width:var(--markmap-max-width);text-align:left}.markmap-foreign>div>div{display:inline-block}.markmap-highlight rect{fill:var(--markmap-highlight-node-bg)}.markmap-dark .markmap{--markmap-code-bg: #1a1b26;--markmap-code-color: #ddd;--markmap-circle-open-bg: #444;--markmap-text-color: #eee}", ve = nt, M = "g.markmap-node", pe = "path.markmap-link", ge = "g.markmap-highlight", A = linkHorizontal();
function U(e, t) {
  const i = minIndex(e, t);
  return e[i];
}
function T(e) {
  e.stopPropagation();
}
const ue = new Hook();
let it$1 = class it {
  constructor(t, i) {
    this.options = { ...J }, this._disposeList = [], this.handleZoom = (n) => {
      const { transform: s } = n;
      this.g.attr("transform", s);
    }, this.handlePan = (n) => {
      n.preventDefault();
      const s = transform(this.svg.node()), a = s.translate(
        -n.deltaX / s.k,
        -n.deltaY / s.k
      );
      this.svg.call(this.zoom.transform, a);
    }, this.handleClick = (n, s) => {
      let a = this.options.toggleRecursively;
      (Z$1 ? n.metaKey : n.ctrlKey) && (a = !a), this.toggleNode(s, a);
    }, this.ensureView = this.ensureVisible, this.svg = t.datum ? t : xt(t), this.styleNode = this.svg.append("style"), this.zoom = yt().filter((n) => this.options.scrollForPan && n.type === "wheel" ? n.ctrlKey && !n.button : (!n.ctrlKey || n.type === "wheel") && !n.button).on("zoom", this.handleZoom), this.setOptions(i), this.state = {
      id: this.options.id || this.svg.attr("id") || getId(),
      rect: { x1: 0, y1: 0, x2: 0, y2: 0 }
    }, this.g = this.svg.append("g"), this.g.append("g").attr("class", "markmap-highlight"), this._observer = new ResizeObserver(
      debounce(() => {
        this.renderData();
      }, 100)
    ), this._disposeList.push(
      ue.tap(() => {
        this.setData();
      }),
      () => this._observer.disconnect()
    );
  }
  getStyleContent() {
    const { style: t } = this.options, { id: i } = this.state, n = typeof t == "function" ? t(i) : "";
    return [this.options.embedGlobalCSS && nt, n].filter(Boolean).join(`
`);
  }
  updateStyle() {
    this.svg.attr(
      "class",
      addClass$1(this.svg.attr("class"), "markmap", this.state.id)
    );
    const t = this.getStyleContent();
    this.styleNode.text(t);
  }
  async toggleNode(t, i = false) {
    var s, a;
    const n = (s = t.payload) != null && s.fold ? 0 : 1;
    i ? walkTree(t, (c2, o) => {
      c2.payload = {
        ...c2.payload,
        fold: n
      }, o();
    }) : t.payload = {
      ...t.payload,
      fold: (a = t.payload) != null && a.fold ? 0 : 1
    }, await this.renderData(t);
  }
  _initializeData(t) {
    let i = 0;
    const { color: n, initialExpandLevel: s } = this.options;
    let a = 0, c2 = 0;
    return walkTree(t, (o, l, h2) => {
      var g, u, m, x2;
      c2 += 1, o.children = (g = o.children) == null ? void 0 : g.map((y2) => ({ ...y2 })), i += 1, o.state = {
        ...o.state,
        depth: c2,
        id: i,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        size: [0, 0]
      }, o.state.key = [(u = h2 == null ? void 0 : h2.state) == null ? void 0 : u.id, o.state.id].filter(Boolean).join(".") + Et(o.content), o.state.path = [(m = h2 == null ? void 0 : h2.state) == null ? void 0 : m.path, o.state.id].filter(Boolean).join("."), n(o);
      const d = ((x2 = o.payload) == null ? void 0 : x2.fold) === 2;
      d ? a += 1 : (a || s >= 0 && o.state.depth >= s) && (o.payload = { ...o.payload, fold: 1 }), l(), d && (a -= 1), c2 -= 1;
    }), t;
  }
  _relayout() {
    if (!this.state.data)
      return;
    this.g.selectAll(v(M)).selectAll(
      v("foreignObject")
    ).each(function(l) {
      var g;
      const h2 = (g = this.firstChild) == null ? void 0 : g.firstChild, d = [h2.scrollWidth, h2.scrollHeight];
      l.state.size = d;
    });
    const { lineWidth: t, paddingX: i, spacingHorizontal: n, spacingVertical: s } = this.options, a = tt({}).children((l) => {
      var h2;
      if (!((h2 = l.payload) != null && h2.fold))
        return l.children;
    }).nodeSize((l) => {
      const [h2, d] = l.data.state.size;
      return [d, h2 + (h2 ? i * 2 : 0) + n];
    }).spacing((l, h2) => (l.parent === h2.parent ? s : s * 2) + t(l.data)), c2 = a.hierarchy(this.state.data);
    a(c2);
    const o = c2.descendants();
    o.forEach((l) => {
      const h2 = l.data;
      h2.state.rect = {
        x: l.y,
        y: l.x - l.xSize / 2,
        width: l.ySize - n,
        height: l.xSize
      };
    }), this.state.rect = {
      x1: min$3(o, (l) => l.data.state.rect.x) || 0,
      y1: min$3(o, (l) => l.data.state.rect.y) || 0,
      x2: max$4(
        o,
        (l) => l.data.state.rect.x + l.data.state.rect.width
      ) || 0,
      y2: max$4(
        o,
        (l) => l.data.state.rect.y + l.data.state.rect.height
      ) || 0
    };
  }
  setOptions(t) {
    this.options = {
      ...this.options,
      ...t
    }, this.options.zoom ? this.svg.call(this.zoom) : this.svg.on(".zoom", null), this.options.pan ? this.svg.on("wheel", this.handlePan) : this.svg.on("wheel", null);
  }
  async setData(t, i) {
    i && this.setOptions(i), t && (this.state.data = this._initializeData(t)), this.state.data && (this.updateStyle(), await this.renderData());
  }
  async setHighlight(t) {
    this.state.highlight = t || void 0, await this.renderData();
  }
  _getHighlightRect(t) {
    const i = this.svg.node(), s = 4 / transform(i).k, a = {
      ...t.state.rect
    };
    return a.x -= s, a.y -= s, a.width += 2 * s, a.height += 2 * s, a;
  }
  async renderData(t) {
    const { paddingX: i, autoFit: n, color: s, maxWidth: a, lineWidth: c2 } = this.options, o = this.state.data;
    if (!o)
      return;
    const l = {}, h2 = {}, d = [];
    walkTree(o, (r, p, f) => {
      var E;
      (E = r.payload) != null && E.fold || p(), l[r.state.id] = r, f && (h2[r.state.id] = f.state.id), d.push(r);
    });
    const g = {}, u = {}, m = (r) => {
      !r || g[r.state.id] || walkTree(r, (p, f) => {
        g[p.state.id] = r.state.id, f();
      });
    }, x2 = (r) => u[g[r.state.id]] || o.state.rect, y2 = (r) => (l[g[r.state.id]] || o).state.rect;
    u[o.state.id] = o.state.rect, t && m(t);
    let { highlight: k } = this.state;
    k && !l[k.state.id] && (k = void 0);
    let b = this.g.selectAll(v(ge)).selectAll(v("rect")).data(k ? [this._getHighlightRect(k)] : []).join("rect").attr("x", (r) => r.x).attr("y", (r) => r.y).attr("width", (r) => r.width).attr("height", (r) => r.height);
    const z = this.g.selectAll(v(M)).each((r) => {
      u[r.state.id] = r.state.rect;
    }).data(d, (r) => r.state.key), B = z.enter().append("g").attr("data-depth", (r) => r.state.depth).attr("data-path", (r) => r.state.path).each((r) => {
      m(l[h2[r.state.id]]);
    }), C = z.exit().each((r) => {
      m(l[h2[r.state.id]]);
    }), S = z.merge(B).attr(
      "class",
      (r) => {
        var p;
        return ["markmap-node", ((p = r.payload) == null ? void 0 : p.fold) && "markmap-fold"].filter(Boolean).join(" ");
      }
    ), F = S.selectAll(v("line")).data(
      (r) => [r],
      (r) => r.state.key
    ), L = F.enter().append("line").attr("stroke", (r) => s(r)).attr("stroke-width", 0), D = F.merge(L), $2 = S.selectAll(v("circle")).data(
      (r) => {
        var p;
        return (p = r.children) != null && p.length ? [r] : [];
      },
      (r) => r.state.key
    ), N = $2.enter().append("circle").attr("stroke-width", 0).attr("r", 0).on("click", (r, p) => this.handleClick(r, p)).on("mousedown", T).merge($2).attr("stroke", (r) => s(r)).attr(
      "fill",
      (r) => {
        var p;
        return (p = r.payload) != null && p.fold && r.children ? s(r) : "var(--markmap-circle-open-bg)";
      }
    ), W = this._observer, I = S.selectAll(v("foreignObject")).data(
      (r) => [r],
      (r) => r.state.key
    ), _ = I.enter().append("foreignObject").attr("class", "markmap-foreign").attr("x", i).attr("y", 0).style("opacity", 0).on("mousedown", T).on("dblclick", T);
    _.append("xhtml:div").append("xhtml:div").html((r) => r.content).attr("xmlns", "http://www.w3.org/1999/xhtml"), _.each(function() {
      var p;
      const r = (p = this.firstChild) == null ? void 0 : p.firstChild;
      W.observe(r);
    });
    const P2 = C.selectAll(
      v("foreignObject")
    );
    P2.each(function() {
      var p;
      const r = (p = this.firstChild) == null ? void 0 : p.firstChild;
      W.unobserve(r);
    });
    const K = _.merge(I), st = d.flatMap(
      (r) => {
        var p;
        return (p = r.payload) != null && p.fold ? [] : r.children.map((f) => ({ source: r, target: f }));
      }
    ), O = this.g.selectAll(v(pe)).data(st, (r) => r.target.state.key), ot = O.exit(), at = O.enter().insert("path", "g").attr("class", "markmap-link").attr("data-depth", (r) => r.target.state.depth).attr("data-path", (r) => r.target.state.path).attr("d", (r) => {
      const p = x2(r.target), f = [
        p.x + p.width,
        p.y + p.height
      ];
      return A({ source: f, target: f });
    }).attr("stroke-width", 0).merge(O);
    this.svg.style(
      "--markmap-max-width",
      a ? `${a}px` : null
    ), await new Promise(requestAnimationFrame), this._relayout(), b = b.data(k ? [this._getHighlightRect(k)] : []).join("rect"), this.transition(b).attr("x", (r) => r.x).attr("y", (r) => r.y).attr("width", (r) => r.width).attr("height", (r) => r.height), B.attr("transform", (r) => {
      const p = x2(r);
      return `translate(${p.x + p.width - r.state.rect.width},${p.y + p.height - r.state.rect.height})`;
    }), this.transition(C).attr("transform", (r) => {
      const p = y2(r), f = p.x + p.width - r.state.rect.width, E = p.y + p.height - r.state.rect.height;
      return `translate(${f},${E})`;
    }).remove(), this.transition(S).attr(
      "transform",
      (r) => `translate(${r.state.rect.x},${r.state.rect.y})`
    );
    const lt = C.selectAll(
      v("line")
    );
    this.transition(lt).attr("x1", (r) => r.state.rect.width).attr("stroke-width", 0), L.attr("x1", (r) => r.state.rect.width).attr("x2", (r) => r.state.rect.width), D.attr("y1", (r) => r.state.rect.height + c2(r) / 2).attr("y2", (r) => r.state.rect.height + c2(r) / 2), this.transition(D).attr("x1", -1).attr("x2", (r) => r.state.rect.width + 2).attr("stroke", (r) => s(r)).attr("stroke-width", c2);
    const ct = C.selectAll(
      v("circle")
    );
    this.transition(ct).attr("r", 0).attr("stroke-width", 0), N.attr("cx", (r) => r.state.rect.width).attr("cy", (r) => r.state.rect.height + c2(r) / 2), this.transition(N).attr("r", 6).attr("stroke-width", "1.5"), this.transition(P2).style("opacity", 0), K.attr("width", (r) => Math.max(0, r.state.rect.width - i * 2)).attr("height", (r) => r.state.rect.height), this.transition(K).style("opacity", 1), this.transition(ot).attr("d", (r) => {
      const p = y2(r.target), f = [
        p.x + p.width,
        p.y + p.height + c2(r.target) / 2
      ];
      return A({ source: f, target: f });
    }).attr("stroke-width", 0).remove(), this.transition(at).attr("stroke", (r) => s(r.target)).attr("stroke-width", (r) => c2(r.target)).attr("d", (r) => {
      const p = r.source, f = r.target, E = [
        p.state.rect.x + p.state.rect.width,
        p.state.rect.y + p.state.rect.height + c2(p) / 2
      ], ht = [
        f.state.rect.x,
        f.state.rect.y + f.state.rect.height + c2(f) / 2
      ];
      return A({ source: E, target: ht });
    }), n && this.fit();
  }
  transition(t) {
    const { duration: i } = this.options;
    return t.transition().duration(i);
  }
  /**
   * Fit the content to the viewport.
   */
  async fit(t = this.options.maxInitialScale) {
    const i = this.svg.node(), { width: n, height: s } = i.getBoundingClientRect(), { fitRatio: a } = this.options, { x1: c2, y1: o, x2: l, y2: h2 } = this.state.rect, d = l - c2, g = h2 - o, u = Math.min(
      n / d * a,
      s / g * a,
      t
    ), m = identity.translate(
      (n - d * u) / 2 - c2 * u,
      (s - g * u) / 2 - o * u
    ).scale(u);
    return this.transition(this.svg).call(this.zoom.transform, m).end().catch(noop$2);
  }
  findElement(t) {
    let i;
    return this.g.selectAll(v(M)).each(function(s) {
      s === t && (i = {
        data: s,
        g: this
      });
    }), i;
  }
  /**
   * Pan the content to make the provided node visible in the viewport.
   */
  async ensureVisible(t, i) {
    var k;
    const n = (k = this.findElement(t)) == null ? void 0 : k.data;
    if (!n)
      return;
    const s = this.svg.node(), a = s.getBoundingClientRect(), c2 = transform(s), [o, l] = [
      n.state.rect.x,
      n.state.rect.x + n.state.rect.width + 2
    ].map((b) => b * c2.k + c2.x), [h2, d] = [
      n.state.rect.y,
      n.state.rect.y + n.state.rect.height
    ].map((b) => b * c2.k + c2.y), g = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...i
    }, u = [g.left - o, a.width - g.right - l], m = [g.top - h2, a.height - g.bottom - d], x2 = u[0] * u[1] > 0 ? U(u, Math.abs) / c2.k : 0, y2 = m[0] * m[1] > 0 ? U(m, Math.abs) / c2.k : 0;
    if (x2 || y2) {
      const b = c2.translate(x2, y2);
      return this.transition(this.svg).call(this.zoom.transform, b).end().catch(noop$2);
    }
  }
  async centerNode(t, i) {
    var x2;
    const n = (x2 = this.findElement(t)) == null ? void 0 : x2.data;
    if (!n)
      return;
    const s = this.svg.node(), a = s.getBoundingClientRect(), c2 = transform(s), o = (n.state.rect.x + n.state.rect.width / 2) * c2.k + c2.x, l = (n.state.rect.y + n.state.rect.height / 2) * c2.k + c2.y, h2 = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...i
    }, d = (h2.left + a.width - h2.right) / 2, g = (h2.top + a.height - h2.bottom) / 2, u = (d - o) / c2.k, m = (g - l) / c2.k;
    if (u || m) {
      const y2 = c2.translate(u, m);
      return this.transition(this.svg).call(this.zoom.transform, y2).end().catch(noop$2);
    }
  }
  /**
   * Scale content with it pinned at the center of the viewport.
   */
  async rescale(t) {
    const i = this.svg.node(), { width: n, height: s } = i.getBoundingClientRect(), a = n / 2, c2 = s / 2, o = transform(i), l = o.translate(
      (a - o.x) * (1 - t) / o.k,
      (c2 - o.y) * (1 - t) / o.k
    ).scale(t);
    return this.transition(this.svg).call(this.zoom.transform, l).end().catch(noop$2);
  }
  destroy() {
    this.svg.on(".zoom", null), this.svg.html(null), this._disposeList.forEach((t) => {
      t();
    });
  }
  static create(t, i, n = null) {
    const s = new it(t, i);
    return n && s.setData(n).then(() => {
      s.fit();
    }), s;
  }
};
const markmap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Markmap: it$1,
  childSelector: v,
  defaultColorFn: bt,
  defaultOptions: J,
  deriveOptions: ke,
  globalCSS: ve,
  isMacintosh: Z$1,
  lineWidthFactory: q,
  loadCSS,
  loadJS,
  refreshHook: ue,
  simpleHash: Et
}, Symbol.toStringTag, { value: "Module" }));
const defaultOpts$1 = {
  _useHtmlParser2: false
};
function flattenOptions(options, baseOptions) {
  if (!options) {
    return baseOptions !== null && baseOptions !== void 0 ? baseOptions : defaultOpts$1;
  }
  const opts = {
    _useHtmlParser2: !!options.xmlMode,
    ...baseOptions,
    ...options
  };
  if (options.xml) {
    opts._useHtmlParser2 = true;
    opts.xmlMode = true;
    if (options.xml !== true) {
      Object.assign(opts, options.xml);
    }
  } else if (options.xmlMode) {
    opts._useHtmlParser2 = true;
  }
  return opts;
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$1(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
const Root = ElementType.Root;
const Text$1 = ElementType.Text;
const Directive = ElementType.Directive;
const Comment$1 = ElementType.Comment;
const Script = ElementType.Script;
const Style = ElementType.Style;
const Tag = ElementType.Tag;
const CDATA$1 = ElementType.CDATA;
const Doctype = ElementType.Doctype;
let Node$2 = class Node2 {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next22) {
    this.next = next22;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
class DataNode extends Node$2 {
  /**
   * @param data The content of the data node
   */
  constructor(data2) {
    super();
    this.data = data2;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data2) {
    this.data = data2;
  }
}
let Text$2 = class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class ProcessingInstruction extends DataNode {
  constructor(name2, data2) {
    super(data2);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class NodeWithChildren extends Node$2 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children2) {
    super();
    this.children = children2;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children2) {
    this.children = children2;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
let Document$1 = class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
let Element$1 = class Element2 extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children2 = [], type = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children2);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a2, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag(node2) {
  return isTag$1(node2);
}
function isCDATA(node2) {
  return node2.type === ElementType.CDATA;
}
function isText(node2) {
  return node2.type === ElementType.Text;
}
function isComment(node2) {
  return node2.type === ElementType.Comment;
}
function isDirective(node2) {
  return node2.type === ElementType.Directive;
}
function isDocument$1(node2) {
  return node2.type === ElementType.Root;
}
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
function cloneNode(node2, recursive = false) {
  let result;
  if (isText(node2)) {
    result = new Text$2(node2.data);
  } else if (isComment(node2)) {
    result = new Comment(node2.data);
  } else if (isTag(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Element$1(node2.name, { ...node2.attribs }, children2);
    children2.forEach((child) => child.parent = clone2);
    if (node2.namespace != null) {
      clone2.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node2["x-attribsNamespace"] };
    }
    if (node2["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node2["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new CDATA(children2);
    children2.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument$1(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Document$1(children2);
    children2.forEach((child) => child.parent = clone2);
    if (node2["x-mode"]) {
      clone2["x-mode"] = node2["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node2)) {
    const instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node2.type}`);
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children2 = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children2.length; i++) {
    children2[i].prev = children2[i - 1];
    children2[i - 1].next = children2[i];
  }
  return children2;
}
const defaultOpts = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
class DomHandler {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document$1(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document$1(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error2) {
    this.handleCallback(error2);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element$1(name2, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data2) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data2;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node2 = new Text$2(data2);
      this.addNode(node2);
      this.lastNode = node2;
    }
  }
  oncomment(data2) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data2;
      return;
    }
    const node2 = new Comment(data2);
    this.addNode(node2);
    this.lastNode = node2;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text$2("");
    const node2 = new CDATA([text2]);
    this.addNode(node2);
    text2.parent = node2;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data2) {
    const node2 = new ProcessingInstruction(name2, data2);
    this.addNode(node2);
  }
  handleCallback(error2) {
    if (typeof this.callback === "function") {
      this.callback(error2, this.dom);
    } else if (error2) {
      throw error2;
    }
  }
  addNode(node2) {
    const parent2 = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent2.children[parent2.children.length - 1];
    if (this.options.withStartIndices) {
      node2.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node2.endIndex = this.parser.endIndex;
    }
    parent2.children.push(node2);
    if (previousSibling) {
      node2.prev = previousSibling;
      previousSibling.next = node2;
    }
    node2.parent = parent2;
    this.lastNode = null;
  }
}
const htmlDecodeTree$1 = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c2) => c2.charCodeAt(0))
);
const xmlDecodeTree$1 = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c2) => c2.charCodeAt(0))
);
var _a$1;
const decodeMap$1 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint$2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a$1 = String.fromCodePoint) !== null && _a$1 !== void 0 ? _a$1 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint$1(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap$1.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes$1;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes$1 || (CharCodes$1 = {}));
const TO_LOWER_BIT$1 = 32;
var BinTrieFlags$1;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags$1 || (BinTrieFlags$1 = {}));
function isNumber$1(code2) {
  return code2 >= CharCodes$1.ZERO && code2 <= CharCodes$1.NINE;
}
function isHexadecimalCharacter$1(code2) {
  return code2 >= CharCodes$1.UPPER_A && code2 <= CharCodes$1.UPPER_F || code2 >= CharCodes$1.LOWER_A && code2 <= CharCodes$1.LOWER_F;
}
function isAsciiAlphaNumeric$1(code2) {
  return code2 >= CharCodes$1.UPPER_A && code2 <= CharCodes$1.UPPER_Z || code2 >= CharCodes$1.LOWER_A && code2 <= CharCodes$1.LOWER_Z || isNumber$1(code2);
}
function isEntityInAttributeInvalidEnd$1(code2) {
  return code2 === CharCodes$1.EQUALS || isAsciiAlphaNumeric$1(code2);
}
var EntityDecoderState$1;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState$1 || (EntityDecoderState$1 = {}));
var DecodingMode$1;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode$1 || (DecodingMode$1 = {}));
let EntityDecoder$1 = class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState$1.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode$1.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState$1.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState$1.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes$1.NUM) {
          this.state = EntityDecoderState$1.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState$1.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState$1.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState$1.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState$1.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState$1.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT$1) === CharCodes$1.LOWER_X) {
      this.state = EntityDecoderState$1.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState$1.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start2, end2, base2) {
    if (start2 !== end2) {
      const digitCount = end2 - start2;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start2, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char) || isHexadecimalCharacter$1(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber$1(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes$1.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode$1.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint$1(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes$1.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags$1.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch$1(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode$1.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd$1(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags$1.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes$1.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode$1.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags$1.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags$1.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState$1.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode$1.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState$1.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState$1.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState$1.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState$1.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder$1(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder$1(decodeTree, (str) => ret += fromCodePoint$2(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch$1(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags$1.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags$1.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi2 = lo + branchCount - 1;
  while (lo <= hi2) {
    const mid = lo + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
getDecoder$1(htmlDecodeTree$1);
getDecoder$1(xmlDecodeTree$1);
const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
const getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c2, index2) => (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match3;
  while ((match3 = xmlReplacer.exec(str)) !== null) {
    const i = match3.index;
    const char = str.charCodeAt(i);
    const next22 = xmlCodeMap.get(char);
    if (next22 !== void 0) {
      ret += str.substring(lastIdx, i) + next22;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex2, map22) {
  return function escape2(data2) {
    let match3;
    let lastIdx = 0;
    let result = "";
    while (match3 = regex2.exec(data2)) {
      if (lastIdx !== match3.index) {
        result += data2.substring(lastIdx, match3.index);
      }
      result += map22.get(match3[0].charCodeAt(0));
      lastIdx = match3.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
const escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
const attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));
const unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode2 = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode2(value)}"`;
  }).join(" ");
}
const singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$1(node2, options = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node2, options) {
  switch (node2.type) {
    case Root:
      return render$1(node2.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node2);
    case Comment$1:
      return renderComment(node2);
    case CDATA$1:
      return renderCdata(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag(node2, options);
    case Text$1:
      return renderText(node2, options);
  }
}
const foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
const foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render$1(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data2 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function getOuterHTML(node2, options) {
  return render$1(node2, options);
}
function getInnerHTML(node2, options) {
  return hasChildren(node2) ? node2.children.map((node22) => getOuterHTML(node22, options)).join("") : "";
}
function getText(node2) {
  if (Array.isArray(node2))
    return node2.map(getText).join("");
  if (isTag(node2))
    return node2.name === "br" ? "\n" : getText(node2.children);
  if (isCDATA(node2))
    return getText(node2.children);
  if (isText(node2))
    return node2.data;
  return "";
}
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if (hasChildren(node2) && !isComment(node2)) {
    return textContent(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if (hasChildren(node2) && (node2.type === ElementType.Tag || isCDATA(node2))) {
    return innerText(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent2 = getParent(elem);
  if (parent2 != null)
    return getChildren(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next22 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next22 != null) {
    siblings2.push(next22);
    ({ next: next22 } = next22);
  }
  return siblings2;
}
function getAttributeValue(elem, name2) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
}
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next22 } = elem;
  while (next22 !== null && !isTag(next22))
    ({ next: next22 } = next22);
  return next22;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement2) {
  const prev2 = replacement2.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement2;
  }
  const next22 = replacement2.next = elem.next;
  if (next22) {
    next22.prev = replacement2;
  }
  const parent2 = replacement2.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement2;
    elem.parent = null;
  }
}
function appendChild(parent2, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent2;
  if (parent2.children.push(child) > 1) {
    const sibling = parent2.children[parent2.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append$1(elem, next22) {
  removeElement(next22);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next22.next = currNext;
  next22.prev = elem;
  elem.next = next22;
  next22.parent = parent2;
  if (currNext) {
    currNext.prev = next22;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next22);
    }
  } else if (parent2) {
    parent2.children.push(next22);
  }
}
function prependChild(parent2, child) {
  removeElement(child);
  child.parent = parent2;
  child.prev = null;
  if (parent2.children.unshift(child) !== 1) {
    const sibling = parent2.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend$1(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}
function filter$2$1(test3, node2, recurse = true, limit = Infinity) {
  return find$2(test3, Array.isArray(node2) ? node2 : [node2], recurse, limit);
}
function find$2(test3, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test3(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test3, nodes) {
  return nodes.find(test3);
}
function findOne(test3, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node2 = nodes[i];
    if (!isTag(node2)) {
      continue;
    } else if (test3(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne(test3, node2.children, true);
    }
  }
  return elem;
}
function existsOne(test3, nodes) {
  return nodes.some((checked) => isTag(checked) && (test3(checked) || existsOne(test3, checked.children)));
}
function findAll(test3, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag(elem))
      continue;
    if (test3(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
const Checks = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag;
    }
    return (elem) => isTag(elem) && elem.name === name2;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node2) {
  const test3 = compileTest(options);
  return test3 ? test3(node2) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test3 = compileTest(options);
  return test3 ? filter$2$1(test3, nodes, recurse, limit) : [];
}
function getElementById(id2, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id2), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter$2$1(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter$2$1(Checks["tag_type"](type), nodes, recurse, limit);
}
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node2 = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node2, i, arr) => !arr.includes(node2, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      const href2 = (_a3 = getOneElement("link", children2)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch$1("summary", children2) || fetch$1("content", children2);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch$1("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      const pubDate = fetch$1("pubDate", children2) || fetch$1("dc:date", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING = ["url", "type", "lang"];
const MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return getElementsByTagName(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch$1(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
const DomUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return DocumentPosition;
  },
  append: append$1,
  appendChild,
  compareDocumentPosition,
  existsOne,
  filter: filter$2$1,
  find: find$2,
  findAll,
  findOne,
  findOneChild,
  getAttributeValue,
  getChildren,
  getElementById,
  getElements,
  getElementsByTagName,
  getElementsByTagType,
  getFeed,
  getInnerHTML,
  getName,
  getOuterHTML,
  getParent,
  getSiblings,
  getText,
  hasAttrib,
  hasChildren,
  innerText,
  isCDATA,
  isComment,
  isDocument: isDocument$1,
  isTag,
  isText,
  nextElementSibling,
  prepend: prepend$1,
  prependChild,
  prevElementSibling,
  removeElement,
  removeSubsets,
  replaceElement,
  testElement,
  textContent,
  uniqueSort
}, Symbol.toStringTag, { value: "Module" }));
function render(that, dom2, options) {
  if (!that)
    return "";
  return that(dom2 !== null && dom2 !== void 0 ? dom2 : that._root.children, null, void 0, options).toString();
}
function isOptions(dom2, options) {
  return typeof dom2 === "object" && dom2 != null && !("length" in dom2) && !("type" in dom2);
}
function html$1$1(dom2, options) {
  const toRender = isOptions(dom2) ? (options = dom2, void 0) : dom2;
  const opts = {
    ...this === null || this === void 0 ? void 0 : this._options,
    ...flattenOptions(options)
  };
  return render(this, toRender, opts);
}
function xml(dom2) {
  const options = { ...this._options, xmlMode: true };
  return render(this, dom2, options);
}
function text$1(elements) {
  const elems = elements !== null && elements !== void 0 ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent(elems[i]);
  }
  return ret;
}
function parseHTML(data2, context, keepScripts = typeof context === "boolean" ? context : false) {
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data2, this._options, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return [...parsed.root()[0].children];
}
function root() {
  return this(this._root);
}
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  let next22 = contained;
  while (next22 && next22 !== next22.parent) {
    next22 = next22.parent;
    if (next22 === container) {
      return true;
    }
  }
  return false;
}
function extract$1(map22) {
  return this.root().extract(map22);
}
function merge$4(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || item === null || !("length" in item) || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (let i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}
const staticMethods = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contains,
  extract: extract$1,
  html: html$1$1,
  merge: merge$4,
  parseHTML,
  root,
  text: text$1,
  xml
}, Symbol.toStringTag, { value: "Module" }));
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str) {
  return str.replace(/[._-](\w|$)/g, (_, x2) => x2.toUpperCase());
}
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach(array2, fn) {
  const len = array2.length;
  for (let i = 0; i < len; i++)
    fn(array2[i], i);
  return array2;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3)
    return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
}
const hasOwn$m = Object.prototype.hasOwnProperty;
const rspace = /\s+/;
const dataAttrPrefix = "data-";
const rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
const rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a2;
  if (!elem || !isTag(elem))
    return void 0;
  (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn$m.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return text$1(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name2, value) {
  if (value === null) {
    removeAttribute(el, name2);
  } else {
    el.attribs[name2] = `${value}`;
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag(el))
          setAttr(el, name2, value.call(el, i, el.attribs[name2]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag(el))
        return;
      if (typeof name2 === "object") {
        for (const objName of Object.keys(name2)) {
          const objValue = name2[objName];
          setAttr(el, objName, objValue);
        }
      } else {
        setAttr(el, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
function getProp(el, name2, xmlMode) {
  return name2 in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name2]
  ) : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
}
function setProp$1(el, name2, value, xmlMode) {
  if (name2 in el) {
    el[name2] = value;
  } else {
    setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : `${value}`);
  }
}
function prop(name2, value) {
  var _a2;
  if (typeof name2 === "string" && value === void 0) {
    const el = this[0];
    if (!el || !isTag(el))
      return void 0;
    switch (name2) {
      case "style": {
        const property = this.css();
        const keys4 = Object.keys(property);
        for (let i = 0; i < keys4.length; i++) {
          property[i] = keys4[i];
        }
        property.length = keys4.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a2 = el.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.tagName === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el);
      }
      case "textContent": {
        return textContent(el);
      }
      case "outerHTML": {
        return this.clone().wrap("<container />").parent().html();
      }
      case "innerHTML": {
        return this.html();
      }
      default: {
        return getProp(el, name2, this.options.xmlMode);
      }
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new TypeError("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag(el)) {
          setProp$1(el, name2, value.call(el, i, getProp(el, name2, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag(el))
        return;
      if (typeof name2 === "object") {
        for (const key of Object.keys(name2)) {
          const val2 = name2[key];
          setProp$1(el, key, val2, this.options.xmlMode);
        }
      } else {
        setProp$1(el, name2, value, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData(elem, name2, value) {
  var _a2;
  (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readAllData(el) {
  for (const domName of Object.keys(el.attribs)) {
    if (!domName.startsWith(dataAttrPrefix)) {
      continue;
    }
    const jsName = camelCase(domName.slice(dataAttrPrefix.length));
    if (!hasOwn$m.call(el.data, jsName)) {
      el.data[jsName] = parseDataValue(el.attribs[domName]);
    }
  }
  return el.data;
}
function readData(el, name2) {
  const domName = dataAttrPrefix + cssCase(name2);
  const data2 = el.data;
  if (hasOwn$m.call(data2, name2)) {
    return data2[name2];
  }
  if (hasOwn$m.call(el.attribs, domName)) {
    return data2[name2] = parseDataValue(el.attribs[domName]);
  }
  return void 0;
}
function parseDataValue(value) {
  if (value === "null")
    return null;
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  const num = Number(value);
  if (value === String(num))
    return num;
  if (rbrace.test(value)) {
    try {
      return JSON.parse(value);
    } catch {
    }
  }
  return value;
}
function data$1(name2, value) {
  var _a2;
  const elem = this[0];
  if (!elem || !isTag(elem))
    return;
  const dataEl = elem;
  (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
  if (name2 == null) {
    return readAllData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    domEach(this, (el) => {
      if (isTag(el)) {
        if (typeof name2 === "object")
          setData(el, name2);
        else
          setData(el, name2, value);
      }
    });
    return this;
  }
  return readData(dataEl, name2);
}
function val(value) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag(element))
    return querying ? void 0 : this;
  switch (element.name) {
    case "textarea": {
      return this.text(value);
    }
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values2 = typeof value === "object" ? value : [value];
        for (const val2 of values2) {
          this.find(`option[value="${val2}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el) => text$1(el.children)) : option.attr("value");
    }
    case "input":
    case "option": {
      return querying ? this.attr("value") : this.attr("value", value);
    }
  }
  return void 0;
}
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn$m.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  const attrNames = splitNames(name2);
  for (const attrName of attrNames) {
    domEach(this, (elem) => {
      if (isTag(elem))
        removeAttribute(elem, attrName);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length > 0) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value.call(el, i, className));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag(el))
      continue;
    const className = getAttr(el, "class", false);
    if (className) {
      let setClass = ` ${className} `;
      for (const cn2 of classNames) {
        const appendClass = `${cn2} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    } else {
      setAttr(el, "class", classNames.join(" ").trim());
    }
  }
  return this;
}
function removeClass(name2) {
  if (typeof name2 === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        removeClass.call([el], name2.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name2);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j2 = 0; j2 < numClasses; j2++) {
        const index2 = elClasses.indexOf(classes[j2]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j2--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        toggleClass.call([el], value.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag(el))
      continue;
    const elementClasses = splitNames(el.attribs["class"]);
    for (let j2 = 0; j2 < numClasses; j2++) {
      const index2 = elementClasses.indexOf(classNames[j2]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j2]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}
const Attributes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass,
  attr,
  data: data$1,
  hasClass,
  prop,
  removeAttr,
  removeClass,
  toggleClass,
  val
}, Symbol.toStringTag, { value: "Module" }));
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$1(selector2) {
  switch (selector2.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace$1(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse$2(selector2) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector2}`, 0);
  if (endIndex < selector2.length) {
    throw new Error(`Unmatched selector: ${selector2.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector2, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match3 = selector2.slice(selectorIndex + offset).match(reName);
    if (!match3) {
      throw new Error(`Expected name, found ${selector2.slice(selectorIndex)}`);
    }
    const [name2] = match3;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector2.length && isWhitespace$1(selector2.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start2 = selectorIndex;
    let counter2 = 1;
    for (; counter2 > 0 && selectorIndex < selector2.length; selectorIndex++) {
      if (selector2.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter2++;
      } else if (selector2.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter2--;
      }
    }
    if (counter2) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector2.slice(start2, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector2.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector2.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector2.length) {
      const firstChar = selector2.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace2 = null;
          if (selector2.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector2.startsWith("*|", selectorIndex)) {
            namespace2 = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 61) {
              namespace2 = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector2.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector2.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector2.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector2.charCodeAt(selectorIndex))) {
              const quote = selector2.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector2.length && (selector2.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector2.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector2.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector2.length && (!isWhitespace$1(selector2.charCodeAt(selectorIndex)) && selector2.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector2.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector2.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector2.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace: namespace2,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector2.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector2.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector2.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector2.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector(data2, selector2, selectorIndex + 1);
              if (selector2.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector2})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector2.startsWith("/*", selectorIndex)) {
            const endIndex = selector2.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace2 = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector2.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector2.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector2.charCodeAt(selectorIndex) === 124 && selector2.charCodeAt(selectorIndex + 1) !== 124) {
            namespace2 = name2;
            if (selector2.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace: namespace2 } : { type: SelectorType.Tag, name: name2, namespace: namespace2 });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var boolbase$1;
var hasRequiredBoolbase;
function requireBoolbase() {
  if (hasRequiredBoolbase)
    return boolbase$1;
  hasRequiredBoolbase = 1;
  boolbase$1 = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
  return boolbase$1;
}
var boolbaseExports = requireBoolbase();
const boolbase = /* @__PURE__ */ getDefaultExportFromCjs$1(boolbaseExports);
const procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal(token2) {
  return !procedure.has(token2.type);
}
const attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j2 = i - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
      const token2 = arr[j2 + 1];
      arr[j2 + 1] = arr[j2];
      arr[j2] = token2;
      procs[j2 + 1] = procs[j2];
      procs[j2] = procNew;
    }
  }
}
function getProcedure(token2) {
  var _a2, _b;
  let proc = (_a2 = procedure.get(token2.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token2.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token2.action)) !== null && _b !== void 0 ? _b : 4;
    if (token2.action === AttributeAction.Equals && token2.name === "id") {
      proc = 9;
    }
    if (token2.ignoreCase) {
      proc >>= 1;
    }
  } else if (token2.type === SelectorType.Pseudo) {
    if (!token2.data) {
      proc = 3;
    } else if (token2.name === "has" || token2.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token2.data)) {
      proc = Math.min(...token2.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}
const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
const caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector2, options) {
  return typeof selector2.ignoreCase === "boolean" ? selector2.ignoreCase : selector2.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector2.name);
}
const attributeRules = {
  equals(next22, data2, options) {
    const { adapter } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next22(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name2) === value && next22(elem);
  },
  hyphen(next22, data2, options) {
    const { adapter } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next22(elem);
      };
    }
    return function hyphen(elem) {
      const attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next22(elem);
    };
  },
  element(next22, data2, options) {
    const { adapter } = options;
    const { name: name2, value } = data2;
    if (/\s/.test(value)) {
      return boolbase.falseFunc;
    }
    const regex2 = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
    return function element(elem) {
      const attr2 = adapter.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex2.test(attr2) && next22(elem);
    };
  },
  exists(next22, { name: name2 }, { adapter }) {
    return (elem) => adapter.hasAttrib(elem, name2) && next22(elem);
  },
  start(next22, data2, options) {
    const { adapter } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next22(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next22(elem);
    };
  },
  end(next22, data2, options) {
    const { adapter } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next22(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next22(elem);
    };
  },
  any(next22, data2, options) {
    const { adapter } = options;
    const { name: name2, value } = data2;
    if (value === "") {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      const regex2 = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex2.test(attr2) && next22(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next22(elem);
    };
  },
  not(next22, data2, options) {
    const { adapter } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter.getAttributeValue(elem, name2) && next22(elem);
    } else if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next22(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name2) !== value && next22(elem);
  }
};
const whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$1(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number2 = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number2 !== null && number2 !== void 0 ? number2 : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number2 = readNumber();
    } else {
      sign = number2 = 0;
    }
  }
  if (number2 === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number2];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start2 = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start2 ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$1(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return boolbase.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? boolbase.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}
function nthCheck(formula) {
  return compile$1(parse$1(formula));
}
function getChildFunc(next22, adapter) {
  return (elem) => {
    const parent2 = adapter.getParent(elem);
    return parent2 != null && adapter.isTag(parent2) && next22(elem);
  };
}
const filters = {
  contains(next22, text2, { adapter }) {
    return function contains2(elem) {
      return next22(elem) && adapter.getText(elem).includes(text2);
    };
  },
  icontains(next22, text2, { adapter }) {
    const itext = text2.toLowerCase();
    return function icontains(elem) {
      return next22(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next22, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next22, adapter);
    return function nthChild(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next22(elem);
    };
  },
  "nth-last-child"(next22, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next22, adapter);
    return function nthLastChild(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next22(elem);
    };
  },
  "nth-of-type"(next22, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next22, adapter);
    return function nthOfType(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next22(elem);
    };
  },
  "nth-last-of-type"(next22, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc(next22, adapter);
    return function nthLastOfType(elem) {
      const siblings2 = adapter.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next22(elem);
    };
  },
  // TODO determine the actual root element
  root(next22, _rule, { adapter }) {
    return (elem) => {
      const parent2 = adapter.getParent(elem);
      return (parent2 == null || !adapter.isTag(parent2)) && next22(elem);
    };
  },
  scope(next22, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next22, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next22(elem);
    }
    return (elem) => context.includes(elem) && next22(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name2) {
  return function dynamicPseudo(next22, _rule, { adapter }) {
    const func = adapter[name2];
    if (typeof func !== "function") {
      return boolbase.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next22(elem);
    };
  };
}
const pseudos = {
  empty(elem, { adapter }) {
    return !adapter.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter.isTag(elem2) || adapter.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter, equals }) {
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    const firstChild = adapter.getSiblings(elem).find((elem2) => adapter.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      if (equals(elem, siblings2[i]))
        return true;
      if (adapter.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = 0; i < siblings2.length; i++) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter, equals }) {
    const siblings2 = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter, equals }) {
    const elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter, equals }) {
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name2} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
  }
}
const aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
const PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next22, adapter) {
  if (next22 === boolbase.falseFunc)
    return boolbase.falseFunc;
  return (elem) => adapter.isTag(elem) && next22(elem);
}
function getNextSiblings(elem, adapter) {
  const siblings2 = adapter.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
const is$2 = (next22, token2, options, context, compileToken2) => {
  const func = compileToken2(token2, copyOptions(options), context);
  return func === boolbase.trueFunc ? next22 : func === boolbase.falseFunc ? boolbase.falseFunc : (elem) => func(elem) && next22(elem);
};
const subselects = {
  is: is$2,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$2,
  where: is$2,
  not(next22, token2, options, context, compileToken2) {
    const func = compileToken2(token2, copyOptions(options), context);
    return func === boolbase.falseFunc ? next22 : func === boolbase.trueFunc ? boolbase.falseFunc : (elem) => !func(elem) && next22(elem);
  },
  has(next22, subselect, options, _context, compileToken2) {
    const { adapter } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === boolbase.falseFunc)
      return boolbase.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter);
    if (context && compiled !== boolbase.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next22(elem))
          return false;
        context[0] = elem;
        const childs = adapter.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter)] : childs;
        return adapter.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next22(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
  }
};
function compilePseudoSelector(next22, selector2, options, context, compileToken2) {
  var _a2;
  const { name: name2, data: data2 } = selector2;
  if (Array.isArray(data2)) {
    if (!(name2 in subselects)) {
      throw new Error(`Unknown pseudo-class :${name2}(${data2})`);
    }
    return subselects[name2](next22, data2, options, context, compileToken2);
  }
  const userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name2];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name2} doesn't have any arguments`);
    }
    const alias = parse$2(stringPseudo);
    return subselects["is"](next22, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name2, data2, 1);
    return (elem) => userPseudo(elem, data2) && next22(elem);
  }
  if (name2 in filters) {
    return filters[name2](next22, data2, options, context);
  }
  if (name2 in pseudos) {
    const pseudo = pseudos[name2];
    verifyPseudoArgs(pseudo, name2, data2, 2);
    return (elem) => pseudo(elem, options, data2) && next22(elem);
  }
  throw new Error(`Unknown pseudo-class :${name2}`);
}
function getElementParent(node2, adapter) {
  const parent2 = adapter.getParent(node2);
  if (parent2 && adapter.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next22, selector2, options, context, compileToken2) {
  const { adapter, equals } = options;
  switch (selector2.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector2.name = selector2.name.toLowerCase();
      }
      return attributeRules[selector2.action](next22, selector2, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next22, selector2, options, context, compileToken2);
    }
    case SelectorType.Tag: {
      if (selector2.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name: name2 } = selector2;
      if (!options.xmlMode || options.lowerCaseTags) {
        name2 = name2.toLowerCase();
      }
      return function tag(elem) {
        return adapter.getName(elem) === name2 && next22(elem);
      };
    }
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next22(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter)) {
          if (!isFalseCache.has(current)) {
            if (adapter.isTag(current) && next22(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next22(current))
            return true;
        } while (current = getElementParent(current, adapter));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent2(elem) {
        return adapter.getChildren(elem).some((elem2) => adapter.isTag(elem2) && next22(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent2 = adapter.getParent(elem);
        return parent2 != null && adapter.isTag(parent2) && next22(parent2);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings2 = adapter.getSiblings(elem);
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && next22(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter.prevElementSibling(elem);
          return previous != null && next22(previous);
        };
      }
      return function adjacent(elem) {
        const siblings2 = adapter.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next22(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector2.namespace != null && selector2.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next22;
    }
  }
}
function includesScopePseudo(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data2) => data2.some(includesScopePseudo)));
}
const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
const FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
const SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token2, { adapter }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter.isTag(e) && adapter.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent2 && adapter.isTag(parent2);
  }));
  for (const t of token2) {
    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== SelectorType.Descendant)
      ;
    else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token2, options, context) {
  var _a2;
  token2.forEach(sortByProcedure);
  context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token2, options, finalContext);
  } else if (token2.some((t) => t.length > 0 && isTraversal(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token2.map((rules2) => {
    if (rules2.length >= 2) {
      const [first2, second] = rules2;
      if (first2.type !== SelectorType.Pseudo || first2.name !== "scope")
        ;
      else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules2[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules2, options, finalContext);
  }).reduce(reduceRules, boolbase.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules2, options, context) {
  var _a2;
  return rules2.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : boolbase.trueFunc);
}
function reduceRules(a, b) {
  if (b === boolbase.falseFunc || a === boolbase.trueFunc) {
    return a;
  }
  if (a === boolbase.falseFunc || b === boolbase.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}
const defaultEquals = (a, b) => a === b;
const defaultOptions$1 = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a2, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions$1;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = DomUtils;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector2, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector2, opts, context);
  };
}
const _compileToken = wrapCompile(compileToken);
function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
}
function appendNextSiblings(elem, adapter) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter);
    elems.push(...nextSiblings);
  }
  return elems;
}
const filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter22, data2, partLimit) {
  const num = data2 != null ? parseInt(data2, 10) : NaN;
  switch (filter22) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
    case "lt":
      return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}
function getDocumentRoot(node2) {
  while (node2.parent)
    node2 = node2.parent;
  return node2;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector2 of selectors) {
    if (selector2.some(isFilter)) {
      filteredSelectors.push(selector2);
    } else {
      plainSelectors.push(selector2);
    }
  }
  return [plainSelectors, filteredSelectors];
}
const UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null
};
const SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is$1(element, selector2, options = {}) {
  return some$4([element], selector2, options);
}
function some$4(elements, selector2, options = {}) {
  if (typeof selector2 === "function")
    return elements.some(selector2);
  const [plain, filtered] = groupSelectors(parse$2(selector2));
  return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
}
function filterByPosition(filter22, elems, data2, options) {
  const num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
  switch (filter22) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data2, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter$1$1(selector2, elements, options = {}) {
  return filterParsed(parse$2(selector2), elements, options);
}
function filterParsed(selector2, elements, options) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector2);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
    const filteredSelector = filteredSelectors[i];
    const missing = found ? elements.filter((e) => isTag(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : (
    // Filter elements to preserve order
    elements.filter((el) => found.has(el))
  ) : [];
}
function filterBySelector(selector2, elements, options) {
  var _a2;
  if (selector2.some(isTraversal$1)) {
    const root2 = (_a2 = options.root) !== null && _a2 !== void 0 ? _a2 : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector2.push(SCOPE_PSEUDO);
    return findFilterElements(root2, selector2, opts, true, elements.length);
  }
  return findFilterElements(elements, selector2, options, false, elements.length);
}
function select(selector2, root2, options = {}, limit = Infinity) {
  if (typeof selector2 === "function") {
    return find$1(root2, selector2);
  }
  const [plain, filtered] = groupSelectors(parse$2(selector2));
  const results = filtered.map((sel) => findFilterElements(root2, sel, options, true, limit));
  if (plain.length) {
    results.push(findElements(root2, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
function findFilterElements(root2, selector2, options, queryForSelector, totalLimit) {
  const filterIndex = selector2.findIndex(isFilter);
  const sub = selector2.slice(0, filterIndex);
  const filter22 = selector2[filterIndex];
  const partLimit = selector2.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter22.name, filter22.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub.length === 0 && !Array.isArray(root2) ? getChildren(root2).filter(isTag) : sub.length === 0 ? (Array.isArray(root2) ? root2 : [root2]).filter(isTag) : queryForSelector || sub.some(isTraversal$1) ? findElements(root2, [sub], options, limit) : filterElements(root2, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter22.name, elems, filter22.data, options);
  if (result.length === 0 || selector2.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector2.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal$1);
  if (remainingHasTraversal) {
    if (isTraversal$1(remainingSelector[0])) {
      const { type } = remainingSelector[0];
      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {
        result = prepareContext(result, DomUtils, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el) => result.includes(el)
    };
  } else if (options.rootFunc && options.rootFunc !== boolbaseExports.trueFunc) {
    options = { ...options, rootFunc: boolbaseExports.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
    // Query existing elements to resolve traversal.
    findElements(result, [remainingSelector], options, totalLimit)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    filterElements(result, [remainingSelector], options)
  );
}
function findElements(root2, sel, options, limit) {
  const query = _compileToken(sel, options, root2);
  return find$1(root2, query, limit);
}
function find$1(root2, query, limit = Infinity) {
  const elems = prepareContext(root2, DomUtils, query.shouldTestNextSiblings);
  return find$2((node2) => isTag(node2) && query(node2), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag);
  if (els.length === 0)
    return els;
  const query = _compileToken(sel, options);
  return query === boolbaseExports.trueFunc ? els : els.filter(query);
}
const reSiblingSelector = /^\s*[+~]/;
function find$3(selectorOrHaystack) {
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    const context = this.toArray();
    return this._make(haystack.filter((elem) => context.some((node2) => contains(node2, elem))));
  }
  return this._findBySelector(selectorOrHaystack, Number.POSITIVE_INFINITY);
}
function _findBySelector(selector2, limit) {
  var _a2;
  const context = this.toArray();
  const elems = reSiblingSelector.test(selector2) ? context : this.children().toArray();
  const options = {
    context,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selector2, elems, options, limit));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector2) {
      var _a2;
      let matched = matchMap(fn, this);
      if (selector2) {
        matched = filterArray(matched, selector2, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
const _matcher = _getMatcher((fn, elems) => {
  let ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value.length > 0)
      ret = ret.concat(value);
  }
  return ret;
});
const _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next22; next22 = nextElem2(elem); elem = next22) {
        if (matches === null || matches === void 0 ? void 0 : matches(next22, matched.length))
          break;
        matched.push(next22);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector2, filterSelector) {
    matches = typeof selector2 === "string" ? (elem) => is$1(elem, selector2, this.options) : selector2 ? getFilterFn(selector2) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return elems.length > 1 ? Array.from(new Set(elems)) : elems;
}
const parent$n = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument$1(parent2) ? parent2 : null, _removeDuplicates);
const parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument$1(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
const parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument$1(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector2) {
  var _a2;
  const set3 = [];
  if (!selector2) {
    return this._make(set3);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
  };
  const selectFn = typeof selector2 === "string" ? (elem) => is$1(elem, selector2, selectOpts) : getFilterFn(selector2);
  domEach(this, (elem) => {
    if (elem && !isDocument$1(elem) && !isTag(elem)) {
      elem = elem.parent;
    }
    while (elem && isTag(elem)) {
      if (selectFn(elem, 0)) {
        if (!set3.includes(elem)) {
          set3.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set3);
}
const next$1 = _singleMatcher((elem) => nextElementSibling(elem));
const nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
const prev = _singleMatcher((elem) => prevElementSibling(elem));
const prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
const siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag(el) && el !== elem), uniqueSort);
const children = _matcher((elem) => getChildren(elem).filter(isTag), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each$1(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
function map$9(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match3) {
  if (typeof match3 === "function") {
    return (el, i) => match3.call(el, i, el);
  }
  if (isCheerio(match3)) {
    return (el) => Array.prototype.includes.call(match3, el);
  }
  return function(el) {
    return match3 === el;
  };
}
function filter$4(match3) {
  var _a2;
  return this._make(filterArray(this.toArray(), match3, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
}
function filterArray(nodes, match3, xmlMode, root2) {
  return typeof match3 === "string" ? filter$1$1(match3, nodes, { xmlMode, root: root2 }) : nodes.filter(getFilterFn(match3));
}
function is(selector2) {
  const nodes = this.toArray();
  return typeof selector2 === "string" ? some$4(nodes.filter(isTag), selector2, this.options) : selector2 ? nodes.some(getFilterFn(selector2)) : false;
}
function not(match3) {
  let nodes = this.toArray();
  if (typeof match3 === "string") {
    const matches = new Set(filter$1$1(match3, nodes, this.options));
    nodes = nodes.filter((el) => !matches.has(el));
  } else {
    const filterFn = getFilterFn(match3);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
function has$2(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${selectorOrHaystack})`
  ) : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
}
function first$1() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq(i) {
  var _a2;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a2 = this[i]) !== null && _a2 !== void 0 ? _a2 : []);
}
function get$7(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
function toArray$1() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice$7(start2, end2) {
  return this._make(Array.prototype.slice.call(this, start2, end2));
}
function end() {
  var _a2;
  return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
}
function add(other, context) {
  const selection2 = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection2.get()]);
  return this._make(contents2);
}
function addBack(selector2) {
  return this.prevObject ? this.add(selector2 ? this.prevObject.filter(selector2) : this.prevObject) : this;
}
const Traversing = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _findBySelector,
  add,
  addBack,
  children,
  closest,
  contents,
  each: each$1,
  end,
  eq,
  filter: filter$4,
  filterArray,
  find: find$3,
  first: first$1,
  get: get$7,
  has: has$2,
  index,
  is,
  last,
  map: map$9,
  next: next$1,
  nextAll,
  nextUntil,
  not,
  parent: parent$n,
  parents,
  parentsUntil,
  prev,
  prevAll,
  prevUntil,
  siblings,
  slice: slice$7,
  toArray: toArray$1
}, Symbol.toStringTag, { value: "Module" }));
function getParse(parser) {
  return function parse2(content, options, isDocument$1$1, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser(content, options, isDocument$1$1, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument$1(doc)) {
      return doc;
    }
    const root2 = new Document$1([]);
    update(doc, root2);
    return root2;
  };
}
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i = 0; i < arr.length; i++) {
    const node2 = arr[i];
    if (node2.parent && node2.parent.children !== arr) {
      removeElement(node2);
    }
    if (parent2) {
      node2.prev = arr[i - 1] || null;
      node2.next = arr[i + 1] || null;
    } else {
      node2.prev = node2.next = null;
    }
    node2.parent = parent2;
  }
  return parent2;
}
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children.slice(0);
  }
  if ("length" in elem) {
    if (elem.length === 1) {
      return this._makeDomArray(elem[0], clone2);
    }
    const result = [];
    for (let i = 0; i < elem.length; i++) {
      const el = elem[i];
      if (typeof el === "object") {
        if (el == null) {
          continue;
        }
        if (!("length" in el)) {
          result.push(clone2 ? cloneNode(el, true) : el);
          continue;
        }
      }
      result.push(...this._makeDomArray(el, clone2));
    }
    return result;
  }
  return [clone2 ? cloneNode(elem, true) : elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom2 = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom2, el.children, el);
    });
  };
}
function uniqueSplice(array2, spliceIdx, spliceCount, newElems, parent2) {
  var _a2, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array2[spliceIdx - 1];
  const next22 = spliceIdx + spliceCount >= array2.length ? null : array2[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node2 = newElems[idx];
    const oldParent = node2.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node2);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node2.parent = parent2;
    if (node2.prev) {
      node2.prev.next = (_a2 = node2.next) !== null && _a2 !== void 0 ? _a2 : null;
    }
    if (node2.next) {
      node2.next.prev = (_b = node2.prev) !== null && _b !== void 0 ? _b : null;
    }
    node2.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node2.next = idx === newElems.length - 1 ? next22 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next22) {
    next22.prev = newElems[newElems.length - 1];
  }
  return array2.splice(...spliceArgs);
}
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
const append = _insert((dom2, children2, parent2) => {
  uniqueSplice(children2, children2.length, 0, dom2, parent2);
});
const prepend = _insert((dom2, children2, parent2) => {
  uniqueSplice(children2, 0, 0, dom2, parent2);
});
function _wrap(insert) {
  return function(wrapper2) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap2 = typeof wrapper2 === "function" ? wrapper2.call(el, i, el) : typeof wrapper2 === "string" && !isHtml(wrapper2) ? lastParent.find(wrapper2).clone() : wrapper2;
      const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j2 = 0;
      while (j2 < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j2];
        if (isTag(child)) {
          elInsertLocation = child;
          j2 = 0;
        } else {
          j2++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
const wrap$1 = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el);
  update([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
const wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el))
    return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
function unwrap(selector2) {
  this.parent(selector2).not("body").each((_, el) => {
    this._make(el).replaceWith(el.children);
  });
  return this;
}
function wrapAll(wrapper2) {
  const el = this[0];
  if (el) {
    const wrap2 = this._make(typeof wrapper2 === "function" ? wrapper2.call(el, 0, el) : wrapper2).insertBefore(el);
    let elInsertLocation;
    for (let i = 0; i < wrap2.length; i++) {
      if (wrap2[i].type === "tag")
        elInsertLocation = wrap2[i];
    }
    let j2 = 0;
    while (elInsertLocation && j2 < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j2];
      if (child.type === "tag") {
        elInsertLocation = child;
        j2 = 0;
      } else {
        j2++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    if (!hasChildren(el) || !el.parent) {
      return;
    }
    const siblings2 = el.parent.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom2 = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom2, el.parent);
  });
}
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  for (const el of this._makeDomArray(target)) {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      continue;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      continue;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  }
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    if (!hasChildren(el) || !el.parent) {
      return;
    }
    const siblings2 = el.parent.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom2 = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom2, el.parent);
  });
}
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector2) {
  const elems = selector2 ? this.filter(selector2) : this;
  domEach(elems, (el) => {
    removeElement(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el, i, el) : content;
    const dom2 = this._makeDomArray(cont);
    update(dom2, null);
    const index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom2, parent2);
    if (!dom2.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
function empty$1() {
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    el.children.length = 0;
  });
}
function html$3(str) {
  if (str === void 0) {
    const el = this[0];
    if (!el || !hasChildren(el))
      return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el).children;
    update(content, el);
  });
}
function toString$e() {
  return this._render(this);
}
function text$2(str) {
  if (str === void 0) {
    return text$1(this);
  }
  if (typeof str === "function") {
    return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text$1([el]))));
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    for (const child of el.children) {
      child.next = child.prev = child.parent = null;
    }
    const textNode = new Text$2(`${str}`);
    update(textNode, el);
  });
}
function clone$1() {
  const clone2 = Array.prototype.map.call(this.get(), (el) => cloneNode(el, true));
  const root2 = new Document$1(clone2);
  for (const node2 of clone2) {
    node2.parent = root2;
  }
  return this._make(clone2);
}
const Manipulation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _makeDomArray,
  after,
  append,
  appendTo,
  before,
  clone: clone$1,
  empty: empty$1,
  html: html$3,
  insertAfter,
  insertBefore,
  prepend,
  prependTo,
  remove,
  replaceWith,
  text: text$2,
  toString: toString$e,
  unwrap,
  wrap: wrap$1,
  wrapAll,
  wrapInner
}, Symbol.toStringTag, { value: "Module" }));
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach(this, (el, i) => {
      if (isTag(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    const styles2 = getCss(el);
    const val2 = typeof value === "function" ? value.call(el, idx, styles2[prop2]) : value;
    if (val2 === "") {
      delete styles2[prop2];
    } else if (val2 != null) {
      styles2[prop2] = val2;
    }
    el.attribs["style"] = stringify$4(styles2);
  } else if (typeof prop2 === "object") {
    const keys4 = Object.keys(prop2);
    for (let i = 0; i < keys4.length; i++) {
      const k = keys4[i];
      setCss(el, k, prop2[k], i);
    }
  }
}
function getCss(el, prop2) {
  if (!el || !isTag(el))
    return;
  const styles2 = parse$3(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles2[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    for (const item of prop2) {
      if (styles2[item] != null) {
        newStyles[item] = styles2[item];
      }
    }
    return newStyles;
  }
  return styles2;
}
function stringify$4(obj) {
  return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse$3(styles2) {
  styles2 = (styles2 || "").trim();
  if (!styles2)
    return {};
  const obj = {};
  let key;
  for (const str of styles2.split(";")) {
    const n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}
const Css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  css
}, Symbol.toStringTag, { value: "Module" }));
const submittableSelector = "input,select,textarea,keygen";
const r20 = /%20/g;
const rCRLF = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
  return retArr.join("&").replace(r20, "+");
}
function serializeArray() {
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((_, elem) => {
    var _a2;
    const $elem = this._make(elem);
    const name2 = $elem.attr("name");
    const value = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
    if (Array.isArray(value)) {
      return value.map((val2) => (
        /*
         * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
         * These can occur inside of `<textarea>'s`
         */
        { name: name2, value: val2.replace(rCRLF, "\r\n") }
      ));
    }
    return { name: name2, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}
const Forms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  serialize,
  serializeArray
}, Symbol.toStringTag, { value: "Module" }));
function getExtractDescr(descr) {
  var _a2;
  if (typeof descr === "string") {
    return { selector: descr, value: "textContent" };
  }
  return {
    selector: descr.selector,
    value: (_a2 = descr.value) !== null && _a2 !== void 0 ? _a2 : "textContent"
  };
}
function extract(map22) {
  const ret = {};
  for (const key in map22) {
    const descr = map22[key];
    const isArray3 = Array.isArray(descr);
    const { selector: selector2, value } = getExtractDescr(isArray3 ? descr[0] : descr);
    const fn = typeof value === "function" ? value : typeof value === "string" ? (el) => this._make(el).prop(value) : (el) => this._make(el).extract(value);
    if (isArray3) {
      ret[key] = this._findBySelector(selector2, Number.POSITIVE_INFINITY).map((_, el) => fn(el, key, ret)).get();
    } else {
      const $2 = this._findBySelector(selector2, 1);
      ret[key] = $2.length > 0 ? fn($2[0], key, ret) : void 0;
    }
  }
  return ret;
}
const Extract = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extract
}, Symbol.toStringTag, { value: "Module" }));
class Cheerio {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root2, options) {
    this.length = 0;
    this.options = options;
    this._root = root2;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
}
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms, Extract);
function getLoad(parse2, render2) {
  return function load2(content, options, isDocument2 = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = flattenOptions(options);
    const initialRoot = parse2(content, internalOpts, isDocument2, null);
    class LoadedCheerio extends Cheerio {
      _make(selector2, context) {
        const cheerio = initialize(selector2, context);
        cheerio.prevObject = this;
        return cheerio;
      }
      _parse(content2, options2, isDocument3, context) {
        return parse2(content2, options2, isDocument3, context);
      }
      _render(dom2) {
        return render2(dom2, this.options);
      }
    }
    function initialize(selector2, context, root2 = initialRoot, opts) {
      if (selector2 && isCheerio(selector2))
        return selector2;
      const options2 = flattenOptions(opts, internalOpts);
      const r = typeof root2 === "string" ? [parse2(root2, options2, false, null)] : "length" in root2 ? root2 : [root2];
      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options2);
      rootInstance._root = rootInstance;
      if (!selector2) {
        return new LoadedCheerio(void 0, rootInstance, options2);
      }
      const elements = typeof selector2 === "string" && isHtml(selector2) ? (
        // $(<html>)
        parse2(selector2, options2, false, null).children
      ) : isNode$1(selector2) ? (
        // $(dom)
        [selector2]
      ) : Array.isArray(selector2) ? (
        // $([dom])
        selector2
      ) : void 0;
      const instance = new LoadedCheerio(elements, rootInstance, options2);
      if (elements) {
        return instance;
      }
      if (typeof selector2 !== "string") {
        throw new TypeError("Unexpected type of selector");
      }
      let search = selector2;
      const searchContext = context ? (
        // If we don't have a context, maybe we have a root, from loading
        typeof context === "string" ? isHtml(context) ? (
          // $('li', '<ul>...</ul>')
          new LoadedCheerio([parse2(context, options2, false, null)], rootInstance, options2)
        ) : (
          // $('li', 'ul')
          (search = `${context} ${search}`, rootInstance)
        ) : isCheerio(context) ? (
          // $('li', $)
          context
        ) : (
          // $('li', node), $('li', [nodes])
          new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2)
        )
      ) : rootInstance;
      if (!searchContext)
        return instance;
      return searchContext.find(search);
    }
    Object.assign(initialize, staticMethods, {
      load: load2,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
function isNode$1(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}
var CharCodes$2;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes2[CharCodes2["Number"] = 35] = "Number";
  CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
  CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
  CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
  CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
  CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
  CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
  CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
  CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
  CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
  CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
  CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
  CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
  CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
  CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
  CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes$2 || (CharCodes$2 = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["BeforeSpecialT"] = 23] = "BeforeSpecialT";
  State2[State2["SpecialStartSequence"] = 24] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 25] = "InSpecialTag";
  State2[State2["InEntity"] = 26] = "InEntity";
})(State || (State = {}));
function isWhitespace$2(c2) {
  return c2 === CharCodes$2.Space || c2 === CharCodes$2.NewLine || c2 === CharCodes$2.Tab || c2 === CharCodes$2.FormFeed || c2 === CharCodes$2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes$2.Slash || c2 === CharCodes$2.Gt || isWhitespace$2(c2);
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes$2.LowerA && c2 <= CharCodes$2.LowerZ || c2 >= CharCodes$2.UpperA && c2 <= CharCodes$2.UpperZ;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.entityStart = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityDecoder = new EntityDecoder$1(xmlMode ? xmlDecodeTree$1 : htmlDecodeTree$1, (cp, consumed) => this.emitCodePoint(cp, consumed));
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  stateText(c2) {
    if (c2 === CharCodes$2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes$2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes$2.Amp) {
      this.startEntity();
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c2)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c2 | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes$2.Gt || isWhitespace$2(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes$2.Amp) {
          this.startEntity();
        }
      } else if (this.fastForwardTo(CharCodes$2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes$2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes$2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower2 = c2 | 32;
      this.sectionStart = this.index;
      if (this.xmlMode) {
        this.state = State.InTagName;
      } else if (lower2 === Sequences.ScriptEnd[2]) {
        this.state = State.BeforeSpecialS;
      } else if (lower2 === Sequences.TitleEnd[2]) {
        this.state = State.BeforeSpecialT;
      } else {
        this.state = State.InTagName;
      }
    } else if (c2 === CharCodes$2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace$2(c2))
      ;
    else if (c2 === CharCodes$2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes$2.Gt || isWhitespace$2(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes$2.Gt || this.fastForwardTo(CharCodes$2.Gt)) {
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes$2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace$2(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes$2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace$2(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes$2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = this.index;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes$2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes$2.Slash || c2 === CharCodes$2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace$2(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes$2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes$2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace$2(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes$2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes$2.Amp) {
      this.startEntity();
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes$2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes$2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace$2(c2) || c2 === CharCodes$2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes$2.Amp) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes$2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes$2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes$2.Gt || this.fastForwardTo(CharCodes$2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes$2.Gt || this.fastForwardTo(CharCodes$2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes$2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes$2.Gt || this.fastForwardTo(CharCodes$2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower2 = c2 | 32;
    if (lower2 === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower2 === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeSpecialT(c2) {
    const lower2 = c2 | 32;
    if (lower2 === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (lower2 === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  startEntity() {
    this.baseState = this.state;
    this.state = State.InEntity;
    this.entityStart = this.index;
    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode$1.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode$1.Legacy : DecodingMode$1.Attribute);
  }
  stateInEntity() {
    const length2 = this.entityDecoder.write(this.buffer, this.index - this.offset);
    if (length2 >= 0) {
      this.state = this.baseState;
      if (length2 === 0) {
        this.index = this.entityStart;
      }
    } else {
      this.index = this.offset + this.buffer.length - 1;
    }
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.BeforeSpecialT: {
          this.stateBeforeSpecialT(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InEntity) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName)
      ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      if (this.sectionStart < this.entityStart) {
        this.cbs.onattribdata(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.onattribentity(cp);
    } else {
      if (this.sectionStart < this.entityStart) {
        this.cbs.ontext(this.sectionStart, this.entityStart);
      }
      this.sectionStart = this.entityStart + consumed;
      this.index = this.sectionStart - 1;
      this.cbs.ontextentity(cp, this.sectionStart);
    }
  }
}
const formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
const pTag = /* @__PURE__ */ new Set(["p"]);
const tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
const ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
const rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
const openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
const voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
const foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
const htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
const reNameEnd = /\s|\//;
let Parser$1 = class Parser {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e, _f;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.htmlMode = !this.options.xmlMode;
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : this.htmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
    this.recognizeSelfClosing = (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
    this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
    this.foreignContext = [!this.htmlMode];
    (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start2, endIndex) {
    var _a2, _b;
    const data2 = this.getSlice(start2, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data2);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint$2(cp));
    this.startIndex = endIndex;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(name2) {
    return this.htmlMode && voidElements.has(name2);
  }
  /** @internal */
  onopentagname(start2, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start2, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = this.htmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
        const element = this.stack.shift();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.unshift(name2);
      if (this.htmlMode) {
        if (foreignContextElements.has(name2)) {
          this.foreignContext.unshift(true);
        } else if (htmlIntegrationElements.has(name2)) {
          this.foreignContext.unshift(false);
        }
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start2, endIndex) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start2, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (this.htmlMode && (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2))) {
      this.foreignContext.shift();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.indexOf(name2);
      if (pos !== -1) {
        for (let index2 = 0; index2 <= pos; index2++) {
          const element = this.stack.shift();
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, index2 !== pos);
        }
      } else if (this.htmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (this.htmlMode && name2 === "br") {
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
      (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
      (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.recognizeSelfClosing || this.foreignContext[0]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[0] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name2, !isOpenImplied);
      this.stack.shift();
    }
  }
  /** @internal */
  onattribname(start2, endIndex) {
    this.startIndex = start2;
    const name2 = this.getSlice(start2, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start2, endIndex) {
    this.attribvalue += this.getSlice(start2, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint$2(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start2, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start2, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start2, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start2, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start2, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start2, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start2, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start2, endIndex - offset);
    if (!this.htmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = 0; index2 < this.stack.length; index2++) {
        this.cbs.onclosetag(this.stack[index2], true);
      }
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.foreignContext.length = 0;
    this.foreignContext.unshift(!this.htmlMode);
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data2) {
    this.reset();
    this.end(data2);
  }
  getSlice(start2, end2) {
    while (start2 - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice22 = this.buffers[0].slice(start2 - this.bufferOffset, end2 - this.bufferOffset);
    while (end2 - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice22 += this.buffers[0].slice(0, end2 - this.bufferOffset);
    }
    return slice22;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};
function parseDocument$1(data2, options) {
  const handler = new DomHandler(void 0, options);
  new Parser$1(handler, options).end(data2);
  return handler.root;
}
const load = getLoad(getParse(parseDocument$1), render$1);
const defaultSelectorRules = {
  "div,p": ({ $node }) => ({
    queue: $node.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node, getContent }) => ({
    ...getContent($node.contents())
  }),
  "ul,ol": ({ $node }) => ({
    queue: $node.children(),
    nesting: true
  }),
  li: ({ $node, getContent }) => {
    const queue = $node.children().filter("ul,ol");
    let content;
    if ($node.contents().first().is("div,p")) {
      content = getContent($node.children().first());
    } else {
      let $contents = $node.contents();
      const i = $contents.index(queue);
      if (i >= 0)
        $contents = $contents.slice(0, i);
      content = getContent($contents);
    }
    return {
      queue,
      nesting: true,
      ...content
    };
  },
  "table,pre,p>img:only-child": ({ $node, getContent }) => ({
    ...getContent($node)
  })
};
const defaultOptions$2 = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: defaultSelectorRules
};
const MARKMAP_COMMENT_PREFIX = "markmap: ";
const SELECTOR_HEADING = /^h[1-6]$/;
const SELECTOR_LIST = /^[uo]l$/;
const SELECTOR_LIST_ITEM = /^li$/;
function getLevel(tagName) {
  if (SELECTOR_HEADING.test(tagName))
    return +tagName[1];
  if (SELECTOR_LIST.test(tagName))
    return 8;
  if (SELECTOR_LIST_ITEM.test(tagName))
    return 9;
  return 7;
}
function parseHtml(html2, opts) {
  const options = {
    ...defaultOptions$2,
    ...opts
  };
  const $2 = load(html2);
  let $root = $2("body");
  if (!$root.length)
    $root = $2.root();
  let id2 = 0;
  const rootNode = {
    id: id2,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  };
  const headingStack = [];
  let skippingHeading = 0;
  checkNodes($root.children());
  return rootNode;
  function addChild(props) {
    var _a2;
    const { parent: parent2 } = props;
    const node2 = {
      id: ++id2,
      tag: props.tagName,
      level: props.level,
      html: props.html,
      childrenLevel: 0,
      children: props.nesting ? [] : void 0,
      parent: parent2.id
    };
    if ((_a2 = props.comments) == null ? void 0 : _a2.length) {
      node2.comments = props.comments;
    }
    if (Object.keys(props.data || {}).length) {
      node2.data = props.data;
    }
    if (parent2.children) {
      if (parent2.childrenLevel === 0 || parent2.childrenLevel > node2.level) {
        parent2.children = [];
        parent2.childrenLevel = node2.level;
      }
      if (parent2.childrenLevel === node2.level) {
        parent2.children.push(node2);
      }
    }
    return node2;
  }
  function getCurrentHeading(level) {
    let heading2;
    while ((heading2 = headingStack[headingStack.length - 1]) && heading2.level >= level) {
      headingStack.pop();
    }
    return heading2 || rootNode;
  }
  function getContent($node) {
    var _a2;
    const result = extractMagicComments($node);
    const html22 = (_a2 = $2.html(result.$node)) == null ? void 0 : _a2.trimEnd();
    return { comments: result.comments, html: html22 };
  }
  function extractMagicComments($node) {
    const comments = [];
    $node = $node.filter((_, child) => {
      if (child.type === "comment") {
        const data2 = child.data.trim();
        if (data2.startsWith(MARKMAP_COMMENT_PREFIX)) {
          comments.push(data2.slice(MARKMAP_COMMENT_PREFIX.length).trim());
          return false;
        }
      }
      return true;
    });
    return { $node, comments };
  }
  function checkNodes($els, node2) {
    $els.each((_, child) => {
      var _a2;
      const $child = $2(child);
      const rule = (_a2 = Object.entries(options.selectorRules).find(
        ([selector2]) => $child.is(selector2)
      )) == null ? void 0 : _a2[1];
      const result = rule == null ? void 0 : rule({ $node: $child, $: $2, getContent });
      if ((result == null ? void 0 : result.queue) && !result.nesting) {
        checkNodes(result.queue, node2);
        return;
      }
      const level = getLevel(child.tagName);
      if (!result) {
        if (level <= 6) {
          skippingHeading = level;
        }
        return;
      }
      if (skippingHeading > 0 && level > skippingHeading)
        return;
      if (!$child.is(options.selector))
        return;
      skippingHeading = 0;
      const isHeading = level <= 6;
      let data2 = {
        // If the child is an inline element and expected to be a separate node,
        // data from the closest `<p>` should be included, e.g. `<p data-lines><img /></p>`
        ...$child.closest("p").data(),
        ...$child.data()
      };
      let html22 = result.html || "";
      if ($child.is("ol>li") && (node2 == null ? void 0 : node2.children)) {
        const start2 = +($child.parent().attr("start") || 1);
        const listIndex = start2 + node2.children.length;
        html22 = `${listIndex}. ${html22}`;
        data2 = {
          ...data2,
          listIndex
        };
      }
      const childNode = addChild({
        parent: node2 || getCurrentHeading(level),
        nesting: !!result.queue || isHeading,
        tagName: child.tagName,
        level,
        html: html22,
        comments: result.comments,
        data: data2
      });
      if (isHeading)
        headingStack.push(childNode);
      if (result.queue)
        checkNodes(result.queue, childNode);
    });
  }
}
function convertNode(htmlRoot) {
  return walkTree(htmlRoot, (htmlNode, next22) => {
    const node2 = {
      content: htmlNode.html,
      children: next22() || []
    };
    if (htmlNode.data) {
      node2.payload = {
        tag: htmlNode.tag,
        ...htmlNode.data
      };
    }
    if (htmlNode.comments) {
      if (htmlNode.comments.includes("foldAll")) {
        node2.payload = { ...node2.payload, fold: 2 };
      } else if (htmlNode.comments.includes("fold")) {
        node2.payload = { ...node2.payload, fold: 1 };
      }
    }
    return node2;
  });
}
function buildTree(html2, opts) {
  const htmlRoot = parseHtml(html2, opts);
  return convertNode(htmlRoot);
}
const decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode$1(string2, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
    let result = "";
    for (let i = 0, l = seq2.length; i < l; i += 3) {
      const b1 = parseInt(seq2.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "��";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "���";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq2.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "����";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "�";
    }
    return result;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
const encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode$1(string2, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string2.length; i < l; i++) {
    const code2 = string2.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
const protocolPattern = /^([a-z0-9.+-]+:)/i;
const portPattern = /:[0-9]*$/;
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
const delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
const unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
const autoEscape = ["'"].concat(unwise);
const nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
const hostEndingChars = ["/", "?", "#"];
const hostnameMaxLen = 255;
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
const hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url)
    return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j2 = 0, k = part.length; j2 < k; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port2 = portPattern.exec(host);
  if (port2) {
    port2 = port2[0];
    if (port2 !== ":") {
      this.port = port2.substr(1);
    }
    host = host.substr(0, host.length - port2.length);
  }
  if (host) {
    this.hostname = host;
  }
};
const mdurl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$1,
  encode: encode$1,
  format,
  parse: urlParse
}, Symbol.toStringTag, { value: "Module" }));
const Any = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
const Cc = /[\0-\x1F\x7F-\x9F]/;
const regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
const P = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
const regex = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
const Z = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
const ucmicro = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any,
  Cc,
  Cf: regex$1,
  P,
  S: regex,
  Z
}, Symbol.toStringTag, { value: "Module" }));
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c2) => c2.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c2) => c2.charCodeAt(0))
);
var _a;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint$1 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder2 {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start2, end2, base2) {
    if (start2 !== end2) {
      const digitCount = end2 - start2;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start2, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder2(decodeTree, (str) => ret += fromCodePoint$1(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi2 = lo + branchCount - 1;
  while (lo <= hi2) {
    const mid = lo + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}
function _class$1(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$2(obj) {
  return _class$1(obj) === "[object String]";
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function has$1(object2, key) {
  return _hasOwnProperty.call(object2, key);
}
function assign$7(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c2) {
  if (c2 >= 55296 && c2 <= 57343) {
    return false;
  }
  if (c2 >= 64976 && c2 <= 65007) {
    return false;
  }
  if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
    return false;
  }
  if (c2 >= 0 && c2 <= 8) {
    return false;
  }
  if (c2 === 11) {
    return false;
  }
  if (c2 >= 14 && c2 <= 31) {
    return false;
  }
  if (c2 >= 127 && c2 <= 159) {
    return false;
  }
  if (c2 > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint(c2) {
  if (c2 > 65535) {
    c2 -= 65536;
    const surrogate1 = 55296 + (c2 >> 10);
    const surrogate2 = 56320 + (c2 & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c2);
}
const UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
const UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
const DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match3, name2) {
  if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint(code2);
    }
    return match3;
  }
  const decoded = decodeHTML(match3);
  if (decoded !== match3) {
    return decoded;
  }
  return match3;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match3, entity2);
  });
}
const HTML_ESCAPE_TEST_RE = /[&<>"]/;
const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
const HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml$1(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
const REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE$1(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return P.test(ch) || regex.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("ẞ".toLowerCase() === "Ṿ") {
    str = str.replace(/ẞ/g, "ß");
  }
  return str.toLowerCase().toUpperCase();
}
const lib = { mdurl, ucmicro };
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt,
  assign: assign$7,
  escapeHtml: escapeHtml$1,
  escapeRE: escapeRE$1,
  fromCodePoint,
  has: has$1,
  isMdAsciiPunct,
  isPunctChar,
  isSpace,
  isString: isString$2,
  isValidEntityCode,
  isWhiteSpace,
  lib,
  normalizeReference,
  unescapeAll,
  unescapeMd
}, Symbol.toStringTag, { value: "Module" }));
function parseLinkLabel(state, start2, disableNested) {
  let level, found, marker, prevPos;
  const max2 = state.posMax;
  const oldPos = state.pos;
  state.pos = start2 + 1;
  level = 1;
  while (state.pos < max2) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}
function parseLinkDestination(str, start2, max2) {
  let code2;
  let pos = start2;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max2) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start2 + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max2) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max2) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max2) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start2 === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start2, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}
function parseLinkTitle(str, start2, max2, prev_state) {
  let code2;
  let pos = start2;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max2) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start2++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max2) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start2, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max2) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start2, pos));
  return state;
}
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination,
  parseLinkLabel,
  parseLinkTitle
}, Symbol.toStringTag, { value: "Module" }));
const default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml$1(token2.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml$1(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  const info = token2.info ? unescapeAll(token2.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml$1(token2.content);
  } else {
    highlighted = escapeHtml$1(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token2.attrIndex("class");
    const tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token2)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml$1(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign$7({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token2) {
  let i, l, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token2.attrs.length; i < l; i++) {
    result += " " + escapeHtml$1(token2.attrs[i][0]) + '="' + escapeHtml$1(token2.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token2 = tokens[idx];
  let result = "";
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules2 = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules2[type] !== "undefined") {
      result += rules2[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules2 = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules2[type] !== "undefined") {
      result += rules2[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name2) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name2, fn, options) {
  const index2 = this.__find__(name2);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index2].fn = fn;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index2 = this.__find__(beforeName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index2 = this.__find__(afterName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name2) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name2, value) {
  const idx = this.attrIndex(name2);
  const attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name2) {
  const idx = this.attrIndex(name2);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name2, value) {
  const idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token;
const NEWLINES_RE = /\r\n?|\n/g;
const NULL_RE = /\0/g;
function normalize$1(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "�");
  state.src = str;
}
function block(state) {
  let token2;
  if (state.inlineMode) {
    token2 = new state.Token("inline", "", 0);
    token2.content = state.src;
    token2.map = [0, 1];
    token2.children = [];
    state.tokens.push(token2);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify$1(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j2 = 0, l = blockTokens.length; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline" || !state.md.linkify.pretest(blockTokens[j2].content)) {
      continue;
    }
    let tokens = blockTokens[j2].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token2 = new state.Token("text", "", 0);
            token2.content = text2.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token2 = new state.Token("text", "", 0);
          token2.content = text2.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j2].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}
const RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
const SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
const SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
const SCOPED_ABBR = {
  c: "©",
  r: "®",
  tm: "™"
};
function replaceFn(match3, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace$3(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}
const QUOTE_TEST_RE = /['"]/;
const QUOTE_RE = /['"]/g;
const APOSTROPHE = "’";
function replaceAt(str, index2, ch) {
  return str.slice(0, index2) + ch + str.slice(index2 + 1);
}
function process_inlines(tokens, state) {
  let j2;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token2 = tokens[i];
    const thisLevel = tokens[i].level;
    for (j2 = stack.length - 1; j2 >= 0; j2--) {
      if (stack[j2].level <= thisLevel) {
        break;
      }
    }
    stack.length = j2 + 1;
    if (token2.type !== "text") {
      continue;
    }
    let text2 = token2.content;
    let pos = 0;
    let max2 = text2.length;
    OUTER:
      while (pos < max2) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j2 = i - 1; j2 >= 0; j2--) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
              break;
            if (!tokens[j2].content)
              continue;
            lastChar = tokens[j2].content.charCodeAt(tokens[j2].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max2) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j2 = i + 1; j2 < tokens.length; j2++) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
              break;
            if (!tokens[j2].content)
              continue;
            nextChar = tokens[j2].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j2 = stack.length - 1; j2 >= 0; j2--) {
            let item = stack[j2];
            if (stack[j2].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j2].level === thisLevel) {
              item = stack[j2];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token2.content;
              max2 = text2.length;
              stack.length = j2;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}
function text_join(state) {
  let curr, last2;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j2 = 0; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline")
      continue;
    const tokens = blockTokens[j2].children;
    const max2 = tokens.length;
    for (curr = 0; curr < max2; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last2 = 0; curr < max2; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last2) {
          tokens[last2] = tokens[curr];
        }
        last2++;
      }
    }
    if (curr !== last2) {
      tokens.length = last2;
    }
  }
}
const _rules$2 = [
  ["normalize", normalize$1],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify$1],
  ["replacements", replace$3],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules2 = this.ruler.getRules("");
  for (let i = 0, l = rules2.length; i < l; i++) {
    rules2[i](state);
  }
};
Core.prototype.State = StateCore;
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start2 = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start2);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start2 = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token2 = new Token(type, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from3) {
  for (let max2 = this.lineMax; from3 < max2; from3++) {
    if (this.bMarks[from3] + this.tShift[from3] < this.eMarks[from3]) {
      break;
    }
  }
  return from3;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max2 = this.src.length; pos < max2; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min2) {
  if (pos <= min2) {
    return pos;
  }
  while (pos > min2) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max2 = this.src.length; pos < max2; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min2) {
  if (pos <= min2) {
    return pos;
  }
  while (pos > min2) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end2, indent, keepLastLF) {
  if (begin >= end2) {
    return "";
  }
  const queue = new Array(end2 - begin);
  for (let i = 0, line = begin; line < end2; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first2 = lineStart;
    let last2;
    if (line + 1 < end2 || keepLastLF) {
      last2 = this.eMarks[line] + 1;
    } else {
      last2 = this.eMarks[line];
    }
    while (first2 < last2 && lineIndent < indent) {
      const ch = this.src.charCodeAt(first2);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first2 - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first2++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
    } else {
      queue[i] = this.src.slice(first2, last2);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = Token;
const MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max2 = state.eMarks[line];
  return state.src.slice(pos, max2);
}
function escapedSplit(str) {
  const result = [];
  const max2 = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max2) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last2 = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last2 = nextLine;
      continue;
    }
    break;
  }
  state.line = last2;
  const token2 = state.push("code_block", "code", 0);
  token2.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
  token2.map = [startLine, state.line];
  return true;
}
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max2) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max2);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max2 = state.eMarks[nextLine];
    if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max2) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token2 = state.push("fence", "code", 0);
  token2.info = params;
  token2.content = state.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state.line];
  return true;
}
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max2 = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max2 = state.eMarks[nextLine];
    if (pos >= max2) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max2) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max2;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}
function hr(state, startLine, endLine, silent) {
  const max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max2) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token2 = state.push("hr", "hr", 0);
  token2.map = [startLine, state.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}
function skipBulletListMarker(state, startLine) {
  const max2 = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max2) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  const max2 = state.eMarks[startLine];
  let pos = start2;
  if (pos + 1 >= max2) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max2) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start2 >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max2) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max2, pos, start2, token2;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start2 = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
      return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token2 = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token2.map = listLines;
  token2.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max2 = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max2) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max2) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token2 = state.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token2.map = itemLines;
    if (isOrdered) {
      token2.info = state.src.slice(start2, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max2 && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token2 = state.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start2 = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max2 = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max3 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max3 + 1);
  }
  let str = state.src.slice(pos, max2 + 1);
  max2 = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max2; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max2 = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max2 && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max2 = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max2; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max2 = str.length;
        nextLine++;
      }
    } else if (isSpace(ch))
      ;
    else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max2);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start2 = pos;
  for (; pos < max2; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max2 = str.length;
        nextLine++;
      }
    } else if (isSpace(ch))
      ;
    else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max2);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null)
      break;
    str += lineContent;
    pos = max2;
    max2 = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max2, titleRes);
  }
  let title;
  if (pos < max2 && start2 !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max2) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max2 && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max2) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max2 && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}
const block_names = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const unquoted = "[^\"'=<>`\\x00-\\x20]+";
const single_quoted = "'[^']*'";
const double_quoted = '"[^"]*"';
const attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
const attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
const open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
const close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
const comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
const processing = "<[?][\\s\\S]*?[?]>";
const declaration = "<![A-Za-z][^>]*>";
const cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
const HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
const HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
const HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max2);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max2 = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max2);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token2 = state.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max2 = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max2) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max2 && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max2 && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max2 = state.skipSpacesBack(max2, pos);
  const tmp = state.skipCharsBack(max2, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max2 = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max2).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max2 = state.eMarks[nextLine];
      if (pos < max2) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max2) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}
const _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules2 = this.ruler.getRules("");
  const len = rules2.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules2[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok)
      throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = StateBlock;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token2 = new Token(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start2, canSplitWord) {
  const max2 = this.posMax;
  const marker = this.src.charCodeAt(start2);
  const lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
  let pos = start2;
  while (pos < max2 && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start2;
  const nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = Token;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}
const SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify(state, silent) {
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  const pos = state.pos;
  const max2 = state.posMax;
  if (pos + 3 > max2)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  const match3 = state.pending.match(SCHEME_RE);
  if (!match3)
    return false;
  const proto = match3[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2)
    return false;
  let url = link2.url;
  if (url.length <= proto.length)
    return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max2 = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}
const ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape(state, silent) {
  let pos = state.pos;
  const max2 = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max2)
    return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max2) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max2) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token2 = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token2.content = escapedStr;
    } else {
      token2.content = origStr;
    }
    token2.markup = origStr;
    token2.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start2 = pos;
  pos++;
  const max2 = state.posMax;
  while (pos < max2 && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start2, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token2 = state.push("code_inline", "code", 0);
        token2.markup = marker;
        token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker;
  state.pos += openerLength;
  return true;
}
function strikethrough_tokenize(state, silent) {
  const start2 = state.pos;
  const marker = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token2;
  if (len % 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess$1(state, delimiters) {
  let token2;
  const loneMarkers = [];
  const max2 = delimiters.length;
  for (let i = 0; i < max2; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token2 = state.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j2 = i + 1;
    while (j2 < state.tokens.length && state.tokens[j2].type === "s_close") {
      j2++;
    }
    j2--;
    if (i !== j2) {
      token2 = state.tokens[j2];
      state.tokens[j2] = state.tokens[i];
      state.tokens[i] = token2;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max2 = state.tokens_meta.length;
  postProcess$1(state, state.delimiters);
  for (let curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
}
const r_strikethrough = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};
function emphasis_tokenize(state, silent) {
  const start2 = state.pos;
  const marker = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token2 = state.push("text", "", 0);
    token2.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  const max2 = delimiters.length;
  for (let i = max2 - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max2 = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
const r_emphasis = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};
function link(state, silent) {
  let code2, label, res, ref2;
  let href = "";
  let title = "";
  let start2 = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max2 = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max2 && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max2; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max2) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start2 = pos;
      for (; pos < max2; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max2 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max2 && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max2;
  return true;
}
function image(state, silent) {
  let code2, content, label, pos, ref2, res, title, start2;
  let href = "";
  const oldPos = state.pos;
  const max2 = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max2 && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max2; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max2) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start2 = pos;
    for (; pos < max2; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max2 && start2 !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max2; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max2 && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref2 = state.env.references[normalizeReference(label)];
    if (!ref2) {
      state.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token2 = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token2.attrs = attrs;
    token2.children = tokens;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max2;
  return true;
}
const EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
const AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start2 = state.pos;
  const max2 = state.posMax;
  for (; ; ) {
    if (++pos >= max2)
      return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start2 + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max2 = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match3 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match3) {
    return false;
  }
  if (!silent) {
    const token2 = state.push("html_inline", "", 0);
    token2.content = match3[0];
    if (isLinkOpen(token2.content))
      state.linkLevel++;
    if (isLinkClose(token2.content))
      state.linkLevel--;
  }
  state.pos += match3[0].length;
  return true;
}
const DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
const NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max2 = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max2)
    return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match3 = state.src.slice(pos).match(DIGITAL_RE);
    if (match3) {
      if (!silent) {
        const code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
        const token2 = state.push("text_special", "", 0);
        token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
        token2.markup = match3[0];
        token2.info = "entity";
      }
      state.pos += match3[0].length;
      return true;
    }
  } else {
    const match3 = state.src.slice(pos).match(NAMED_RE);
    if (match3) {
      const decoded = decodeHTML(match3[0]);
      if (decoded !== match3[0]) {
        if (!silent) {
          const token2 = state.push("text_special", "", 0);
          token2.content = decoded;
          token2.markup = match3[0];
          token2.info = "entity";
        }
        state.pos += match3[0].length;
        return true;
      }
    }
  }
  return false;
}
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max2 = delimiters.length;
  if (!max2)
    return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max2; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max2 = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max2; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}
function fragments_join(state) {
  let curr, last2;
  let level = 0;
  const tokens = state.tokens;
  const max2 = state.tokens.length;
  for (curr = last2 = 0; curr < max2; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last2) {
        tokens[last2] = tokens[curr];
      }
      last2++;
    }
  }
  if (curr !== last2) {
    tokens.length = last2;
  }
}
const _rules = [
  ["text", text],
  ["linkify", linkify],
  ["newline", newline],
  ["escape", escape],
  ["backticks", backtick],
  ["strikethrough", r_strikethrough.tokenize],
  ["emphasis", r_emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
const _rules2 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", r_strikethrough.postProcess],
  ["emphasis", r_emphasis.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules2 = this.ruler.getRules("");
  const len = rules2.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules2[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules2 = this.ruler.getRules("");
  const len = rules2.length;
  const end2 = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end2) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules2[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end2) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  const rules2 = this.ruler2.getRules("");
  const len = rules2.length;
  for (let i = 0; i < len; i++) {
    rules2[i](state);
  }
};
ParserInline.prototype.State = StateInline;
function reFactory(opts) {
  const re2 = {};
  opts = opts || {};
  re2.src_Any = Any.source;
  re2.src_Cc = Cc.source;
  re2.src_Z = Z.source;
  re2.src_P = P.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  const text_separators = "[><｜]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
}
function assign$6(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$1(obj) {
  return _class(obj) === "[object String]";
}
function isObject$n(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp$1(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
const defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
const tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
const tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match3, self2) {
    self2.normalize(match3);
  };
}
function compile(self2) {
  const re2 = self2.re = reFactory(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re2.src_xn);
  re2.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re2.src_tlds);
  }
  re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
  re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
  re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
  re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
  const aliases2 = [];
  self2.__compiled__ = {};
  function schemaError(name2, val2) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val2);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    const val2 = self2.__schemas__[name2];
    if (val2 === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject$n(val2)) {
      if (isRegExp$1(val2.validate)) {
        compiled.validate = createValidator(val2.validate);
      } else if (isFunction(val2.validate)) {
        compiled.validate = val2.validate;
      } else {
        schemaError(name2, val2);
      }
      if (isFunction(val2.normalize)) {
        compiled.normalize = val2.normalize;
      } else if (!val2.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val2);
      }
      return;
    }
    if (isString$1(val2)) {
      aliases2.push(name2);
      return;
    }
    schemaError(name2, val2);
  });
  aliases2.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start2 = self2.__index__;
  const end2 = self2.__last_index__;
  const text2 = self2.__text_cache__.slice(start2, end2);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start2 + shift;
  this.lastIndex = end2 + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self2, shift) {
  const match3 = new Match(self2, shift);
  self2.__compiled__[match3.schema].normalize(match3, self2);
  return match3;
}
function LinkifyIt(schemas2, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas2, options);
  }
  if (!options) {
    if (isOptionsObj(schemas2)) {
      options = schemas2;
      schemas2 = {};
    }
  }
  this.__opts__ = assign$6({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign$6({}, defaultSchemas, schemas2);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add2(schema2, definition) {
  this.__schemas__[schema2] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign$6(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next3, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m = re2.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next3 = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next3 > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next3;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema2, pos) {
  if (!this.__compiled__[schema2.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema2.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length)
    return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m)
    return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize(match3) {
  if (!match3.schema) {
    match3.url = "http://" + match3.url;
  }
  if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
    match3.url = "mailto:" + match3.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor$2 = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$8(array2, callback) {
  const result = [];
  let length2 = array2.length;
  while (length2--) {
    result[length2] = callback(array2[length2]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map$8(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter2 = 0;
  const length2 = string2.length;
  while (counter2 < length2) {
    const value = string2.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length2) {
      const extra = string2.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor$2(delta / damp) : delta >> 1;
  delta += floor$2(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor$2(delta / baseMinusTMin);
  }
  return floor$2(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j2 = 0; j2 < basic; ++j2) {
    if (input.charCodeAt(j2) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j2));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor$2((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor$2(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor$2(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor$2(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor$2((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q2 = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q2 < t) {
            break;
          }
          const qMinusT = q2 - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q2 = floor$2(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
  });
};
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const cfg_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
const cfg_zero = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
const cfg_commonmark = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
const config$2 = {
  default: cfg_default,
  zero: cfg_zero,
  commonmark: cfg_commonmark
};
const BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
const GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
const RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode$1(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode$1(format(parsed), decode$1.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString$2(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new Core();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = assign$7({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign$7(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString$2(presets)) {
    const presetName = presets;
    presets = config$2[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin2) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin2.apply(plugin2, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
function ins_plugin$1(md) {
  function tokenize(state, silent) {
    const start2 = state.pos;
    const marker = state.src.charCodeAt(start2);
    if (silent) {
      return false;
    }
    if (marker !== 43) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token2 = state.push("text", "", 0);
      token2.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token2 = state.push("text", "", 0);
      token2.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: i / 2,
        // 1 delimiter = 2 characters
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess2(state, delimiters) {
    let token2;
    const loneMarkers = [];
    const max2 = delimiters.length;
    for (let i = 0; i < max2; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 43) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      token2 = state.tokens[startDelim.token];
      token2.type = "ins_open";
      token2.tag = "ins";
      token2.nesting = 1;
      token2.markup = "++";
      token2.content = "";
      token2 = state.tokens[endDelim.token];
      token2.type = "ins_close";
      token2.tag = "ins";
      token2.nesting = -1;
      token2.markup = "++";
      token2.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "+") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j2 = i + 1;
      while (j2 < state.tokens.length && state.tokens[j2].type === "ins_close") {
        j2++;
      }
      j2--;
      if (i !== j2) {
        token2 = state.tokens[j2];
        state.tokens[j2] = state.tokens[i];
        state.tokens[i] = token2;
      }
    }
  }
  md.inline.ruler.before("emphasis", "ins", tokenize);
  md.inline.ruler2.before("emphasis", "ins", function(state) {
    const tokens_meta = state.tokens_meta;
    const max2 = (state.tokens_meta || []).length;
    postProcess2(state, state.delimiters);
    for (let curr = 0; curr < max2; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess2(state, tokens_meta[curr].delimiters);
      }
    }
  });
}
function ins_plugin(md) {
  function tokenize(state, silent) {
    const start2 = state.pos;
    const marker = state.src.charCodeAt(start2);
    if (silent) {
      return false;
    }
    if (marker !== 61) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token2 = state.push("text", "", 0);
      token2.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token2 = state.push("text", "", 0);
      token2.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: i / 2,
        // 1 delimiter = 2 characters
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess2(state, delimiters) {
    const loneMarkers = [];
    const max2 = delimiters.length;
    for (let i = 0; i < max2; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 61) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      const token_o = state.tokens[startDelim.token];
      token_o.type = "mark_open";
      token_o.tag = "mark";
      token_o.nesting = 1;
      token_o.markup = "==";
      token_o.content = "";
      const token_c = state.tokens[endDelim.token];
      token_c.type = "mark_close";
      token_c.tag = "mark";
      token_c.nesting = -1;
      token_c.markup = "==";
      token_c.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j2 = i + 1;
      while (j2 < state.tokens.length && state.tokens[j2].type === "mark_close") {
        j2++;
      }
      j2--;
      if (i !== j2) {
        const token2 = state.tokens[j2];
        state.tokens[j2] = state.tokens[i];
        state.tokens[i] = token2;
      }
    }
  }
  md.inline.ruler.before("emphasis", "mark", tokenize);
  md.inline.ruler2.before("emphasis", "mark", function(state) {
    let curr;
    const tokens_meta = state.tokens_meta;
    const max2 = (state.tokens_meta || []).length;
    postProcess2(state, state.delimiters);
    for (curr = 0; curr < max2; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess2(state, tokens_meta[curr].delimiters);
      }
    }
  });
}
const UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function subscript(state, silent) {
  const max2 = state.posMax;
  const start2 = state.pos;
  if (state.src.charCodeAt(start2) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start2 + 2 >= max2) {
    return false;
  }
  state.pos = start2 + 1;
  let found = false;
  while (state.pos < max2) {
    if (state.src.charCodeAt(state.pos) === 126) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start2 + 1 === state.pos) {
    state.pos = start2;
    return false;
  }
  const content = state.src.slice(start2 + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start2;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start2 + 1;
  const token_so = state.push("sub_open", "sub", 1);
  token_so.markup = "~";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE$1, "$1");
  const token_sc = state.push("sub_close", "sub", -1);
  token_sc.markup = "~";
  state.pos = state.posMax + 1;
  state.posMax = max2;
  return true;
}
function sub_plugin(md) {
  md.inline.ruler.after("emphasis", "sub", subscript);
}
const UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state, silent) {
  const max2 = state.posMax;
  const start2 = state.pos;
  if (state.src.charCodeAt(start2) !== 94) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start2 + 2 >= max2) {
    return false;
  }
  state.pos = start2 + 1;
  let found = false;
  while (state.pos < max2) {
    if (state.src.charCodeAt(state.pos) === 94) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start2 + 1 === state.pos) {
    state.pos = start2;
    return false;
  }
  const content = state.src.slice(start2 + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start2;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start2 + 1;
  const token_so = state.push("sup_open", "sup", 1);
  token_so.markup = "^";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE, "$1");
  const token_sc = state.push("sup_close", "sup", -1);
  token_sc.markup = "^";
  state.pos = state.posMax + 1;
  state.posMax = max2;
  return true;
}
function sup_plugin(md) {
  md.inline.ruler.after("emphasis", "sup", superscript);
}
const ALIAS = Symbol.for("yaml.alias");
const DOC = Symbol.for("yaml.document");
const MAP = Symbol.for("yaml.map");
const PAIR = Symbol.for("yaml.pair");
const SCALAR$1 = Symbol.for("yaml.scalar");
const SEQ = Symbol.for("yaml.seq");
const NODE_TYPE = Symbol.for("yaml.node.type");
const isAlias = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS;
const isDocument = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC;
const isMap = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP;
const isPair = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR;
const isScalar = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR$1;
const isSeq = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ;
function isCollection(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
const hasAnchor = (node2) => (isScalar(node2) || isCollection(node2)) && !!node2.anchor;
const BREAK = Symbol("break visit");
const SKIP = Symbol("skip children");
const REMOVE = Symbol("remove node");
function visit(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE)
      node2.contents = null;
  } else
    visit_(null, node2, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node2, visitor, path2) {
  const ctrl = callVisitor(key, node2, visitor, path2);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path2, ctrl);
    return visit_(key, ctrl, visitor, path2);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node2)) {
      path2 = Object.freeze(path2.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = visit_(i, node2.items[i], visitor, path2);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path2 = Object.freeze(path2.concat(node2));
      const ck = visit_("key", node2.key, visitor, path2);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node2.key = null;
      const cv = visit_("value", node2.value, visitor, path2);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node2.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node2, visitor, path2) {
  if (typeof visitor === "function")
    return visitor(key, node2, path2);
  if (isMap(node2))
    return visitor.Map?.(key, node2, path2);
  if (isSeq(node2))
    return visitor.Seq?.(key, node2, path2);
  if (isPair(node2))
    return visitor.Pair?.(key, node2, path2);
  if (isScalar(node2))
    return visitor.Scalar?.(key, node2, path2);
  if (isAlias(node2))
    return visitor.Alias?.(key, node2, path2);
  return void 0;
}
function replaceNode(key, path2, node2) {
  const parent2 = path2[path2.length - 1];
  if (isCollection(parent2)) {
    parent2.items[key] = node2;
  } else if (isPair(parent2)) {
    if (key === "key")
      parent2.key = node2;
    else
      parent2.value = node2;
  } else if (isDocument(parent2)) {
    parent2.contents = node2;
  } else {
    const pt2 = isAlias(parent2) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt2} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
class Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name2 = parts.shift();
    switch (name2) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version2] = parts;
        if (version2 === "1.1" || version2 === "1.2") {
          this.yaml.version = version2;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version2);
          onError(6, `Unsupported YAML version ${version2}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name2}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error2) {
        onError(String(error2));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node2) => {
        if (isNode(node2) && node2.tag)
          tags[node2.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
}
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root2) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root2, {
    Value(_key, node2) {
      if (node2.anchor)
        anchors.add(node2.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar(ref2.node) || isCollection(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}
function applyReviver(reviver, obj, key, val2) {
  if (val2 && typeof val2 === "object") {
    if (Array.isArray(val2)) {
      for (let i = 0, len = val2.length; i < len; ++i) {
        const v0 = val2[i];
        const v1 = applyReviver(reviver, val2, String(i), v0);
        if (v1 === void 0)
          delete val2[i];
        else if (v1 !== v0)
          val2[i] = v1;
      }
    } else if (val2 instanceof Map) {
      for (const k of Array.from(val2.keys())) {
        const v0 = val2.get(k);
        const v1 = applyReviver(reviver, val2, k, v0);
        if (v1 === void 0)
          val2.delete(k);
        else if (v1 !== v0)
          val2.set(k, v1);
      }
    } else if (val2 instanceof Set) {
      for (const v0 of Array.from(val2)) {
        const v1 = applyReviver(reviver, val2, v0, v0);
        if (v1 === void 0)
          val2.delete(v0);
        else if (v1 !== v0) {
          val2.delete(v0);
          val2.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val2)) {
        const v1 = applyReviver(reviver, val2, k, v0);
        if (v1 === void 0)
          delete val2[k];
        else if (v1 !== v0)
          val2[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val2);
}
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v2, i) => toJS(v2, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data2);
    ctx.onCreate = (res2) => {
      data2.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
let NodeBase$1 = class NodeBase {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};
class Alias extends NodeBase$1 {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node2) => {
        if (node2 === this)
          return visit.BREAK;
        if (node2.anchor === this.source)
          found = node2;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data2 = anchors.get(source);
    if (!data2) {
      toJS(source, null, ctx);
      data2 = anchors.get(source);
    }
    if (!data2 || data2.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data2.count += 1;
      if (data2.aliasCount === 0)
        data2.aliasCount = getAliasCount(doc, source, anchors);
      if (data2.count * data2.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data2.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
}
function getAliasCount(doc, node2, anchors) {
  if (isAlias(node2)) {
    const source = node2.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node2)) {
    let count = 0;
    for (const item of node2.items) {
      const c2 = getAliasCount(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair(node2)) {
    const kc = getAliasCount(doc, node2.key, anchors);
    const vc = getAliasCount(doc, node2.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
class Scalar extends NodeBase$1 {
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match3 = tags.filter((t) => t.tag === tagName);
    const tagObj = match3.find((t) => !t.format) ?? match3[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map3 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map3.items.push(value);
    return map3;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref2 = sourceObjects.get(value);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value, ref2);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node3 = new Scalar(value);
      if (ref2)
        ref2.node = node3;
      return node3;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node2 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node2.tag = tagName;
  else if (!tagObj.default)
    node2.tag = tagObj.tag;
  if (ref2)
    ref2.node = node2;
  return node2;
}
function collectionFromPath(schema2, path2, value) {
  let v2 = value;
  for (let i = path2.length - 1; i >= 0; --i) {
    const k = path2[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v2;
      v2 = a;
    } else {
      v2 = /* @__PURE__ */ new Map([[k, v2]]);
    }
  }
  return createNode(v2, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
let Collection$1 = class Collection extends NodeBase$1 {
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it3) => isNode(it3) || isPair(it3) ? it3.clone(schema2) : it3);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path2, value) {
    if (isEmptyPath(path2))
      this.add(value);
    else {
      const [key, ...rest] = path2;
      const node2 = this.get(key, true);
      if (isCollection(node2))
        node2.addIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path2) {
    const [key, ...rest] = path2;
    if (rest.length === 0)
      return this.delete(key);
    const node2 = this.get(key, true);
    if (isCollection(node2))
      return node2.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path2, keepScalar) {
    const [key, ...rest] = path2;
    const node2 = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node2) ? node2.value : node2;
    else
      return isCollection(node2) ? node2.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node2) => {
      if (!isPair(node2))
        return false;
      const n = node2.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path2) {
    const [key, ...rest] = path2;
    if (rest.length === 0)
      return this.has(key);
    const node2 = this.get(key, true);
    return isCollection(node2) ? node2.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path2, value) {
    const [key, ...rest] = path2;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node2 = this.get(key, true);
      if (isCollection(node2))
        node2.setIn(rest, value);
      else if (node2 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
const lineComment = (str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2;
const FOLD_FLOW = "flow";
const FOLD_BLOCK = "block";
const FOLD_QUOTED = "quoted";
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  let split2 = void 0;
  let prev2 = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text2, i, indent.length);
    if (i !== -1)
      end2 = i + endStep;
  }
  for (let ch; ch = text2[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text2[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text2, i, indent.length);
      end2 = i + indent.length + endStep;
      split2 = void 0;
    } else {
      if (ch === " " && prev2 && prev2 !== " " && prev2 !== "\n" && prev2 !== "	") {
        const next3 = text2[i + 1];
        if (next3 && next3 !== " " && next3 !== "\n" && next3 !== "	")
          split2 = i;
      }
      if (i >= end2) {
        if (split2) {
          folds.push(split2);
          end2 = split2 + endStep;
          split2 = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev2 === " " || prev2 === "	") {
            prev2 = ch;
            ch = text2[i += 1];
            overflow = true;
          }
          const j2 = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text2;
          folds.push(j2);
          escapedFolds[j2] = true;
          end2 = j2 + endStep;
          split2 = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev2 = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end3 = folds[i2 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end3)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end3)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i, indent) {
  let end2 = i;
  let start2 = i + 1;
  let ch = text2[start2];
  while (ch === " " || ch === "	") {
    if (i < start2 + indent) {
      ch = text2[++i];
    } else {
      do {
        ch = text2[++i];
      } while (ch && ch !== "\n");
      end2 = i;
      start2 = i + 1;
      ch = text2[start2];
    }
  }
  return end2;
}
const getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start2 = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start2 > limit)
        return true;
      start2 = i + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start2 = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start2, i) + "\\ ";
      i += 1;
      start2 = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start2, i);
            const code2 = json.substr(i + 2, 4);
            switch (code2) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code2.substr(0, 2) === "00")
                  str += "\\x" + code2.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start2 = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start2, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start2 = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start2 ? str + json.slice(start2) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
let blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end2 = value.substring(endStart);
  const endNlPos = end2.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end2 || endNlPos !== end2.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end2) {
    value = value.slice(0, -end2.length);
    if (end2[end2.length - 1] === "\n")
      end2 = end2.slice(0, -1);
    end2 = end2.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value = value.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start2}${foldedValue}${end2}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start2}${value}${end2}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test3 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test3) || compat?.some(test3))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match3 = tags.filter((t) => t.tag === item.tag);
    if (match3.length > 0)
      return match3.find((t) => t.format === item.format) ?? match3[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match3 = tags.filter((t) => t.identify?.(obj));
    if (match3.length > 1) {
      const testMatch = match3.filter((t) => t.test);
      if (testMatch.length > 0)
        match3 = testMatch;
    }
    tagObj = match3.find((t) => t.format === item.format) ?? match3.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name2 = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node2, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node2) || isCollection(node2)) && node2.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify$3(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node2 = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node2);
  const props = stringifyProps(node2, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx, onComment, onChompKeep) : isScalar(node2) ? stringifyString(node2, ctx, onComment, onChompKeep) : node2.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node2) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$3(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$3(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs2 = commentString(vcb);
      ws += `
${indentComment(cs2, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}
const MERGE_KEY = "<<";
const merge$3 = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge$3.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge$3.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge$3.tag && tag.default);
function addMergeToJSMap(ctx, map3, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it3 of value.items)
      mergeValue(ctx, map3, it3);
  else if (Array.isArray(value))
    for (const it3 of value)
      mergeValue(ctx, map3, it3);
  else
    mergeValue(ctx, map3, value);
}
function mergeValue(ctx, map3, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map3 instanceof Map) {
      if (!map3.has(key))
        map3.set(key, value2);
    } else if (map3 instanceof Set) {
      map3.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
      Object.defineProperty(map3, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map3;
}
function addPairToJSMap(ctx, map3, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map3, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map3, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map3 instanceof Map) {
      map3.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map3 instanceof Set) {
      map3.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map3)
        Object.defineProperty(map3, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map3[stringKey] = jsValue;
    }
  }
  return map3;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node2 of ctx.anchors.keys())
      strCtx.anchors.add(node2.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v2 = createNode(value, void 0, ctx);
  return new Pair(k, v2);
}
class Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
function stringifyCollection(collection2, ctx, options) {
  const flow = ctx.inFlow ?? collection2.flow;
  const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify3(collection2, ctx, options);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment3 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$3(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str = stringify$3(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str += ",";
    if (comment2)
      str += lineComment(str, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start: start2, end: end2 } = flowChars;
  if (lines.length === 0) {
    return start2 + end2;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start2;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end2}`;
    } else {
      return `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it3 of items) {
    if (isPair(it3)) {
      if (it3.key === key || it3.key === k)
        return it3;
      if (isScalar(it3.key) && it3.key.value === k)
        return it3;
    }
  }
  return void 0;
}
class YAMLMap extends Collection$1 {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema2, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map3 = new this(schema2);
    const add3 = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map3.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add3(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add3(key, obj[key]);
    }
    if (typeof schema2.sortMapEntries === "function") {
      map3.items.sort(schema2.sortMapEntries);
    }
    return map3;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev2 = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev2) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev2.value) && isScalarValue(_pair.value))
        prev2.value.value = _pair.value;
      else
        prev2.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it3 = findPair(this.items, key);
    if (!it3)
      return false;
    const del = this.items.splice(this.items.indexOf(it3), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it3 = findPair(this.items, key);
    const node2 = it3?.value;
    return (!keepScalar && isScalar(node2) ? node2.value : node2) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map3 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map3);
    for (const item of this.items)
      addPairToJSMap(ctx, map3, item);
    return map3;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
}
const map$7 = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map3, onError) {
    if (!isMap(map3))
      onError("Expected a mapping for this tag");
    return map3;
  },
  createNode: (schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx)
};
class YAMLSeq extends Collection$1 {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it3 = this.items[idx];
    return !keepScalar && isScalar(it3) ? it3.value : it3;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev2 = this.items[idx];
    if (isScalar(prev2) && isScalarValue(value))
      prev2.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema2, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema2);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it3 of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it3 : String(i++);
          it3 = replacer.call(obj, key, it3);
        }
        seq2.items.push(createNode(it3, void 0, ctx));
      }
    }
    return seq2;
  }
}
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
const seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx)
};
const string$1 = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
const nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
const boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
const floatNaN$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
const float$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str));
    const dot2 = str.indexOf(".");
    if (dot2 !== -1 && str[str.length - 1] === "0")
      node2.minFractionDigits = str.length - dot2 - 1;
    return node2;
  },
  stringify: stringifyNumber
};
const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify$1(node2, radix, prefix) {
  const { value } = node2;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node2);
}
const intOct$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
  stringify: (node2) => intStringify$1(node2, 8, "0o")
};
const int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
  stringify: (node2) => intStringify$1(node2, 16, "0x")
};
const schema$2 = [
  map$7,
  seq,
  string$1,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
const jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
const schema$1 = [map$7, seq].concat(jsonScalars, jsonError);
const binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn2 = pair.value ?? pair.key;
          cn2.comment = cn2.comment ? `${item.comment}
${cn2.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it3 of iterable) {
      if (typeof replacer === "function")
        it3 = replacer.call(iterable, String(i++), it3);
      let key, value;
      if (Array.isArray(it3)) {
        if (it3.length === 2) {
          key = it3[0];
          value = it3[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it3}`);
      } else if (it3 && it3 instanceof Object) {
        const keys4 = Object.keys(it3);
        if (keys4.length === 1) {
          key = keys4[0];
          value = it3[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys4.length} keys`);
        }
      } else {
        key = it3;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
const pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map3 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map3);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map3.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map3.set(key, value);
    }
    return map3;
  }
  static from(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
};
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
const falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
const floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node2) {
    const num = Number(node2.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
  }
};
const float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node2 = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot2 = str.indexOf(".");
    if (dot2 !== -1) {
      const f = str.substring(dot2 + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node2.minFractionDigits = f.length;
    }
    return node2;
  },
  stringify: stringifyNumber
};
const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node2, radix, prefix) {
  const { value } = node2;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node2);
}
const intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: (node2) => intStringify(node2, 2, "0b")
};
const intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: (node2) => intStringify(node2, 8, "0")
};
const int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node2) => intStringify(node2, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev2 = findPair(this.items, pair.key);
    if (!prev2)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev2 = findPair(this.items, key);
    if (prev2 && !value) {
      this.items.splice(this.items.indexOf(prev2), 1);
    } else if (!prev2 && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema2, iterable, ctx) {
    const { replacer } = ctx;
    const set3 = new this(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set3.items.push(createPair(value, null, ctx));
      }
    return set3;
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set$5 = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
  resolve(map3, onError) {
    if (isMap(map3)) {
      if (map3.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map3);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map3;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node2) {
  let { value } = node2;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node2);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match3 = str.match(timestamp.test);
    if (!match3)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match3.map(Number);
    const millisec = match3[7] ? Number((match3[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match3[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
};
const schema = [
  map$7,
  seq,
  string$1,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  merge$3,
  omap,
  pairs,
  set$5,
  intTime,
  floatTime,
  timestamp
];
const schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map$7, seq, string$1]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
const tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map: map$7,
  merge: merge$3,
  null: nullTag,
  omap,
  pairs,
  seq,
  set: set$5,
  timestamp
};
const coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge$3,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set$5,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge$3) ? schemaTags.concat(merge$3) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys4 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys4} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge$3);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys4 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys4}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}
const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map$7 });
    Object.defineProperty(this, SCALAR$1, { value: string$1 });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
}
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs2 = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs2, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs2 = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs2, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$3(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$3(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs2 = commentString(doc.comment);
      if (cs2.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs2, ""));
      } else {
        lines.push(`... ${cs2}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
class Document2 {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version: version2 } = opt;
    if (options?._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version2 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version2 });
    this.setSchema(version2, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document2.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path2, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path2, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node2, name2) {
    if (!node2.anchor) {
      const prev2 = anchorNames(this);
      node2.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name2 || prev2.has(name2) ? findNewAnchor(name2 || "a", prev2) : name2;
    }
    return new Alias(node2.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v2) => typeof v2 === "number" || v2 instanceof String || v2 instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node2 = createNode(value, tag, ctx);
    if (flow && isCollection(node2))
      node2.flow = true;
    setAnchors();
    return node2;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v2 = this.createNode(value, null, options);
    return new Pair(k, v2);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path2) {
    if (isEmptyPath(path2)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path2, keepScalar) {
    if (isEmptyPath(path2))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path2) {
    if (isEmptyPath(path2))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path2) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path2, value) {
    if (isEmptyPath(path2)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path2), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path2, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version2, options = {}) {
    if (typeof version2 === "number")
      version2 = String(version2);
    let opt;
    switch (version2) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version2;
        else
          this.directives = new Directives({ version: version2 });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version2);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
}
function assertCollection(contents2) {
  if (isCollection(contents2))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
class YAMLError extends Error {
  constructor(name2, pos, code2, message) {
    super();
    this.name = name2;
    this.code = code2;
    this.message = message;
    this.pos = pos;
  }
}
class YAMLParseError extends YAMLError {
  constructor(pos, code2, message) {
    super("YAMLParseError", pos, code2, message);
  }
}
class YAMLWarning extends YAMLError {
  constructor(pos, code2, message) {
    super("YAMLWarning", pos, code2, message);
  }
}
const prettifyError = (src, lc) => (error2) => {
  if (error2.pos[0] === -1)
    return;
  error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error2.linePos[0];
  error2.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "…" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "…";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev2 = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev2.length > 80)
      prev2 = prev2.substring(0, 79) + "…\n";
    lineStr = prev2 + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end2 = error2.linePos[1];
    if (end2 && end2.line === line && end2.col > col) {
      count = Math.max(1, Math.min(end2.col - col, 80 - ci));
    }
    const pointer2 = " ".repeat(ci) + "^".repeat(count);
    error2.message += `:

${lineStr}
${pointer2}
`;
  }
};
function resolveProps(tokens, { flow, indicator, next: next3, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start2 = null;
  for (const token2 of tokens) {
    if (reqSpace) {
      if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
        onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token2.type !== "comment" && token2.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token2.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next3?.type !== "flow-collection") && token2.source.includes("	")) {
          tab = token2;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token2.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token2.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token2.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token2;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token2.source.endsWith(":"))
          onError(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token2;
        if (start2 === null)
          start2 = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token2;
        if (start2 === null)
          start2 = token2.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
        if (found)
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow ?? "collection"}`);
        found = token2;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token2;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last2 = tokens[tokens.length - 1];
  const end2 = last2 ? last2.offset + last2.source.length : offset;
  if (reqSpace && next3 && next3.type !== "space" && next3.type !== "newline" && next3.type !== "comma" && (next3.type !== "scalar" || next3.source !== "")) {
    onError(next3.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next3?.type === "block-map" || next3?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end: end2,
    start: start2 ?? end2
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it3 of key.items) {
        for (const st of it3.start)
          if (st.type === "newline")
            return true;
        if (it3.sep) {
          for (const st of it3.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it3.key) || containsNewline(it3.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end2 = fc.end[0];
    if (end2.indent === indent && (end2.source === "]" || end2.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end2, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}
const startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map3 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start: start2, key, sep, value } = collItem;
    const keyProps = resolveProps(start2, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map3.comment)
            map3.comment += "\n" + keyProps.comment;
          else
            map3.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map3.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map3.range = [bm.offset, offset, commentEnd ?? offset];
  return map3;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start: start2, value } of bs.items) {
    const props = resolveProps(start2, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node2 = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start2, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node2.range[2];
    seq2.items.push(node2);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
function resolveEnd(end2, offset, reqSpace, onError) {
  let comment2 = "";
  if (end2) {
    let hasSpace = false;
    let sep = "";
    for (const token2 of end2) {
      const { source, type } = token2;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment: comment2, offset };
}
const blockMsg = "Block collections are not allowed within flow collections";
const isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start: start2, key, sep, value } = collItem;
    const props = resolveProps(start2, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start2) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev2 = coll.items[coll.items.length - 1];
          if (isPair(prev2))
            prev2 = prev2.value ?? prev2.key;
          if (prev2.comment)
            prev2.comment += "\n" + prevItemComment;
          else
            prev2.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map3 = coll;
        if (mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map3.items.push(pair);
      } else {
        const map3 = new YAMLMap(ctx.schema);
        map3.flow = true;
        map3.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map3.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map3);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce2, ...ee2] = fc.end;
  let cePos = offset;
  if (ce2 && ce2.source === expectedEnd)
    cePos = ce2.offset + ce2.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce2 && ce2.source.length !== 1)
      ee2.unshift(ce2);
  }
  if (ee2.length > 0) {
    const end2 = resolveEnd(ee2, cePos, ctx.options.strict, onError);
    if (end2.comment) {
      if (coll.comment)
        coll.comment += "\n" + end2.comment;
      else
        coll.comment = end2.comment;
    }
    coll.range = [fc.offset, cePos, end2.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function resolveCollection(CN2, ctx, token2, onError, tagName, tag) {
  const coll = token2.type === "block-map" ? resolveBlockMap(CN2, ctx, token2, onError, tag) : token2.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token2, onError, tag) : resolveFlowCollection(CN2, ctx, token2, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token2, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token2.type === "block-seq") {
    const { anchor, newlineAfterProp: nl2 } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl2 || nl2.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token2.type === "block-map" ? "map" : token2.type === "block-seq" ? "seq" : token2.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token2, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt?.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token2, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token2, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node2 = isNode(res) ? res : new Scalar(res);
  node2.range = coll.range;
  node2.tag = tagName;
  if (tag?.format)
    node2.format = tag.format;
  return node2;
}
function resolveBlockScalar(ctx, scalar, onError) {
  const start2 = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start2, start2, start2] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end3 = start2 + header.length;
    if (scalar.source)
      end3 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start2, end3, end3] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end2 = start2 + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start2, end2, end2] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error2 === -1)
        error2 = offset + i;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment2 = "";
  let length2 = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token2 = props[i];
    switch (token2.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length2 += token2.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token2, "MISSING_CHAR", message);
        }
        length2 += token2.source.length;
        comment2 = token2.source.substring(1);
        break;
      case "error":
        onError(token2, "UNEXPECTED_TOKEN", token2.message);
        length2 += token2.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token2.type}`;
        onError(token2, "UNEXPECTED_TOKEN", message);
        const ts = token2.source;
        if (ts && typeof ts === "string")
          length2 += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment: comment2, length: length2 };
}
function splitLines(source) {
  const split2 = source.split(/\n( *)/);
  const first2 = split2[0];
  const m = first2.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split2.length; i += 2)
    lines.push([split2[i], split2[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end: end2 } = scalar;
  let _type;
  let value;
  const _onError = (rel, code2, msg) => onError(offset + rel, code2, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re2 = resolveEnd(end2, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re2.comment,
    range: [offset, valueEnd, re2.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match3 = first2.exec(source);
  if (!match3)
    return source;
  let res = match3[1];
  let sep = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match3 = line.exec(source)) {
    if (match3[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match3[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last2 = /[ \t]*(.*)/sy;
  last2.lastIndex = pos;
  match3 = last2.exec(source);
  return res + sep + (match3?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next3 = source[++i];
      const cc = escapeCodes[next3];
      if (cc)
        res += cc;
      else if (next3 === "\n") {
        next3 = source[i + 1];
        while (next3 === " " || next3 === "	")
          next3 = source[++i + 1];
      } else if (next3 === "\r" && source[i + 1] === "\n") {
        next3 = source[++i + 1];
        while (next3 === " " || next3 === "	")
          next3 = source[++i + 1];
      } else if (next3 === "x" || next3 === "u" || next3 === "U") {
        const length2 = { x: 2, u: 4, U: 8 }[next3];
        res += parseCharCode(source, i + 1, length2, onError);
        i += length2;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next3 = source[i + 1];
      while (next3 === " " || next3 === "	")
        next3 = source[++i + 1];
      if (next3 !== "\n" && !(next3 === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
const escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length2, onError) {
  const cc = source.substr(offset, length2);
  const ok = cc.length === length2 && /^[0-9a-fA-F]+$/.test(cc);
  const code2 = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code2)) {
    const raw = source.substr(offset - 2, length2 + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code2);
}
function composeScalar(ctx, token2, tagToken, onError) {
  const { value, type, comment: comment2, range } = token2.type === "block-scalar" ? resolveBlockScalar(ctx, token2, onError) : resolveFlowScalar(token2, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR$1];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token2.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token2, onError);
  else
    tag = ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ atKey, directives, schema: schema2 }, value, token2, onError) {
  const tag = schema2.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs2 = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs2}`;
      onError(token2, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset, before2, pos) {
  if (before2) {
    if (pos === null)
      pos = before2.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before2[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before2[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before2[++i];
      }
      break;
    }
  }
  return offset;
}
const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token2, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node2;
  let isSrcToken = true;
  switch (token2.type) {
    case "alias":
      node2 = composeAlias(ctx, token2, onError);
      if (anchor || tag)
        onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node2 = composeScalar(ctx, token2, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node2 = composeCollection(CN, ctx, token2, props, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
      onError(token2, "UNEXPECTED_TOKEN", message);
      node2 = composeEmptyNode(ctx, token2.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node2.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node2) || typeof node2.value !== "string" || node2.tag && node2.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag ?? token2, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment2) {
    if (token2.type === "scalar" && token2.source === "")
      node2.comment = comment2;
    else
      node2.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node2.srcToken = token2;
  return node2;
}
function composeEmptyNode(ctx, offset, before2, pos, { spaceBefore, comment: comment2, anchor, tag, end: end2 }, onError) {
  const token2 = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before2, pos),
    indent: -1,
    source: ""
  };
  const node2 = composeScalar(ctx, token2, tag, onError);
  if (anchor) {
    node2.anchor = anchor.source.substring(1);
    if (node2.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment2) {
    node2.comment = comment2;
    node2.range[2] = end2;
  }
  return node2;
}
function composeAlias({ options }, { offset, source, end: end2 }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re2 = resolveEnd(end2, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re2.offset];
  if (re2.comment)
    alias.comment = re2.comment;
  return alias;
}
function composeDoc(options, directives, { offset, start: start2, value, end: end2 }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document2(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start2, {
    indicator: "doc-start",
    next: value ?? end2?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start2, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re2 = resolveEnd(end2, contentEnd, false, onError);
  if (re2.comment)
    doc.comment = re2.comment;
  doc.range = [offset, contentEnd, re2.offset];
  return doc;
}
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
class Composer {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code2, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code2, message));
      else
        this.errors.push(new YAMLParseError(pos, code2, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it3 = dc.items[0];
        if (isPair(it3))
          it3 = it3.key;
        const cb = it3.commentBefore;
        it3.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token2 of tokens)
      yield* this.next(token2);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token2) {
    switch (token2.type) {
      case "directive":
        this.directives.add(token2.source, (offset, message, warning) => {
          const pos = getErrorPos(token2);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token2.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token2, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token2.source);
        break;
      case "error": {
        const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
        const error2 = new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error2);
        else
          this.doc.errors.push(error2);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end2 = resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end2.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
        }
        this.doc.range[2] = end2.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document2(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
}
const BOM = "\uFEFF";
const DOCUMENT = "";
const FLOW_END = "";
const SCALAR = "";
function tokenType$1(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty2(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
const hexDigits = new Set("0123456789ABCDEFabcdef");
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(",[]{}");
const invalidAnchorChars = new Set(" ,[]{}\n\r	");
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
class Lexer {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next3 = this.next ?? "stream";
    while (next3 && (incomplete || this.hasChars(1)))
      next3 = yield* this.parseNext(next3);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next3 = this.buffer[indent + offset + 1];
        if (next3 === "\n" || !next3 && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end2 = this.lineEndPos;
    if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
      end2 = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end2;
    }
    if (end2 === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end2 - 1] === "\r")
      end2 -= 1;
    return this.buffer.substring(this.pos, end2);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next3) {
    switch (next3) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs2 = line.indexOf("#");
      while (cs2 !== -1) {
        const ch = line[cs2 - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs2 - 1;
          break;
        } else {
          cs2 = line.indexOf("#", cs2 + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl2, sp;
    let indent = -1;
    do {
      nl2 = yield* this.pushNewline();
      if (nl2 > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl2 + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next3 = this.charAt(1);
        if (this.flowKey || isEmpty2(next3) || next3 === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end2 = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end2 !== -1 && this.buffer[end2 + 1] === "'")
        end2 = this.buffer.indexOf("'", end2 + 2);
    } else {
      while (end2 !== -1) {
        let n = 0;
        while (this.buffer[end2 - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end2 = this.buffer.indexOf('"', end2 + 1);
      }
    }
    const qb = this.buffer.substring(0, end2);
    let nl2 = qb.indexOf("\n", this.pos);
    if (nl2 !== -1) {
      while (nl2 !== -1) {
        const cs2 = this.continueScalar(nl2 + 1);
        if (cs2 === -1)
          break;
        nl2 = qb.indexOf("\n", cs2);
      }
      if (nl2 !== -1) {
        end2 = nl2 - (qb[nl2 - 1] === "\r" ? 2 : 1);
      }
    }
    if (end2 === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end2 = this.buffer.length;
    }
    yield* this.pushToIndex(end2 + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl2 = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl2 = i2;
            indent = 0;
            break;
          case "\r": {
            const next3 = this.buffer[i2 + 1];
            if (!next3 && !this.atEnd)
              return this.setNext("block-scalar");
            if (next3 === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs2 = this.continueScalar(nl2 + 1);
        if (cs2 === -1)
          break;
        nl2 = this.buffer.indexOf("\n", cs2);
      } while (nl2 !== -1);
      if (nl2 === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl2 = this.buffer.length;
      }
    }
    let i = nl2 + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl2 = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl2 - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl2 = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl2 + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end2 = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next3 = this.buffer[i + 1];
        if (isEmpty2(next3) || inFlow && flowIndicatorChars.has(next3))
          break;
        end2 = i;
      } else if (isEmpty2(ch)) {
        let next3 = this.buffer[i + 1];
        if (ch === "\r") {
          if (next3 === "\n") {
            i += 1;
            ch = "\n";
            next3 = this.buffer[i + 1];
          } else
            end2 = i;
        }
        if (next3 === "#" || inFlow && flowIndicatorChars.has(next3))
          break;
        if (ch === "\n") {
          const cs2 = this.continueScalar(i + 1);
          if (cs2 === -1)
            break;
          i = Math.max(i, cs2 - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end2 = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end2 + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty2(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test3) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test3(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
}
class LineCounter {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low2 = 0;
      let high = this.lineStarts.length;
      while (low2 < high) {
        const mid = low2 + high >> 1;
        if (this.lineStarts[mid] < offset)
          low2 = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low2] === offset)
        return { line: low2 + 1, col: 1 };
      if (low2 === 0)
        return { line: 0, col: offset };
      const start2 = this.lineStarts[low2 - 1];
      return { line: low2, col: offset - start2 + 1 };
    };
  }
}
function includesToken(list2, type) {
  for (let i = 0; i < list2.length; ++i)
    if (list2[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list2) {
  for (let i = 0; i < list2.length; ++i) {
    switch (list2[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token2) {
  switch (token2?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent2) {
  switch (parent2.type) {
    case "document":
      return parent2.start;
    case "block-map": {
      const it3 = parent2.items[parent2.items.length - 1];
      return it3.sep ?? it3.start;
    }
    case "block-seq":
      return parent2.items[parent2.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev2) {
  if (prev2.length === 0)
    return [];
  let i = prev2.length;
  loop:
    while (--i >= 0) {
      switch (prev2[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (prev2[++i]?.type === "space") {
  }
  return prev2.splice(i, prev2.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it3 of fc.items) {
      if (it3.sep && !it3.value && !includesToken(it3.start, "explicit-key-ind") && !includesToken(it3.sep, "map-value-ind")) {
        if (it3.key)
          it3.value = it3.key;
        delete it3.key;
        if (isFlowToken(it3.value)) {
          if (it3.value.end)
            Array.prototype.push.apply(it3.value.end, it3.sep);
          else
            it3.value.end = it3.sep;
        } else
          Array.prototype.push.apply(it3.start, it3.sep);
        delete it3.sep;
      }
    }
  }
}
class Parser2 {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType$1(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error2) {
    const token2 = error2 ?? this.stack.pop();
    if (!token2) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token2;
    } else {
      const top = this.peek(1);
      if (token2.type === "block-scalar") {
        token2.indent = "indent" in top ? top.indent : 0;
      } else if (token2.type === "flow-collection" && top.type === "document") {
        token2.indent = 0;
      }
      if (token2.type === "flow-collection")
        fixFlowSeqItems(token2);
      switch (top.type) {
        case "document":
          top.value = token2;
          break;
        case "block-scalar":
          top.props.push(token2);
          break;
        case "block-map": {
          const it3 = top.items[top.items.length - 1];
          if (it3.value) {
            top.items.push({ start: [], key: token2, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it3.sep) {
            it3.value = token2;
          } else {
            Object.assign(it3, { key: token2, sep: [] });
            this.onKeyLine = !it3.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it3 = top.items[top.items.length - 1];
          if (it3.value)
            top.items.push({ start: [], value: token2 });
          else
            it3.value = token2;
          break;
        }
        case "flow-collection": {
          const it3 = top.items[top.items.length - 1];
          if (!it3 || it3.value)
            top.items.push({ start: [], key: token2, sep: [] });
          else if (it3.sep)
            it3.value = token2;
          else
            Object.assign(it3, { key: token2, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token2);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
        const last2 = token2.items[token2.items.length - 1];
        if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token2.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
          if (top.type === "document")
            top.end = last2.start;
          else
            top.items.push({ start: last2.start });
          token2.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev2 = getPrevProps(this.peek(2));
      const start2 = getFirstKeyStartProps(prev2);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map3 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start: start2, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map3;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl2 = this.source.indexOf("\n") + 1;
          while (nl2 !== 0) {
            this.onNewLine(this.offset + nl2);
            nl2 = this.source.indexOf("\n", nl2) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map3) {
    const it3 = map3.items[map3.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it3.value) {
          const end2 = "end" in it3.value ? it3.value.end : void 0;
          const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if (last2?.type === "comment")
            end2?.push(this.sourceToken);
          else
            map3.items.push({ start: [this.sourceToken] });
        } else if (it3.sep) {
          it3.sep.push(this.sourceToken);
        } else {
          it3.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it3.value) {
          map3.items.push({ start: [this.sourceToken] });
        } else if (it3.sep) {
          it3.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it3.start, map3.indent)) {
            const prev2 = map3.items[map3.items.length - 2];
            const end2 = prev2?.value?.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it3.start);
              end2.push(this.sourceToken);
              map3.items.pop();
              return;
            }
          }
          it3.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map3.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
      const atNextItem = atMapIndent && (it3.sep || it3.explicitKey) && this.type !== "seq-item-ind";
      let start2 = [];
      if (atNextItem && it3.sep && !it3.value) {
        const nl2 = [];
        for (let i = 0; i < it3.sep.length; ++i) {
          const st = it3.sep[i];
          switch (st.type) {
            case "newline":
              nl2.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map3.indent)
                nl2.length = 0;
              break;
            default:
              nl2.length = 0;
          }
        }
        if (nl2.length >= 2)
          start2 = it3.sep.splice(nl2[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it3.value) {
            start2.push(this.sourceToken);
            map3.items.push({ start: start2 });
            this.onKeyLine = true;
          } else if (it3.sep) {
            it3.sep.push(this.sourceToken);
          } else {
            it3.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it3.sep && !it3.explicitKey) {
            it3.start.push(this.sourceToken);
            it3.explicitKey = true;
          } else if (atNextItem || it3.value) {
            start2.push(this.sourceToken);
            map3.items.push({ start: start2, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it3.explicitKey) {
            if (!it3.sep) {
              if (includesToken(it3.start, "newline")) {
                Object.assign(it3, { key: null, sep: [this.sourceToken] });
              } else {
                const start3 = getFirstKeyStartProps(it3.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it3.value) {
              map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it3.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it3.key) && !includesToken(it3.sep, "newline")) {
              const start3 = getFirstKeyStartProps(it3.start);
              const key = it3.key;
              const sep = it3.sep;
              sep.push(this.sourceToken);
              delete it3.key;
              delete it3.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start3, key, sep }]
              });
            } else if (start2.length > 0) {
              it3.sep = it3.sep.concat(start2, this.sourceToken);
            } else {
              it3.sep.push(this.sourceToken);
            }
          } else {
            if (!it3.sep) {
              Object.assign(it3, { key: null, sep: [this.sourceToken] });
            } else if (it3.value || atNextItem) {
              map3.items.push({ start: start2, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it3.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it3.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it3.value) {
            map3.items.push({ start: start2, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it3.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it3, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map3);
          if (bv) {
            if (atMapIndent && bv.type !== "block-seq") {
              map3.items.push({ start: start2 });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it3 = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it3.value) {
          const end2 = "end" in it3.value ? it3.value.end : void 0;
          const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if (last2?.type === "comment")
            end2?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it3.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it3.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it3.start, seq2.indent)) {
            const prev2 = seq2.items[seq2.items.length - 2];
            const end2 = prev2?.value?.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it3.start);
              end2.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it3.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it3.value || this.indent <= seq2.indent)
          break;
        it3.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it3.value || includesToken(it3.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it3.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it3 = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it3 || it3.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it3.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it3 || it3.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it3.sep)
            it3.sep.push(this.sourceToken);
          else
            Object.assign(it3, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it3 || it3.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it3.sep)
            it3.sep.push(this.sourceToken);
          else
            it3.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it3 || it3.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it3.sep)
            this.stack.push(fs);
          else
            Object.assign(it3, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent2 = this.peek(2);
      if (parent2.type === "block-map" && (this.type === "map-value-ind" && parent2.indent === fc.indent || this.type === "newline" && !parent2.items[parent2.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent2.type !== "flow-collection") {
        const prev2 = getPrevProps(parent2);
        const start2 = getFirstKeyStartProps(prev2);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map3 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start: start2, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map3;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl2 = this.source.indexOf("\n") + 1;
      while (nl2 !== 0) {
        this.onNewLine(this.offset + nl2);
        nl2 = this.source.indexOf("\n", nl2) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent2) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev2 = getPrevProps(parent2);
        const start2 = getFirstKeyStartProps(prev2);
        start2.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev2 = getPrevProps(parent2);
        const start2 = getFirstKeyStartProps(prev2);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start2, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start2.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token2) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token2.end)
          token2.end.push(this.sourceToken);
        else
          token2.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
}
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser2(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
var dist = {};
var katex = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal$1, function() {
    return (
      /******/
      function() {
        var __webpack_require__ = {};
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.o = function(obj, prop2) {
            return Object.prototype.hasOwnProperty.call(obj, prop2);
          };
        }();
        var __webpack_exports__ = {};
        __webpack_require__.d(__webpack_exports__, {
          "default": function() {
            return (
              /* binding */
              katex_webpack
            );
          }
        });
        class ParseError {
          // Error start position based on passed-in Token or ParseNode.
          // Length of affected text based on passed-in Token or ParseNode.
          // The underlying error message without any context added.
          constructor(message, token2) {
            this.name = void 0;
            this.position = void 0;
            this.length = void 0;
            this.rawMessage = void 0;
            let error2 = "KaTeX parse error: " + message;
            let start2;
            let end2;
            const loc = token2 && token2.loc;
            if (loc && loc.start <= loc.end) {
              const input = loc.lexer.input;
              start2 = loc.start;
              end2 = loc.end;
              if (start2 === input.length) {
                error2 += " at end of input: ";
              } else {
                error2 += " at position " + (start2 + 1) + ": ";
              }
              const underlined = input.slice(start2, end2).replace(/[^]/g, "$&̲");
              let left;
              if (start2 > 15) {
                left = "…" + input.slice(start2 - 15, start2);
              } else {
                left = input.slice(0, start2);
              }
              let right;
              if (end2 + 15 < input.length) {
                right = input.slice(end2, end2 + 15) + "…";
              } else {
                right = input.slice(end2);
              }
              error2 += left + underlined + right;
            }
            const self2 = new Error(error2);
            self2.name = "ParseError";
            self2.__proto__ = ParseError.prototype;
            self2.position = start2;
            if (start2 != null && end2 != null) {
              self2.length = end2 - start2;
            }
            self2.rawMessage = message;
            return self2;
          }
        }
        ParseError.prototype.__proto__ = Error.prototype;
        var src_ParseError = ParseError;
        const contains2 = function(list2, elem) {
          return list2.indexOf(elem) !== -1;
        };
        const deflt = function(setting, defaultIfUndefined) {
          return setting === void 0 ? defaultIfUndefined : setting;
        };
        const uppercase = /([A-Z])/g;
        const hyphenate = function(str) {
          return str.replace(uppercase, "-$1").toLowerCase();
        };
        const ESCAPE_LOOKUP = {
          "&": "&amp;",
          ">": "&gt;",
          "<": "&lt;",
          '"': "&quot;",
          "'": "&#x27;"
        };
        const ESCAPE_REGEX = /[&><"']/g;
        function utils_escape(text2) {
          return String(text2).replace(ESCAPE_REGEX, (match3) => ESCAPE_LOOKUP[match3]);
        }
        const getBaseElem = function(group) {
          if (group.type === "ordgroup") {
            if (group.body.length === 1) {
              return getBaseElem(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "color") {
            if (group.body.length === 1) {
              return getBaseElem(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "font") {
            return getBaseElem(group.body);
          } else {
            return group;
          }
        };
        const isCharacterBox = function(group) {
          const baseElem = getBaseElem(group);
          return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
        };
        const assert = function(value) {
          if (!value) {
            throw new Error("Expected non-null, but got " + String(value));
          }
          return value;
        };
        const protocolFromUrl = function(url) {
          const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
          if (!protocol) {
            return "_relative";
          }
          if (protocol[2] !== ":") {
            return null;
          }
          if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
            return null;
          }
          return protocol[1].toLowerCase();
        };
        var utils2 = {
          contains: contains2,
          deflt,
          escape: utils_escape,
          hyphenate,
          getBaseElem,
          isCharacterBox,
          protocolFromUrl
        };
        const SETTINGS_SCHEMA = {
          displayMode: {
            type: "boolean",
            description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
            cli: "-d, --display-mode"
          },
          output: {
            type: {
              enum: ["htmlAndMathml", "html", "mathml"]
            },
            description: "Determines the markup language of the output.",
            cli: "-F, --format <type>"
          },
          leqno: {
            type: "boolean",
            description: "Render display math in leqno style (left-justified tags)."
          },
          fleqn: {
            type: "boolean",
            description: "Render display math flush left."
          },
          throwOnError: {
            type: "boolean",
            default: true,
            cli: "-t, --no-throw-on-error",
            cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
          },
          errorColor: {
            type: "string",
            default: "#cc0000",
            cli: "-c, --error-color <color>",
            cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
            cliProcessor: (color2) => "#" + color2
          },
          macros: {
            type: "object",
            cli: "-m, --macro <def>",
            cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
            cliDefault: [],
            cliProcessor: (def, defs) => {
              defs.push(def);
              return defs;
            }
          },
          minRuleThickness: {
            type: "number",
            description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
            processor: (t) => Math.max(0, t),
            cli: "--min-rule-thickness <size>",
            cliProcessor: parseFloat
          },
          colorIsTextColor: {
            type: "boolean",
            description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
            cli: "-b, --color-is-text-color"
          },
          strict: {
            type: [{
              enum: ["warn", "ignore", "error"]
            }, "boolean", "function"],
            description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
            cli: "-S, --strict",
            cliDefault: false
          },
          trust: {
            type: ["boolean", "function"],
            description: "Trust the input, enabling all HTML features such as \\url.",
            cli: "-T, --trust"
          },
          maxSize: {
            type: "number",
            default: Infinity,
            description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
            processor: (s) => Math.max(0, s),
            cli: "-s, --max-size <n>",
            cliProcessor: parseInt
          },
          maxExpand: {
            type: "number",
            default: 1e3,
            description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
            processor: (n) => Math.max(0, n),
            cli: "-e, --max-expand <n>",
            cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
          },
          globalGroup: {
            type: "boolean",
            cli: false
          }
        };
        function getDefaultValue(schema2) {
          if (schema2.default) {
            return schema2.default;
          }
          const type = schema2.type;
          const defaultType = Array.isArray(type) ? type[0] : type;
          if (typeof defaultType !== "string") {
            return defaultType.enum[0];
          }
          switch (defaultType) {
            case "boolean":
              return false;
            case "string":
              return "";
            case "number":
              return 0;
            case "object":
              return {};
          }
        }
        class Settings {
          constructor(options) {
            this.displayMode = void 0;
            this.output = void 0;
            this.leqno = void 0;
            this.fleqn = void 0;
            this.throwOnError = void 0;
            this.errorColor = void 0;
            this.macros = void 0;
            this.minRuleThickness = void 0;
            this.colorIsTextColor = void 0;
            this.strict = void 0;
            this.trust = void 0;
            this.maxSize = void 0;
            this.maxExpand = void 0;
            this.globalGroup = void 0;
            options = options || {};
            for (const prop2 in SETTINGS_SCHEMA) {
              if (SETTINGS_SCHEMA.hasOwnProperty(prop2)) {
                const schema2 = SETTINGS_SCHEMA[prop2];
                this[prop2] = options[prop2] !== void 0 ? schema2.processor ? schema2.processor(options[prop2]) : options[prop2] : getDefaultValue(schema2);
              }
            }
          }
          /**
           * Report nonstrict (non-LaTeX-compatible) input.
           * Can safely not be called if `this.strict` is false in JavaScript.
           */
          reportNonstrict(errorCode, errorMsg, token2) {
            let strict = this.strict;
            if (typeof strict === "function") {
              strict = strict(errorCode, errorMsg, token2);
            }
            if (!strict || strict === "ignore") {
              return;
            } else if (strict === true || strict === "error") {
              throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token2);
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            }
          }
          /**
           * Check whether to apply strict (LaTeX-adhering) behavior for unusual
           * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
           * instead, "error" translates to a return value of `true`, while "ignore"
           * translates to a return value of `false`.  May still print a warning:
           * "warn" prints a warning and returns `false`.
           * This is for the second category of `errorCode`s listed in the README.
           */
          useStrictBehavior(errorCode, errorMsg, token2) {
            let strict = this.strict;
            if (typeof strict === "function") {
              try {
                strict = strict(errorCode, errorMsg, token2);
              } catch (error2) {
                strict = "error";
              }
            }
            if (!strict || strict === "ignore") {
              return false;
            } else if (strict === true || strict === "error") {
              return true;
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              return false;
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              return false;
            }
          }
          /**
           * Check whether to test potentially dangerous input, and return
           * `true` (trusted) or `false` (untrusted).  The sole argument `context`
           * should be an object with `command` field specifying the relevant LaTeX
           * command (as a string starting with `\`), and any other arguments, etc.
           * If `context` has a `url` field, a `protocol` field will automatically
           * get added by this function (changing the specified object).
           */
          isTrusted(context) {
            if (context.url && !context.protocol) {
              const protocol = utils2.protocolFromUrl(context.url);
              if (protocol == null) {
                return false;
              }
              context.protocol = protocol;
            }
            const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
            return Boolean(trust);
          }
        }
        class Style2 {
          constructor(id2, size, cramped) {
            this.id = void 0;
            this.size = void 0;
            this.cramped = void 0;
            this.id = id2;
            this.size = size;
            this.cramped = cramped;
          }
          /**
           * Get the style of a superscript given a base in the current style.
           */
          sup() {
            return styles2[sup[this.id]];
          }
          /**
           * Get the style of a subscript given a base in the current style.
           */
          sub() {
            return styles2[sub[this.id]];
          }
          /**
           * Get the style of a fraction numerator given the fraction in the current
           * style.
           */
          fracNum() {
            return styles2[fracNum[this.id]];
          }
          /**
           * Get the style of a fraction denominator given the fraction in the current
           * style.
           */
          fracDen() {
            return styles2[fracDen[this.id]];
          }
          /**
           * Get the cramped version of a style (in particular, cramping a cramped style
           * doesn't change the style).
           */
          cramp() {
            return styles2[cramp[this.id]];
          }
          /**
           * Get a text or display version of this style.
           */
          text() {
            return styles2[Style_text[this.id]];
          }
          /**
           * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
           */
          isTight() {
            return this.size >= 2;
          }
        }
        const D = 0;
        const Dc = 1;
        const T2 = 2;
        const Tc = 3;
        const S = 4;
        const Sc = 5;
        const SS = 6;
        const SSc = 7;
        const styles2 = [new Style2(D, 0, false), new Style2(Dc, 0, true), new Style2(T2, 1, false), new Style2(Tc, 1, true), new Style2(S, 2, false), new Style2(Sc, 2, true), new Style2(SS, 3, false), new Style2(SSc, 3, true)];
        const sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
        const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
        const fracNum = [T2, Tc, S, Sc, SS, SSc, SS, SSc];
        const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
        const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
        const Style_text = [D, Dc, T2, Tc, T2, Tc, T2, Tc];
        var src_Style = {
          DISPLAY: styles2[D],
          TEXT: styles2[T2],
          SCRIPT: styles2[S],
          SCRIPTSCRIPT: styles2[SS]
        };
        const scriptData = [{
          // Latin characters beyond the Latin-1 characters we have metrics for.
          // Needed for Czech, Hungarian and Turkish text, for example.
          name: "latin",
          blocks: [
            [256, 591],
            // Latin Extended-A and Latin Extended-B
            [768, 879]
            // Combining Diacritical marks
          ]
        }, {
          // The Cyrillic script used by Russian and related languages.
          // A Cyrillic subset used to be supported as explicitly defined
          // symbols in symbols.js
          name: "cyrillic",
          blocks: [[1024, 1279]]
        }, {
          // Armenian
          name: "armenian",
          blocks: [[1328, 1423]]
        }, {
          // The Brahmic scripts of South and Southeast Asia
          // Devanagari (0900–097F)
          // Bengali (0980–09FF)
          // Gurmukhi (0A00–0A7F)
          // Gujarati (0A80–0AFF)
          // Oriya (0B00–0B7F)
          // Tamil (0B80–0BFF)
          // Telugu (0C00–0C7F)
          // Kannada (0C80–0CFF)
          // Malayalam (0D00–0D7F)
          // Sinhala (0D80–0DFF)
          // Thai (0E00–0E7F)
          // Lao (0E80–0EFF)
          // Tibetan (0F00–0FFF)
          // Myanmar (1000–109F)
          name: "brahmic",
          blocks: [[2304, 4255]]
        }, {
          name: "georgian",
          blocks: [[4256, 4351]]
        }, {
          // Chinese and Japanese.
          // The "k" in cjk is for Korean, but we've separated Korean out
          name: "cjk",
          blocks: [
            [12288, 12543],
            // CJK symbols and punctuation, Hiragana, Katakana
            [19968, 40879],
            // CJK ideograms
            [65280, 65376]
            // Fullwidth punctuation
            // TODO: add halfwidth Katakana and Romanji glyphs
          ]
        }, {
          // Korean
          name: "hangul",
          blocks: [[44032, 55215]]
        }];
        function scriptFromCodepoint(codepoint) {
          for (let i = 0; i < scriptData.length; i++) {
            const script = scriptData[i];
            for (let i2 = 0; i2 < script.blocks.length; i2++) {
              const block2 = script.blocks[i2];
              if (codepoint >= block2[0] && codepoint <= block2[1]) {
                return script.name;
              }
            }
          }
          return null;
        }
        const allBlocks = [];
        scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
        function supportedCodepoint(codepoint) {
          for (let i = 0; i < allBlocks.length; i += 2) {
            if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
              return true;
            }
          }
          return false;
        }
        const hLinePad = 80;
        const sqrtMain = function(extraVinculum, hLinePad2) {
          return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize1 = function(extraVinculum, hLinePad2) {
          return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize2 = function(extraVinculum, hLinePad2) {
          return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize3 = function(extraVinculum, hLinePad2) {
          return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
        };
        const sqrtSize4 = function(extraVinculum, hLinePad2) {
          return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
        };
        const phasePath = function(y2) {
          const x2 = y2 / 2;
          return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
        };
        const sqrtTall = function(extraVinculum, hLinePad2, viewBoxHeight) {
          const vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
          return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
        };
        const sqrtPath = function(size, extraVinculum, viewBoxHeight) {
          extraVinculum = 1e3 * extraVinculum;
          let path3 = "";
          switch (size) {
            case "sqrtMain":
              path3 = sqrtMain(extraVinculum, hLinePad);
              break;
            case "sqrtSize1":
              path3 = sqrtSize1(extraVinculum, hLinePad);
              break;
            case "sqrtSize2":
              path3 = sqrtSize2(extraVinculum, hLinePad);
              break;
            case "sqrtSize3":
              path3 = sqrtSize3(extraVinculum, hLinePad);
              break;
            case "sqrtSize4":
              path3 = sqrtSize4(extraVinculum, hLinePad);
              break;
            case "sqrtTall":
              path3 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
          }
          return path3;
        };
        const innerPath = function(name2, height) {
          switch (name2) {
            case "⎜":
              return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
            case "∣":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
            case "∥":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
            case "⎟":
              return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
            case "⎢":
              return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
            case "⎥":
              return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
            case "⎪":
              return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
            case "⏐":
              return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
            case "‖":
              return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
            default:
              return "";
          }
        };
        const path2 = {
          // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
          doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
          // doublerightarrow is from glyph U+21D2 in font KaTeX Main
          doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
          // leftarrow is from glyph U+2190 in font KaTeX Main
          leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
          // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
          leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
          leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
          // overgroup is from the MnSymbol package (public domain)
          leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
          leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
          // Harpoons are from glyph U+21BD in font KaTeX Main
          leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
          leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
          leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
          leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
          // hook is from glyph U+21A9 in font KaTeX Main
          lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
          leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
          leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
          // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
          leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
          longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
          midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
          midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
          oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
          oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
          oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
          oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
          rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
          rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
          rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
          rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
          rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
          rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
          rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
          rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
          rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
          righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
          rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
          rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
          // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
          twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
          twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
          // tilde1 is a modified version of a glyph from the MnSymbol package
          tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
          // ditto tilde2, tilde3, & tilde4
          tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
          tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
          tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
          // vec is from glyph U+20D7 in font KaTeX Main
          vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
          // widehat1 is a modified version of a glyph from the MnSymbol package
          widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
          // ditto widehat2, widehat3, & widehat4
          widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          // widecheck paths are all inverted versions of widehat
          widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
          widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          // The next ten paths support reaction arrows from the mhchem package.
          // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
          // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
          baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
          // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
          rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
          // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
          // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
          baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
          rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
          shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
          shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
        };
        const tallDelim = function(label, midHeight) {
          switch (label) {
            case "lbrack":
              return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
            case "rbrack":
              return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
            case "vert":
              return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
            case "doublevert":
              return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
            case "lfloor":
              return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
            case "rfloor":
              return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
            case "lceil":
              return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
            case "rceil":
              return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
            case "lparen":
              return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
            case "rparen":
              return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
            default:
              throw new Error("Unknown stretchy delimiter.");
          }
        };
        class DocumentFragment {
          // HtmlDomNode
          // Never used; needed for satisfying interface.
          constructor(children2) {
            this.children = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.children = children2;
            this.classes = [];
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = {};
          }
          hasClass(className) {
            return utils2.contains(this.classes, className);
          }
          /** Convert the fragment into a node. */
          toNode() {
            const frag = document.createDocumentFragment();
            for (let i = 0; i < this.children.length; i++) {
              frag.appendChild(this.children[i].toNode());
            }
            return frag;
          }
          /** Convert the fragment into HTML markup. */
          toMarkup() {
            let markup = "";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            return markup;
          }
          /**
           * Converts the math node into a string, similar to innerText. Applies to
           * MathDomNode's only.
           */
          toText() {
            const toText = (child) => child.toText();
            return this.children.map(toText).join("");
          }
        }
        var fontMetricsData = {
          "AMS-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68889, 0, 0, 0.72222],
            "66": [0, 0.68889, 0, 0, 0.66667],
            "67": [0, 0.68889, 0, 0, 0.72222],
            "68": [0, 0.68889, 0, 0, 0.72222],
            "69": [0, 0.68889, 0, 0, 0.66667],
            "70": [0, 0.68889, 0, 0, 0.61111],
            "71": [0, 0.68889, 0, 0, 0.77778],
            "72": [0, 0.68889, 0, 0, 0.77778],
            "73": [0, 0.68889, 0, 0, 0.38889],
            "74": [0.16667, 0.68889, 0, 0, 0.5],
            "75": [0, 0.68889, 0, 0, 0.77778],
            "76": [0, 0.68889, 0, 0, 0.66667],
            "77": [0, 0.68889, 0, 0, 0.94445],
            "78": [0, 0.68889, 0, 0, 0.72222],
            "79": [0.16667, 0.68889, 0, 0, 0.77778],
            "80": [0, 0.68889, 0, 0, 0.61111],
            "81": [0.16667, 0.68889, 0, 0, 0.77778],
            "82": [0, 0.68889, 0, 0, 0.72222],
            "83": [0, 0.68889, 0, 0, 0.55556],
            "84": [0, 0.68889, 0, 0, 0.66667],
            "85": [0, 0.68889, 0, 0, 0.72222],
            "86": [0, 0.68889, 0, 0, 0.72222],
            "87": [0, 0.68889, 0, 0, 1],
            "88": [0, 0.68889, 0, 0, 0.72222],
            "89": [0, 0.68889, 0, 0, 0.72222],
            "90": [0, 0.68889, 0, 0, 0.66667],
            "107": [0, 0.68889, 0, 0, 0.55556],
            "160": [0, 0, 0, 0, 0.25],
            "165": [0, 0.675, 0.025, 0, 0.75],
            "174": [0.15559, 0.69224, 0, 0, 0.94666],
            "240": [0, 0.68889, 0, 0, 0.55556],
            "295": [0, 0.68889, 0, 0, 0.54028],
            "710": [0, 0.825, 0, 0, 2.33334],
            "732": [0, 0.9, 0, 0, 2.33334],
            "770": [0, 0.825, 0, 0, 2.33334],
            "771": [0, 0.9, 0, 0, 2.33334],
            "989": [0.08167, 0.58167, 0, 0, 0.77778],
            "1008": [0, 0.43056, 0.04028, 0, 0.66667],
            "8245": [0, 0.54986, 0, 0, 0.275],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8487": [0, 0.68889, 0, 0, 0.72222],
            "8498": [0, 0.68889, 0, 0, 0.55556],
            "8502": [0, 0.68889, 0, 0, 0.66667],
            "8503": [0, 0.68889, 0, 0, 0.44445],
            "8504": [0, 0.68889, 0, 0, 0.66667],
            "8513": [0, 0.68889, 0, 0, 0.63889],
            "8592": [-0.03598, 0.46402, 0, 0, 0.5],
            "8594": [-0.03598, 0.46402, 0, 0, 0.5],
            "8602": [-0.13313, 0.36687, 0, 0, 1],
            "8603": [-0.13313, 0.36687, 0, 0, 1],
            "8606": [0.01354, 0.52239, 0, 0, 1],
            "8608": [0.01354, 0.52239, 0, 0, 1],
            "8610": [0.01354, 0.52239, 0, 0, 1.11111],
            "8611": [0.01354, 0.52239, 0, 0, 1.11111],
            "8619": [0, 0.54986, 0, 0, 1],
            "8620": [0, 0.54986, 0, 0, 1],
            "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
            "8622": [-0.13313, 0.36687, 0, 0, 1],
            "8624": [0, 0.69224, 0, 0, 0.5],
            "8625": [0, 0.69224, 0, 0, 0.5],
            "8630": [0, 0.43056, 0, 0, 1],
            "8631": [0, 0.43056, 0, 0, 1],
            "8634": [0.08198, 0.58198, 0, 0, 0.77778],
            "8635": [0.08198, 0.58198, 0, 0, 0.77778],
            "8638": [0.19444, 0.69224, 0, 0, 0.41667],
            "8639": [0.19444, 0.69224, 0, 0, 0.41667],
            "8642": [0.19444, 0.69224, 0, 0, 0.41667],
            "8643": [0.19444, 0.69224, 0, 0, 0.41667],
            "8644": [0.1808, 0.675, 0, 0, 1],
            "8646": [0.1808, 0.675, 0, 0, 1],
            "8647": [0.1808, 0.675, 0, 0, 1],
            "8648": [0.19444, 0.69224, 0, 0, 0.83334],
            "8649": [0.1808, 0.675, 0, 0, 1],
            "8650": [0.19444, 0.69224, 0, 0, 0.83334],
            "8651": [0.01354, 0.52239, 0, 0, 1],
            "8652": [0.01354, 0.52239, 0, 0, 1],
            "8653": [-0.13313, 0.36687, 0, 0, 1],
            "8654": [-0.13313, 0.36687, 0, 0, 1],
            "8655": [-0.13313, 0.36687, 0, 0, 1],
            "8666": [0.13667, 0.63667, 0, 0, 1],
            "8667": [0.13667, 0.63667, 0, 0, 1],
            "8669": [-0.13313, 0.37788, 0, 0, 1],
            "8672": [-0.064, 0.437, 0, 0, 1.334],
            "8674": [-0.064, 0.437, 0, 0, 1.334],
            "8705": [0, 0.825, 0, 0, 0.5],
            "8708": [0, 0.68889, 0, 0, 0.55556],
            "8709": [0.08167, 0.58167, 0, 0, 0.77778],
            "8717": [0, 0.43056, 0, 0, 0.42917],
            "8722": [-0.03598, 0.46402, 0, 0, 0.5],
            "8724": [0.08198, 0.69224, 0, 0, 0.77778],
            "8726": [0.08167, 0.58167, 0, 0, 0.77778],
            "8733": [0, 0.69224, 0, 0, 0.77778],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8737": [0, 0.69224, 0, 0, 0.72222],
            "8738": [0.03517, 0.52239, 0, 0, 0.72222],
            "8739": [0.08167, 0.58167, 0, 0, 0.22222],
            "8740": [0.25142, 0.74111, 0, 0, 0.27778],
            "8741": [0.08167, 0.58167, 0, 0, 0.38889],
            "8742": [0.25142, 0.74111, 0, 0, 0.5],
            "8756": [0, 0.69224, 0, 0, 0.66667],
            "8757": [0, 0.69224, 0, 0, 0.66667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
            "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8774": [0.30274, 0.79383, 0, 0, 0.77778],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8778": [0.08167, 0.58167, 0, 0, 0.77778],
            "8782": [0.06062, 0.54986, 0, 0, 0.77778],
            "8783": [0.06062, 0.54986, 0, 0, 0.77778],
            "8785": [0.08198, 0.58198, 0, 0, 0.77778],
            "8786": [0.08198, 0.58198, 0, 0, 0.77778],
            "8787": [0.08198, 0.58198, 0, 0, 0.77778],
            "8790": [0, 0.69224, 0, 0, 0.77778],
            "8791": [0.22958, 0.72958, 0, 0, 0.77778],
            "8796": [0.08198, 0.91667, 0, 0, 0.77778],
            "8806": [0.25583, 0.75583, 0, 0, 0.77778],
            "8807": [0.25583, 0.75583, 0, 0, 0.77778],
            "8808": [0.25142, 0.75726, 0, 0, 0.77778],
            "8809": [0.25142, 0.75726, 0, 0, 0.77778],
            "8812": [0.25583, 0.75583, 0, 0, 0.5],
            "8814": [0.20576, 0.70576, 0, 0, 0.77778],
            "8815": [0.20576, 0.70576, 0, 0, 0.77778],
            "8816": [0.30274, 0.79383, 0, 0, 0.77778],
            "8817": [0.30274, 0.79383, 0, 0, 0.77778],
            "8818": [0.22958, 0.72958, 0, 0, 0.77778],
            "8819": [0.22958, 0.72958, 0, 0, 0.77778],
            "8822": [0.1808, 0.675, 0, 0, 0.77778],
            "8823": [0.1808, 0.675, 0, 0, 0.77778],
            "8828": [0.13667, 0.63667, 0, 0, 0.77778],
            "8829": [0.13667, 0.63667, 0, 0, 0.77778],
            "8830": [0.22958, 0.72958, 0, 0, 0.77778],
            "8831": [0.22958, 0.72958, 0, 0, 0.77778],
            "8832": [0.20576, 0.70576, 0, 0, 0.77778],
            "8833": [0.20576, 0.70576, 0, 0, 0.77778],
            "8840": [0.30274, 0.79383, 0, 0, 0.77778],
            "8841": [0.30274, 0.79383, 0, 0, 0.77778],
            "8842": [0.13597, 0.63597, 0, 0, 0.77778],
            "8843": [0.13597, 0.63597, 0, 0, 0.77778],
            "8847": [0.03517, 0.54986, 0, 0, 0.77778],
            "8848": [0.03517, 0.54986, 0, 0, 0.77778],
            "8858": [0.08198, 0.58198, 0, 0, 0.77778],
            "8859": [0.08198, 0.58198, 0, 0, 0.77778],
            "8861": [0.08198, 0.58198, 0, 0, 0.77778],
            "8862": [0, 0.675, 0, 0, 0.77778],
            "8863": [0, 0.675, 0, 0, 0.77778],
            "8864": [0, 0.675, 0, 0, 0.77778],
            "8865": [0, 0.675, 0, 0, 0.77778],
            "8872": [0, 0.69224, 0, 0, 0.61111],
            "8873": [0, 0.69224, 0, 0, 0.72222],
            "8874": [0, 0.69224, 0, 0, 0.88889],
            "8876": [0, 0.68889, 0, 0, 0.61111],
            "8877": [0, 0.68889, 0, 0, 0.61111],
            "8878": [0, 0.68889, 0, 0, 0.72222],
            "8879": [0, 0.68889, 0, 0, 0.72222],
            "8882": [0.03517, 0.54986, 0, 0, 0.77778],
            "8883": [0.03517, 0.54986, 0, 0, 0.77778],
            "8884": [0.13667, 0.63667, 0, 0, 0.77778],
            "8885": [0.13667, 0.63667, 0, 0, 0.77778],
            "8888": [0, 0.54986, 0, 0, 1.11111],
            "8890": [0.19444, 0.43056, 0, 0, 0.55556],
            "8891": [0.19444, 0.69224, 0, 0, 0.61111],
            "8892": [0.19444, 0.69224, 0, 0, 0.61111],
            "8901": [0, 0.54986, 0, 0, 0.27778],
            "8903": [0.08167, 0.58167, 0, 0, 0.77778],
            "8905": [0.08167, 0.58167, 0, 0, 0.77778],
            "8906": [0.08167, 0.58167, 0, 0, 0.77778],
            "8907": [0, 0.69224, 0, 0, 0.77778],
            "8908": [0, 0.69224, 0, 0, 0.77778],
            "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
            "8910": [0, 0.54986, 0, 0, 0.76042],
            "8911": [0, 0.54986, 0, 0, 0.76042],
            "8912": [0.03517, 0.54986, 0, 0, 0.77778],
            "8913": [0.03517, 0.54986, 0, 0, 0.77778],
            "8914": [0, 0.54986, 0, 0, 0.66667],
            "8915": [0, 0.54986, 0, 0, 0.66667],
            "8916": [0, 0.69224, 0, 0, 0.66667],
            "8918": [0.0391, 0.5391, 0, 0, 0.77778],
            "8919": [0.0391, 0.5391, 0, 0, 0.77778],
            "8920": [0.03517, 0.54986, 0, 0, 1.33334],
            "8921": [0.03517, 0.54986, 0, 0, 1.33334],
            "8922": [0.38569, 0.88569, 0, 0, 0.77778],
            "8923": [0.38569, 0.88569, 0, 0, 0.77778],
            "8926": [0.13667, 0.63667, 0, 0, 0.77778],
            "8927": [0.13667, 0.63667, 0, 0, 0.77778],
            "8928": [0.30274, 0.79383, 0, 0, 0.77778],
            "8929": [0.30274, 0.79383, 0, 0, 0.77778],
            "8934": [0.23222, 0.74111, 0, 0, 0.77778],
            "8935": [0.23222, 0.74111, 0, 0, 0.77778],
            "8936": [0.23222, 0.74111, 0, 0, 0.77778],
            "8937": [0.23222, 0.74111, 0, 0, 0.77778],
            "8938": [0.20576, 0.70576, 0, 0, 0.77778],
            "8939": [0.20576, 0.70576, 0, 0, 0.77778],
            "8940": [0.30274, 0.79383, 0, 0, 0.77778],
            "8941": [0.30274, 0.79383, 0, 0, 0.77778],
            "8994": [0.19444, 0.69224, 0, 0, 0.77778],
            "8995": [0.19444, 0.69224, 0, 0, 0.77778],
            "9416": [0.15559, 0.69224, 0, 0, 0.90222],
            "9484": [0, 0.69224, 0, 0, 0.5],
            "9488": [0, 0.69224, 0, 0, 0.5],
            "9492": [0, 0.37788, 0, 0, 0.5],
            "9496": [0, 0.37788, 0, 0, 0.5],
            "9585": [0.19444, 0.68889, 0, 0, 0.88889],
            "9586": [0.19444, 0.74111, 0, 0, 0.88889],
            "9632": [0, 0.675, 0, 0, 0.77778],
            "9633": [0, 0.675, 0, 0, 0.77778],
            "9650": [0, 0.54986, 0, 0, 0.72222],
            "9651": [0, 0.54986, 0, 0, 0.72222],
            "9654": [0.03517, 0.54986, 0, 0, 0.77778],
            "9660": [0, 0.54986, 0, 0, 0.72222],
            "9661": [0, 0.54986, 0, 0, 0.72222],
            "9664": [0.03517, 0.54986, 0, 0, 0.77778],
            "9674": [0.11111, 0.69224, 0, 0, 0.66667],
            "9733": [0.19444, 0.69224, 0, 0, 0.94445],
            "10003": [0, 0.69224, 0, 0, 0.83334],
            "10016": [0, 0.69224, 0, 0, 0.83334],
            "10731": [0.11111, 0.69224, 0, 0, 0.66667],
            "10846": [0.19444, 0.75583, 0, 0, 0.61111],
            "10877": [0.13667, 0.63667, 0, 0, 0.77778],
            "10878": [0.13667, 0.63667, 0, 0, 0.77778],
            "10885": [0.25583, 0.75583, 0, 0, 0.77778],
            "10886": [0.25583, 0.75583, 0, 0, 0.77778],
            "10887": [0.13597, 0.63597, 0, 0, 0.77778],
            "10888": [0.13597, 0.63597, 0, 0, 0.77778],
            "10889": [0.26167, 0.75726, 0, 0, 0.77778],
            "10890": [0.26167, 0.75726, 0, 0, 0.77778],
            "10891": [0.48256, 0.98256, 0, 0, 0.77778],
            "10892": [0.48256, 0.98256, 0, 0, 0.77778],
            "10901": [0.13667, 0.63667, 0, 0, 0.77778],
            "10902": [0.13667, 0.63667, 0, 0, 0.77778],
            "10933": [0.25142, 0.75726, 0, 0, 0.77778],
            "10934": [0.25142, 0.75726, 0, 0, 0.77778],
            "10935": [0.26167, 0.75726, 0, 0, 0.77778],
            "10936": [0.26167, 0.75726, 0, 0, 0.77778],
            "10937": [0.26167, 0.75726, 0, 0, 0.77778],
            "10938": [0.26167, 0.75726, 0, 0, 0.77778],
            "10949": [0.25583, 0.75583, 0, 0, 0.77778],
            "10950": [0.25583, 0.75583, 0, 0, 0.77778],
            "10955": [0.28481, 0.79383, 0, 0, 0.77778],
            "10956": [0.28481, 0.79383, 0, 0, 0.77778],
            "57350": [0.08167, 0.58167, 0, 0, 0.22222],
            "57351": [0.08167, 0.58167, 0, 0, 0.38889],
            "57352": [0.08167, 0.58167, 0, 0, 0.77778],
            "57353": [0, 0.43056, 0.04028, 0, 0.66667],
            "57356": [0.25142, 0.75726, 0, 0, 0.77778],
            "57357": [0.25142, 0.75726, 0, 0, 0.77778],
            "57358": [0.41951, 0.91951, 0, 0, 0.77778],
            "57359": [0.30274, 0.79383, 0, 0, 0.77778],
            "57360": [0.30274, 0.79383, 0, 0, 0.77778],
            "57361": [0.41951, 0.91951, 0, 0, 0.77778],
            "57366": [0.25142, 0.75726, 0, 0, 0.77778],
            "57367": [0.25142, 0.75726, 0, 0, 0.77778],
            "57368": [0.25142, 0.75726, 0, 0, 0.77778],
            "57369": [0.25142, 0.75726, 0, 0, 0.77778],
            "57370": [0.13597, 0.63597, 0, 0, 0.77778],
            "57371": [0.13597, 0.63597, 0, 0, 0.77778]
          },
          "Caligraphic-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68333, 0, 0.19445, 0.79847],
            "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
            "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
            "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
            "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
            "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
            "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
            "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
            "73": [0, 0.68333, 0.07382, 0, 0.54452],
            "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
            "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
            "76": [0, 0.68333, 0, 0.13889, 0.68972],
            "77": [0, 0.68333, 0, 0.13889, 1.2009],
            "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
            "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
            "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
            "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
            "82": [0, 0.68333, 0, 0.08334, 0.8475],
            "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
            "84": [0, 0.68333, 0.25417, 0, 0.54464],
            "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
            "86": [0, 0.68333, 0.08222, 0, 0.61278],
            "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
            "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
            "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
            "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Fraktur-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69141, 0, 0, 0.29574],
            "34": [0, 0.69141, 0, 0, 0.21471],
            "38": [0, 0.69141, 0, 0, 0.73786],
            "39": [0, 0.69141, 0, 0, 0.21201],
            "40": [0.24982, 0.74947, 0, 0, 0.38865],
            "41": [0.24982, 0.74947, 0, 0, 0.38865],
            "42": [0, 0.62119, 0, 0, 0.27764],
            "43": [0.08319, 0.58283, 0, 0, 0.75623],
            "44": [0, 0.10803, 0, 0, 0.27764],
            "45": [0.08319, 0.58283, 0, 0, 0.75623],
            "46": [0, 0.10803, 0, 0, 0.27764],
            "47": [0.24982, 0.74947, 0, 0, 0.50181],
            "48": [0, 0.47534, 0, 0, 0.50181],
            "49": [0, 0.47534, 0, 0, 0.50181],
            "50": [0, 0.47534, 0, 0, 0.50181],
            "51": [0.18906, 0.47534, 0, 0, 0.50181],
            "52": [0.18906, 0.47534, 0, 0, 0.50181],
            "53": [0.18906, 0.47534, 0, 0, 0.50181],
            "54": [0, 0.69141, 0, 0, 0.50181],
            "55": [0.18906, 0.47534, 0, 0, 0.50181],
            "56": [0, 0.69141, 0, 0, 0.50181],
            "57": [0.18906, 0.47534, 0, 0, 0.50181],
            "58": [0, 0.47534, 0, 0, 0.21606],
            "59": [0.12604, 0.47534, 0, 0, 0.21606],
            "61": [-0.13099, 0.36866, 0, 0, 0.75623],
            "63": [0, 0.69141, 0, 0, 0.36245],
            "65": [0, 0.69141, 0, 0, 0.7176],
            "66": [0, 0.69141, 0, 0, 0.88397],
            "67": [0, 0.69141, 0, 0, 0.61254],
            "68": [0, 0.69141, 0, 0, 0.83158],
            "69": [0, 0.69141, 0, 0, 0.66278],
            "70": [0.12604, 0.69141, 0, 0, 0.61119],
            "71": [0, 0.69141, 0, 0, 0.78539],
            "72": [0.06302, 0.69141, 0, 0, 0.7203],
            "73": [0, 0.69141, 0, 0, 0.55448],
            "74": [0.12604, 0.69141, 0, 0, 0.55231],
            "75": [0, 0.69141, 0, 0, 0.66845],
            "76": [0, 0.69141, 0, 0, 0.66602],
            "77": [0, 0.69141, 0, 0, 1.04953],
            "78": [0, 0.69141, 0, 0, 0.83212],
            "79": [0, 0.69141, 0, 0, 0.82699],
            "80": [0.18906, 0.69141, 0, 0, 0.82753],
            "81": [0.03781, 0.69141, 0, 0, 0.82699],
            "82": [0, 0.69141, 0, 0, 0.82807],
            "83": [0, 0.69141, 0, 0, 0.82861],
            "84": [0, 0.69141, 0, 0, 0.66899],
            "85": [0, 0.69141, 0, 0, 0.64576],
            "86": [0, 0.69141, 0, 0, 0.83131],
            "87": [0, 0.69141, 0, 0, 1.04602],
            "88": [0, 0.69141, 0, 0, 0.71922],
            "89": [0.18906, 0.69141, 0, 0, 0.83293],
            "90": [0.12604, 0.69141, 0, 0, 0.60201],
            "91": [0.24982, 0.74947, 0, 0, 0.27764],
            "93": [0.24982, 0.74947, 0, 0, 0.27764],
            "94": [0, 0.69141, 0, 0, 0.49965],
            "97": [0, 0.47534, 0, 0, 0.50046],
            "98": [0, 0.69141, 0, 0, 0.51315],
            "99": [0, 0.47534, 0, 0, 0.38946],
            "100": [0, 0.62119, 0, 0, 0.49857],
            "101": [0, 0.47534, 0, 0, 0.40053],
            "102": [0.18906, 0.69141, 0, 0, 0.32626],
            "103": [0.18906, 0.47534, 0, 0, 0.5037],
            "104": [0.18906, 0.69141, 0, 0, 0.52126],
            "105": [0, 0.69141, 0, 0, 0.27899],
            "106": [0, 0.69141, 0, 0, 0.28088],
            "107": [0, 0.69141, 0, 0, 0.38946],
            "108": [0, 0.69141, 0, 0, 0.27953],
            "109": [0, 0.47534, 0, 0, 0.76676],
            "110": [0, 0.47534, 0, 0, 0.52666],
            "111": [0, 0.47534, 0, 0, 0.48885],
            "112": [0.18906, 0.52396, 0, 0, 0.50046],
            "113": [0.18906, 0.47534, 0, 0, 0.48912],
            "114": [0, 0.47534, 0, 0, 0.38919],
            "115": [0, 0.47534, 0, 0, 0.44266],
            "116": [0, 0.62119, 0, 0, 0.33301],
            "117": [0, 0.47534, 0, 0, 0.5172],
            "118": [0, 0.52396, 0, 0, 0.5118],
            "119": [0, 0.52396, 0, 0, 0.77351],
            "120": [0.18906, 0.47534, 0, 0, 0.38865],
            "121": [0.18906, 0.47534, 0, 0, 0.49884],
            "122": [0.18906, 0.47534, 0, 0, 0.39054],
            "160": [0, 0, 0, 0, 0.25],
            "8216": [0, 0.69141, 0, 0, 0.21471],
            "8217": [0, 0.69141, 0, 0, 0.21471],
            "58112": [0, 0.62119, 0, 0, 0.49749],
            "58113": [0, 0.62119, 0, 0, 0.4983],
            "58114": [0.18906, 0.69141, 0, 0, 0.33328],
            "58115": [0.18906, 0.69141, 0, 0, 0.32923],
            "58116": [0.18906, 0.47534, 0, 0, 0.50343],
            "58117": [0, 0.69141, 0, 0, 0.33301],
            "58118": [0, 0.62119, 0, 0, 0.33409],
            "58119": [0, 0.47534, 0, 0, 0.50073]
          },
          "Main-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.35],
            "34": [0, 0.69444, 0, 0, 0.60278],
            "35": [0.19444, 0.69444, 0, 0, 0.95833],
            "36": [0.05556, 0.75, 0, 0, 0.575],
            "37": [0.05556, 0.75, 0, 0, 0.95833],
            "38": [0, 0.69444, 0, 0, 0.89444],
            "39": [0, 0.69444, 0, 0, 0.31944],
            "40": [0.25, 0.75, 0, 0, 0.44722],
            "41": [0.25, 0.75, 0, 0, 0.44722],
            "42": [0, 0.75, 0, 0, 0.575],
            "43": [0.13333, 0.63333, 0, 0, 0.89444],
            "44": [0.19444, 0.15556, 0, 0, 0.31944],
            "45": [0, 0.44444, 0, 0, 0.38333],
            "46": [0, 0.15556, 0, 0, 0.31944],
            "47": [0.25, 0.75, 0, 0, 0.575],
            "48": [0, 0.64444, 0, 0, 0.575],
            "49": [0, 0.64444, 0, 0, 0.575],
            "50": [0, 0.64444, 0, 0, 0.575],
            "51": [0, 0.64444, 0, 0, 0.575],
            "52": [0, 0.64444, 0, 0, 0.575],
            "53": [0, 0.64444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0, 0.64444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0, 0.64444, 0, 0, 0.575],
            "58": [0, 0.44444, 0, 0, 0.31944],
            "59": [0.19444, 0.44444, 0, 0, 0.31944],
            "60": [0.08556, 0.58556, 0, 0, 0.89444],
            "61": [-0.10889, 0.39111, 0, 0, 0.89444],
            "62": [0.08556, 0.58556, 0, 0, 0.89444],
            "63": [0, 0.69444, 0, 0, 0.54305],
            "64": [0, 0.69444, 0, 0, 0.89444],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0, 0, 0.81805],
            "67": [0, 0.68611, 0, 0, 0.83055],
            "68": [0, 0.68611, 0, 0, 0.88194],
            "69": [0, 0.68611, 0, 0, 0.75555],
            "70": [0, 0.68611, 0, 0, 0.72361],
            "71": [0, 0.68611, 0, 0, 0.90416],
            "72": [0, 0.68611, 0, 0, 0.9],
            "73": [0, 0.68611, 0, 0, 0.43611],
            "74": [0, 0.68611, 0, 0, 0.59444],
            "75": [0, 0.68611, 0, 0, 0.90138],
            "76": [0, 0.68611, 0, 0, 0.69166],
            "77": [0, 0.68611, 0, 0, 1.09166],
            "78": [0, 0.68611, 0, 0, 0.9],
            "79": [0, 0.68611, 0, 0, 0.86388],
            "80": [0, 0.68611, 0, 0, 0.78611],
            "81": [0.19444, 0.68611, 0, 0, 0.86388],
            "82": [0, 0.68611, 0, 0, 0.8625],
            "83": [0, 0.68611, 0, 0, 0.63889],
            "84": [0, 0.68611, 0, 0, 0.8],
            "85": [0, 0.68611, 0, 0, 0.88472],
            "86": [0, 0.68611, 0.01597, 0, 0.86944],
            "87": [0, 0.68611, 0.01597, 0, 1.18888],
            "88": [0, 0.68611, 0, 0, 0.86944],
            "89": [0, 0.68611, 0.02875, 0, 0.86944],
            "90": [0, 0.68611, 0, 0, 0.70277],
            "91": [0.25, 0.75, 0, 0, 0.31944],
            "92": [0.25, 0.75, 0, 0, 0.575],
            "93": [0.25, 0.75, 0, 0, 0.31944],
            "94": [0, 0.69444, 0, 0, 0.575],
            "95": [0.31, 0.13444, 0.03194, 0, 0.575],
            "97": [0, 0.44444, 0, 0, 0.55902],
            "98": [0, 0.69444, 0, 0, 0.63889],
            "99": [0, 0.44444, 0, 0, 0.51111],
            "100": [0, 0.69444, 0, 0, 0.63889],
            "101": [0, 0.44444, 0, 0, 0.52708],
            "102": [0, 0.69444, 0.10903, 0, 0.35139],
            "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
            "104": [0, 0.69444, 0, 0, 0.63889],
            "105": [0, 0.69444, 0, 0, 0.31944],
            "106": [0.19444, 0.69444, 0, 0, 0.35139],
            "107": [0, 0.69444, 0, 0, 0.60694],
            "108": [0, 0.69444, 0, 0, 0.31944],
            "109": [0, 0.44444, 0, 0, 0.95833],
            "110": [0, 0.44444, 0, 0, 0.63889],
            "111": [0, 0.44444, 0, 0, 0.575],
            "112": [0.19444, 0.44444, 0, 0, 0.63889],
            "113": [0.19444, 0.44444, 0, 0, 0.60694],
            "114": [0, 0.44444, 0, 0, 0.47361],
            "115": [0, 0.44444, 0, 0, 0.45361],
            "116": [0, 0.63492, 0, 0, 0.44722],
            "117": [0, 0.44444, 0, 0, 0.63889],
            "118": [0, 0.44444, 0.01597, 0, 0.60694],
            "119": [0, 0.44444, 0.01597, 0, 0.83055],
            "120": [0, 0.44444, 0, 0, 0.60694],
            "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
            "122": [0, 0.44444, 0, 0, 0.51111],
            "123": [0.25, 0.75, 0, 0, 0.575],
            "124": [0.25, 0.75, 0, 0, 0.31944],
            "125": [0.25, 0.75, 0, 0, 0.575],
            "126": [0.35, 0.34444, 0, 0, 0.575],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.86853],
            "168": [0, 0.69444, 0, 0, 0.575],
            "172": [0, 0.44444, 0, 0, 0.76666],
            "176": [0, 0.69444, 0, 0, 0.86944],
            "177": [0.13333, 0.63333, 0, 0, 0.89444],
            "184": [0.17014, 0, 0, 0, 0.51111],
            "198": [0, 0.68611, 0, 0, 1.04166],
            "215": [0.13333, 0.63333, 0, 0, 0.89444],
            "216": [0.04861, 0.73472, 0, 0, 0.89444],
            "223": [0, 0.69444, 0, 0, 0.59722],
            "230": [0, 0.44444, 0, 0, 0.83055],
            "247": [0.13333, 0.63333, 0, 0, 0.89444],
            "248": [0.09722, 0.54167, 0, 0, 0.575],
            "305": [0, 0.44444, 0, 0, 0.31944],
            "338": [0, 0.68611, 0, 0, 1.16944],
            "339": [0, 0.44444, 0, 0, 0.89444],
            "567": [0.19444, 0.44444, 0, 0, 0.35139],
            "710": [0, 0.69444, 0, 0, 0.575],
            "711": [0, 0.63194, 0, 0, 0.575],
            "713": [0, 0.59611, 0, 0, 0.575],
            "714": [0, 0.69444, 0, 0, 0.575],
            "715": [0, 0.69444, 0, 0, 0.575],
            "728": [0, 0.69444, 0, 0, 0.575],
            "729": [0, 0.69444, 0, 0, 0.31944],
            "730": [0, 0.69444, 0, 0, 0.86944],
            "732": [0, 0.69444, 0, 0, 0.575],
            "733": [0, 0.69444, 0, 0, 0.575],
            "915": [0, 0.68611, 0, 0, 0.69166],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0, 0, 0.89444],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0, 0, 0.76666],
            "928": [0, 0.68611, 0, 0, 0.9],
            "931": [0, 0.68611, 0, 0, 0.83055],
            "933": [0, 0.68611, 0, 0, 0.89444],
            "934": [0, 0.68611, 0, 0, 0.83055],
            "936": [0, 0.68611, 0, 0, 0.89444],
            "937": [0, 0.68611, 0, 0, 0.83055],
            "8211": [0, 0.44444, 0.03194, 0, 0.575],
            "8212": [0, 0.44444, 0.03194, 0, 1.14999],
            "8216": [0, 0.69444, 0, 0, 0.31944],
            "8217": [0, 0.69444, 0, 0, 0.31944],
            "8220": [0, 0.69444, 0, 0, 0.60278],
            "8221": [0, 0.69444, 0, 0, 0.60278],
            "8224": [0.19444, 0.69444, 0, 0, 0.51111],
            "8225": [0.19444, 0.69444, 0, 0, 0.51111],
            "8242": [0, 0.55556, 0, 0, 0.34444],
            "8407": [0, 0.72444, 0.15486, 0, 0.575],
            "8463": [0, 0.69444, 0, 0, 0.66759],
            "8465": [0, 0.69444, 0, 0, 0.83055],
            "8467": [0, 0.69444, 0, 0, 0.47361],
            "8472": [0.19444, 0.44444, 0, 0, 0.74027],
            "8476": [0, 0.69444, 0, 0, 0.83055],
            "8501": [0, 0.69444, 0, 0, 0.70277],
            "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8593": [0.19444, 0.69444, 0, 0, 0.575],
            "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8595": [0.19444, 0.69444, 0, 0, 0.575],
            "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8597": [0.25, 0.75, 0, 0, 0.575],
            "8598": [0.19444, 0.69444, 0, 0, 1.14999],
            "8599": [0.19444, 0.69444, 0, 0, 1.14999],
            "8600": [0.19444, 0.69444, 0, 0, 1.14999],
            "8601": [0.19444, 0.69444, 0, 0, 1.14999],
            "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8657": [0.19444, 0.69444, 0, 0, 0.70277],
            "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8659": [0.19444, 0.69444, 0, 0, 0.70277],
            "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8661": [0.25, 0.75, 0, 0, 0.70277],
            "8704": [0, 0.69444, 0, 0, 0.63889],
            "8706": [0, 0.69444, 0.06389, 0, 0.62847],
            "8707": [0, 0.69444, 0, 0, 0.63889],
            "8709": [0.05556, 0.75, 0, 0, 0.575],
            "8711": [0, 0.68611, 0, 0, 0.95833],
            "8712": [0.08556, 0.58556, 0, 0, 0.76666],
            "8715": [0.08556, 0.58556, 0, 0, 0.76666],
            "8722": [0.13333, 0.63333, 0, 0, 0.89444],
            "8723": [0.13333, 0.63333, 0, 0, 0.89444],
            "8725": [0.25, 0.75, 0, 0, 0.575],
            "8726": [0.25, 0.75, 0, 0, 0.575],
            "8727": [-0.02778, 0.47222, 0, 0, 0.575],
            "8728": [-0.02639, 0.47361, 0, 0, 0.575],
            "8729": [-0.02639, 0.47361, 0, 0, 0.575],
            "8730": [0.18, 0.82, 0, 0, 0.95833],
            "8733": [0, 0.44444, 0, 0, 0.89444],
            "8734": [0, 0.44444, 0, 0, 1.14999],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.31944],
            "8741": [0.25, 0.75, 0, 0, 0.575],
            "8743": [0, 0.55556, 0, 0, 0.76666],
            "8744": [0, 0.55556, 0, 0, 0.76666],
            "8745": [0, 0.55556, 0, 0, 0.76666],
            "8746": [0, 0.55556, 0, 0, 0.76666],
            "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
            "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
            "8768": [0.19444, 0.69444, 0, 0, 0.31944],
            "8771": [222e-5, 0.50222, 0, 0, 0.89444],
            "8773": [0.027, 0.638, 0, 0, 0.894],
            "8776": [0.02444, 0.52444, 0, 0, 0.89444],
            "8781": [222e-5, 0.50222, 0, 0, 0.89444],
            "8801": [222e-5, 0.50222, 0, 0, 0.89444],
            "8804": [0.19667, 0.69667, 0, 0, 0.89444],
            "8805": [0.19667, 0.69667, 0, 0, 0.89444],
            "8810": [0.08556, 0.58556, 0, 0, 1.14999],
            "8811": [0.08556, 0.58556, 0, 0, 1.14999],
            "8826": [0.08556, 0.58556, 0, 0, 0.89444],
            "8827": [0.08556, 0.58556, 0, 0, 0.89444],
            "8834": [0.08556, 0.58556, 0, 0, 0.89444],
            "8835": [0.08556, 0.58556, 0, 0, 0.89444],
            "8838": [0.19667, 0.69667, 0, 0, 0.89444],
            "8839": [0.19667, 0.69667, 0, 0, 0.89444],
            "8846": [0, 0.55556, 0, 0, 0.76666],
            "8849": [0.19667, 0.69667, 0, 0, 0.89444],
            "8850": [0.19667, 0.69667, 0, 0, 0.89444],
            "8851": [0, 0.55556, 0, 0, 0.76666],
            "8852": [0, 0.55556, 0, 0, 0.76666],
            "8853": [0.13333, 0.63333, 0, 0, 0.89444],
            "8854": [0.13333, 0.63333, 0, 0, 0.89444],
            "8855": [0.13333, 0.63333, 0, 0, 0.89444],
            "8856": [0.13333, 0.63333, 0, 0, 0.89444],
            "8857": [0.13333, 0.63333, 0, 0, 0.89444],
            "8866": [0, 0.69444, 0, 0, 0.70277],
            "8867": [0, 0.69444, 0, 0, 0.70277],
            "8868": [0, 0.69444, 0, 0, 0.89444],
            "8869": [0, 0.69444, 0, 0, 0.89444],
            "8900": [-0.02639, 0.47361, 0, 0, 0.575],
            "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
            "8902": [-0.02778, 0.47222, 0, 0, 0.575],
            "8968": [0.25, 0.75, 0, 0, 0.51111],
            "8969": [0.25, 0.75, 0, 0, 0.51111],
            "8970": [0.25, 0.75, 0, 0, 0.51111],
            "8971": [0.25, 0.75, 0, 0, 0.51111],
            "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
            "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
            "9651": [0.19444, 0.69444, 0, 0, 1.02222],
            "9657": [-0.02778, 0.47222, 0, 0, 0.575],
            "9661": [0.19444, 0.69444, 0, 0, 1.02222],
            "9667": [-0.02778, 0.47222, 0, 0, 0.575],
            "9711": [0.19444, 0.69444, 0, 0, 1.14999],
            "9824": [0.12963, 0.69444, 0, 0, 0.89444],
            "9825": [0.12963, 0.69444, 0, 0, 0.89444],
            "9826": [0.12963, 0.69444, 0, 0, 0.89444],
            "9827": [0.12963, 0.69444, 0, 0, 0.89444],
            "9837": [0, 0.75, 0, 0, 0.44722],
            "9838": [0.19444, 0.69444, 0, 0, 0.44722],
            "9839": [0.19444, 0.69444, 0, 0, 0.44722],
            "10216": [0.25, 0.75, 0, 0, 0.44722],
            "10217": [0.25, 0.75, 0, 0, 0.44722],
            "10815": [0, 0.68611, 0, 0, 0.9],
            "10927": [0.19667, 0.69667, 0, 0, 0.89444],
            "10928": [0.19667, 0.69667, 0, 0, 0.89444],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Main-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.11417, 0, 0.38611],
            "34": [0, 0.69444, 0.07939, 0, 0.62055],
            "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
            "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
            "38": [0, 0.69444, 0.08528, 0, 0.88555],
            "39": [0, 0.69444, 0.12945, 0, 0.35555],
            "40": [0.25, 0.75, 0.15806, 0, 0.47333],
            "41": [0.25, 0.75, 0.03306, 0, 0.47333],
            "42": [0, 0.75, 0.14333, 0, 0.59111],
            "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
            "44": [0.19444, 0.14722, 0, 0, 0.35555],
            "45": [0, 0.44444, 0.02611, 0, 0.41444],
            "46": [0, 0.14722, 0, 0, 0.35555],
            "47": [0.25, 0.75, 0.15806, 0, 0.59111],
            "48": [0, 0.64444, 0.13167, 0, 0.59111],
            "49": [0, 0.64444, 0.13167, 0, 0.59111],
            "50": [0, 0.64444, 0.13167, 0, 0.59111],
            "51": [0, 0.64444, 0.13167, 0, 0.59111],
            "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "53": [0, 0.64444, 0.13167, 0, 0.59111],
            "54": [0, 0.64444, 0.13167, 0, 0.59111],
            "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "56": [0, 0.64444, 0.13167, 0, 0.59111],
            "57": [0, 0.64444, 0.13167, 0, 0.59111],
            "58": [0, 0.44444, 0.06695, 0, 0.35555],
            "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
            "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
            "63": [0, 0.69444, 0.11472, 0, 0.59111],
            "64": [0, 0.69444, 0.09208, 0, 0.88555],
            "65": [0, 0.68611, 0, 0, 0.86555],
            "66": [0, 0.68611, 0.0992, 0, 0.81666],
            "67": [0, 0.68611, 0.14208, 0, 0.82666],
            "68": [0, 0.68611, 0.09062, 0, 0.87555],
            "69": [0, 0.68611, 0.11431, 0, 0.75666],
            "70": [0, 0.68611, 0.12903, 0, 0.72722],
            "71": [0, 0.68611, 0.07347, 0, 0.89527],
            "72": [0, 0.68611, 0.17208, 0, 0.8961],
            "73": [0, 0.68611, 0.15681, 0, 0.47166],
            "74": [0, 0.68611, 0.145, 0, 0.61055],
            "75": [0, 0.68611, 0.14208, 0, 0.89499],
            "76": [0, 0.68611, 0, 0, 0.69777],
            "77": [0, 0.68611, 0.17208, 0, 1.07277],
            "78": [0, 0.68611, 0.17208, 0, 0.8961],
            "79": [0, 0.68611, 0.09062, 0, 0.85499],
            "80": [0, 0.68611, 0.0992, 0, 0.78721],
            "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
            "82": [0, 0.68611, 0.02559, 0, 0.85944],
            "83": [0, 0.68611, 0.11264, 0, 0.64999],
            "84": [0, 0.68611, 0.12903, 0, 0.7961],
            "85": [0, 0.68611, 0.17208, 0, 0.88083],
            "86": [0, 0.68611, 0.18625, 0, 0.86555],
            "87": [0, 0.68611, 0.18625, 0, 1.15999],
            "88": [0, 0.68611, 0.15681, 0, 0.86555],
            "89": [0, 0.68611, 0.19803, 0, 0.86555],
            "90": [0, 0.68611, 0.14208, 0, 0.70888],
            "91": [0.25, 0.75, 0.1875, 0, 0.35611],
            "93": [0.25, 0.75, 0.09972, 0, 0.35611],
            "94": [0, 0.69444, 0.06709, 0, 0.59111],
            "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
            "97": [0, 0.44444, 0.09426, 0, 0.59111],
            "98": [0, 0.69444, 0.07861, 0, 0.53222],
            "99": [0, 0.44444, 0.05222, 0, 0.53222],
            "100": [0, 0.69444, 0.10861, 0, 0.59111],
            "101": [0, 0.44444, 0.085, 0, 0.53222],
            "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
            "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "104": [0, 0.69444, 0.09426, 0, 0.59111],
            "105": [0, 0.69326, 0.11387, 0, 0.35555],
            "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
            "107": [0, 0.69444, 0.11111, 0, 0.53222],
            "108": [0, 0.69444, 0.10861, 0, 0.29666],
            "109": [0, 0.44444, 0.09426, 0, 0.94444],
            "110": [0, 0.44444, 0.09426, 0, 0.64999],
            "111": [0, 0.44444, 0.07861, 0, 0.59111],
            "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
            "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "114": [0, 0.44444, 0.11111, 0, 0.50167],
            "115": [0, 0.44444, 0.08167, 0, 0.48694],
            "116": [0, 0.63492, 0.09639, 0, 0.385],
            "117": [0, 0.44444, 0.09426, 0, 0.62055],
            "118": [0, 0.44444, 0.11111, 0, 0.53222],
            "119": [0, 0.44444, 0.11111, 0, 0.76777],
            "120": [0, 0.44444, 0.12583, 0, 0.56055],
            "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
            "122": [0, 0.44444, 0.13889, 0, 0.49055],
            "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0.11473, 0, 0.59111],
            "176": [0, 0.69444, 0, 0, 0.94888],
            "184": [0.17014, 0, 0, 0, 0.53222],
            "198": [0, 0.68611, 0.11431, 0, 1.02277],
            "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
            "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
            "230": [0, 0.44444, 0.085, 0, 0.82666],
            "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
            "305": [0, 0.44444, 0.09426, 0, 0.35555],
            "338": [0, 0.68611, 0.11431, 0, 1.14054],
            "339": [0, 0.44444, 0.085, 0, 0.82666],
            "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
            "710": [0, 0.69444, 0.06709, 0, 0.59111],
            "711": [0, 0.63194, 0.08271, 0, 0.59111],
            "713": [0, 0.59444, 0.10444, 0, 0.59111],
            "714": [0, 0.69444, 0.08528, 0, 0.59111],
            "715": [0, 0.69444, 0, 0, 0.59111],
            "728": [0, 0.69444, 0.10333, 0, 0.59111],
            "729": [0, 0.69444, 0.12945, 0, 0.35555],
            "730": [0, 0.69444, 0, 0, 0.94888],
            "732": [0, 0.69444, 0.11472, 0, 0.59111],
            "733": [0, 0.69444, 0.11472, 0, 0.59111],
            "915": [0, 0.68611, 0.12903, 0, 0.69777],
            "916": [0, 0.68611, 0, 0, 0.94444],
            "920": [0, 0.68611, 0.09062, 0, 0.88555],
            "923": [0, 0.68611, 0, 0, 0.80666],
            "926": [0, 0.68611, 0.15092, 0, 0.76777],
            "928": [0, 0.68611, 0.17208, 0, 0.8961],
            "931": [0, 0.68611, 0.11431, 0, 0.82666],
            "933": [0, 0.68611, 0.10778, 0, 0.88555],
            "934": [0, 0.68611, 0.05632, 0, 0.82666],
            "936": [0, 0.68611, 0.10778, 0, 0.88555],
            "937": [0, 0.68611, 0.0992, 0, 0.82666],
            "8211": [0, 0.44444, 0.09811, 0, 0.59111],
            "8212": [0, 0.44444, 0.09811, 0, 1.18221],
            "8216": [0, 0.69444, 0.12945, 0, 0.35555],
            "8217": [0, 0.69444, 0.12945, 0, 0.35555],
            "8220": [0, 0.69444, 0.16772, 0, 0.62055],
            "8221": [0, 0.69444, 0.07939, 0, 0.62055]
          },
          "Main-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.12417, 0, 0.30667],
            "34": [0, 0.69444, 0.06961, 0, 0.51444],
            "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
            "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
            "38": [0, 0.69444, 0.09694, 0, 0.76666],
            "39": [0, 0.69444, 0.12417, 0, 0.30667],
            "40": [0.25, 0.75, 0.16194, 0, 0.40889],
            "41": [0.25, 0.75, 0.03694, 0, 0.40889],
            "42": [0, 0.75, 0.14917, 0, 0.51111],
            "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
            "44": [0.19444, 0.10556, 0, 0, 0.30667],
            "45": [0, 0.43056, 0.02826, 0, 0.35778],
            "46": [0, 0.10556, 0, 0, 0.30667],
            "47": [0.25, 0.75, 0.16194, 0, 0.51111],
            "48": [0, 0.64444, 0.13556, 0, 0.51111],
            "49": [0, 0.64444, 0.13556, 0, 0.51111],
            "50": [0, 0.64444, 0.13556, 0, 0.51111],
            "51": [0, 0.64444, 0.13556, 0, 0.51111],
            "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "53": [0, 0.64444, 0.13556, 0, 0.51111],
            "54": [0, 0.64444, 0.13556, 0, 0.51111],
            "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "56": [0, 0.64444, 0.13556, 0, 0.51111],
            "57": [0, 0.64444, 0.13556, 0, 0.51111],
            "58": [0, 0.43056, 0.0582, 0, 0.30667],
            "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
            "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
            "63": [0, 0.69444, 0.1225, 0, 0.51111],
            "64": [0, 0.69444, 0.09597, 0, 0.76666],
            "65": [0, 0.68333, 0, 0, 0.74333],
            "66": [0, 0.68333, 0.10257, 0, 0.70389],
            "67": [0, 0.68333, 0.14528, 0, 0.71555],
            "68": [0, 0.68333, 0.09403, 0, 0.755],
            "69": [0, 0.68333, 0.12028, 0, 0.67833],
            "70": [0, 0.68333, 0.13305, 0, 0.65277],
            "71": [0, 0.68333, 0.08722, 0, 0.77361],
            "72": [0, 0.68333, 0.16389, 0, 0.74333],
            "73": [0, 0.68333, 0.15806, 0, 0.38555],
            "74": [0, 0.68333, 0.14028, 0, 0.525],
            "75": [0, 0.68333, 0.14528, 0, 0.76888],
            "76": [0, 0.68333, 0, 0, 0.62722],
            "77": [0, 0.68333, 0.16389, 0, 0.89666],
            "78": [0, 0.68333, 0.16389, 0, 0.74333],
            "79": [0, 0.68333, 0.09403, 0, 0.76666],
            "80": [0, 0.68333, 0.10257, 0, 0.67833],
            "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
            "82": [0, 0.68333, 0.03868, 0, 0.72944],
            "83": [0, 0.68333, 0.11972, 0, 0.56222],
            "84": [0, 0.68333, 0.13305, 0, 0.71555],
            "85": [0, 0.68333, 0.16389, 0, 0.74333],
            "86": [0, 0.68333, 0.18361, 0, 0.74333],
            "87": [0, 0.68333, 0.18361, 0, 0.99888],
            "88": [0, 0.68333, 0.15806, 0, 0.74333],
            "89": [0, 0.68333, 0.19383, 0, 0.74333],
            "90": [0, 0.68333, 0.14528, 0, 0.61333],
            "91": [0.25, 0.75, 0.1875, 0, 0.30667],
            "93": [0.25, 0.75, 0.10528, 0, 0.30667],
            "94": [0, 0.69444, 0.06646, 0, 0.51111],
            "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
            "97": [0, 0.43056, 0.07671, 0, 0.51111],
            "98": [0, 0.69444, 0.06312, 0, 0.46],
            "99": [0, 0.43056, 0.05653, 0, 0.46],
            "100": [0, 0.69444, 0.10333, 0, 0.51111],
            "101": [0, 0.43056, 0.07514, 0, 0.46],
            "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
            "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "104": [0, 0.69444, 0.07671, 0, 0.51111],
            "105": [0, 0.65536, 0.1019, 0, 0.30667],
            "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
            "107": [0, 0.69444, 0.10764, 0, 0.46],
            "108": [0, 0.69444, 0.10333, 0, 0.25555],
            "109": [0, 0.43056, 0.07671, 0, 0.81777],
            "110": [0, 0.43056, 0.07671, 0, 0.56222],
            "111": [0, 0.43056, 0.06312, 0, 0.51111],
            "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
            "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "114": [0, 0.43056, 0.10764, 0, 0.42166],
            "115": [0, 0.43056, 0.08208, 0, 0.40889],
            "116": [0, 0.61508, 0.09486, 0, 0.33222],
            "117": [0, 0.43056, 0.07671, 0, 0.53666],
            "118": [0, 0.43056, 0.10764, 0, 0.46],
            "119": [0, 0.43056, 0.10764, 0, 0.66444],
            "120": [0, 0.43056, 0.12042, 0, 0.46389],
            "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
            "122": [0, 0.43056, 0.12292, 0, 0.40889],
            "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.66786, 0.10474, 0, 0.51111],
            "176": [0, 0.69444, 0, 0, 0.83129],
            "184": [0.17014, 0, 0, 0, 0.46],
            "198": [0, 0.68333, 0.12028, 0, 0.88277],
            "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
            "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
            "230": [0, 0.43056, 0.07514, 0, 0.71555],
            "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
            "338": [0, 0.68333, 0.12028, 0, 0.98499],
            "339": [0, 0.43056, 0.07514, 0, 0.71555],
            "710": [0, 0.69444, 0.06646, 0, 0.51111],
            "711": [0, 0.62847, 0.08295, 0, 0.51111],
            "713": [0, 0.56167, 0.10333, 0, 0.51111],
            "714": [0, 0.69444, 0.09694, 0, 0.51111],
            "715": [0, 0.69444, 0, 0, 0.51111],
            "728": [0, 0.69444, 0.10806, 0, 0.51111],
            "729": [0, 0.66786, 0.11752, 0, 0.30667],
            "730": [0, 0.69444, 0, 0, 0.83129],
            "732": [0, 0.66786, 0.11585, 0, 0.51111],
            "733": [0, 0.69444, 0.1225, 0, 0.51111],
            "915": [0, 0.68333, 0.13305, 0, 0.62722],
            "916": [0, 0.68333, 0, 0, 0.81777],
            "920": [0, 0.68333, 0.09403, 0, 0.76666],
            "923": [0, 0.68333, 0, 0, 0.69222],
            "926": [0, 0.68333, 0.15294, 0, 0.66444],
            "928": [0, 0.68333, 0.16389, 0, 0.74333],
            "931": [0, 0.68333, 0.12028, 0, 0.71555],
            "933": [0, 0.68333, 0.11111, 0, 0.76666],
            "934": [0, 0.68333, 0.05986, 0, 0.71555],
            "936": [0, 0.68333, 0.11111, 0, 0.76666],
            "937": [0, 0.68333, 0.10257, 0, 0.71555],
            "8211": [0, 0.43056, 0.09208, 0, 0.51111],
            "8212": [0, 0.43056, 0.09208, 0, 1.02222],
            "8216": [0, 0.69444, 0.12417, 0, 0.30667],
            "8217": [0, 0.69444, 0.12417, 0, 0.30667],
            "8220": [0, 0.69444, 0.1685, 0, 0.51444],
            "8221": [0, 0.69444, 0.06961, 0, 0.51444],
            "8463": [0, 0.68889, 0, 0, 0.54028]
          },
          "Main-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.27778],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.77778],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.19444, 0.10556, 0, 0, 0.27778],
            "45": [0, 0.43056, 0, 0, 0.33333],
            "46": [0, 0.10556, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.64444, 0, 0, 0.5],
            "49": [0, 0.64444, 0, 0, 0.5],
            "50": [0, 0.64444, 0, 0, 0.5],
            "51": [0, 0.64444, 0, 0, 0.5],
            "52": [0, 0.64444, 0, 0, 0.5],
            "53": [0, 0.64444, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0, 0.64444, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0, 0.64444, 0, 0, 0.5],
            "58": [0, 0.43056, 0, 0, 0.27778],
            "59": [0.19444, 0.43056, 0, 0, 0.27778],
            "60": [0.0391, 0.5391, 0, 0, 0.77778],
            "61": [-0.13313, 0.36687, 0, 0, 0.77778],
            "62": [0.0391, 0.5391, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.77778],
            "65": [0, 0.68333, 0, 0, 0.75],
            "66": [0, 0.68333, 0, 0, 0.70834],
            "67": [0, 0.68333, 0, 0, 0.72222],
            "68": [0, 0.68333, 0, 0, 0.76389],
            "69": [0, 0.68333, 0, 0, 0.68056],
            "70": [0, 0.68333, 0, 0, 0.65278],
            "71": [0, 0.68333, 0, 0, 0.78472],
            "72": [0, 0.68333, 0, 0, 0.75],
            "73": [0, 0.68333, 0, 0, 0.36111],
            "74": [0, 0.68333, 0, 0, 0.51389],
            "75": [0, 0.68333, 0, 0, 0.77778],
            "76": [0, 0.68333, 0, 0, 0.625],
            "77": [0, 0.68333, 0, 0, 0.91667],
            "78": [0, 0.68333, 0, 0, 0.75],
            "79": [0, 0.68333, 0, 0, 0.77778],
            "80": [0, 0.68333, 0, 0, 0.68056],
            "81": [0.19444, 0.68333, 0, 0, 0.77778],
            "82": [0, 0.68333, 0, 0, 0.73611],
            "83": [0, 0.68333, 0, 0, 0.55556],
            "84": [0, 0.68333, 0, 0, 0.72222],
            "85": [0, 0.68333, 0, 0, 0.75],
            "86": [0, 0.68333, 0.01389, 0, 0.75],
            "87": [0, 0.68333, 0.01389, 0, 1.02778],
            "88": [0, 0.68333, 0, 0, 0.75],
            "89": [0, 0.68333, 0.025, 0, 0.75],
            "90": [0, 0.68333, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.27778],
            "92": [0.25, 0.75, 0, 0, 0.5],
            "93": [0.25, 0.75, 0, 0, 0.27778],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.31, 0.12056, 0.02778, 0, 0.5],
            "97": [0, 0.43056, 0, 0, 0.5],
            "98": [0, 0.69444, 0, 0, 0.55556],
            "99": [0, 0.43056, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.55556],
            "101": [0, 0.43056, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.07778, 0, 0.30556],
            "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.55556],
            "105": [0, 0.66786, 0, 0, 0.27778],
            "106": [0.19444, 0.66786, 0, 0, 0.30556],
            "107": [0, 0.69444, 0, 0, 0.52778],
            "108": [0, 0.69444, 0, 0, 0.27778],
            "109": [0, 0.43056, 0, 0, 0.83334],
            "110": [0, 0.43056, 0, 0, 0.55556],
            "111": [0, 0.43056, 0, 0, 0.5],
            "112": [0.19444, 0.43056, 0, 0, 0.55556],
            "113": [0.19444, 0.43056, 0, 0, 0.52778],
            "114": [0, 0.43056, 0, 0, 0.39167],
            "115": [0, 0.43056, 0, 0, 0.39445],
            "116": [0, 0.61508, 0, 0, 0.38889],
            "117": [0, 0.43056, 0, 0, 0.55556],
            "118": [0, 0.43056, 0.01389, 0, 0.52778],
            "119": [0, 0.43056, 0.01389, 0, 0.72222],
            "120": [0, 0.43056, 0, 0, 0.52778],
            "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
            "122": [0, 0.43056, 0, 0, 0.44445],
            "123": [0.25, 0.75, 0, 0, 0.5],
            "124": [0.25, 0.75, 0, 0, 0.27778],
            "125": [0.25, 0.75, 0, 0, 0.5],
            "126": [0.35, 0.31786, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.76909],
            "167": [0.19444, 0.69444, 0, 0, 0.44445],
            "168": [0, 0.66786, 0, 0, 0.5],
            "172": [0, 0.43056, 0, 0, 0.66667],
            "176": [0, 0.69444, 0, 0, 0.75],
            "177": [0.08333, 0.58333, 0, 0, 0.77778],
            "182": [0.19444, 0.69444, 0, 0, 0.61111],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "198": [0, 0.68333, 0, 0, 0.90278],
            "215": [0.08333, 0.58333, 0, 0, 0.77778],
            "216": [0.04861, 0.73194, 0, 0, 0.77778],
            "223": [0, 0.69444, 0, 0, 0.5],
            "230": [0, 0.43056, 0, 0, 0.72222],
            "247": [0.08333, 0.58333, 0, 0, 0.77778],
            "248": [0.09722, 0.52778, 0, 0, 0.5],
            "305": [0, 0.43056, 0, 0, 0.27778],
            "338": [0, 0.68333, 0, 0, 1.01389],
            "339": [0, 0.43056, 0, 0, 0.77778],
            "567": [0.19444, 0.43056, 0, 0, 0.30556],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.62847, 0, 0, 0.5],
            "713": [0, 0.56778, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.66786, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.75],
            "732": [0, 0.66786, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.68333, 0, 0, 0.625],
            "916": [0, 0.68333, 0, 0, 0.83334],
            "920": [0, 0.68333, 0, 0, 0.77778],
            "923": [0, 0.68333, 0, 0, 0.69445],
            "926": [0, 0.68333, 0, 0, 0.66667],
            "928": [0, 0.68333, 0, 0, 0.75],
            "931": [0, 0.68333, 0, 0, 0.72222],
            "933": [0, 0.68333, 0, 0, 0.77778],
            "934": [0, 0.68333, 0, 0, 0.72222],
            "936": [0, 0.68333, 0, 0, 0.77778],
            "937": [0, 0.68333, 0, 0, 0.72222],
            "8211": [0, 0.43056, 0.02778, 0, 0.5],
            "8212": [0, 0.43056, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5],
            "8224": [0.19444, 0.69444, 0, 0, 0.44445],
            "8225": [0.19444, 0.69444, 0, 0, 0.44445],
            "8230": [0, 0.123, 0, 0, 1.172],
            "8242": [0, 0.55556, 0, 0, 0.275],
            "8407": [0, 0.71444, 0.15382, 0, 0.5],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8465": [0, 0.69444, 0, 0, 0.72222],
            "8467": [0, 0.69444, 0, 0.11111, 0.41667],
            "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
            "8476": [0, 0.69444, 0, 0, 0.72222],
            "8501": [0, 0.69444, 0, 0, 0.61111],
            "8592": [-0.13313, 0.36687, 0, 0, 1],
            "8593": [0.19444, 0.69444, 0, 0, 0.5],
            "8594": [-0.13313, 0.36687, 0, 0, 1],
            "8595": [0.19444, 0.69444, 0, 0, 0.5],
            "8596": [-0.13313, 0.36687, 0, 0, 1],
            "8597": [0.25, 0.75, 0, 0, 0.5],
            "8598": [0.19444, 0.69444, 0, 0, 1],
            "8599": [0.19444, 0.69444, 0, 0, 1],
            "8600": [0.19444, 0.69444, 0, 0, 1],
            "8601": [0.19444, 0.69444, 0, 0, 1],
            "8614": [0.011, 0.511, 0, 0, 1],
            "8617": [0.011, 0.511, 0, 0, 1.126],
            "8618": [0.011, 0.511, 0, 0, 1.126],
            "8636": [-0.13313, 0.36687, 0, 0, 1],
            "8637": [-0.13313, 0.36687, 0, 0, 1],
            "8640": [-0.13313, 0.36687, 0, 0, 1],
            "8641": [-0.13313, 0.36687, 0, 0, 1],
            "8652": [0.011, 0.671, 0, 0, 1],
            "8656": [-0.13313, 0.36687, 0, 0, 1],
            "8657": [0.19444, 0.69444, 0, 0, 0.61111],
            "8658": [-0.13313, 0.36687, 0, 0, 1],
            "8659": [0.19444, 0.69444, 0, 0, 0.61111],
            "8660": [-0.13313, 0.36687, 0, 0, 1],
            "8661": [0.25, 0.75, 0, 0, 0.61111],
            "8704": [0, 0.69444, 0, 0, 0.55556],
            "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
            "8707": [0, 0.69444, 0, 0, 0.55556],
            "8709": [0.05556, 0.75, 0, 0, 0.5],
            "8711": [0, 0.68333, 0, 0, 0.83334],
            "8712": [0.0391, 0.5391, 0, 0, 0.66667],
            "8715": [0.0391, 0.5391, 0, 0, 0.66667],
            "8722": [0.08333, 0.58333, 0, 0, 0.77778],
            "8723": [0.08333, 0.58333, 0, 0, 0.77778],
            "8725": [0.25, 0.75, 0, 0, 0.5],
            "8726": [0.25, 0.75, 0, 0, 0.5],
            "8727": [-0.03472, 0.46528, 0, 0, 0.5],
            "8728": [-0.05555, 0.44445, 0, 0, 0.5],
            "8729": [-0.05555, 0.44445, 0, 0, 0.5],
            "8730": [0.2, 0.8, 0, 0, 0.83334],
            "8733": [0, 0.43056, 0, 0, 0.77778],
            "8734": [0, 0.43056, 0, 0, 1],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.27778],
            "8741": [0.25, 0.75, 0, 0, 0.5],
            "8743": [0, 0.55556, 0, 0, 0.66667],
            "8744": [0, 0.55556, 0, 0, 0.66667],
            "8745": [0, 0.55556, 0, 0, 0.66667],
            "8746": [0, 0.55556, 0, 0, 0.66667],
            "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8768": [0.19444, 0.69444, 0, 0, 0.27778],
            "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8773": [-0.022, 0.589, 0, 0, 0.778],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8784": [-0.133, 0.673, 0, 0, 0.778],
            "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8804": [0.13597, 0.63597, 0, 0, 0.77778],
            "8805": [0.13597, 0.63597, 0, 0, 0.77778],
            "8810": [0.0391, 0.5391, 0, 0, 1],
            "8811": [0.0391, 0.5391, 0, 0, 1],
            "8826": [0.0391, 0.5391, 0, 0, 0.77778],
            "8827": [0.0391, 0.5391, 0, 0, 0.77778],
            "8834": [0.0391, 0.5391, 0, 0, 0.77778],
            "8835": [0.0391, 0.5391, 0, 0, 0.77778],
            "8838": [0.13597, 0.63597, 0, 0, 0.77778],
            "8839": [0.13597, 0.63597, 0, 0, 0.77778],
            "8846": [0, 0.55556, 0, 0, 0.66667],
            "8849": [0.13597, 0.63597, 0, 0, 0.77778],
            "8850": [0.13597, 0.63597, 0, 0, 0.77778],
            "8851": [0, 0.55556, 0, 0, 0.66667],
            "8852": [0, 0.55556, 0, 0, 0.66667],
            "8853": [0.08333, 0.58333, 0, 0, 0.77778],
            "8854": [0.08333, 0.58333, 0, 0, 0.77778],
            "8855": [0.08333, 0.58333, 0, 0, 0.77778],
            "8856": [0.08333, 0.58333, 0, 0, 0.77778],
            "8857": [0.08333, 0.58333, 0, 0, 0.77778],
            "8866": [0, 0.69444, 0, 0, 0.61111],
            "8867": [0, 0.69444, 0, 0, 0.61111],
            "8868": [0, 0.69444, 0, 0, 0.77778],
            "8869": [0, 0.69444, 0, 0, 0.77778],
            "8872": [0.249, 0.75, 0, 0, 0.867],
            "8900": [-0.05555, 0.44445, 0, 0, 0.5],
            "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
            "8902": [-0.03472, 0.46528, 0, 0, 0.5],
            "8904": [5e-3, 0.505, 0, 0, 0.9],
            "8942": [0.03, 0.903, 0, 0, 0.278],
            "8943": [-0.19, 0.313, 0, 0, 1.172],
            "8945": [-0.1, 0.823, 0, 0, 1.282],
            "8968": [0.25, 0.75, 0, 0, 0.44445],
            "8969": [0.25, 0.75, 0, 0, 0.44445],
            "8970": [0.25, 0.75, 0, 0, 0.44445],
            "8971": [0.25, 0.75, 0, 0, 0.44445],
            "8994": [-0.14236, 0.35764, 0, 0, 1],
            "8995": [-0.14236, 0.35764, 0, 0, 1],
            "9136": [0.244, 0.744, 0, 0, 0.412],
            "9137": [0.244, 0.745, 0, 0, 0.412],
            "9651": [0.19444, 0.69444, 0, 0, 0.88889],
            "9657": [-0.03472, 0.46528, 0, 0, 0.5],
            "9661": [0.19444, 0.69444, 0, 0, 0.88889],
            "9667": [-0.03472, 0.46528, 0, 0, 0.5],
            "9711": [0.19444, 0.69444, 0, 0, 1],
            "9824": [0.12963, 0.69444, 0, 0, 0.77778],
            "9825": [0.12963, 0.69444, 0, 0, 0.77778],
            "9826": [0.12963, 0.69444, 0, 0, 0.77778],
            "9827": [0.12963, 0.69444, 0, 0, 0.77778],
            "9837": [0, 0.75, 0, 0, 0.38889],
            "9838": [0.19444, 0.69444, 0, 0, 0.38889],
            "9839": [0.19444, 0.69444, 0, 0, 0.38889],
            "10216": [0.25, 0.75, 0, 0, 0.38889],
            "10217": [0.25, 0.75, 0, 0, 0.38889],
            "10222": [0.244, 0.744, 0, 0, 0.412],
            "10223": [0.244, 0.745, 0, 0, 0.412],
            "10229": [0.011, 0.511, 0, 0, 1.609],
            "10230": [0.011, 0.511, 0, 0, 1.638],
            "10231": [0.011, 0.511, 0, 0, 1.859],
            "10232": [0.024, 0.525, 0, 0, 1.609],
            "10233": [0.024, 0.525, 0, 0, 1.638],
            "10234": [0.024, 0.525, 0, 0, 1.858],
            "10236": [0.011, 0.511, 0, 0, 1.638],
            "10815": [0, 0.68333, 0, 0, 0.75],
            "10927": [0.13597, 0.63597, 0, 0, 0.77778],
            "10928": [0.13597, 0.63597, 0, 0, 0.77778],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Math-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.44444, 0, 0, 0.575],
            "49": [0, 0.44444, 0, 0, 0.575],
            "50": [0, 0.44444, 0, 0, 0.575],
            "51": [0.19444, 0.44444, 0, 0, 0.575],
            "52": [0.19444, 0.44444, 0, 0, 0.575],
            "53": [0.19444, 0.44444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0.19444, 0.44444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0.19444, 0.44444, 0, 0, 0.575],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0.04835, 0, 0.8664],
            "67": [0, 0.68611, 0.06979, 0, 0.81694],
            "68": [0, 0.68611, 0.03194, 0, 0.93812],
            "69": [0, 0.68611, 0.05451, 0, 0.81007],
            "70": [0, 0.68611, 0.15972, 0, 0.68889],
            "71": [0, 0.68611, 0, 0, 0.88673],
            "72": [0, 0.68611, 0.08229, 0, 0.98229],
            "73": [0, 0.68611, 0.07778, 0, 0.51111],
            "74": [0, 0.68611, 0.10069, 0, 0.63125],
            "75": [0, 0.68611, 0.06979, 0, 0.97118],
            "76": [0, 0.68611, 0, 0, 0.75555],
            "77": [0, 0.68611, 0.11424, 0, 1.14201],
            "78": [0, 0.68611, 0.11424, 0, 0.95034],
            "79": [0, 0.68611, 0.03194, 0, 0.83666],
            "80": [0, 0.68611, 0.15972, 0, 0.72309],
            "81": [0.19444, 0.68611, 0, 0, 0.86861],
            "82": [0, 0.68611, 421e-5, 0, 0.87235],
            "83": [0, 0.68611, 0.05382, 0, 0.69271],
            "84": [0, 0.68611, 0.15972, 0, 0.63663],
            "85": [0, 0.68611, 0.11424, 0, 0.80027],
            "86": [0, 0.68611, 0.25555, 0, 0.67778],
            "87": [0, 0.68611, 0.15972, 0, 1.09305],
            "88": [0, 0.68611, 0.07778, 0, 0.94722],
            "89": [0, 0.68611, 0.25555, 0, 0.67458],
            "90": [0, 0.68611, 0.06979, 0, 0.77257],
            "97": [0, 0.44444, 0, 0, 0.63287],
            "98": [0, 0.69444, 0, 0, 0.52083],
            "99": [0, 0.44444, 0, 0, 0.51342],
            "100": [0, 0.69444, 0, 0, 0.60972],
            "101": [0, 0.44444, 0, 0, 0.55361],
            "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
            "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
            "104": [0, 0.69444, 0, 0, 0.66759],
            "105": [0, 0.69326, 0, 0, 0.4048],
            "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
            "107": [0, 0.69444, 0.01852, 0, 0.6037],
            "108": [0, 0.69444, 88e-4, 0, 0.34815],
            "109": [0, 0.44444, 0, 0, 1.0324],
            "110": [0, 0.44444, 0, 0, 0.71296],
            "111": [0, 0.44444, 0, 0, 0.58472],
            "112": [0.19444, 0.44444, 0, 0, 0.60092],
            "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
            "114": [0, 0.44444, 0.03194, 0, 0.5287],
            "115": [0, 0.44444, 0, 0, 0.53125],
            "116": [0, 0.63492, 0, 0, 0.41528],
            "117": [0, 0.44444, 0, 0, 0.68102],
            "118": [0, 0.44444, 0.03704, 0, 0.56666],
            "119": [0, 0.44444, 0.02778, 0, 0.83148],
            "120": [0, 0.44444, 0, 0, 0.65903],
            "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
            "122": [0, 0.44444, 0.04213, 0, 0.55509],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68611, 0.15972, 0, 0.65694],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0.03194, 0, 0.86722],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0.07458, 0, 0.84125],
            "928": [0, 0.68611, 0.08229, 0, 0.98229],
            "931": [0, 0.68611, 0.05451, 0, 0.88507],
            "933": [0, 0.68611, 0.15972, 0, 0.67083],
            "934": [0, 0.68611, 0, 0, 0.76666],
            "936": [0, 0.68611, 0.11653, 0, 0.71402],
            "937": [0, 0.68611, 0.04835, 0, 0.8789],
            "945": [0, 0.44444, 0, 0, 0.76064],
            "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
            "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
            "948": [0, 0.69444, 0.03819, 0, 0.52222],
            "949": [0, 0.44444, 0, 0, 0.52882],
            "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
            "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
            "952": [0, 0.69444, 0.03194, 0, 0.5618],
            "953": [0, 0.44444, 0, 0, 0.41204],
            "954": [0, 0.44444, 0, 0, 0.66759],
            "955": [0, 0.69444, 0, 0, 0.67083],
            "956": [0.19444, 0.44444, 0, 0, 0.70787],
            "957": [0, 0.44444, 0.06898, 0, 0.57685],
            "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
            "959": [0, 0.44444, 0, 0, 0.58472],
            "960": [0, 0.44444, 0.03704, 0, 0.68241],
            "961": [0.19444, 0.44444, 0, 0, 0.6118],
            "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
            "963": [0, 0.44444, 0.03704, 0, 0.68588],
            "964": [0, 0.44444, 0.13472, 0, 0.52083],
            "965": [0, 0.44444, 0.03704, 0, 0.63055],
            "966": [0.19444, 0.44444, 0, 0, 0.74722],
            "967": [0.19444, 0.44444, 0, 0, 0.71805],
            "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
            "969": [0, 0.44444, 0.03704, 0, 0.71782],
            "977": [0, 0.69444, 0, 0, 0.69155],
            "981": [0.19444, 0.69444, 0, 0, 0.7125],
            "982": [0, 0.44444, 0.03194, 0, 0.975],
            "1009": [0.19444, 0.44444, 0, 0, 0.6118],
            "1013": [0, 0.44444, 0, 0, 0.48333],
            "57649": [0, 0.44444, 0, 0, 0.39352],
            "57911": [0.19444, 0.44444, 0, 0, 0.43889]
          },
          "Math-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.43056, 0, 0, 0.5],
            "49": [0, 0.43056, 0, 0, 0.5],
            "50": [0, 0.43056, 0, 0, 0.5],
            "51": [0.19444, 0.43056, 0, 0, 0.5],
            "52": [0.19444, 0.43056, 0, 0, 0.5],
            "53": [0.19444, 0.43056, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0.19444, 0.43056, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0.19444, 0.43056, 0, 0, 0.5],
            "65": [0, 0.68333, 0, 0.13889, 0.75],
            "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
            "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
            "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
            "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
            "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
            "71": [0, 0.68333, 0, 0.08334, 0.78625],
            "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
            "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
            "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
            "76": [0, 0.68333, 0, 0.02778, 0.68056],
            "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
            "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
            "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
            "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
            "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
            "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
            "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
            "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
            "86": [0, 0.68333, 0.22222, 0, 0.58333],
            "87": [0, 0.68333, 0.13889, 0, 0.94445],
            "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
            "89": [0, 0.68333, 0.22222, 0, 0.58056],
            "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
            "97": [0, 0.43056, 0, 0, 0.52859],
            "98": [0, 0.69444, 0, 0, 0.42917],
            "99": [0, 0.43056, 0, 0.05556, 0.43276],
            "100": [0, 0.69444, 0, 0.16667, 0.52049],
            "101": [0, 0.43056, 0, 0.05556, 0.46563],
            "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
            "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
            "104": [0, 0.69444, 0, 0, 0.57616],
            "105": [0, 0.65952, 0, 0, 0.34451],
            "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
            "107": [0, 0.69444, 0.03148, 0, 0.5206],
            "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
            "109": [0, 0.43056, 0, 0, 0.87801],
            "110": [0, 0.43056, 0, 0, 0.60023],
            "111": [0, 0.43056, 0, 0.05556, 0.48472],
            "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
            "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
            "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
            "115": [0, 0.43056, 0, 0.05556, 0.46875],
            "116": [0, 0.61508, 0, 0.08334, 0.36111],
            "117": [0, 0.43056, 0, 0.02778, 0.57246],
            "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
            "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
            "120": [0, 0.43056, 0, 0.02778, 0.57153],
            "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
            "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
            "916": [0, 0.68333, 0, 0.16667, 0.83334],
            "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "923": [0, 0.68333, 0, 0.16667, 0.69445],
            "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
            "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
            "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
            "934": [0, 0.68333, 0, 0.08334, 0.66667],
            "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
            "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
            "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
            "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
            "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
            "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
            "949": [0, 0.43056, 0, 0.08334, 0.46632],
            "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
            "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
            "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
            "953": [0, 0.43056, 0, 0.05556, 0.35394],
            "954": [0, 0.43056, 0, 0, 0.57616],
            "955": [0, 0.69444, 0, 0, 0.58334],
            "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
            "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
            "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
            "959": [0, 0.43056, 0, 0.05556, 0.48472],
            "960": [0, 0.43056, 0.03588, 0, 0.57003],
            "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
            "963": [0, 0.43056, 0.03588, 0, 0.57141],
            "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
            "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
            "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
            "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
            "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
            "969": [0, 0.43056, 0.03588, 0, 0.62245],
            "977": [0, 0.69444, 0, 0.08334, 0.59144],
            "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
            "982": [0, 0.43056, 0.02778, 0, 0.82813],
            "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "1013": [0, 0.43056, 0, 0.05556, 0.4059],
            "57649": [0, 0.43056, 0, 0.02778, 0.32246],
            "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
          },
          "SansSerif-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.36667],
            "34": [0, 0.69444, 0, 0, 0.55834],
            "35": [0.19444, 0.69444, 0, 0, 0.91667],
            "36": [0.05556, 0.75, 0, 0, 0.55],
            "37": [0.05556, 0.75, 0, 0, 1.02912],
            "38": [0, 0.69444, 0, 0, 0.83056],
            "39": [0, 0.69444, 0, 0, 0.30556],
            "40": [0.25, 0.75, 0, 0, 0.42778],
            "41": [0.25, 0.75, 0, 0, 0.42778],
            "42": [0, 0.75, 0, 0, 0.55],
            "43": [0.11667, 0.61667, 0, 0, 0.85556],
            "44": [0.10556, 0.13056, 0, 0, 0.30556],
            "45": [0, 0.45833, 0, 0, 0.36667],
            "46": [0, 0.13056, 0, 0, 0.30556],
            "47": [0.25, 0.75, 0, 0, 0.55],
            "48": [0, 0.69444, 0, 0, 0.55],
            "49": [0, 0.69444, 0, 0, 0.55],
            "50": [0, 0.69444, 0, 0, 0.55],
            "51": [0, 0.69444, 0, 0, 0.55],
            "52": [0, 0.69444, 0, 0, 0.55],
            "53": [0, 0.69444, 0, 0, 0.55],
            "54": [0, 0.69444, 0, 0, 0.55],
            "55": [0, 0.69444, 0, 0, 0.55],
            "56": [0, 0.69444, 0, 0, 0.55],
            "57": [0, 0.69444, 0, 0, 0.55],
            "58": [0, 0.45833, 0, 0, 0.30556],
            "59": [0.10556, 0.45833, 0, 0, 0.30556],
            "61": [-0.09375, 0.40625, 0, 0, 0.85556],
            "63": [0, 0.69444, 0, 0, 0.51945],
            "64": [0, 0.69444, 0, 0, 0.73334],
            "65": [0, 0.69444, 0, 0, 0.73334],
            "66": [0, 0.69444, 0, 0, 0.73334],
            "67": [0, 0.69444, 0, 0, 0.70278],
            "68": [0, 0.69444, 0, 0, 0.79445],
            "69": [0, 0.69444, 0, 0, 0.64167],
            "70": [0, 0.69444, 0, 0, 0.61111],
            "71": [0, 0.69444, 0, 0, 0.73334],
            "72": [0, 0.69444, 0, 0, 0.79445],
            "73": [0, 0.69444, 0, 0, 0.33056],
            "74": [0, 0.69444, 0, 0, 0.51945],
            "75": [0, 0.69444, 0, 0, 0.76389],
            "76": [0, 0.69444, 0, 0, 0.58056],
            "77": [0, 0.69444, 0, 0, 0.97778],
            "78": [0, 0.69444, 0, 0, 0.79445],
            "79": [0, 0.69444, 0, 0, 0.79445],
            "80": [0, 0.69444, 0, 0, 0.70278],
            "81": [0.10556, 0.69444, 0, 0, 0.79445],
            "82": [0, 0.69444, 0, 0, 0.70278],
            "83": [0, 0.69444, 0, 0, 0.61111],
            "84": [0, 0.69444, 0, 0, 0.73334],
            "85": [0, 0.69444, 0, 0, 0.76389],
            "86": [0, 0.69444, 0.01528, 0, 0.73334],
            "87": [0, 0.69444, 0.01528, 0, 1.03889],
            "88": [0, 0.69444, 0, 0, 0.73334],
            "89": [0, 0.69444, 0.0275, 0, 0.73334],
            "90": [0, 0.69444, 0, 0, 0.67223],
            "91": [0.25, 0.75, 0, 0, 0.34306],
            "93": [0.25, 0.75, 0, 0, 0.34306],
            "94": [0, 0.69444, 0, 0, 0.55],
            "95": [0.35, 0.10833, 0.03056, 0, 0.55],
            "97": [0, 0.45833, 0, 0, 0.525],
            "98": [0, 0.69444, 0, 0, 0.56111],
            "99": [0, 0.45833, 0, 0, 0.48889],
            "100": [0, 0.69444, 0, 0, 0.56111],
            "101": [0, 0.45833, 0, 0, 0.51111],
            "102": [0, 0.69444, 0.07639, 0, 0.33611],
            "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
            "104": [0, 0.69444, 0, 0, 0.56111],
            "105": [0, 0.69444, 0, 0, 0.25556],
            "106": [0.19444, 0.69444, 0, 0, 0.28611],
            "107": [0, 0.69444, 0, 0, 0.53056],
            "108": [0, 0.69444, 0, 0, 0.25556],
            "109": [0, 0.45833, 0, 0, 0.86667],
            "110": [0, 0.45833, 0, 0, 0.56111],
            "111": [0, 0.45833, 0, 0, 0.55],
            "112": [0.19444, 0.45833, 0, 0, 0.56111],
            "113": [0.19444, 0.45833, 0, 0, 0.56111],
            "114": [0, 0.45833, 0.01528, 0, 0.37222],
            "115": [0, 0.45833, 0, 0, 0.42167],
            "116": [0, 0.58929, 0, 0, 0.40417],
            "117": [0, 0.45833, 0, 0, 0.56111],
            "118": [0, 0.45833, 0.01528, 0, 0.5],
            "119": [0, 0.45833, 0.01528, 0, 0.74445],
            "120": [0, 0.45833, 0, 0, 0.5],
            "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
            "122": [0, 0.45833, 0, 0, 0.47639],
            "126": [0.35, 0.34444, 0, 0, 0.55],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0, 0, 0.55],
            "176": [0, 0.69444, 0, 0, 0.73334],
            "180": [0, 0.69444, 0, 0, 0.55],
            "184": [0.17014, 0, 0, 0, 0.48889],
            "305": [0, 0.45833, 0, 0, 0.25556],
            "567": [0.19444, 0.45833, 0, 0, 0.28611],
            "710": [0, 0.69444, 0, 0, 0.55],
            "711": [0, 0.63542, 0, 0, 0.55],
            "713": [0, 0.63778, 0, 0, 0.55],
            "728": [0, 0.69444, 0, 0, 0.55],
            "729": [0, 0.69444, 0, 0, 0.30556],
            "730": [0, 0.69444, 0, 0, 0.73334],
            "732": [0, 0.69444, 0, 0, 0.55],
            "733": [0, 0.69444, 0, 0, 0.55],
            "915": [0, 0.69444, 0, 0, 0.58056],
            "916": [0, 0.69444, 0, 0, 0.91667],
            "920": [0, 0.69444, 0, 0, 0.85556],
            "923": [0, 0.69444, 0, 0, 0.67223],
            "926": [0, 0.69444, 0, 0, 0.73334],
            "928": [0, 0.69444, 0, 0, 0.79445],
            "931": [0, 0.69444, 0, 0, 0.79445],
            "933": [0, 0.69444, 0, 0, 0.85556],
            "934": [0, 0.69444, 0, 0, 0.79445],
            "936": [0, 0.69444, 0, 0, 0.85556],
            "937": [0, 0.69444, 0, 0, 0.79445],
            "8211": [0, 0.45833, 0.03056, 0, 0.55],
            "8212": [0, 0.45833, 0.03056, 0, 1.10001],
            "8216": [0, 0.69444, 0, 0, 0.30556],
            "8217": [0, 0.69444, 0, 0, 0.30556],
            "8220": [0, 0.69444, 0, 0, 0.55834],
            "8221": [0, 0.69444, 0, 0, 0.55834]
          },
          "SansSerif-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.05733, 0, 0.31945],
            "34": [0, 0.69444, 316e-5, 0, 0.5],
            "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
            "36": [0.05556, 0.75, 0.11156, 0, 0.5],
            "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
            "38": [0, 0.69444, 0.03058, 0, 0.75834],
            "39": [0, 0.69444, 0.07816, 0, 0.27778],
            "40": [0.25, 0.75, 0.13164, 0, 0.38889],
            "41": [0.25, 0.75, 0.02536, 0, 0.38889],
            "42": [0, 0.75, 0.11775, 0, 0.5],
            "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0.01946, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0.13164, 0, 0.5],
            "48": [0, 0.65556, 0.11156, 0, 0.5],
            "49": [0, 0.65556, 0.11156, 0, 0.5],
            "50": [0, 0.65556, 0.11156, 0, 0.5],
            "51": [0, 0.65556, 0.11156, 0, 0.5],
            "52": [0, 0.65556, 0.11156, 0, 0.5],
            "53": [0, 0.65556, 0.11156, 0, 0.5],
            "54": [0, 0.65556, 0.11156, 0, 0.5],
            "55": [0, 0.65556, 0.11156, 0, 0.5],
            "56": [0, 0.65556, 0.11156, 0, 0.5],
            "57": [0, 0.65556, 0.11156, 0, 0.5],
            "58": [0, 0.44444, 0.02502, 0, 0.27778],
            "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
            "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
            "63": [0, 0.69444, 0.11809, 0, 0.47222],
            "64": [0, 0.69444, 0.07555, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0.08293, 0, 0.66667],
            "67": [0, 0.69444, 0.11983, 0, 0.63889],
            "68": [0, 0.69444, 0.07555, 0, 0.72223],
            "69": [0, 0.69444, 0.11983, 0, 0.59722],
            "70": [0, 0.69444, 0.13372, 0, 0.56945],
            "71": [0, 0.69444, 0.11983, 0, 0.66667],
            "72": [0, 0.69444, 0.08094, 0, 0.70834],
            "73": [0, 0.69444, 0.13372, 0, 0.27778],
            "74": [0, 0.69444, 0.08094, 0, 0.47222],
            "75": [0, 0.69444, 0.11983, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0.08094, 0, 0.875],
            "78": [0, 0.69444, 0.08094, 0, 0.70834],
            "79": [0, 0.69444, 0.07555, 0, 0.73611],
            "80": [0, 0.69444, 0.08293, 0, 0.63889],
            "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
            "82": [0, 0.69444, 0.08293, 0, 0.64584],
            "83": [0, 0.69444, 0.09205, 0, 0.55556],
            "84": [0, 0.69444, 0.13372, 0, 0.68056],
            "85": [0, 0.69444, 0.08094, 0, 0.6875],
            "86": [0, 0.69444, 0.1615, 0, 0.66667],
            "87": [0, 0.69444, 0.1615, 0, 0.94445],
            "88": [0, 0.69444, 0.13372, 0, 0.66667],
            "89": [0, 0.69444, 0.17261, 0, 0.66667],
            "90": [0, 0.69444, 0.11983, 0, 0.61111],
            "91": [0.25, 0.75, 0.15942, 0, 0.28889],
            "93": [0.25, 0.75, 0.08719, 0, 0.28889],
            "94": [0, 0.69444, 0.0799, 0, 0.5],
            "95": [0.35, 0.09444, 0.08616, 0, 0.5],
            "97": [0, 0.44444, 981e-5, 0, 0.48056],
            "98": [0, 0.69444, 0.03057, 0, 0.51667],
            "99": [0, 0.44444, 0.08336, 0, 0.44445],
            "100": [0, 0.69444, 0.09483, 0, 0.51667],
            "101": [0, 0.44444, 0.06778, 0, 0.44445],
            "102": [0, 0.69444, 0.21705, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
            "104": [0, 0.69444, 0.01778, 0, 0.51667],
            "105": [0, 0.67937, 0.09718, 0, 0.23889],
            "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
            "107": [0, 0.69444, 0.08336, 0, 0.48889],
            "108": [0, 0.69444, 0.09483, 0, 0.23889],
            "109": [0, 0.44444, 0.01778, 0, 0.79445],
            "110": [0, 0.44444, 0.01778, 0, 0.51667],
            "111": [0, 0.44444, 0.06613, 0, 0.5],
            "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
            "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
            "114": [0, 0.44444, 0.10836, 0, 0.34167],
            "115": [0, 0.44444, 0.0778, 0, 0.38333],
            "116": [0, 0.57143, 0.07225, 0, 0.36111],
            "117": [0, 0.44444, 0.04169, 0, 0.51667],
            "118": [0, 0.44444, 0.10836, 0, 0.46111],
            "119": [0, 0.44444, 0.10836, 0, 0.68334],
            "120": [0, 0.44444, 0.09169, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
            "122": [0, 0.44444, 0.08752, 0, 0.43472],
            "126": [0.35, 0.32659, 0.08826, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0.06385, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.73752],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0.04169, 0, 0.23889],
            "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
            "710": [0, 0.69444, 0.0799, 0, 0.5],
            "711": [0, 0.63194, 0.08432, 0, 0.5],
            "713": [0, 0.60889, 0.08776, 0, 0.5],
            "714": [0, 0.69444, 0.09205, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0.09483, 0, 0.5],
            "729": [0, 0.67937, 0.07774, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.73752],
            "732": [0, 0.67659, 0.08826, 0, 0.5],
            "733": [0, 0.69444, 0.09205, 0, 0.5],
            "915": [0, 0.69444, 0.13372, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0.07555, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0.12816, 0, 0.66667],
            "928": [0, 0.69444, 0.08094, 0, 0.70834],
            "931": [0, 0.69444, 0.11983, 0, 0.72222],
            "933": [0, 0.69444, 0.09031, 0, 0.77778],
            "934": [0, 0.69444, 0.04603, 0, 0.72222],
            "936": [0, 0.69444, 0.09031, 0, 0.77778],
            "937": [0, 0.69444, 0.08293, 0, 0.72222],
            "8211": [0, 0.44444, 0.08616, 0, 0.5],
            "8212": [0, 0.44444, 0.08616, 0, 1],
            "8216": [0, 0.69444, 0.07816, 0, 0.27778],
            "8217": [0, 0.69444, 0.07816, 0, 0.27778],
            "8220": [0, 0.69444, 0.14205, 0, 0.5],
            "8221": [0, 0.69444, 316e-5, 0, 0.5]
          },
          "SansSerif-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.31945],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.75834],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.65556, 0, 0, 0.5],
            "49": [0, 0.65556, 0, 0, 0.5],
            "50": [0, 0.65556, 0, 0, 0.5],
            "51": [0, 0.65556, 0, 0, 0.5],
            "52": [0, 0.65556, 0, 0, 0.5],
            "53": [0, 0.65556, 0, 0, 0.5],
            "54": [0, 0.65556, 0, 0, 0.5],
            "55": [0, 0.65556, 0, 0, 0.5],
            "56": [0, 0.65556, 0, 0, 0.5],
            "57": [0, 0.65556, 0, 0, 0.5],
            "58": [0, 0.44444, 0, 0, 0.27778],
            "59": [0.125, 0.44444, 0, 0, 0.27778],
            "61": [-0.13, 0.37, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0, 0, 0.66667],
            "67": [0, 0.69444, 0, 0, 0.63889],
            "68": [0, 0.69444, 0, 0, 0.72223],
            "69": [0, 0.69444, 0, 0, 0.59722],
            "70": [0, 0.69444, 0, 0, 0.56945],
            "71": [0, 0.69444, 0, 0, 0.66667],
            "72": [0, 0.69444, 0, 0, 0.70834],
            "73": [0, 0.69444, 0, 0, 0.27778],
            "74": [0, 0.69444, 0, 0, 0.47222],
            "75": [0, 0.69444, 0, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0, 0, 0.875],
            "78": [0, 0.69444, 0, 0, 0.70834],
            "79": [0, 0.69444, 0, 0, 0.73611],
            "80": [0, 0.69444, 0, 0, 0.63889],
            "81": [0.125, 0.69444, 0, 0, 0.73611],
            "82": [0, 0.69444, 0, 0, 0.64584],
            "83": [0, 0.69444, 0, 0, 0.55556],
            "84": [0, 0.69444, 0, 0, 0.68056],
            "85": [0, 0.69444, 0, 0, 0.6875],
            "86": [0, 0.69444, 0.01389, 0, 0.66667],
            "87": [0, 0.69444, 0.01389, 0, 0.94445],
            "88": [0, 0.69444, 0, 0, 0.66667],
            "89": [0, 0.69444, 0.025, 0, 0.66667],
            "90": [0, 0.69444, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.28889],
            "93": [0.25, 0.75, 0, 0, 0.28889],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.35, 0.09444, 0.02778, 0, 0.5],
            "97": [0, 0.44444, 0, 0, 0.48056],
            "98": [0, 0.69444, 0, 0, 0.51667],
            "99": [0, 0.44444, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.51667],
            "101": [0, 0.44444, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.06944, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.51667],
            "105": [0, 0.67937, 0, 0, 0.23889],
            "106": [0.19444, 0.67937, 0, 0, 0.26667],
            "107": [0, 0.69444, 0, 0, 0.48889],
            "108": [0, 0.69444, 0, 0, 0.23889],
            "109": [0, 0.44444, 0, 0, 0.79445],
            "110": [0, 0.44444, 0, 0, 0.51667],
            "111": [0, 0.44444, 0, 0, 0.5],
            "112": [0.19444, 0.44444, 0, 0, 0.51667],
            "113": [0.19444, 0.44444, 0, 0, 0.51667],
            "114": [0, 0.44444, 0.01389, 0, 0.34167],
            "115": [0, 0.44444, 0, 0, 0.38333],
            "116": [0, 0.57143, 0, 0, 0.36111],
            "117": [0, 0.44444, 0, 0, 0.51667],
            "118": [0, 0.44444, 0.01389, 0, 0.46111],
            "119": [0, 0.44444, 0.01389, 0, 0.68334],
            "120": [0, 0.44444, 0, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
            "122": [0, 0.44444, 0, 0, 0.43472],
            "126": [0.35, 0.32659, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.66667],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0, 0, 0.23889],
            "567": [0.19444, 0.44444, 0, 0, 0.26667],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.63194, 0, 0, 0.5],
            "713": [0, 0.60889, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.67937, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.66667],
            "732": [0, 0.67659, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.69444, 0, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0, 0, 0.66667],
            "928": [0, 0.69444, 0, 0, 0.70834],
            "931": [0, 0.69444, 0, 0, 0.72222],
            "933": [0, 0.69444, 0, 0, 0.77778],
            "934": [0, 0.69444, 0, 0, 0.72222],
            "936": [0, 0.69444, 0, 0, 0.77778],
            "937": [0, 0.69444, 0, 0, 0.72222],
            "8211": [0, 0.44444, 0.02778, 0, 0.5],
            "8212": [0, 0.44444, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5]
          },
          "Script-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.7, 0.22925, 0, 0.80253],
            "66": [0, 0.7, 0.04087, 0, 0.90757],
            "67": [0, 0.7, 0.1689, 0, 0.66619],
            "68": [0, 0.7, 0.09371, 0, 0.77443],
            "69": [0, 0.7, 0.18583, 0, 0.56162],
            "70": [0, 0.7, 0.13634, 0, 0.89544],
            "71": [0, 0.7, 0.17322, 0, 0.60961],
            "72": [0, 0.7, 0.29694, 0, 0.96919],
            "73": [0, 0.7, 0.19189, 0, 0.80907],
            "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
            "75": [0, 0.7, 0.31259, 0, 0.91364],
            "76": [0, 0.7, 0.19189, 0, 0.87373],
            "77": [0, 0.7, 0.15981, 0, 1.08031],
            "78": [0, 0.7, 0.3525, 0, 0.9015],
            "79": [0, 0.7, 0.08078, 0, 0.73787],
            "80": [0, 0.7, 0.08078, 0, 1.01262],
            "81": [0, 0.7, 0.03305, 0, 0.88282],
            "82": [0, 0.7, 0.06259, 0, 0.85],
            "83": [0, 0.7, 0.19189, 0, 0.86767],
            "84": [0, 0.7, 0.29087, 0, 0.74697],
            "85": [0, 0.7, 0.25815, 0, 0.79996],
            "86": [0, 0.7, 0.27523, 0, 0.62204],
            "87": [0, 0.7, 0.27523, 0, 0.80532],
            "88": [0, 0.7, 0.26006, 0, 0.94445],
            "89": [0, 0.7, 0.2939, 0, 0.70961],
            "90": [0, 0.7, 0.24037, 0, 0.8212],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Size1-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.35001, 0.85, 0, 0, 0.45834],
            "41": [0.35001, 0.85, 0, 0, 0.45834],
            "47": [0.35001, 0.85, 0, 0, 0.57778],
            "91": [0.35001, 0.85, 0, 0, 0.41667],
            "92": [0.35001, 0.85, 0, 0, 0.57778],
            "93": [0.35001, 0.85, 0, 0, 0.41667],
            "123": [0.35001, 0.85, 0, 0, 0.58334],
            "125": [0.35001, 0.85, 0, 0, 0.58334],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.72222, 0, 0, 0.55556],
            "732": [0, 0.72222, 0, 0, 0.55556],
            "770": [0, 0.72222, 0, 0, 0.55556],
            "771": [0, 0.72222, 0, 0, 0.55556],
            "8214": [-99e-5, 0.601, 0, 0, 0.77778],
            "8593": [1e-5, 0.6, 0, 0, 0.66667],
            "8595": [1e-5, 0.6, 0, 0, 0.66667],
            "8657": [1e-5, 0.6, 0, 0, 0.77778],
            "8659": [1e-5, 0.6, 0, 0, 0.77778],
            "8719": [0.25001, 0.75, 0, 0, 0.94445],
            "8720": [0.25001, 0.75, 0, 0, 0.94445],
            "8721": [0.25001, 0.75, 0, 0, 1.05556],
            "8730": [0.35001, 0.85, 0, 0, 1],
            "8739": [-599e-5, 0.606, 0, 0, 0.33333],
            "8741": [-599e-5, 0.606, 0, 0, 0.55556],
            "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8896": [0.25001, 0.75, 0, 0, 0.83334],
            "8897": [0.25001, 0.75, 0, 0, 0.83334],
            "8898": [0.25001, 0.75, 0, 0, 0.83334],
            "8899": [0.25001, 0.75, 0, 0, 0.83334],
            "8968": [0.35001, 0.85, 0, 0, 0.47222],
            "8969": [0.35001, 0.85, 0, 0, 0.47222],
            "8970": [0.35001, 0.85, 0, 0, 0.47222],
            "8971": [0.35001, 0.85, 0, 0, 0.47222],
            "9168": [-99e-5, 0.601, 0, 0, 0.66667],
            "10216": [0.35001, 0.85, 0, 0, 0.47222],
            "10217": [0.35001, 0.85, 0, 0, 0.47222],
            "10752": [0.25001, 0.75, 0, 0, 1.11111],
            "10753": [0.25001, 0.75, 0, 0, 1.11111],
            "10754": [0.25001, 0.75, 0, 0, 1.11111],
            "10756": [0.25001, 0.75, 0, 0, 0.83334],
            "10758": [0.25001, 0.75, 0, 0, 0.83334]
          },
          "Size2-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.65002, 1.15, 0, 0, 0.59722],
            "41": [0.65002, 1.15, 0, 0, 0.59722],
            "47": [0.65002, 1.15, 0, 0, 0.81111],
            "91": [0.65002, 1.15, 0, 0, 0.47222],
            "92": [0.65002, 1.15, 0, 0, 0.81111],
            "93": [0.65002, 1.15, 0, 0, 0.47222],
            "123": [0.65002, 1.15, 0, 0, 0.66667],
            "125": [0.65002, 1.15, 0, 0, 0.66667],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1],
            "732": [0, 0.75, 0, 0, 1],
            "770": [0, 0.75, 0, 0, 1],
            "771": [0, 0.75, 0, 0, 1],
            "8719": [0.55001, 1.05, 0, 0, 1.27778],
            "8720": [0.55001, 1.05, 0, 0, 1.27778],
            "8721": [0.55001, 1.05, 0, 0, 1.44445],
            "8730": [0.65002, 1.15, 0, 0, 1],
            "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8896": [0.55001, 1.05, 0, 0, 1.11111],
            "8897": [0.55001, 1.05, 0, 0, 1.11111],
            "8898": [0.55001, 1.05, 0, 0, 1.11111],
            "8899": [0.55001, 1.05, 0, 0, 1.11111],
            "8968": [0.65002, 1.15, 0, 0, 0.52778],
            "8969": [0.65002, 1.15, 0, 0, 0.52778],
            "8970": [0.65002, 1.15, 0, 0, 0.52778],
            "8971": [0.65002, 1.15, 0, 0, 0.52778],
            "10216": [0.65002, 1.15, 0, 0, 0.61111],
            "10217": [0.65002, 1.15, 0, 0, 0.61111],
            "10752": [0.55001, 1.05, 0, 0, 1.51112],
            "10753": [0.55001, 1.05, 0, 0, 1.51112],
            "10754": [0.55001, 1.05, 0, 0, 1.51112],
            "10756": [0.55001, 1.05, 0, 0, 1.11111],
            "10758": [0.55001, 1.05, 0, 0, 1.11111]
          },
          "Size3-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.95003, 1.45, 0, 0, 0.73611],
            "41": [0.95003, 1.45, 0, 0, 0.73611],
            "47": [0.95003, 1.45, 0, 0, 1.04445],
            "91": [0.95003, 1.45, 0, 0, 0.52778],
            "92": [0.95003, 1.45, 0, 0, 1.04445],
            "93": [0.95003, 1.45, 0, 0, 0.52778],
            "123": [0.95003, 1.45, 0, 0, 0.75],
            "125": [0.95003, 1.45, 0, 0, 0.75],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1.44445],
            "732": [0, 0.75, 0, 0, 1.44445],
            "770": [0, 0.75, 0, 0, 1.44445],
            "771": [0, 0.75, 0, 0, 1.44445],
            "8730": [0.95003, 1.45, 0, 0, 1],
            "8968": [0.95003, 1.45, 0, 0, 0.58334],
            "8969": [0.95003, 1.45, 0, 0, 0.58334],
            "8970": [0.95003, 1.45, 0, 0, 0.58334],
            "8971": [0.95003, 1.45, 0, 0, 0.58334],
            "10216": [0.95003, 1.45, 0, 0, 0.75],
            "10217": [0.95003, 1.45, 0, 0, 0.75]
          },
          "Size4-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [1.25003, 1.75, 0, 0, 0.79167],
            "41": [1.25003, 1.75, 0, 0, 0.79167],
            "47": [1.25003, 1.75, 0, 0, 1.27778],
            "91": [1.25003, 1.75, 0, 0, 0.58334],
            "92": [1.25003, 1.75, 0, 0, 1.27778],
            "93": [1.25003, 1.75, 0, 0, 0.58334],
            "123": [1.25003, 1.75, 0, 0, 0.80556],
            "125": [1.25003, 1.75, 0, 0, 0.80556],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.825, 0, 0, 1.8889],
            "732": [0, 0.825, 0, 0, 1.8889],
            "770": [0, 0.825, 0, 0, 1.8889],
            "771": [0, 0.825, 0, 0, 1.8889],
            "8730": [1.25003, 1.75, 0, 0, 1],
            "8968": [1.25003, 1.75, 0, 0, 0.63889],
            "8969": [1.25003, 1.75, 0, 0, 0.63889],
            "8970": [1.25003, 1.75, 0, 0, 0.63889],
            "8971": [1.25003, 1.75, 0, 0, 0.63889],
            "9115": [0.64502, 1.155, 0, 0, 0.875],
            "9116": [1e-5, 0.6, 0, 0, 0.875],
            "9117": [0.64502, 1.155, 0, 0, 0.875],
            "9118": [0.64502, 1.155, 0, 0, 0.875],
            "9119": [1e-5, 0.6, 0, 0, 0.875],
            "9120": [0.64502, 1.155, 0, 0, 0.875],
            "9121": [0.64502, 1.155, 0, 0, 0.66667],
            "9122": [-99e-5, 0.601, 0, 0, 0.66667],
            "9123": [0.64502, 1.155, 0, 0, 0.66667],
            "9124": [0.64502, 1.155, 0, 0, 0.66667],
            "9125": [-99e-5, 0.601, 0, 0, 0.66667],
            "9126": [0.64502, 1.155, 0, 0, 0.66667],
            "9127": [1e-5, 0.9, 0, 0, 0.88889],
            "9128": [0.65002, 1.15, 0, 0, 0.88889],
            "9129": [0.90001, 0, 0, 0, 0.88889],
            "9130": [0, 0.3, 0, 0, 0.88889],
            "9131": [1e-5, 0.9, 0, 0, 0.88889],
            "9132": [0.65002, 1.15, 0, 0, 0.88889],
            "9133": [0.90001, 0, 0, 0, 0.88889],
            "9143": [0.88502, 0.915, 0, 0, 1.05556],
            "10216": [1.25003, 1.75, 0, 0, 0.80556],
            "10217": [1.25003, 1.75, 0, 0, 0.80556],
            "57344": [-499e-5, 0.605, 0, 0, 1.05556],
            "57345": [-499e-5, 0.605, 0, 0, 1.05556],
            "57680": [0, 0.12, 0, 0, 0.45],
            "57681": [0, 0.12, 0, 0, 0.45],
            "57682": [0, 0.12, 0, 0, 0.45],
            "57683": [0, 0.12, 0, 0, 0.45]
          },
          "Typewriter-Regular": {
            "32": [0, 0, 0, 0, 0.525],
            "33": [0, 0.61111, 0, 0, 0.525],
            "34": [0, 0.61111, 0, 0, 0.525],
            "35": [0, 0.61111, 0, 0, 0.525],
            "36": [0.08333, 0.69444, 0, 0, 0.525],
            "37": [0.08333, 0.69444, 0, 0, 0.525],
            "38": [0, 0.61111, 0, 0, 0.525],
            "39": [0, 0.61111, 0, 0, 0.525],
            "40": [0.08333, 0.69444, 0, 0, 0.525],
            "41": [0.08333, 0.69444, 0, 0, 0.525],
            "42": [0, 0.52083, 0, 0, 0.525],
            "43": [-0.08056, 0.53055, 0, 0, 0.525],
            "44": [0.13889, 0.125, 0, 0, 0.525],
            "45": [-0.08056, 0.53055, 0, 0, 0.525],
            "46": [0, 0.125, 0, 0, 0.525],
            "47": [0.08333, 0.69444, 0, 0, 0.525],
            "48": [0, 0.61111, 0, 0, 0.525],
            "49": [0, 0.61111, 0, 0, 0.525],
            "50": [0, 0.61111, 0, 0, 0.525],
            "51": [0, 0.61111, 0, 0, 0.525],
            "52": [0, 0.61111, 0, 0, 0.525],
            "53": [0, 0.61111, 0, 0, 0.525],
            "54": [0, 0.61111, 0, 0, 0.525],
            "55": [0, 0.61111, 0, 0, 0.525],
            "56": [0, 0.61111, 0, 0, 0.525],
            "57": [0, 0.61111, 0, 0, 0.525],
            "58": [0, 0.43056, 0, 0, 0.525],
            "59": [0.13889, 0.43056, 0, 0, 0.525],
            "60": [-0.05556, 0.55556, 0, 0, 0.525],
            "61": [-0.19549, 0.41562, 0, 0, 0.525],
            "62": [-0.05556, 0.55556, 0, 0, 0.525],
            "63": [0, 0.61111, 0, 0, 0.525],
            "64": [0, 0.61111, 0, 0, 0.525],
            "65": [0, 0.61111, 0, 0, 0.525],
            "66": [0, 0.61111, 0, 0, 0.525],
            "67": [0, 0.61111, 0, 0, 0.525],
            "68": [0, 0.61111, 0, 0, 0.525],
            "69": [0, 0.61111, 0, 0, 0.525],
            "70": [0, 0.61111, 0, 0, 0.525],
            "71": [0, 0.61111, 0, 0, 0.525],
            "72": [0, 0.61111, 0, 0, 0.525],
            "73": [0, 0.61111, 0, 0, 0.525],
            "74": [0, 0.61111, 0, 0, 0.525],
            "75": [0, 0.61111, 0, 0, 0.525],
            "76": [0, 0.61111, 0, 0, 0.525],
            "77": [0, 0.61111, 0, 0, 0.525],
            "78": [0, 0.61111, 0, 0, 0.525],
            "79": [0, 0.61111, 0, 0, 0.525],
            "80": [0, 0.61111, 0, 0, 0.525],
            "81": [0.13889, 0.61111, 0, 0, 0.525],
            "82": [0, 0.61111, 0, 0, 0.525],
            "83": [0, 0.61111, 0, 0, 0.525],
            "84": [0, 0.61111, 0, 0, 0.525],
            "85": [0, 0.61111, 0, 0, 0.525],
            "86": [0, 0.61111, 0, 0, 0.525],
            "87": [0, 0.61111, 0, 0, 0.525],
            "88": [0, 0.61111, 0, 0, 0.525],
            "89": [0, 0.61111, 0, 0, 0.525],
            "90": [0, 0.61111, 0, 0, 0.525],
            "91": [0.08333, 0.69444, 0, 0, 0.525],
            "92": [0.08333, 0.69444, 0, 0, 0.525],
            "93": [0.08333, 0.69444, 0, 0, 0.525],
            "94": [0, 0.61111, 0, 0, 0.525],
            "95": [0.09514, 0, 0, 0, 0.525],
            "96": [0, 0.61111, 0, 0, 0.525],
            "97": [0, 0.43056, 0, 0, 0.525],
            "98": [0, 0.61111, 0, 0, 0.525],
            "99": [0, 0.43056, 0, 0, 0.525],
            "100": [0, 0.61111, 0, 0, 0.525],
            "101": [0, 0.43056, 0, 0, 0.525],
            "102": [0, 0.61111, 0, 0, 0.525],
            "103": [0.22222, 0.43056, 0, 0, 0.525],
            "104": [0, 0.61111, 0, 0, 0.525],
            "105": [0, 0.61111, 0, 0, 0.525],
            "106": [0.22222, 0.61111, 0, 0, 0.525],
            "107": [0, 0.61111, 0, 0, 0.525],
            "108": [0, 0.61111, 0, 0, 0.525],
            "109": [0, 0.43056, 0, 0, 0.525],
            "110": [0, 0.43056, 0, 0, 0.525],
            "111": [0, 0.43056, 0, 0, 0.525],
            "112": [0.22222, 0.43056, 0, 0, 0.525],
            "113": [0.22222, 0.43056, 0, 0, 0.525],
            "114": [0, 0.43056, 0, 0, 0.525],
            "115": [0, 0.43056, 0, 0, 0.525],
            "116": [0, 0.55358, 0, 0, 0.525],
            "117": [0, 0.43056, 0, 0, 0.525],
            "118": [0, 0.43056, 0, 0, 0.525],
            "119": [0, 0.43056, 0, 0, 0.525],
            "120": [0, 0.43056, 0, 0, 0.525],
            "121": [0.22222, 0.43056, 0, 0, 0.525],
            "122": [0, 0.43056, 0, 0, 0.525],
            "123": [0.08333, 0.69444, 0, 0, 0.525],
            "124": [0.08333, 0.69444, 0, 0, 0.525],
            "125": [0.08333, 0.69444, 0, 0, 0.525],
            "126": [0, 0.61111, 0, 0, 0.525],
            "127": [0, 0.61111, 0, 0, 0.525],
            "160": [0, 0, 0, 0, 0.525],
            "176": [0, 0.61111, 0, 0, 0.525],
            "184": [0.19445, 0, 0, 0, 0.525],
            "305": [0, 0.43056, 0, 0, 0.525],
            "567": [0.22222, 0.43056, 0, 0, 0.525],
            "711": [0, 0.56597, 0, 0, 0.525],
            "713": [0, 0.56555, 0, 0, 0.525],
            "714": [0, 0.61111, 0, 0, 0.525],
            "715": [0, 0.61111, 0, 0, 0.525],
            "728": [0, 0.61111, 0, 0, 0.525],
            "730": [0, 0.61111, 0, 0, 0.525],
            "770": [0, 0.61111, 0, 0, 0.525],
            "771": [0, 0.61111, 0, 0, 0.525],
            "776": [0, 0.61111, 0, 0, 0.525],
            "915": [0, 0.61111, 0, 0, 0.525],
            "916": [0, 0.61111, 0, 0, 0.525],
            "920": [0, 0.61111, 0, 0, 0.525],
            "923": [0, 0.61111, 0, 0, 0.525],
            "926": [0, 0.61111, 0, 0, 0.525],
            "928": [0, 0.61111, 0, 0, 0.525],
            "931": [0, 0.61111, 0, 0, 0.525],
            "933": [0, 0.61111, 0, 0, 0.525],
            "934": [0, 0.61111, 0, 0, 0.525],
            "936": [0, 0.61111, 0, 0, 0.525],
            "937": [0, 0.61111, 0, 0, 0.525],
            "8216": [0, 0.61111, 0, 0, 0.525],
            "8217": [0, 0.61111, 0, 0, 0.525],
            "8242": [0, 0.61111, 0, 0, 0.525],
            "9251": [0.11111, 0.21944, 0, 0, 0.525]
          }
        };
        const sigmasAndXis = {
          slant: [0.25, 0.25, 0.25],
          // sigma1
          space: [0, 0, 0],
          // sigma2
          stretch: [0, 0, 0],
          // sigma3
          shrink: [0, 0, 0],
          // sigma4
          xHeight: [0.431, 0.431, 0.431],
          // sigma5
          quad: [1, 1.171, 1.472],
          // sigma6
          extraSpace: [0, 0, 0],
          // sigma7
          num1: [0.677, 0.732, 0.925],
          // sigma8
          num2: [0.394, 0.384, 0.387],
          // sigma9
          num3: [0.444, 0.471, 0.504],
          // sigma10
          denom1: [0.686, 0.752, 1.025],
          // sigma11
          denom2: [0.345, 0.344, 0.532],
          // sigma12
          sup1: [0.413, 0.503, 0.504],
          // sigma13
          sup2: [0.363, 0.431, 0.404],
          // sigma14
          sup3: [0.289, 0.286, 0.294],
          // sigma15
          sub1: [0.15, 0.143, 0.2],
          // sigma16
          sub2: [0.247, 0.286, 0.4],
          // sigma17
          supDrop: [0.386, 0.353, 0.494],
          // sigma18
          subDrop: [0.05, 0.071, 0.1],
          // sigma19
          delim1: [2.39, 1.7, 1.98],
          // sigma20
          delim2: [1.01, 1.157, 1.42],
          // sigma21
          axisHeight: [0.25, 0.25, 0.25],
          // sigma22
          // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
          // they correspond to the font parameters of the extension fonts (family 3).
          // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
          // match cmex7, we'd use cmex7.tfm values for script and scriptscript
          // values.
          defaultRuleThickness: [0.04, 0.049, 0.049],
          // xi8; cmex7: 0.049
          bigOpSpacing1: [0.111, 0.111, 0.111],
          // xi9
          bigOpSpacing2: [0.166, 0.166, 0.166],
          // xi10
          bigOpSpacing3: [0.2, 0.2, 0.2],
          // xi11
          bigOpSpacing4: [0.6, 0.611, 0.611],
          // xi12; cmex7: 0.611
          bigOpSpacing5: [0.1, 0.143, 0.143],
          // xi13; cmex7: 0.143
          // The \sqrt rule width is taken from the height of the surd character.
          // Since we use the same font at all sizes, this thickness doesn't scale.
          sqrtRuleThickness: [0.04, 0.04, 0.04],
          // This value determines how large a pt is, for metrics which are defined
          // in terms of pts.
          // This value is also used in katex.scss; if you change it make sure the
          // values match.
          ptPerEm: [10, 10, 10],
          // The space between adjacent `|` columns in an array definition. From
          // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
          doubleRuleSep: [0.2, 0.2, 0.2],
          // The width of separator lines in {array} environments. From
          // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
          arrayRuleWidth: [0.04, 0.04, 0.04],
          // Two values from LaTeX source2e:
          fboxsep: [0.3, 0.3, 0.3],
          //        3 pt / ptPerEm
          fboxrule: [0.04, 0.04, 0.04]
          // 0.4 pt / ptPerEm
        };
        const extraCharacterMap = {
          // Latin-1
          "Å": "A",
          "Ð": "D",
          "Þ": "o",
          "å": "a",
          "ð": "d",
          "þ": "o",
          // Cyrillic
          "А": "A",
          "Б": "B",
          "В": "B",
          "Г": "F",
          "Д": "A",
          "Е": "E",
          "Ж": "K",
          "З": "3",
          "И": "N",
          "Й": "N",
          "К": "K",
          "Л": "N",
          "М": "M",
          "Н": "H",
          "О": "O",
          "П": "N",
          "Р": "P",
          "С": "C",
          "Т": "T",
          "У": "y",
          "Ф": "O",
          "Х": "X",
          "Ц": "U",
          "Ч": "h",
          "Ш": "W",
          "Щ": "W",
          "Ъ": "B",
          "Ы": "X",
          "Ь": "B",
          "Э": "3",
          "Ю": "X",
          "Я": "R",
          "а": "a",
          "б": "b",
          "в": "a",
          "г": "r",
          "д": "y",
          "е": "e",
          "ж": "m",
          "з": "e",
          "и": "n",
          "й": "n",
          "к": "n",
          "л": "n",
          "м": "m",
          "н": "n",
          "о": "o",
          "п": "n",
          "р": "p",
          "с": "c",
          "т": "o",
          "у": "y",
          "ф": "b",
          "х": "x",
          "ц": "n",
          "ч": "n",
          "ш": "w",
          "щ": "w",
          "ъ": "a",
          "ы": "m",
          "ь": "a",
          "э": "e",
          "ю": "m",
          "я": "r"
        };
        function setFontMetrics(fontName, metrics) {
          fontMetricsData[fontName] = metrics;
        }
        function getCharacterMetrics(character, font, mode) {
          if (!fontMetricsData[font]) {
            throw new Error("Font metrics not found for font: " + font + ".");
          }
          let ch = character.charCodeAt(0);
          let metrics = fontMetricsData[font][ch];
          if (!metrics && character[0] in extraCharacterMap) {
            ch = extraCharacterMap[character[0]].charCodeAt(0);
            metrics = fontMetricsData[font][ch];
          }
          if (!metrics && mode === "text") {
            if (supportedCodepoint(ch)) {
              metrics = fontMetricsData[font][77];
            }
          }
          if (metrics) {
            return {
              depth: metrics[0],
              height: metrics[1],
              italic: metrics[2],
              skew: metrics[3],
              width: metrics[4]
            };
          }
        }
        const fontMetricsBySizeIndex = {};
        function getGlobalMetrics(size) {
          let sizeIndex;
          if (size >= 5) {
            sizeIndex = 0;
          } else if (size >= 3) {
            sizeIndex = 1;
          } else {
            sizeIndex = 2;
          }
          if (!fontMetricsBySizeIndex[sizeIndex]) {
            const metrics = fontMetricsBySizeIndex[sizeIndex] = {
              cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
            };
            for (const key in sigmasAndXis) {
              if (sigmasAndXis.hasOwnProperty(key)) {
                metrics[key] = sigmasAndXis[key][sizeIndex];
              }
            }
          }
          return fontMetricsBySizeIndex[sizeIndex];
        }
        const sizeStyleMap = [
          // Each element contains [textsize, scriptsize, scriptscriptsize].
          // The size mappings are taken from TeX with \normalsize=10pt.
          [1, 1, 1],
          // size1: [5, 5, 5]              \tiny
          [2, 1, 1],
          // size2: [6, 5, 5]
          [3, 1, 1],
          // size3: [7, 5, 5]              \scriptsize
          [4, 2, 1],
          // size4: [8, 6, 5]              \footnotesize
          [5, 2, 1],
          // size5: [9, 6, 5]              \small
          [6, 3, 1],
          // size6: [10, 7, 5]             \normalsize
          [7, 4, 2],
          // size7: [12, 8, 6]             \large
          [8, 6, 3],
          // size8: [14.4, 10, 7]          \Large
          [9, 7, 6],
          // size9: [17.28, 12, 10]        \LARGE
          [10, 8, 7],
          // size10: [20.74, 14.4, 12]     \huge
          [11, 10, 9]
          // size11: [24.88, 20.74, 17.28] \HUGE
        ];
        const sizeMultipliers = [
          // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
          // you change size indexes, change that function.
          0.5,
          0.6,
          0.7,
          0.8,
          0.9,
          1,
          1.2,
          1.44,
          1.728,
          2.074,
          2.488
        ];
        const sizeAtStyle = function(size, style) {
          return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
        };
        class Options {
          // A font family applies to a group of fonts (i.e. SansSerif), while a font
          // represents a specific font (i.e. SansSerif Bold).
          // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
          /**
           * The base size index.
           */
          constructor(data2) {
            this.style = void 0;
            this.color = void 0;
            this.size = void 0;
            this.textSize = void 0;
            this.phantom = void 0;
            this.font = void 0;
            this.fontFamily = void 0;
            this.fontWeight = void 0;
            this.fontShape = void 0;
            this.sizeMultiplier = void 0;
            this.maxSize = void 0;
            this.minRuleThickness = void 0;
            this._fontMetrics = void 0;
            this.style = data2.style;
            this.color = data2.color;
            this.size = data2.size || Options.BASESIZE;
            this.textSize = data2.textSize || this.size;
            this.phantom = !!data2.phantom;
            this.font = data2.font || "";
            this.fontFamily = data2.fontFamily || "";
            this.fontWeight = data2.fontWeight || "";
            this.fontShape = data2.fontShape || "";
            this.sizeMultiplier = sizeMultipliers[this.size - 1];
            this.maxSize = data2.maxSize;
            this.minRuleThickness = data2.minRuleThickness;
            this._fontMetrics = void 0;
          }
          /**
           * Returns a new options object with the same properties as "this".  Properties
           * from "extension" will be copied to the new options object.
           */
          extend(extension) {
            const data2 = {
              style: this.style,
              size: this.size,
              textSize: this.textSize,
              color: this.color,
              phantom: this.phantom,
              font: this.font,
              fontFamily: this.fontFamily,
              fontWeight: this.fontWeight,
              fontShape: this.fontShape,
              maxSize: this.maxSize,
              minRuleThickness: this.minRuleThickness
            };
            for (const key in extension) {
              if (extension.hasOwnProperty(key)) {
                data2[key] = extension[key];
              }
            }
            return new Options(data2);
          }
          /**
           * Return an options object with the given style. If `this.style === style`,
           * returns `this`.
           */
          havingStyle(style) {
            if (this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: sizeAtStyle(this.textSize, style)
              });
            }
          }
          /**
           * Return an options object with a cramped version of the current style. If
           * the current style is cramped, returns `this`.
           */
          havingCrampedStyle() {
            return this.havingStyle(this.style.cramp());
          }
          /**
           * Return an options object with the given size and in at least `\textstyle`.
           * Returns `this` if appropriate.
           */
          havingSize(size) {
            if (this.size === size && this.textSize === size) {
              return this;
            } else {
              return this.extend({
                style: this.style.text(),
                size,
                textSize: size,
                sizeMultiplier: sizeMultipliers[size - 1]
              });
            }
          }
          /**
           * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
           * changes to at least `\textstyle`.
           */
          havingBaseStyle(style) {
            style = style || this.style.text();
            const wantSize = sizeAtStyle(Options.BASESIZE, style);
            if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: wantSize
              });
            }
          }
          /**
           * Remove the effect of sizing changes such as \Huge.
           * Keep the effect of the current style, such as \scriptstyle.
           */
          havingBaseSizing() {
            let size;
            switch (this.style.id) {
              case 4:
              case 5:
                size = 3;
                break;
              case 6:
              case 7:
                size = 1;
                break;
              default:
                size = 6;
            }
            return this.extend({
              style: this.style.text(),
              size
            });
          }
          /**
           * Create a new options object with the given color.
           */
          withColor(color2) {
            return this.extend({
              color: color2
            });
          }
          /**
           * Create a new options object with "phantom" set to true.
           */
          withPhantom() {
            return this.extend({
              phantom: true
            });
          }
          /**
           * Creates a new options object with the given math font or old text font.
           * @type {[type]}
           */
          withFont(font) {
            return this.extend({
              font
            });
          }
          /**
           * Create a new options objects with the given fontFamily.
           */
          withTextFontFamily(fontFamily) {
            return this.extend({
              fontFamily,
              font: ""
            });
          }
          /**
           * Creates a new options object with the given font weight
           */
          withTextFontWeight(fontWeight) {
            return this.extend({
              fontWeight,
              font: ""
            });
          }
          /**
           * Creates a new options object with the given font weight
           */
          withTextFontShape(fontShape) {
            return this.extend({
              fontShape,
              font: ""
            });
          }
          /**
           * Return the CSS sizing classes required to switch from enclosing options
           * `oldOptions` to `this`. Returns an array of classes.
           */
          sizingClasses(oldOptions) {
            if (oldOptions.size !== this.size) {
              return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
            } else {
              return [];
            }
          }
          /**
           * Return the CSS sizing classes required to switch to the base size. Like
           * `this.havingSize(BASESIZE).sizingClasses(this)`.
           */
          baseSizingClasses() {
            if (this.size !== Options.BASESIZE) {
              return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
            } else {
              return [];
            }
          }
          /**
           * Return the font metrics for this size.
           */
          fontMetrics() {
            if (!this._fontMetrics) {
              this._fontMetrics = getGlobalMetrics(this.size);
            }
            return this._fontMetrics;
          }
          /**
           * Gets the CSS color of the current options object
           */
          getColor() {
            if (this.phantom) {
              return "transparent";
            } else {
              return this.color;
            }
          }
        }
        Options.BASESIZE = 6;
        var src_Options = Options;
        const ptPerUnit = {
          // https://en.wikibooks.org/wiki/LaTeX/Lengths and
          // https://tex.stackexchange.com/a/8263
          "pt": 1,
          // TeX point
          "mm": 7227 / 2540,
          // millimeter
          "cm": 7227 / 254,
          // centimeter
          "in": 72.27,
          // inch
          "bp": 803 / 800,
          // big (PostScript) points
          "pc": 12,
          // pica
          "dd": 1238 / 1157,
          // didot
          "cc": 14856 / 1157,
          // cicero (12 didot)
          "nd": 685 / 642,
          // new didot
          "nc": 1370 / 107,
          // new cicero (12 new didot)
          "sp": 1 / 65536,
          // scaled point (TeX's internal smallest unit)
          // https://tex.stackexchange.com/a/41371
          "px": 803 / 800
          // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
        };
        const relativeUnit = {
          "ex": true,
          "em": true,
          "mu": true
        };
        const validUnit = function(unit) {
          if (typeof unit !== "string") {
            unit = unit.unit;
          }
          return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
        };
        const calculateSize = function(sizeValue, options) {
          let scale;
          if (sizeValue.unit in ptPerUnit) {
            scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
          } else if (sizeValue.unit === "mu") {
            scale = options.fontMetrics().cssEmPerMu;
          } else {
            let unitOptions;
            if (options.style.isTight()) {
              unitOptions = options.havingStyle(options.style.text());
            } else {
              unitOptions = options;
            }
            if (sizeValue.unit === "ex") {
              scale = unitOptions.fontMetrics().xHeight;
            } else if (sizeValue.unit === "em") {
              scale = unitOptions.fontMetrics().quad;
            } else {
              throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
            }
            if (unitOptions !== options) {
              scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          return Math.min(sizeValue.number * scale, options.maxSize);
        };
        const makeEm = function(n) {
          return +n.toFixed(4) + "em";
        };
        const createClass = function(classes) {
          return classes.filter((cls) => cls).join(" ");
        };
        const initNode = function(classes, options, style) {
          this.classes = classes || [];
          this.attributes = {};
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = style || {};
          if (options) {
            if (options.style.isTight()) {
              this.classes.push("mtight");
            }
            const color2 = options.getColor();
            if (color2) {
              this.style.color = color2;
            }
          }
        };
        const toNode = function(tagName) {
          const node2 = document.createElement(tagName);
          node2.className = createClass(this.classes);
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node2.style[style] = this.style[style];
            }
          }
          for (const attr2 in this.attributes) {
            if (this.attributes.hasOwnProperty(attr2)) {
              node2.setAttribute(attr2, this.attributes[attr2]);
            }
          }
          for (let i = 0; i < this.children.length; i++) {
            node2.appendChild(this.children[i].toNode());
          }
          return node2;
        };
        const invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
        const toMarkup = function(tagName) {
          let markup = "<" + tagName;
          if (this.classes.length) {
            markup += ' class="' + utils2.escape(createClass(this.classes)) + '"';
          }
          let styles3 = "";
          for (const style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles3) {
            markup += ' style="' + utils2.escape(styles3) + '"';
          }
          for (const attr2 in this.attributes) {
            if (this.attributes.hasOwnProperty(attr2)) {
              if (invalidAttributeNameRegex.test(attr2)) {
                throw new src_ParseError("Invalid attribute name '" + attr2 + "'");
              }
              markup += " " + attr2 + '="' + utils2.escape(this.attributes[attr2]) + '"';
            }
          }
          markup += ">";
          for (let i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</" + tagName + ">";
          return markup;
        };
        class Span {
          constructor(classes, children2, options, style) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options, style);
            this.children = children2 || [];
          }
          /**
           * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
           * all browsers support attributes the same, and having too many custom
           * attributes is probably bad.
           */
          setAttribute(attribute2, value) {
            this.attributes[attribute2] = value;
          }
          hasClass(className) {
            return utils2.contains(this.classes, className);
          }
          toNode() {
            return toNode.call(this, "span");
          }
          toMarkup() {
            return toMarkup.call(this, "span");
          }
        }
        class Anchor {
          constructor(href, classes, children2, options) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options);
            this.children = children2 || [];
            this.setAttribute("href", href);
          }
          setAttribute(attribute2, value) {
            this.attributes[attribute2] = value;
          }
          hasClass(className) {
            return utils2.contains(this.classes, className);
          }
          toNode() {
            return toNode.call(this, "a");
          }
          toMarkup() {
            return toMarkup.call(this, "a");
          }
        }
        class Img {
          constructor(src, alt, style) {
            this.src = void 0;
            this.alt = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.alt = alt;
            this.src = src;
            this.classes = ["mord"];
            this.style = style;
          }
          hasClass(className) {
            return utils2.contains(this.classes, className);
          }
          toNode() {
            const node2 = document.createElement("img");
            node2.src = this.src;
            node2.alt = this.alt;
            node2.className = "mord";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node2.style[style] = this.style[style];
              }
            }
            return node2;
          }
          toMarkup() {
            let markup = '<img src="' + utils2.escape(this.src) + '"' + (' alt="' + utils2.escape(this.alt) + '"');
            let styles3 = "";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles3) {
              markup += ' style="' + utils2.escape(styles3) + '"';
            }
            markup += "'/>";
            return markup;
          }
        }
        const iCombinations = {
          "î": "ı̂",
          "ï": "ı̈",
          "í": "ı́",
          // 'ī': '\u0131\u0304', // enable when we add Extended Latin
          "ì": "ı̀"
        };
        class SymbolNode {
          constructor(text2, height, depth, italic, skew2, width, classes, style) {
            this.text = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.italic = void 0;
            this.skew = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.classes = void 0;
            this.style = void 0;
            this.text = text2;
            this.height = height || 0;
            this.depth = depth || 0;
            this.italic = italic || 0;
            this.skew = skew2 || 0;
            this.width = width || 0;
            this.classes = classes || [];
            this.style = style || {};
            this.maxFontSize = 0;
            const script = scriptFromCodepoint(this.text.charCodeAt(0));
            if (script) {
              this.classes.push(script + "_fallback");
            }
            if (/[îïíì]/.test(this.text)) {
              this.text = iCombinations[this.text];
            }
          }
          hasClass(className) {
            return utils2.contains(this.classes, className);
          }
          /**
           * Creates a text node or span from a symbol node. Note that a span is only
           * created if it is needed.
           */
          toNode() {
            const node2 = document.createTextNode(this.text);
            let span = null;
            if (this.italic > 0) {
              span = document.createElement("span");
              span.style.marginRight = makeEm(this.italic);
            }
            if (this.classes.length > 0) {
              span = span || document.createElement("span");
              span.className = createClass(this.classes);
            }
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                span = span || document.createElement("span");
                span.style[style] = this.style[style];
              }
            }
            if (span) {
              span.appendChild(node2);
              return span;
            } else {
              return node2;
            }
          }
          /**
           * Creates markup for a symbol node.
           */
          toMarkup() {
            let needsSpan = false;
            let markup = "<span";
            if (this.classes.length) {
              needsSpan = true;
              markup += ' class="';
              markup += utils2.escape(createClass(this.classes));
              markup += '"';
            }
            let styles3 = "";
            if (this.italic > 0) {
              styles3 += "margin-right:" + this.italic + "em;";
            }
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles3) {
              needsSpan = true;
              markup += ' style="' + utils2.escape(styles3) + '"';
            }
            const escaped = utils2.escape(this.text);
            if (needsSpan) {
              markup += ">";
              markup += escaped;
              markup += "</span>";
              return markup;
            } else {
              return escaped;
            }
          }
        }
        class SvgNode {
          constructor(children2, attributes2) {
            this.children = void 0;
            this.attributes = void 0;
            this.children = children2 || [];
            this.attributes = attributes2 || {};
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node2 = document.createElementNS(svgNS, "svg");
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                node2.setAttribute(attr2, this.attributes[attr2]);
              }
            }
            for (let i = 0; i < this.children.length; i++) {
              node2.appendChild(this.children[i].toNode());
            }
            return node2;
          }
          toMarkup() {
            let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                markup += " " + attr2 + '="' + utils2.escape(this.attributes[attr2]) + '"';
              }
            }
            markup += ">";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</svg>";
            return markup;
          }
        }
        class PathNode {
          constructor(pathName, alternate) {
            this.pathName = void 0;
            this.alternate = void 0;
            this.pathName = pathName;
            this.alternate = alternate;
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node2 = document.createElementNS(svgNS, "path");
            if (this.alternate) {
              node2.setAttribute("d", this.alternate);
            } else {
              node2.setAttribute("d", path2[this.pathName]);
            }
            return node2;
          }
          toMarkup() {
            if (this.alternate) {
              return '<path d="' + utils2.escape(this.alternate) + '"/>';
            } else {
              return '<path d="' + utils2.escape(path2[this.pathName]) + '"/>';
            }
          }
        }
        class LineNode {
          constructor(attributes2) {
            this.attributes = void 0;
            this.attributes = attributes2 || {};
          }
          toNode() {
            const svgNS = "http://www.w3.org/2000/svg";
            const node2 = document.createElementNS(svgNS, "line");
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                node2.setAttribute(attr2, this.attributes[attr2]);
              }
            }
            return node2;
          }
          toMarkup() {
            let markup = "<line";
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                markup += " " + attr2 + '="' + utils2.escape(this.attributes[attr2]) + '"';
              }
            }
            markup += "/>";
            return markup;
          }
        }
        function assertSymbolDomNode(group) {
          if (group instanceof SymbolNode) {
            return group;
          } else {
            throw new Error("Expected symbolNode but got " + String(group) + ".");
          }
        }
        function assertSpan(group) {
          if (group instanceof Span) {
            return group;
          } else {
            throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
          }
        }
        const ATOMS = {
          "bin": 1,
          "close": 1,
          "inner": 1,
          "open": 1,
          "punct": 1,
          "rel": 1
        };
        const NON_ATOMS = {
          "accent-token": 1,
          "mathord": 1,
          "op-token": 1,
          "spacing": 1,
          "textord": 1
        };
        const symbols = {
          "math": {},
          "text": {}
        };
        var src_symbols = symbols;
        function defineSymbol(mode, font, group, replace2, name2, acceptUnicodeChar) {
          symbols[mode][name2] = {
            font,
            group,
            replace: replace2
          };
          if (acceptUnicodeChar && replace2) {
            symbols[mode][replace2] = symbols[mode][name2];
          }
        }
        const math = "math";
        const symbols_text = "text";
        const main = "main";
        const ams = "ams";
        const accent = "accent-token";
        const bin = "bin";
        const symbols_close = "close";
        const inner = "inner";
        const mathord = "mathord";
        const op = "op-token";
        const symbols_open = "open";
        const punct = "punct";
        const rel = "rel";
        const spacing = "spacing";
        const textord = "textord";
        defineSymbol(math, main, rel, "≡", "\\equiv", true);
        defineSymbol(math, main, rel, "≺", "\\prec", true);
        defineSymbol(math, main, rel, "≻", "\\succ", true);
        defineSymbol(math, main, rel, "∼", "\\sim", true);
        defineSymbol(math, main, rel, "⊥", "\\perp");
        defineSymbol(math, main, rel, "⪯", "\\preceq", true);
        defineSymbol(math, main, rel, "⪰", "\\succeq", true);
        defineSymbol(math, main, rel, "≃", "\\simeq", true);
        defineSymbol(math, main, rel, "∣", "\\mid", true);
        defineSymbol(math, main, rel, "≪", "\\ll", true);
        defineSymbol(math, main, rel, "≫", "\\gg", true);
        defineSymbol(math, main, rel, "≍", "\\asymp", true);
        defineSymbol(math, main, rel, "∥", "\\parallel");
        defineSymbol(math, main, rel, "⋈", "\\bowtie", true);
        defineSymbol(math, main, rel, "⌣", "\\smile", true);
        defineSymbol(math, main, rel, "⊑", "\\sqsubseteq", true);
        defineSymbol(math, main, rel, "⊒", "\\sqsupseteq", true);
        defineSymbol(math, main, rel, "≐", "\\doteq", true);
        defineSymbol(math, main, rel, "⌢", "\\frown", true);
        defineSymbol(math, main, rel, "∋", "\\ni", true);
        defineSymbol(math, main, rel, "∝", "\\propto", true);
        defineSymbol(math, main, rel, "⊢", "\\vdash", true);
        defineSymbol(math, main, rel, "⊣", "\\dashv", true);
        defineSymbol(math, main, rel, "∋", "\\owns");
        defineSymbol(math, main, punct, ".", "\\ldotp");
        defineSymbol(math, main, punct, "⋅", "\\cdotp");
        defineSymbol(math, main, textord, "#", "\\#");
        defineSymbol(symbols_text, main, textord, "#", "\\#");
        defineSymbol(math, main, textord, "&", "\\&");
        defineSymbol(symbols_text, main, textord, "&", "\\&");
        defineSymbol(math, main, textord, "ℵ", "\\aleph", true);
        defineSymbol(math, main, textord, "∀", "\\forall", true);
        defineSymbol(math, main, textord, "ℏ", "\\hbar", true);
        defineSymbol(math, main, textord, "∃", "\\exists", true);
        defineSymbol(math, main, textord, "∇", "\\nabla", true);
        defineSymbol(math, main, textord, "♭", "\\flat", true);
        defineSymbol(math, main, textord, "ℓ", "\\ell", true);
        defineSymbol(math, main, textord, "♮", "\\natural", true);
        defineSymbol(math, main, textord, "♣", "\\clubsuit", true);
        defineSymbol(math, main, textord, "℘", "\\wp", true);
        defineSymbol(math, main, textord, "♯", "\\sharp", true);
        defineSymbol(math, main, textord, "♢", "\\diamondsuit", true);
        defineSymbol(math, main, textord, "ℜ", "\\Re", true);
        defineSymbol(math, main, textord, "♡", "\\heartsuit", true);
        defineSymbol(math, main, textord, "ℑ", "\\Im", true);
        defineSymbol(math, main, textord, "♠", "\\spadesuit", true);
        defineSymbol(math, main, textord, "§", "\\S", true);
        defineSymbol(symbols_text, main, textord, "§", "\\S");
        defineSymbol(math, main, textord, "¶", "\\P", true);
        defineSymbol(symbols_text, main, textord, "¶", "\\P");
        defineSymbol(math, main, textord, "†", "\\dag");
        defineSymbol(symbols_text, main, textord, "†", "\\dag");
        defineSymbol(symbols_text, main, textord, "†", "\\textdagger");
        defineSymbol(math, main, textord, "‡", "\\ddag");
        defineSymbol(symbols_text, main, textord, "‡", "\\ddag");
        defineSymbol(symbols_text, main, textord, "‡", "\\textdaggerdbl");
        defineSymbol(math, main, symbols_close, "⎱", "\\rmoustache", true);
        defineSymbol(math, main, symbols_open, "⎰", "\\lmoustache", true);
        defineSymbol(math, main, symbols_close, "⟯", "\\rgroup", true);
        defineSymbol(math, main, symbols_open, "⟮", "\\lgroup", true);
        defineSymbol(math, main, bin, "∓", "\\mp", true);
        defineSymbol(math, main, bin, "⊖", "\\ominus", true);
        defineSymbol(math, main, bin, "⊎", "\\uplus", true);
        defineSymbol(math, main, bin, "⊓", "\\sqcap", true);
        defineSymbol(math, main, bin, "∗", "\\ast");
        defineSymbol(math, main, bin, "⊔", "\\sqcup", true);
        defineSymbol(math, main, bin, "◯", "\\bigcirc", true);
        defineSymbol(math, main, bin, "∙", "\\bullet", true);
        defineSymbol(math, main, bin, "‡", "\\ddagger");
        defineSymbol(math, main, bin, "≀", "\\wr", true);
        defineSymbol(math, main, bin, "⨿", "\\amalg");
        defineSymbol(math, main, bin, "&", "\\And");
        defineSymbol(math, main, rel, "⟵", "\\longleftarrow", true);
        defineSymbol(math, main, rel, "⇐", "\\Leftarrow", true);
        defineSymbol(math, main, rel, "⟸", "\\Longleftarrow", true);
        defineSymbol(math, main, rel, "⟶", "\\longrightarrow", true);
        defineSymbol(math, main, rel, "⇒", "\\Rightarrow", true);
        defineSymbol(math, main, rel, "⟹", "\\Longrightarrow", true);
        defineSymbol(math, main, rel, "↔", "\\leftrightarrow", true);
        defineSymbol(math, main, rel, "⟷", "\\longleftrightarrow", true);
        defineSymbol(math, main, rel, "⇔", "\\Leftrightarrow", true);
        defineSymbol(math, main, rel, "⟺", "\\Longleftrightarrow", true);
        defineSymbol(math, main, rel, "↦", "\\mapsto", true);
        defineSymbol(math, main, rel, "⟼", "\\longmapsto", true);
        defineSymbol(math, main, rel, "↗", "\\nearrow", true);
        defineSymbol(math, main, rel, "↩", "\\hookleftarrow", true);
        defineSymbol(math, main, rel, "↪", "\\hookrightarrow", true);
        defineSymbol(math, main, rel, "↘", "\\searrow", true);
        defineSymbol(math, main, rel, "↼", "\\leftharpoonup", true);
        defineSymbol(math, main, rel, "⇀", "\\rightharpoonup", true);
        defineSymbol(math, main, rel, "↙", "\\swarrow", true);
        defineSymbol(math, main, rel, "↽", "\\leftharpoondown", true);
        defineSymbol(math, main, rel, "⇁", "\\rightharpoondown", true);
        defineSymbol(math, main, rel, "↖", "\\nwarrow", true);
        defineSymbol(math, main, rel, "⇌", "\\rightleftharpoons", true);
        defineSymbol(math, ams, rel, "≮", "\\nless", true);
        defineSymbol(math, ams, rel, "", "\\@nleqslant");
        defineSymbol(math, ams, rel, "", "\\@nleqq");
        defineSymbol(math, ams, rel, "⪇", "\\lneq", true);
        defineSymbol(math, ams, rel, "≨", "\\lneqq", true);
        defineSymbol(math, ams, rel, "", "\\@lvertneqq");
        defineSymbol(math, ams, rel, "⋦", "\\lnsim", true);
        defineSymbol(math, ams, rel, "⪉", "\\lnapprox", true);
        defineSymbol(math, ams, rel, "⊀", "\\nprec", true);
        defineSymbol(math, ams, rel, "⋠", "\\npreceq", true);
        defineSymbol(math, ams, rel, "⋨", "\\precnsim", true);
        defineSymbol(math, ams, rel, "⪹", "\\precnapprox", true);
        defineSymbol(math, ams, rel, "≁", "\\nsim", true);
        defineSymbol(math, ams, rel, "", "\\@nshortmid");
        defineSymbol(math, ams, rel, "∤", "\\nmid", true);
        defineSymbol(math, ams, rel, "⊬", "\\nvdash", true);
        defineSymbol(math, ams, rel, "⊭", "\\nvDash", true);
        defineSymbol(math, ams, rel, "⋪", "\\ntriangleleft");
        defineSymbol(math, ams, rel, "⋬", "\\ntrianglelefteq", true);
        defineSymbol(math, ams, rel, "⊊", "\\subsetneq", true);
        defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
        defineSymbol(math, ams, rel, "⫋", "\\subsetneqq", true);
        defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
        defineSymbol(math, ams, rel, "≯", "\\ngtr", true);
        defineSymbol(math, ams, rel, "", "\\@ngeqslant");
        defineSymbol(math, ams, rel, "", "\\@ngeqq");
        defineSymbol(math, ams, rel, "⪈", "\\gneq", true);
        defineSymbol(math, ams, rel, "≩", "\\gneqq", true);
        defineSymbol(math, ams, rel, "", "\\@gvertneqq");
        defineSymbol(math, ams, rel, "⋧", "\\gnsim", true);
        defineSymbol(math, ams, rel, "⪊", "\\gnapprox", true);
        defineSymbol(math, ams, rel, "⊁", "\\nsucc", true);
        defineSymbol(math, ams, rel, "⋡", "\\nsucceq", true);
        defineSymbol(math, ams, rel, "⋩", "\\succnsim", true);
        defineSymbol(math, ams, rel, "⪺", "\\succnapprox", true);
        defineSymbol(math, ams, rel, "≆", "\\ncong", true);
        defineSymbol(math, ams, rel, "", "\\@nshortparallel");
        defineSymbol(math, ams, rel, "∦", "\\nparallel", true);
        defineSymbol(math, ams, rel, "⊯", "\\nVDash", true);
        defineSymbol(math, ams, rel, "⋫", "\\ntriangleright");
        defineSymbol(math, ams, rel, "⋭", "\\ntrianglerighteq", true);
        defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
        defineSymbol(math, ams, rel, "⊋", "\\supsetneq", true);
        defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
        defineSymbol(math, ams, rel, "⫌", "\\supsetneqq", true);
        defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
        defineSymbol(math, ams, rel, "⊮", "\\nVdash", true);
        defineSymbol(math, ams, rel, "⪵", "\\precneqq", true);
        defineSymbol(math, ams, rel, "⪶", "\\succneqq", true);
        defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
        defineSymbol(math, ams, bin, "⊴", "\\unlhd");
        defineSymbol(math, ams, bin, "⊵", "\\unrhd");
        defineSymbol(math, ams, rel, "↚", "\\nleftarrow", true);
        defineSymbol(math, ams, rel, "↛", "\\nrightarrow", true);
        defineSymbol(math, ams, rel, "⇍", "\\nLeftarrow", true);
        defineSymbol(math, ams, rel, "⇏", "\\nRightarrow", true);
        defineSymbol(math, ams, rel, "↮", "\\nleftrightarrow", true);
        defineSymbol(math, ams, rel, "⇎", "\\nLeftrightarrow", true);
        defineSymbol(math, ams, rel, "△", "\\vartriangle");
        defineSymbol(math, ams, textord, "ℏ", "\\hslash");
        defineSymbol(math, ams, textord, "▽", "\\triangledown");
        defineSymbol(math, ams, textord, "◊", "\\lozenge");
        defineSymbol(math, ams, textord, "Ⓢ", "\\circledS");
        defineSymbol(math, ams, textord, "®", "\\circledR");
        defineSymbol(symbols_text, ams, textord, "®", "\\circledR");
        defineSymbol(math, ams, textord, "∡", "\\measuredangle", true);
        defineSymbol(math, ams, textord, "∄", "\\nexists");
        defineSymbol(math, ams, textord, "℧", "\\mho");
        defineSymbol(math, ams, textord, "Ⅎ", "\\Finv", true);
        defineSymbol(math, ams, textord, "⅁", "\\Game", true);
        defineSymbol(math, ams, textord, "‵", "\\backprime");
        defineSymbol(math, ams, textord, "▲", "\\blacktriangle");
        defineSymbol(math, ams, textord, "▼", "\\blacktriangledown");
        defineSymbol(math, ams, textord, "■", "\\blacksquare");
        defineSymbol(math, ams, textord, "⧫", "\\blacklozenge");
        defineSymbol(math, ams, textord, "★", "\\bigstar");
        defineSymbol(math, ams, textord, "∢", "\\sphericalangle", true);
        defineSymbol(math, ams, textord, "∁", "\\complement", true);
        defineSymbol(math, ams, textord, "ð", "\\eth", true);
        defineSymbol(symbols_text, main, textord, "ð", "ð");
        defineSymbol(math, ams, textord, "╱", "\\diagup");
        defineSymbol(math, ams, textord, "╲", "\\diagdown");
        defineSymbol(math, ams, textord, "□", "\\square");
        defineSymbol(math, ams, textord, "□", "\\Box");
        defineSymbol(math, ams, textord, "◊", "\\Diamond");
        defineSymbol(math, ams, textord, "¥", "\\yen", true);
        defineSymbol(symbols_text, ams, textord, "¥", "\\yen", true);
        defineSymbol(math, ams, textord, "✓", "\\checkmark", true);
        defineSymbol(symbols_text, ams, textord, "✓", "\\checkmark");
        defineSymbol(math, ams, textord, "ℶ", "\\beth", true);
        defineSymbol(math, ams, textord, "ℸ", "\\daleth", true);
        defineSymbol(math, ams, textord, "ℷ", "\\gimel", true);
        defineSymbol(math, ams, textord, "ϝ", "\\digamma", true);
        defineSymbol(math, ams, textord, "ϰ", "\\varkappa");
        defineSymbol(math, ams, symbols_open, "┌", "\\@ulcorner", true);
        defineSymbol(math, ams, symbols_close, "┐", "\\@urcorner", true);
        defineSymbol(math, ams, symbols_open, "└", "\\@llcorner", true);
        defineSymbol(math, ams, symbols_close, "┘", "\\@lrcorner", true);
        defineSymbol(math, ams, rel, "≦", "\\leqq", true);
        defineSymbol(math, ams, rel, "⩽", "\\leqslant", true);
        defineSymbol(math, ams, rel, "⪕", "\\eqslantless", true);
        defineSymbol(math, ams, rel, "≲", "\\lesssim", true);
        defineSymbol(math, ams, rel, "⪅", "\\lessapprox", true);
        defineSymbol(math, ams, rel, "≊", "\\approxeq", true);
        defineSymbol(math, ams, bin, "⋖", "\\lessdot");
        defineSymbol(math, ams, rel, "⋘", "\\lll", true);
        defineSymbol(math, ams, rel, "≶", "\\lessgtr", true);
        defineSymbol(math, ams, rel, "⋚", "\\lesseqgtr", true);
        defineSymbol(math, ams, rel, "⪋", "\\lesseqqgtr", true);
        defineSymbol(math, ams, rel, "≑", "\\doteqdot");
        defineSymbol(math, ams, rel, "≓", "\\risingdotseq", true);
        defineSymbol(math, ams, rel, "≒", "\\fallingdotseq", true);
        defineSymbol(math, ams, rel, "∽", "\\backsim", true);
        defineSymbol(math, ams, rel, "⋍", "\\backsimeq", true);
        defineSymbol(math, ams, rel, "⫅", "\\subseteqq", true);
        defineSymbol(math, ams, rel, "⋐", "\\Subset", true);
        defineSymbol(math, ams, rel, "⊏", "\\sqsubset", true);
        defineSymbol(math, ams, rel, "≼", "\\preccurlyeq", true);
        defineSymbol(math, ams, rel, "⋞", "\\curlyeqprec", true);
        defineSymbol(math, ams, rel, "≾", "\\precsim", true);
        defineSymbol(math, ams, rel, "⪷", "\\precapprox", true);
        defineSymbol(math, ams, rel, "⊲", "\\vartriangleleft");
        defineSymbol(math, ams, rel, "⊴", "\\trianglelefteq");
        defineSymbol(math, ams, rel, "⊨", "\\vDash", true);
        defineSymbol(math, ams, rel, "⊪", "\\Vvdash", true);
        defineSymbol(math, ams, rel, "⌣", "\\smallsmile");
        defineSymbol(math, ams, rel, "⌢", "\\smallfrown");
        defineSymbol(math, ams, rel, "≏", "\\bumpeq", true);
        defineSymbol(math, ams, rel, "≎", "\\Bumpeq", true);
        defineSymbol(math, ams, rel, "≧", "\\geqq", true);
        defineSymbol(math, ams, rel, "⩾", "\\geqslant", true);
        defineSymbol(math, ams, rel, "⪖", "\\eqslantgtr", true);
        defineSymbol(math, ams, rel, "≳", "\\gtrsim", true);
        defineSymbol(math, ams, rel, "⪆", "\\gtrapprox", true);
        defineSymbol(math, ams, bin, "⋗", "\\gtrdot");
        defineSymbol(math, ams, rel, "⋙", "\\ggg", true);
        defineSymbol(math, ams, rel, "≷", "\\gtrless", true);
        defineSymbol(math, ams, rel, "⋛", "\\gtreqless", true);
        defineSymbol(math, ams, rel, "⪌", "\\gtreqqless", true);
        defineSymbol(math, ams, rel, "≖", "\\eqcirc", true);
        defineSymbol(math, ams, rel, "≗", "\\circeq", true);
        defineSymbol(math, ams, rel, "≜", "\\triangleq", true);
        defineSymbol(math, ams, rel, "∼", "\\thicksim");
        defineSymbol(math, ams, rel, "≈", "\\thickapprox");
        defineSymbol(math, ams, rel, "⫆", "\\supseteqq", true);
        defineSymbol(math, ams, rel, "⋑", "\\Supset", true);
        defineSymbol(math, ams, rel, "⊐", "\\sqsupset", true);
        defineSymbol(math, ams, rel, "≽", "\\succcurlyeq", true);
        defineSymbol(math, ams, rel, "⋟", "\\curlyeqsucc", true);
        defineSymbol(math, ams, rel, "≿", "\\succsim", true);
        defineSymbol(math, ams, rel, "⪸", "\\succapprox", true);
        defineSymbol(math, ams, rel, "⊳", "\\vartriangleright");
        defineSymbol(math, ams, rel, "⊵", "\\trianglerighteq");
        defineSymbol(math, ams, rel, "⊩", "\\Vdash", true);
        defineSymbol(math, ams, rel, "∣", "\\shortmid");
        defineSymbol(math, ams, rel, "∥", "\\shortparallel");
        defineSymbol(math, ams, rel, "≬", "\\between", true);
        defineSymbol(math, ams, rel, "⋔", "\\pitchfork", true);
        defineSymbol(math, ams, rel, "∝", "\\varpropto");
        defineSymbol(math, ams, rel, "◀", "\\blacktriangleleft");
        defineSymbol(math, ams, rel, "∴", "\\therefore", true);
        defineSymbol(math, ams, rel, "∍", "\\backepsilon");
        defineSymbol(math, ams, rel, "▶", "\\blacktriangleright");
        defineSymbol(math, ams, rel, "∵", "\\because", true);
        defineSymbol(math, ams, rel, "⋘", "\\llless");
        defineSymbol(math, ams, rel, "⋙", "\\gggtr");
        defineSymbol(math, ams, bin, "⊲", "\\lhd");
        defineSymbol(math, ams, bin, "⊳", "\\rhd");
        defineSymbol(math, ams, rel, "≂", "\\eqsim", true);
        defineSymbol(math, main, rel, "⋈", "\\Join");
        defineSymbol(math, ams, rel, "≑", "\\Doteq", true);
        defineSymbol(math, ams, bin, "∔", "\\dotplus", true);
        defineSymbol(math, ams, bin, "∖", "\\smallsetminus");
        defineSymbol(math, ams, bin, "⋒", "\\Cap", true);
        defineSymbol(math, ams, bin, "⋓", "\\Cup", true);
        defineSymbol(math, ams, bin, "⩞", "\\doublebarwedge", true);
        defineSymbol(math, ams, bin, "⊟", "\\boxminus", true);
        defineSymbol(math, ams, bin, "⊞", "\\boxplus", true);
        defineSymbol(math, ams, bin, "⋇", "\\divideontimes", true);
        defineSymbol(math, ams, bin, "⋉", "\\ltimes", true);
        defineSymbol(math, ams, bin, "⋊", "\\rtimes", true);
        defineSymbol(math, ams, bin, "⋋", "\\leftthreetimes", true);
        defineSymbol(math, ams, bin, "⋌", "\\rightthreetimes", true);
        defineSymbol(math, ams, bin, "⋏", "\\curlywedge", true);
        defineSymbol(math, ams, bin, "⋎", "\\curlyvee", true);
        defineSymbol(math, ams, bin, "⊝", "\\circleddash", true);
        defineSymbol(math, ams, bin, "⊛", "\\circledast", true);
        defineSymbol(math, ams, bin, "⋅", "\\centerdot");
        defineSymbol(math, ams, bin, "⊺", "\\intercal", true);
        defineSymbol(math, ams, bin, "⋒", "\\doublecap");
        defineSymbol(math, ams, bin, "⋓", "\\doublecup");
        defineSymbol(math, ams, bin, "⊠", "\\boxtimes", true);
        defineSymbol(math, ams, rel, "⇢", "\\dashrightarrow", true);
        defineSymbol(math, ams, rel, "⇠", "\\dashleftarrow", true);
        defineSymbol(math, ams, rel, "⇇", "\\leftleftarrows", true);
        defineSymbol(math, ams, rel, "⇆", "\\leftrightarrows", true);
        defineSymbol(math, ams, rel, "⇚", "\\Lleftarrow", true);
        defineSymbol(math, ams, rel, "↞", "\\twoheadleftarrow", true);
        defineSymbol(math, ams, rel, "↢", "\\leftarrowtail", true);
        defineSymbol(math, ams, rel, "↫", "\\looparrowleft", true);
        defineSymbol(math, ams, rel, "⇋", "\\leftrightharpoons", true);
        defineSymbol(math, ams, rel, "↶", "\\curvearrowleft", true);
        defineSymbol(math, ams, rel, "↺", "\\circlearrowleft", true);
        defineSymbol(math, ams, rel, "↰", "\\Lsh", true);
        defineSymbol(math, ams, rel, "⇈", "\\upuparrows", true);
        defineSymbol(math, ams, rel, "↿", "\\upharpoonleft", true);
        defineSymbol(math, ams, rel, "⇃", "\\downharpoonleft", true);
        defineSymbol(math, main, rel, "⊶", "\\origof", true);
        defineSymbol(math, main, rel, "⊷", "\\imageof", true);
        defineSymbol(math, ams, rel, "⊸", "\\multimap", true);
        defineSymbol(math, ams, rel, "↭", "\\leftrightsquigarrow", true);
        defineSymbol(math, ams, rel, "⇉", "\\rightrightarrows", true);
        defineSymbol(math, ams, rel, "⇄", "\\rightleftarrows", true);
        defineSymbol(math, ams, rel, "↠", "\\twoheadrightarrow", true);
        defineSymbol(math, ams, rel, "↣", "\\rightarrowtail", true);
        defineSymbol(math, ams, rel, "↬", "\\looparrowright", true);
        defineSymbol(math, ams, rel, "↷", "\\curvearrowright", true);
        defineSymbol(math, ams, rel, "↻", "\\circlearrowright", true);
        defineSymbol(math, ams, rel, "↱", "\\Rsh", true);
        defineSymbol(math, ams, rel, "⇊", "\\downdownarrows", true);
        defineSymbol(math, ams, rel, "↾", "\\upharpoonright", true);
        defineSymbol(math, ams, rel, "⇂", "\\downharpoonright", true);
        defineSymbol(math, ams, rel, "⇝", "\\rightsquigarrow", true);
        defineSymbol(math, ams, rel, "⇝", "\\leadsto");
        defineSymbol(math, ams, rel, "⇛", "\\Rrightarrow", true);
        defineSymbol(math, ams, rel, "↾", "\\restriction");
        defineSymbol(math, main, textord, "‘", "`");
        defineSymbol(math, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
        defineSymbol(math, main, textord, "%", "\\%");
        defineSymbol(symbols_text, main, textord, "%", "\\%");
        defineSymbol(math, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
        defineSymbol(math, main, textord, "∠", "\\angle", true);
        defineSymbol(math, main, textord, "∞", "\\infty", true);
        defineSymbol(math, main, textord, "′", "\\prime");
        defineSymbol(math, main, textord, "△", "\\triangle");
        defineSymbol(math, main, textord, "Γ", "\\Gamma", true);
        defineSymbol(math, main, textord, "Δ", "\\Delta", true);
        defineSymbol(math, main, textord, "Θ", "\\Theta", true);
        defineSymbol(math, main, textord, "Λ", "\\Lambda", true);
        defineSymbol(math, main, textord, "Ξ", "\\Xi", true);
        defineSymbol(math, main, textord, "Π", "\\Pi", true);
        defineSymbol(math, main, textord, "Σ", "\\Sigma", true);
        defineSymbol(math, main, textord, "Υ", "\\Upsilon", true);
        defineSymbol(math, main, textord, "Φ", "\\Phi", true);
        defineSymbol(math, main, textord, "Ψ", "\\Psi", true);
        defineSymbol(math, main, textord, "Ω", "\\Omega", true);
        defineSymbol(math, main, textord, "A", "Α");
        defineSymbol(math, main, textord, "B", "Β");
        defineSymbol(math, main, textord, "E", "Ε");
        defineSymbol(math, main, textord, "Z", "Ζ");
        defineSymbol(math, main, textord, "H", "Η");
        defineSymbol(math, main, textord, "I", "Ι");
        defineSymbol(math, main, textord, "K", "Κ");
        defineSymbol(math, main, textord, "M", "Μ");
        defineSymbol(math, main, textord, "N", "Ν");
        defineSymbol(math, main, textord, "O", "Ο");
        defineSymbol(math, main, textord, "P", "Ρ");
        defineSymbol(math, main, textord, "T", "Τ");
        defineSymbol(math, main, textord, "X", "Χ");
        defineSymbol(math, main, textord, "¬", "\\neg", true);
        defineSymbol(math, main, textord, "¬", "\\lnot");
        defineSymbol(math, main, textord, "⊤", "\\top");
        defineSymbol(math, main, textord, "⊥", "\\bot");
        defineSymbol(math, main, textord, "∅", "\\emptyset");
        defineSymbol(math, ams, textord, "∅", "\\varnothing");
        defineSymbol(math, main, mathord, "α", "\\alpha", true);
        defineSymbol(math, main, mathord, "β", "\\beta", true);
        defineSymbol(math, main, mathord, "γ", "\\gamma", true);
        defineSymbol(math, main, mathord, "δ", "\\delta", true);
        defineSymbol(math, main, mathord, "ϵ", "\\epsilon", true);
        defineSymbol(math, main, mathord, "ζ", "\\zeta", true);
        defineSymbol(math, main, mathord, "η", "\\eta", true);
        defineSymbol(math, main, mathord, "θ", "\\theta", true);
        defineSymbol(math, main, mathord, "ι", "\\iota", true);
        defineSymbol(math, main, mathord, "κ", "\\kappa", true);
        defineSymbol(math, main, mathord, "λ", "\\lambda", true);
        defineSymbol(math, main, mathord, "μ", "\\mu", true);
        defineSymbol(math, main, mathord, "ν", "\\nu", true);
        defineSymbol(math, main, mathord, "ξ", "\\xi", true);
        defineSymbol(math, main, mathord, "ο", "\\omicron", true);
        defineSymbol(math, main, mathord, "π", "\\pi", true);
        defineSymbol(math, main, mathord, "ρ", "\\rho", true);
        defineSymbol(math, main, mathord, "σ", "\\sigma", true);
        defineSymbol(math, main, mathord, "τ", "\\tau", true);
        defineSymbol(math, main, mathord, "υ", "\\upsilon", true);
        defineSymbol(math, main, mathord, "ϕ", "\\phi", true);
        defineSymbol(math, main, mathord, "χ", "\\chi", true);
        defineSymbol(math, main, mathord, "ψ", "\\psi", true);
        defineSymbol(math, main, mathord, "ω", "\\omega", true);
        defineSymbol(math, main, mathord, "ε", "\\varepsilon", true);
        defineSymbol(math, main, mathord, "ϑ", "\\vartheta", true);
        defineSymbol(math, main, mathord, "ϖ", "\\varpi", true);
        defineSymbol(math, main, mathord, "ϱ", "\\varrho", true);
        defineSymbol(math, main, mathord, "ς", "\\varsigma", true);
        defineSymbol(math, main, mathord, "φ", "\\varphi", true);
        defineSymbol(math, main, bin, "∗", "*", true);
        defineSymbol(math, main, bin, "+", "+");
        defineSymbol(math, main, bin, "−", "-", true);
        defineSymbol(math, main, bin, "⋅", "\\cdot", true);
        defineSymbol(math, main, bin, "∘", "\\circ", true);
        defineSymbol(math, main, bin, "÷", "\\div", true);
        defineSymbol(math, main, bin, "±", "\\pm", true);
        defineSymbol(math, main, bin, "×", "\\times", true);
        defineSymbol(math, main, bin, "∩", "\\cap", true);
        defineSymbol(math, main, bin, "∪", "\\cup", true);
        defineSymbol(math, main, bin, "∖", "\\setminus", true);
        defineSymbol(math, main, bin, "∧", "\\land");
        defineSymbol(math, main, bin, "∨", "\\lor");
        defineSymbol(math, main, bin, "∧", "\\wedge", true);
        defineSymbol(math, main, bin, "∨", "\\vee", true);
        defineSymbol(math, main, textord, "√", "\\surd");
        defineSymbol(math, main, symbols_open, "⟨", "\\langle", true);
        defineSymbol(math, main, symbols_open, "∣", "\\lvert");
        defineSymbol(math, main, symbols_open, "∥", "\\lVert");
        defineSymbol(math, main, symbols_close, "?", "?");
        defineSymbol(math, main, symbols_close, "!", "!");
        defineSymbol(math, main, symbols_close, "⟩", "\\rangle", true);
        defineSymbol(math, main, symbols_close, "∣", "\\rvert");
        defineSymbol(math, main, symbols_close, "∥", "\\rVert");
        defineSymbol(math, main, rel, "=", "=");
        defineSymbol(math, main, rel, ":", ":");
        defineSymbol(math, main, rel, "≈", "\\approx", true);
        defineSymbol(math, main, rel, "≅", "\\cong", true);
        defineSymbol(math, main, rel, "≥", "\\ge");
        defineSymbol(math, main, rel, "≥", "\\geq", true);
        defineSymbol(math, main, rel, "←", "\\gets");
        defineSymbol(math, main, rel, ">", "\\gt", true);
        defineSymbol(math, main, rel, "∈", "\\in", true);
        defineSymbol(math, main, rel, "", "\\@not");
        defineSymbol(math, main, rel, "⊂", "\\subset", true);
        defineSymbol(math, main, rel, "⊃", "\\supset", true);
        defineSymbol(math, main, rel, "⊆", "\\subseteq", true);
        defineSymbol(math, main, rel, "⊇", "\\supseteq", true);
        defineSymbol(math, ams, rel, "⊈", "\\nsubseteq", true);
        defineSymbol(math, ams, rel, "⊉", "\\nsupseteq", true);
        defineSymbol(math, main, rel, "⊨", "\\models");
        defineSymbol(math, main, rel, "←", "\\leftarrow", true);
        defineSymbol(math, main, rel, "≤", "\\le");
        defineSymbol(math, main, rel, "≤", "\\leq", true);
        defineSymbol(math, main, rel, "<", "\\lt", true);
        defineSymbol(math, main, rel, "→", "\\rightarrow", true);
        defineSymbol(math, main, rel, "→", "\\to");
        defineSymbol(math, ams, rel, "≱", "\\ngeq", true);
        defineSymbol(math, ams, rel, "≰", "\\nleq", true);
        defineSymbol(math, main, spacing, " ", "\\ ");
        defineSymbol(math, main, spacing, " ", "\\space");
        defineSymbol(math, main, spacing, " ", "\\nobreakspace");
        defineSymbol(symbols_text, main, spacing, " ", "\\ ");
        defineSymbol(symbols_text, main, spacing, " ", " ");
        defineSymbol(symbols_text, main, spacing, " ", "\\space");
        defineSymbol(symbols_text, main, spacing, " ", "\\nobreakspace");
        defineSymbol(math, main, spacing, null, "\\nobreak");
        defineSymbol(math, main, spacing, null, "\\allowbreak");
        defineSymbol(math, main, punct, ",", ",");
        defineSymbol(math, main, punct, ";", ";");
        defineSymbol(math, ams, bin, "⊼", "\\barwedge", true);
        defineSymbol(math, ams, bin, "⊻", "\\veebar", true);
        defineSymbol(math, main, bin, "⊙", "\\odot", true);
        defineSymbol(math, main, bin, "⊕", "\\oplus", true);
        defineSymbol(math, main, bin, "⊗", "\\otimes", true);
        defineSymbol(math, main, textord, "∂", "\\partial", true);
        defineSymbol(math, main, bin, "⊘", "\\oslash", true);
        defineSymbol(math, ams, bin, "⊚", "\\circledcirc", true);
        defineSymbol(math, ams, bin, "⊡", "\\boxdot", true);
        defineSymbol(math, main, bin, "△", "\\bigtriangleup");
        defineSymbol(math, main, bin, "▽", "\\bigtriangledown");
        defineSymbol(math, main, bin, "†", "\\dagger");
        defineSymbol(math, main, bin, "⋄", "\\diamond");
        defineSymbol(math, main, bin, "⋆", "\\star");
        defineSymbol(math, main, bin, "◃", "\\triangleleft");
        defineSymbol(math, main, bin, "▹", "\\triangleright");
        defineSymbol(math, main, symbols_open, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
        defineSymbol(math, main, symbols_close, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
        defineSymbol(math, main, symbols_open, "{", "\\lbrace");
        defineSymbol(math, main, symbols_close, "}", "\\rbrace");
        defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
        defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
        defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
        defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
        defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
        defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
        defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
        defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
        defineSymbol(math, main, symbols_open, "⌊", "\\lfloor", true);
        defineSymbol(math, main, symbols_close, "⌋", "\\rfloor", true);
        defineSymbol(math, main, symbols_open, "⌈", "\\lceil", true);
        defineSymbol(math, main, symbols_close, "⌉", "\\rceil", true);
        defineSymbol(math, main, textord, "\\", "\\backslash");
        defineSymbol(math, main, textord, "∣", "|");
        defineSymbol(math, main, textord, "∣", "\\vert");
        defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
        defineSymbol(math, main, textord, "∥", "\\|");
        defineSymbol(math, main, textord, "∥", "\\Vert");
        defineSymbol(symbols_text, main, textord, "∥", "\\textbardbl");
        defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
        defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
        defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
        defineSymbol(math, main, rel, "↑", "\\uparrow", true);
        defineSymbol(math, main, rel, "⇑", "\\Uparrow", true);
        defineSymbol(math, main, rel, "↓", "\\downarrow", true);
        defineSymbol(math, main, rel, "⇓", "\\Downarrow", true);
        defineSymbol(math, main, rel, "↕", "\\updownarrow", true);
        defineSymbol(math, main, rel, "⇕", "\\Updownarrow", true);
        defineSymbol(math, main, op, "∐", "\\coprod");
        defineSymbol(math, main, op, "⋁", "\\bigvee");
        defineSymbol(math, main, op, "⋀", "\\bigwedge");
        defineSymbol(math, main, op, "⨄", "\\biguplus");
        defineSymbol(math, main, op, "⋂", "\\bigcap");
        defineSymbol(math, main, op, "⋃", "\\bigcup");
        defineSymbol(math, main, op, "∫", "\\int");
        defineSymbol(math, main, op, "∫", "\\intop");
        defineSymbol(math, main, op, "∬", "\\iint");
        defineSymbol(math, main, op, "∭", "\\iiint");
        defineSymbol(math, main, op, "∏", "\\prod");
        defineSymbol(math, main, op, "∑", "\\sum");
        defineSymbol(math, main, op, "⨂", "\\bigotimes");
        defineSymbol(math, main, op, "⨁", "\\bigoplus");
        defineSymbol(math, main, op, "⨀", "\\bigodot");
        defineSymbol(math, main, op, "∮", "\\oint");
        defineSymbol(math, main, op, "∯", "\\oiint");
        defineSymbol(math, main, op, "∰", "\\oiiint");
        defineSymbol(math, main, op, "⨆", "\\bigsqcup");
        defineSymbol(math, main, op, "∫", "\\smallint");
        defineSymbol(symbols_text, main, inner, "…", "\\textellipsis");
        defineSymbol(math, main, inner, "…", "\\mathellipsis");
        defineSymbol(symbols_text, main, inner, "…", "\\ldots", true);
        defineSymbol(math, main, inner, "…", "\\ldots", true);
        defineSymbol(math, main, inner, "⋯", "\\@cdots", true);
        defineSymbol(math, main, inner, "⋱", "\\ddots", true);
        defineSymbol(math, main, textord, "⋮", "\\varvdots");
        defineSymbol(symbols_text, main, textord, "⋮", "\\varvdots");
        defineSymbol(math, main, accent, "ˊ", "\\acute");
        defineSymbol(math, main, accent, "ˋ", "\\grave");
        defineSymbol(math, main, accent, "¨", "\\ddot");
        defineSymbol(math, main, accent, "~", "\\tilde");
        defineSymbol(math, main, accent, "ˉ", "\\bar");
        defineSymbol(math, main, accent, "˘", "\\breve");
        defineSymbol(math, main, accent, "ˇ", "\\check");
        defineSymbol(math, main, accent, "^", "\\hat");
        defineSymbol(math, main, accent, "⃗", "\\vec");
        defineSymbol(math, main, accent, "˙", "\\dot");
        defineSymbol(math, main, accent, "˚", "\\mathring");
        defineSymbol(math, main, mathord, "", "\\@imath");
        defineSymbol(math, main, mathord, "", "\\@jmath");
        defineSymbol(math, main, textord, "ı", "ı");
        defineSymbol(math, main, textord, "ȷ", "ȷ");
        defineSymbol(symbols_text, main, textord, "ı", "\\i", true);
        defineSymbol(symbols_text, main, textord, "ȷ", "\\j", true);
        defineSymbol(symbols_text, main, textord, "ß", "\\ss", true);
        defineSymbol(symbols_text, main, textord, "æ", "\\ae", true);
        defineSymbol(symbols_text, main, textord, "œ", "\\oe", true);
        defineSymbol(symbols_text, main, textord, "ø", "\\o", true);
        defineSymbol(symbols_text, main, textord, "Æ", "\\AE", true);
        defineSymbol(symbols_text, main, textord, "Œ", "\\OE", true);
        defineSymbol(symbols_text, main, textord, "Ø", "\\O", true);
        defineSymbol(symbols_text, main, accent, "ˊ", "\\'");
        defineSymbol(symbols_text, main, accent, "ˋ", "\\`");
        defineSymbol(symbols_text, main, accent, "ˆ", "\\^");
        defineSymbol(symbols_text, main, accent, "˜", "\\~");
        defineSymbol(symbols_text, main, accent, "ˉ", "\\=");
        defineSymbol(symbols_text, main, accent, "˘", "\\u");
        defineSymbol(symbols_text, main, accent, "˙", "\\.");
        defineSymbol(symbols_text, main, accent, "¸", "\\c");
        defineSymbol(symbols_text, main, accent, "˚", "\\r");
        defineSymbol(symbols_text, main, accent, "ˇ", "\\v");
        defineSymbol(symbols_text, main, accent, "¨", '\\"');
        defineSymbol(symbols_text, main, accent, "˝", "\\H");
        defineSymbol(symbols_text, main, accent, "◯", "\\textcircled");
        const ligatures = {
          "--": true,
          "---": true,
          "``": true,
          "''": true
        };
        defineSymbol(symbols_text, main, textord, "–", "--", true);
        defineSymbol(symbols_text, main, textord, "–", "\\textendash");
        defineSymbol(symbols_text, main, textord, "—", "---", true);
        defineSymbol(symbols_text, main, textord, "—", "\\textemdash");
        defineSymbol(symbols_text, main, textord, "‘", "`", true);
        defineSymbol(symbols_text, main, textord, "‘", "\\textquoteleft");
        defineSymbol(symbols_text, main, textord, "’", "'", true);
        defineSymbol(symbols_text, main, textord, "’", "\\textquoteright");
        defineSymbol(symbols_text, main, textord, "“", "``", true);
        defineSymbol(symbols_text, main, textord, "“", "\\textquotedblleft");
        defineSymbol(symbols_text, main, textord, "”", "''", true);
        defineSymbol(symbols_text, main, textord, "”", "\\textquotedblright");
        defineSymbol(math, main, textord, "°", "\\degree", true);
        defineSymbol(symbols_text, main, textord, "°", "\\degree");
        defineSymbol(symbols_text, main, textord, "°", "\\textdegree", true);
        defineSymbol(math, main, textord, "£", "\\pounds");
        defineSymbol(math, main, textord, "£", "\\mathsterling", true);
        defineSymbol(symbols_text, main, textord, "£", "\\pounds");
        defineSymbol(symbols_text, main, textord, "£", "\\textsterling", true);
        defineSymbol(math, ams, textord, "✠", "\\maltese");
        defineSymbol(symbols_text, ams, textord, "✠", "\\maltese");
        const mathTextSymbols = '0123456789/@."';
        for (let i = 0; i < mathTextSymbols.length; i++) {
          const ch = mathTextSymbols.charAt(i);
          defineSymbol(math, main, textord, ch, ch);
        }
        const textSymbols = '0123456789!@*()-=+";:?/.,';
        for (let i = 0; i < textSymbols.length; i++) {
          const ch = textSymbols.charAt(i);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        for (let i = 0; i < letters.length; i++) {
          const ch = letters.charAt(i);
          defineSymbol(math, main, mathord, ch, ch);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        defineSymbol(math, ams, textord, "C", "ℂ");
        defineSymbol(symbols_text, ams, textord, "C", "ℂ");
        defineSymbol(math, ams, textord, "H", "ℍ");
        defineSymbol(symbols_text, ams, textord, "H", "ℍ");
        defineSymbol(math, ams, textord, "N", "ℕ");
        defineSymbol(symbols_text, ams, textord, "N", "ℕ");
        defineSymbol(math, ams, textord, "P", "ℙ");
        defineSymbol(symbols_text, ams, textord, "P", "ℙ");
        defineSymbol(math, ams, textord, "Q", "ℚ");
        defineSymbol(symbols_text, ams, textord, "Q", "ℚ");
        defineSymbol(math, ams, textord, "R", "ℝ");
        defineSymbol(symbols_text, ams, textord, "R", "ℝ");
        defineSymbol(math, ams, textord, "Z", "ℤ");
        defineSymbol(symbols_text, ams, textord, "Z", "ℤ");
        defineSymbol(math, main, mathord, "h", "ℎ");
        defineSymbol(symbols_text, main, mathord, "h", "ℎ");
        let wideChar = "";
        for (let i = 0; i < letters.length; i++) {
          const ch = letters.charAt(i);
          wideChar = String.fromCharCode(55349, 56320 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56372 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56424 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56580 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56684 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56736 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56788 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56840 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 56944 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          if (i < 26) {
            wideChar = String.fromCharCode(55349, 56632 + i);
            defineSymbol(math, main, mathord, ch, wideChar);
            defineSymbol(symbols_text, main, textord, ch, wideChar);
            wideChar = String.fromCharCode(55349, 56476 + i);
            defineSymbol(math, main, mathord, ch, wideChar);
            defineSymbol(symbols_text, main, textord, ch, wideChar);
          }
        }
        wideChar = String.fromCharCode(55349, 56668);
        defineSymbol(math, main, mathord, "k", wideChar);
        defineSymbol(symbols_text, main, textord, "k", wideChar);
        for (let i = 0; i < 10; i++) {
          const ch = i.toString();
          wideChar = String.fromCharCode(55349, 57294 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57314 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57324 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
          wideChar = String.fromCharCode(55349, 57334 + i);
          defineSymbol(math, main, mathord, ch, wideChar);
          defineSymbol(symbols_text, main, textord, ch, wideChar);
        }
        const extraLatin = "ÐÞþ";
        for (let i = 0; i < extraLatin.length; i++) {
          const ch = extraLatin.charAt(i);
          defineSymbol(math, main, mathord, ch, ch);
          defineSymbol(symbols_text, main, textord, ch, ch);
        }
        const wideLatinLetterData = [
          ["mathbf", "textbf", "Main-Bold"],
          // A-Z bold upright
          ["mathbf", "textbf", "Main-Bold"],
          // a-z bold upright
          ["mathnormal", "textit", "Math-Italic"],
          // A-Z italic
          ["mathnormal", "textit", "Math-Italic"],
          // a-z italic
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          // A-Z bold italic
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          // a-z bold italic
          // Map fancy A-Z letters to script, not calligraphic.
          // This aligns with unicode-math and math fonts (except Cambria Math).
          ["mathscr", "textscr", "Script-Regular"],
          // A-Z script
          ["", "", ""],
          // a-z script.  No font
          ["", "", ""],
          // A-Z bold script. No font
          ["", "", ""],
          // a-z bold script. No font
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          // A-Z Fraktur
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          // a-z Fraktur
          ["mathbb", "textbb", "AMS-Regular"],
          // A-Z double-struck
          ["mathbb", "textbb", "AMS-Regular"],
          // k double-struck
          // Note that we are using a bold font, but font metrics for regular Fraktur.
          ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
          // A-Z bold Fraktur
          ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
          // a-z bold Fraktur
          ["mathsf", "textsf", "SansSerif-Regular"],
          // A-Z sans-serif
          ["mathsf", "textsf", "SansSerif-Regular"],
          // a-z sans-serif
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          // A-Z bold sans-serif
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          // a-z bold sans-serif
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          // A-Z italic sans-serif
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          // a-z italic sans-serif
          ["", "", ""],
          // A-Z bold italic sans. No font
          ["", "", ""],
          // a-z bold italic sans. No font
          ["mathtt", "texttt", "Typewriter-Regular"],
          // A-Z monospace
          ["mathtt", "texttt", "Typewriter-Regular"]
          // a-z monospace
        ];
        const wideNumeralData = [
          ["mathbf", "textbf", "Main-Bold"],
          // 0-9 bold
          ["", "", ""],
          // 0-9 double-struck. No KaTeX font.
          ["mathsf", "textsf", "SansSerif-Regular"],
          // 0-9 sans-serif
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          // 0-9 bold sans-serif
          ["mathtt", "texttt", "Typewriter-Regular"]
          // 0-9 monospace
        ];
        const wideCharacterFont = function(wideChar2, mode) {
          const H2 = wideChar2.charCodeAt(0);
          const L = wideChar2.charCodeAt(1);
          const codePoint = (H2 - 55296) * 1024 + (L - 56320) + 65536;
          const j2 = mode === "math" ? 0 : 1;
          if (119808 <= codePoint && codePoint < 120484) {
            const i = Math.floor((codePoint - 119808) / 26);
            return [wideLatinLetterData[i][2], wideLatinLetterData[i][j2]];
          } else if (120782 <= codePoint && codePoint <= 120831) {
            const i = Math.floor((codePoint - 120782) / 10);
            return [wideNumeralData[i][2], wideNumeralData[i][j2]];
          } else if (codePoint === 120485 || codePoint === 120486) {
            return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
          } else if (120486 < codePoint && codePoint < 120782) {
            return ["", ""];
          } else {
            throw new src_ParseError("Unsupported character: " + wideChar2);
          }
        };
        const lookupSymbol = function(value, fontName, mode) {
          if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
            value = src_symbols[mode][value].replace;
          }
          return {
            value,
            metrics: getCharacterMetrics(value, fontName, mode)
          };
        };
        const makeSymbol = function(value, fontName, mode, options, classes) {
          const lookup = lookupSymbol(value, fontName, mode);
          const metrics = lookup.metrics;
          value = lookup.value;
          let symbolNode;
          if (metrics) {
            let italic = metrics.italic;
            if (mode === "text" || options && options.font === "mathit") {
              italic = 0;
            }
            symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
          } else {
            typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
            symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
          }
          if (options) {
            symbolNode.maxFontSize = options.sizeMultiplier;
            if (options.style.isTight()) {
              symbolNode.classes.push("mtight");
            }
            const color2 = options.getColor();
            if (color2) {
              symbolNode.style.color = color2;
            }
          }
          return symbolNode;
        };
        const mathsym = function(value, mode, options, classes) {
          if (classes === void 0) {
            classes = [];
          }
          if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
            return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
          } else if (value === "\\" || src_symbols[mode][value].font === "main") {
            return makeSymbol(value, "Main-Regular", mode, options, classes);
          } else {
            return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
          }
        };
        const boldsymbol = function(value, mode, options, classes, type) {
          if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
            return {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            };
          } else {
            return {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }
        };
        const makeOrd = function(group, options, type) {
          const mode = group.mode;
          const text2 = group.text;
          const classes = ["mord"];
          const isFont = mode === "math" || mode === "text" && options.font;
          const fontOrFamily = isFont ? options.font : options.fontFamily;
          let wideFontName = "";
          let wideFontClass = "";
          if (text2.charCodeAt(0) === 55349) {
            [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
          }
          if (wideFontName.length > 0) {
            return makeSymbol(text2, wideFontName, mode, options, classes.concat(wideFontClass));
          } else if (fontOrFamily) {
            let fontName;
            let fontClasses;
            if (fontOrFamily === "boldsymbol") {
              const fontData = boldsymbol(text2, mode, options, classes, type);
              fontName = fontData.fontName;
              fontClasses = [fontData.fontClass];
            } else if (isFont) {
              fontName = fontMap[fontOrFamily].fontName;
              fontClasses = [fontOrFamily];
            } else {
              fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
              fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
            }
            if (lookupSymbol(text2, fontName, mode).metrics) {
              return makeSymbol(text2, fontName, mode, options, classes.concat(fontClasses));
            } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
              const parts = [];
              for (let i = 0; i < text2.length; i++) {
                parts.push(makeSymbol(text2[i], fontName, mode, options, classes.concat(fontClasses)));
              }
              return makeFragment(parts);
            }
          }
          if (type === "mathord") {
            return makeSymbol(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
          } else if (type === "textord") {
            const font = src_symbols[mode][text2] && src_symbols[mode][text2].font;
            if (font === "ams") {
              const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
              return makeSymbol(text2, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
            } else if (font === "main" || !font) {
              const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
              return makeSymbol(text2, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
            } else {
              const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape);
              return makeSymbol(text2, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
            }
          } else {
            throw new Error("unexpected type: " + type + " in makeOrd");
          }
        };
        const canCombine = (prev2, next3) => {
          if (createClass(prev2.classes) !== createClass(next3.classes) || prev2.skew !== next3.skew || prev2.maxFontSize !== next3.maxFontSize) {
            return false;
          }
          if (prev2.classes.length === 1) {
            const cls = prev2.classes[0];
            if (cls === "mbin" || cls === "mord") {
              return false;
            }
          }
          for (const style in prev2.style) {
            if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next3.style[style]) {
              return false;
            }
          }
          for (const style in next3.style) {
            if (next3.style.hasOwnProperty(style) && prev2.style[style] !== next3.style[style]) {
              return false;
            }
          }
          return true;
        };
        const tryCombineChars = (chars) => {
          for (let i = 0; i < chars.length - 1; i++) {
            const prev2 = chars[i];
            const next3 = chars[i + 1];
            if (prev2 instanceof SymbolNode && next3 instanceof SymbolNode && canCombine(prev2, next3)) {
              prev2.text += next3.text;
              prev2.height = Math.max(prev2.height, next3.height);
              prev2.depth = Math.max(prev2.depth, next3.depth);
              prev2.italic = next3.italic;
              chars.splice(i + 1, 1);
              i--;
            }
          }
          return chars;
        };
        const sizeElementFromChildren = function(elem) {
          let height = 0;
          let depth = 0;
          let maxFontSize = 0;
          for (let i = 0; i < elem.children.length; i++) {
            const child = elem.children[i];
            if (child.height > height) {
              height = child.height;
            }
            if (child.depth > depth) {
              depth = child.depth;
            }
            if (child.maxFontSize > maxFontSize) {
              maxFontSize = child.maxFontSize;
            }
          }
          elem.height = height;
          elem.depth = depth;
          elem.maxFontSize = maxFontSize;
        };
        const makeSpan = function(classes, children2, options, style) {
          const span = new Span(classes, children2, options, style);
          sizeElementFromChildren(span);
          return span;
        };
        const makeSvgSpan = (classes, children2, options, style) => new Span(classes, children2, options, style);
        const makeLineSpan = function(className, options, thickness) {
          const line = makeSpan([className], [], options);
          line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
          line.style.borderBottomWidth = makeEm(line.height);
          line.maxFontSize = 1;
          return line;
        };
        const makeAnchor = function(href, classes, children2, options) {
          const anchor = new Anchor(href, classes, children2, options);
          sizeElementFromChildren(anchor);
          return anchor;
        };
        const makeFragment = function(children2) {
          const fragment = new DocumentFragment(children2);
          sizeElementFromChildren(fragment);
          return fragment;
        };
        const wrapFragment = function(group, options) {
          if (group instanceof DocumentFragment) {
            return makeSpan([], [group], options);
          }
          return group;
        };
        const getVListChildrenAndDepth = function(params) {
          if (params.positionType === "individualShift") {
            const oldChildren = params.children;
            const children2 = [oldChildren[0]];
            const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
            let currPos = depth2;
            for (let i = 1; i < oldChildren.length; i++) {
              const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
              const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
              currPos = currPos + diff;
              children2.push({
                type: "kern",
                size
              });
              children2.push(oldChildren[i]);
            }
            return {
              children: children2,
              depth: depth2
            };
          }
          let depth;
          if (params.positionType === "top") {
            let bottom = params.positionData;
            for (let i = 0; i < params.children.length; i++) {
              const child = params.children[i];
              bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
            }
            depth = bottom;
          } else if (params.positionType === "bottom") {
            depth = -params.positionData;
          } else {
            const firstChild = params.children[0];
            if (firstChild.type !== "elem") {
              throw new Error('First child must have type "elem".');
            }
            if (params.positionType === "shift") {
              depth = -firstChild.elem.depth - params.positionData;
            } else if (params.positionType === "firstBaseline") {
              depth = -firstChild.elem.depth;
            } else {
              throw new Error("Invalid positionType " + params.positionType + ".");
            }
          }
          return {
            children: params.children,
            depth
          };
        };
        const makeVList = function(params, options) {
          const {
            children: children2,
            depth
          } = getVListChildrenAndDepth(params);
          let pstrutSize = 0;
          for (let i = 0; i < children2.length; i++) {
            const child = children2[i];
            if (child.type === "elem") {
              const elem = child.elem;
              pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
            }
          }
          pstrutSize += 2;
          const pstrut = makeSpan(["pstrut"], []);
          pstrut.style.height = makeEm(pstrutSize);
          const realChildren = [];
          let minPos = depth;
          let maxPos = depth;
          let currPos = depth;
          for (let i = 0; i < children2.length; i++) {
            const child = children2[i];
            if (child.type === "kern") {
              currPos += child.size;
            } else {
              const elem = child.elem;
              const classes = child.wrapperClasses || [];
              const style = child.wrapperStyle || {};
              const childWrap = makeSpan(classes, [pstrut, elem], void 0, style);
              childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);
              if (child.marginLeft) {
                childWrap.style.marginLeft = child.marginLeft;
              }
              if (child.marginRight) {
                childWrap.style.marginRight = child.marginRight;
              }
              realChildren.push(childWrap);
              currPos += elem.height + elem.depth;
            }
            minPos = Math.min(minPos, currPos);
            maxPos = Math.max(maxPos, currPos);
          }
          const vlist = makeSpan(["vlist"], realChildren);
          vlist.style.height = makeEm(maxPos);
          let rows;
          if (minPos < 0) {
            const emptySpan = makeSpan([], []);
            const depthStrut = makeSpan(["vlist"], [emptySpan]);
            depthStrut.style.height = makeEm(-minPos);
            const topStrut = makeSpan(["vlist-s"], [new SymbolNode("​")]);
            rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
          } else {
            rows = [makeSpan(["vlist-r"], [vlist])];
          }
          const vtable = makeSpan(["vlist-t"], rows);
          if (rows.length === 2) {
            vtable.classes.push("vlist-t2");
          }
          vtable.height = maxPos;
          vtable.depth = -minPos;
          return vtable;
        };
        const makeGlue = (measurement, options) => {
          const rule = makeSpan(["mspace"], [], options);
          const size = calculateSize(measurement, options);
          rule.style.marginRight = makeEm(size);
          return rule;
        };
        const retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
          let baseFontName = "";
          switch (fontFamily) {
            case "amsrm":
              baseFontName = "AMS";
              break;
            case "textrm":
              baseFontName = "Main";
              break;
            case "textsf":
              baseFontName = "SansSerif";
              break;
            case "texttt":
              baseFontName = "Typewriter";
              break;
            default:
              baseFontName = fontFamily;
          }
          let fontStylesName;
          if (fontWeight === "textbf" && fontShape === "textit") {
            fontStylesName = "BoldItalic";
          } else if (fontWeight === "textbf") {
            fontStylesName = "Bold";
          } else if (fontWeight === "textit") {
            fontStylesName = "Italic";
          } else {
            fontStylesName = "Regular";
          }
          return baseFontName + "-" + fontStylesName;
        };
        const fontMap = {
          // styles
          "mathbf": {
            variant: "bold",
            fontName: "Main-Bold"
          },
          "mathrm": {
            variant: "normal",
            fontName: "Main-Regular"
          },
          "textit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathnormal": {
            variant: "italic",
            fontName: "Math-Italic"
          },
          "mathsfit": {
            variant: "sans-serif-italic",
            fontName: "SansSerif-Italic"
          },
          // "boldsymbol" is missing because they require the use of multiple fonts:
          // Math-BoldItalic and Main-Bold.  This is handled by a special case in
          // makeOrd which ends up calling boldsymbol.
          // families
          "mathbb": {
            variant: "double-struck",
            fontName: "AMS-Regular"
          },
          "mathcal": {
            variant: "script",
            fontName: "Caligraphic-Regular"
          },
          "mathfrak": {
            variant: "fraktur",
            fontName: "Fraktur-Regular"
          },
          "mathscr": {
            variant: "script",
            fontName: "Script-Regular"
          },
          "mathsf": {
            variant: "sans-serif",
            fontName: "SansSerif-Regular"
          },
          "mathtt": {
            variant: "monospace",
            fontName: "Typewriter-Regular"
          }
        };
        const svgData = {
          //   path, width, height
          vec: ["vec", 0.471, 0.714],
          // values from the font glyph
          oiintSize1: ["oiintSize1", 0.957, 0.499],
          // oval to overlay the integrand
          oiintSize2: ["oiintSize2", 1.472, 0.659],
          oiiintSize1: ["oiiintSize1", 1.304, 0.499],
          oiiintSize2: ["oiiintSize2", 1.98, 0.659]
        };
        const staticSvg = function(value, options) {
          const [pathName, width, height] = svgData[value];
          const path3 = new PathNode(pathName);
          const svgNode2 = new SvgNode([path3], {
            "width": makeEm(width),
            "height": makeEm(height),
            // Override CSS rule `.katex svg { width: 100% }`
            "style": "width:" + makeEm(width),
            "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
            "preserveAspectRatio": "xMinYMin"
          });
          const span = makeSvgSpan(["overlay"], [svgNode2], options);
          span.height = height;
          span.style.height = makeEm(height);
          span.style.width = makeEm(width);
          return span;
        };
        var buildCommon = {
          fontMap,
          makeSymbol,
          mathsym,
          makeSpan,
          makeSvgSpan,
          makeLineSpan,
          makeAnchor,
          makeFragment,
          wrapFragment,
          makeVList,
          makeOrd,
          makeGlue,
          staticSvg,
          svgData,
          tryCombineChars
        };
        const thinspace = {
          number: 3,
          unit: "mu"
        };
        const mediumspace = {
          number: 4,
          unit: "mu"
        };
        const thickspace = {
          number: 5,
          unit: "mu"
        };
        const spacings = {
          mord: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            minner: thinspace
          },
          mbin: {
            mord: mediumspace,
            mop: mediumspace,
            mopen: mediumspace,
            minner: mediumspace
          },
          mrel: {
            mord: thickspace,
            mop: thickspace,
            mopen: thickspace,
            minner: thickspace
          },
          mopen: {},
          mclose: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mpunct: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            mopen: thinspace,
            mclose: thinspace,
            mpunct: thinspace,
            minner: thinspace
          },
          minner: {
            mord: thinspace,
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            mopen: thinspace,
            mpunct: thinspace,
            minner: thinspace
          }
        };
        const tightSpacings = {
          mord: {
            mop: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace
          },
          mbin: {},
          mrel: {},
          mopen: {},
          mclose: {
            mop: thinspace
          },
          mpunct: {},
          minner: {
            mop: thinspace
          }
        };
        const _functions = {};
        const _htmlGroupBuilders = {};
        const _mathmlGroupBuilders = {};
        function defineFunction(_ref) {
          let {
            type,
            names,
            props,
            handler,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref;
          const data2 = {
            type,
            numArgs: props.numArgs,
            argTypes: props.argTypes,
            allowedInArgument: !!props.allowedInArgument,
            allowedInText: !!props.allowedInText,
            allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
            numOptionalArgs: props.numOptionalArgs || 0,
            infix: !!props.infix,
            primitive: !!props.primitive,
            handler
          };
          for (let i = 0; i < names.length; ++i) {
            _functions[names[i]] = data2;
          }
          if (type) {
            if (htmlBuilder2) {
              _htmlGroupBuilders[type] = htmlBuilder2;
            }
            if (mathmlBuilder2) {
              _mathmlGroupBuilders[type] = mathmlBuilder2;
            }
          }
        }
        function defineFunctionBuilders(_ref2) {
          let {
            type,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref2;
          defineFunction({
            type,
            names: [],
            props: {
              numArgs: 0
            },
            handler() {
              throw new Error("Should never be called.");
            },
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          });
        }
        const normalizeArgument = function(arg) {
          return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
        };
        const ordargument = function(arg) {
          return arg.type === "ordgroup" ? arg.body : [arg];
        };
        const buildHTML_makeSpan = buildCommon.makeSpan;
        const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
        const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
        const styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        const DomEnum = {
          mord: "mord",
          mop: "mop",
          mbin: "mbin",
          mrel: "mrel",
          mopen: "mopen",
          mclose: "mclose",
          mpunct: "mpunct",
          minner: "minner"
        };
        const buildExpression = function(expression, options, isRealGroup, surrounding) {
          if (surrounding === void 0) {
            surrounding = [null, null];
          }
          const groups = [];
          for (let i = 0; i < expression.length; i++) {
            const output = buildGroup(expression[i], options);
            if (output instanceof DocumentFragment) {
              const children2 = output.children;
              groups.push(...children2);
            } else {
              groups.push(output);
            }
          }
          buildCommon.tryCombineChars(groups);
          if (!isRealGroup) {
            return groups;
          }
          let glueOptions = options;
          if (expression.length === 1) {
            const node2 = expression[0];
            if (node2.type === "sizing") {
              glueOptions = options.havingSize(node2.size);
            } else if (node2.type === "styling") {
              glueOptions = options.havingStyle(styleMap[node2.style]);
            }
          }
          const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
          const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
          const isRoot = isRealGroup === "root";
          traverseNonSpaceNodes(groups, (node2, prev2) => {
            const prevType = prev2.classes[0];
            const type = node2.classes[0];
            if (prevType === "mbin" && utils2.contains(binRightCanceller, type)) {
              prev2.classes[0] = "mord";
            } else if (type === "mbin" && utils2.contains(binLeftCanceller, prevType)) {
              node2.classes[0] = "mord";
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          traverseNonSpaceNodes(groups, (node2, prev2) => {
            const prevType = getTypeOfDomTree(prev2);
            const type = getTypeOfDomTree(node2);
            const space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
            if (space) {
              return buildCommon.makeGlue(space, glueOptions);
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          return groups;
        };
        const traverseNonSpaceNodes = function(nodes, callback, prev2, next3, isRoot) {
          if (next3) {
            nodes.push(next3);
          }
          let i = 0;
          for (; i < nodes.length; i++) {
            const node2 = nodes[i];
            const partialGroup = checkPartialGroup(node2);
            if (partialGroup) {
              traverseNonSpaceNodes(partialGroup.children, callback, prev2, null, isRoot);
              continue;
            }
            const nonspace = !node2.hasClass("mspace");
            if (nonspace) {
              const result = callback(node2, prev2.node);
              if (result) {
                if (prev2.insertAfter) {
                  prev2.insertAfter(result);
                } else {
                  nodes.unshift(result);
                  i++;
                }
              }
            }
            if (nonspace) {
              prev2.node = node2;
            } else if (isRoot && node2.hasClass("newline")) {
              prev2.node = buildHTML_makeSpan(["leftmost"]);
            }
            prev2.insertAfter = /* @__PURE__ */ ((index2) => (n) => {
              nodes.splice(index2 + 1, 0, n);
              i++;
            })(i);
          }
          if (next3) {
            nodes.pop();
          }
        };
        const checkPartialGroup = function(node2) {
          if (node2 instanceof DocumentFragment || node2 instanceof Anchor || node2 instanceof Span && node2.hasClass("enclosing")) {
            return node2;
          }
          return null;
        };
        const getOutermostNode = function(node2, side) {
          const partialGroup = checkPartialGroup(node2);
          if (partialGroup) {
            const children2 = partialGroup.children;
            if (children2.length) {
              if (side === "right") {
                return getOutermostNode(children2[children2.length - 1], "right");
              } else if (side === "left") {
                return getOutermostNode(children2[0], "left");
              }
            }
          }
          return node2;
        };
        const getTypeOfDomTree = function(node2, side) {
          if (!node2) {
            return null;
          }
          if (side) {
            node2 = getOutermostNode(node2, side);
          }
          return DomEnum[node2.classes[0]] || null;
        };
        const makeNullDelimiter = function(options, classes) {
          const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
          return buildHTML_makeSpan(classes.concat(moreClasses));
        };
        const buildGroup = function(group, options, baseOptions) {
          if (!group) {
            return buildHTML_makeSpan();
          }
          if (_htmlGroupBuilders[group.type]) {
            let groupNode = _htmlGroupBuilders[group.type](group, options);
            if (baseOptions && options.size !== baseOptions.size) {
              groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
              const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              groupNode.height *= multiplier;
              groupNode.depth *= multiplier;
            }
            return groupNode;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildHTMLUnbreakable(children2, options) {
          const body = buildHTML_makeSpan(["base"], children2, options);
          const strut = buildHTML_makeSpan(["strut"]);
          strut.style.height = makeEm(body.height + body.depth);
          if (body.depth) {
            strut.style.verticalAlign = makeEm(-body.depth);
          }
          body.children.unshift(strut);
          return body;
        }
        function buildHTML(tree, options) {
          let tag = null;
          if (tree.length === 1 && tree[0].type === "tag") {
            tag = tree[0].tag;
            tree = tree[0].body;
          }
          const expression = buildExpression(tree, options, "root");
          let eqnNum;
          if (expression.length === 2 && expression[1].hasClass("tag")) {
            eqnNum = expression.pop();
          }
          const children2 = [];
          let parts = [];
          for (let i = 0; i < expression.length; i++) {
            parts.push(expression[i]);
            if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
              let nobreak = false;
              while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                i++;
                parts.push(expression[i]);
                if (expression[i].hasClass("nobreak")) {
                  nobreak = true;
                }
              }
              if (!nobreak) {
                children2.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
            } else if (expression[i].hasClass("newline")) {
              parts.pop();
              if (parts.length > 0) {
                children2.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
              children2.push(expression[i]);
            }
          }
          if (parts.length > 0) {
            children2.push(buildHTMLUnbreakable(parts, options));
          }
          let tagChild;
          if (tag) {
            tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
            tagChild.classes = ["tag"];
            children2.push(tagChild);
          } else if (eqnNum) {
            children2.push(eqnNum);
          }
          const htmlNode = buildHTML_makeSpan(["katex-html"], children2);
          htmlNode.setAttribute("aria-hidden", "true");
          if (tagChild) {
            const strut = tagChild.children[0];
            strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
            if (htmlNode.depth) {
              strut.style.verticalAlign = makeEm(-htmlNode.depth);
            }
          }
          return htmlNode;
        }
        function newDocumentFragment(children2) {
          return new DocumentFragment(children2);
        }
        class MathNode {
          constructor(type, children2, classes) {
            this.type = void 0;
            this.attributes = void 0;
            this.children = void 0;
            this.classes = void 0;
            this.type = type;
            this.attributes = {};
            this.children = children2 || [];
            this.classes = classes || [];
          }
          /**
           * Sets an attribute on a MathML node. MathML depends on attributes to convey a
           * semantic content, so this is used heavily.
           */
          setAttribute(name2, value) {
            this.attributes[name2] = value;
          }
          /**
           * Gets an attribute on a MathML node.
           */
          getAttribute(name2) {
            return this.attributes[name2];
          }
          /**
           * Converts the math node into a MathML-namespaced DOM element.
           */
          toNode() {
            const node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                node2.setAttribute(attr2, this.attributes[attr2]);
              }
            }
            if (this.classes.length > 0) {
              node2.className = createClass(this.classes);
            }
            for (let i = 0; i < this.children.length; i++) {
              if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
                let text2 = this.children[i].toText() + this.children[++i].toText();
                while (this.children[i + 1] instanceof TextNode) {
                  text2 += this.children[++i].toText();
                }
                node2.appendChild(new TextNode(text2).toNode());
              } else {
                node2.appendChild(this.children[i].toNode());
              }
            }
            return node2;
          }
          /**
           * Converts the math node into an HTML markup string.
           */
          toMarkup() {
            let markup = "<" + this.type;
            for (const attr2 in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                markup += " " + attr2 + '="';
                markup += utils2.escape(this.attributes[attr2]);
                markup += '"';
              }
            }
            if (this.classes.length > 0) {
              markup += ' class ="' + utils2.escape(createClass(this.classes)) + '"';
            }
            markup += ">";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</" + this.type + ">";
            return markup;
          }
          /**
           * Converts the math node into a string, similar to innerText, but escaped.
           */
          toText() {
            return this.children.map((child) => child.toText()).join("");
          }
        }
        class TextNode {
          constructor(text2) {
            this.text = void 0;
            this.text = text2;
          }
          /**
           * Converts the text node into a DOM text node.
           */
          toNode() {
            return document.createTextNode(this.text);
          }
          /**
           * Converts the text node into escaped HTML markup
           * (representing the text itself).
           */
          toMarkup() {
            return utils2.escape(this.toText());
          }
          /**
           * Converts the text node into a string
           * (representing the text itself).
           */
          toText() {
            return this.text;
          }
        }
        class SpaceNode {
          /**
           * Create a Space node with width given in CSS ems.
           */
          constructor(width) {
            this.width = void 0;
            this.character = void 0;
            this.width = width;
            if (width >= 0.05555 && width <= 0.05556) {
              this.character = " ";
            } else if (width >= 0.1666 && width <= 0.1667) {
              this.character = " ";
            } else if (width >= 0.2222 && width <= 0.2223) {
              this.character = " ";
            } else if (width >= 0.2777 && width <= 0.2778) {
              this.character = "  ";
            } else if (width >= -0.05556 && width <= -0.05555) {
              this.character = " ⁣";
            } else if (width >= -0.1667 && width <= -0.1666) {
              this.character = " ⁣";
            } else if (width >= -0.2223 && width <= -0.2222) {
              this.character = " ⁣";
            } else if (width >= -0.2778 && width <= -0.2777) {
              this.character = " ⁣";
            } else {
              this.character = null;
            }
          }
          /**
           * Converts the math node into a MathML-namespaced DOM element.
           */
          toNode() {
            if (this.character) {
              return document.createTextNode(this.character);
            } else {
              const node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
              node2.setAttribute("width", makeEm(this.width));
              return node2;
            }
          }
          /**
           * Converts the math node into an HTML markup string.
           */
          toMarkup() {
            if (this.character) {
              return "<mtext>" + this.character + "</mtext>";
            } else {
              return '<mspace width="' + makeEm(this.width) + '"/>';
            }
          }
          /**
           * Converts the math node into a string, similar to innerText.
           */
          toText() {
            if (this.character) {
              return this.character;
            } else {
              return " ";
            }
          }
        }
        var mathMLTree = {
          MathNode,
          TextNode,
          SpaceNode,
          newDocumentFragment
        };
        const makeText = function(text2, mode, options) {
          if (src_symbols[mode][text2] && src_symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
            text2 = src_symbols[mode][text2].replace;
          }
          return new mathMLTree.TextNode(text2);
        };
        const makeRow = function(body) {
          if (body.length === 1) {
            return body[0];
          } else {
            return new mathMLTree.MathNode("mrow", body);
          }
        };
        const getVariant = function(group, options) {
          if (options.fontFamily === "texttt") {
            return "monospace";
          } else if (options.fontFamily === "textsf") {
            if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "sans-serif-bold-italic";
            } else if (options.fontShape === "textit") {
              return "sans-serif-italic";
            } else if (options.fontWeight === "textbf") {
              return "bold-sans-serif";
            } else {
              return "sans-serif";
            }
          } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "bold-italic";
          } else if (options.fontShape === "textit") {
            return "italic";
          } else if (options.fontWeight === "textbf") {
            return "bold";
          }
          const font = options.font;
          if (!font || font === "mathnormal") {
            return null;
          }
          const mode = group.mode;
          if (font === "mathit") {
            return "italic";
          } else if (font === "boldsymbol") {
            return group.type === "textord" ? "bold" : "bold-italic";
          } else if (font === "mathbf") {
            return "bold";
          } else if (font === "mathbb") {
            return "double-struck";
          } else if (font === "mathsfit") {
            return "sans-serif-italic";
          } else if (font === "mathfrak") {
            return "fraktur";
          } else if (font === "mathscr" || font === "mathcal") {
            return "script";
          } else if (font === "mathsf") {
            return "sans-serif";
          } else if (font === "mathtt") {
            return "monospace";
          }
          let text2 = group.text;
          if (utils2.contains(["\\imath", "\\jmath"], text2)) {
            return null;
          }
          if (src_symbols[mode][text2] && src_symbols[mode][text2].replace) {
            text2 = src_symbols[mode][text2].replace;
          }
          const fontName = buildCommon.fontMap[font].fontName;
          if (getCharacterMetrics(text2, fontName, mode)) {
            return buildCommon.fontMap[font].variant;
          }
          return null;
        };
        function isNumberPunctuation(group) {
          if (!group) {
            return false;
          }
          if (group.type === "mi" && group.children.length === 1) {
            const child = group.children[0];
            return child instanceof TextNode && child.text === ".";
          } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
            const child = group.children[0];
            return child instanceof TextNode && child.text === ",";
          } else {
            return false;
          }
        }
        const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
          if (expression.length === 1) {
            const group = buildMathML_buildGroup(expression[0], options);
            if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
              group.setAttribute("lspace", "0em");
              group.setAttribute("rspace", "0em");
            }
            return [group];
          }
          const groups = [];
          let lastGroup;
          for (let i = 0; i < expression.length; i++) {
            const group = buildMathML_buildGroup(expression[i], options);
            if (group instanceof MathNode && lastGroup instanceof MathNode) {
              if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                lastGroup.children.push(...group.children);
                continue;
              } else if (group.type === "mn" && lastGroup.type === "mn") {
                lastGroup.children.push(...group.children);
                continue;
              } else if (isNumberPunctuation(group) && lastGroup.type === "mn") {
                lastGroup.children.push(...group.children);
                continue;
              } else if (group.type === "mn" && isNumberPunctuation(lastGroup)) {
                group.children = [...lastGroup.children, ...group.children];
                groups.pop();
              } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
                const base2 = group.children[0];
                if (base2 instanceof MathNode && base2.type === "mn") {
                  base2.children = [...lastGroup.children, ...base2.children];
                  groups.pop();
                }
              } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                const lastChild = lastGroup.children[0];
                if (lastChild instanceof TextNode && lastChild.text === "̸" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                  const child = group.children[0];
                  if (child instanceof TextNode && child.text.length > 0) {
                    child.text = child.text.slice(0, 1) + "̸" + child.text.slice(1);
                    groups.pop();
                  }
                }
              }
            }
            groups.push(group);
            lastGroup = group;
          }
          return groups;
        };
        const buildExpressionRow = function(expression, options, isOrdgroup) {
          return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
        };
        const buildMathML_buildGroup = function(group, options) {
          if (!group) {
            return new mathMLTree.MathNode("mrow");
          }
          if (_mathmlGroupBuilders[group.type]) {
            const result = _mathmlGroupBuilders[group.type](group, options);
            return result;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
          const expression = buildMathML_buildExpression(tree, options);
          let wrapper2;
          if (expression.length === 1 && expression[0] instanceof MathNode && utils2.contains(["mrow", "mtable"], expression[0].type)) {
            wrapper2 = expression[0];
          } else {
            wrapper2 = new mathMLTree.MathNode("mrow", expression);
          }
          const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
          annotation.setAttribute("encoding", "application/x-tex");
          const semantics = new mathMLTree.MathNode("semantics", [wrapper2, annotation]);
          const math2 = new mathMLTree.MathNode("math", [semantics]);
          math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
          if (isDisplayMode) {
            math2.setAttribute("display", "block");
          }
          const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
          return buildCommon.makeSpan([wrapperClass], [math2]);
        }
        const optionsFromSettings = function(settings) {
          return new src_Options({
            style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
            maxSize: settings.maxSize,
            minRuleThickness: settings.minRuleThickness
          });
        };
        const displayWrap = function(node2, settings) {
          if (settings.displayMode) {
            const classes = ["katex-display"];
            if (settings.leqno) {
              classes.push("leqno");
            }
            if (settings.fleqn) {
              classes.push("fleqn");
            }
            node2 = buildCommon.makeSpan(classes, [node2]);
          }
          return node2;
        };
        const buildTree2 = function(tree, expression, settings) {
          const options = optionsFromSettings(settings);
          let katexNode;
          if (settings.output === "mathml") {
            return buildMathML(tree, expression, options, settings.displayMode, true);
          } else if (settings.output === "html") {
            const htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          } else {
            const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
            const htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
          }
          return displayWrap(katexNode, settings);
        };
        const buildHTMLTree = function(tree, expression, settings) {
          const options = optionsFromSettings(settings);
          const htmlNode = buildHTML(tree, options);
          const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          return displayWrap(katexNode, settings);
        };
        const stretchyCodePoint = {
          widehat: "^",
          widecheck: "ˇ",
          widetilde: "~",
          utilde: "~",
          overleftarrow: "←",
          underleftarrow: "←",
          xleftarrow: "←",
          overrightarrow: "→",
          underrightarrow: "→",
          xrightarrow: "→",
          underbrace: "⏟",
          overbrace: "⏞",
          overgroup: "⏠",
          undergroup: "⏡",
          overleftrightarrow: "↔",
          underleftrightarrow: "↔",
          xleftrightarrow: "↔",
          Overrightarrow: "⇒",
          xRightarrow: "⇒",
          overleftharpoon: "↼",
          xleftharpoonup: "↼",
          overrightharpoon: "⇀",
          xrightharpoonup: "⇀",
          xLeftarrow: "⇐",
          xLeftrightarrow: "⇔",
          xhookleftarrow: "↩",
          xhookrightarrow: "↪",
          xmapsto: "↦",
          xrightharpoondown: "⇁",
          xleftharpoondown: "↽",
          xrightleftharpoons: "⇌",
          xleftrightharpoons: "⇋",
          xtwoheadleftarrow: "↞",
          xtwoheadrightarrow: "↠",
          xlongequal: "=",
          xtofrom: "⇄",
          xrightleftarrows: "⇄",
          xrightequilibrium: "⇌",
          // Not a perfect match.
          xleftequilibrium: "⇋",
          // None better available.
          "\\cdrightarrow": "→",
          "\\cdleftarrow": "←",
          "\\cdlongequal": "="
        };
        const mathMLnode = function(label) {
          const node2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
          node2.setAttribute("stretchy", "true");
          return node2;
        };
        const katexImagesData = {
          //   path(s), minWidth, height, align
          overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
          "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
          // CD minwwidth2.5pc
          xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
          "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
          Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
          xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
          xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
          overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
          overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
          xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
          "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
          xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
          xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
          overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
          underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
          underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
          xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
          xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
          xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
          xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
          xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
          overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
          undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
          xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
          xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
          // The next three arrows are from the mhchem package.
          // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
          // document as \xrightarrow or \xrightleftharpoons. Those have
          // min-length = 1.75em, so we set min-length on these next three to match.
          xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
          xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
          xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
        };
        const groupLength = function(arg) {
          if (arg.type === "ordgroup") {
            return arg.body.length;
          } else {
            return 1;
          }
        };
        const svgSpan = function(group, options) {
          function buildSvgSpan_() {
            let viewBoxWidth = 4e5;
            const label = group.label.slice(1);
            if (utils2.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
              const grp = group;
              const numChars = groupLength(grp.base);
              let viewBoxHeight;
              let pathName;
              let height2;
              if (numChars > 5) {
                if (label === "widehat" || label === "widecheck") {
                  viewBoxHeight = 420;
                  viewBoxWidth = 2364;
                  height2 = 0.42;
                  pathName = label + "4";
                } else {
                  viewBoxHeight = 312;
                  viewBoxWidth = 2340;
                  height2 = 0.34;
                  pathName = "tilde4";
                }
              } else {
                const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                if (label === "widehat" || label === "widecheck") {
                  viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                  viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                  height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                  pathName = label + imgIndex;
                } else {
                  viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                  viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                  height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                  pathName = "tilde" + imgIndex;
                }
              }
              const path3 = new PathNode(pathName);
              const svgNode2 = new SvgNode([path3], {
                "width": "100%",
                "height": makeEm(height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                "preserveAspectRatio": "none"
              });
              return {
                span: buildCommon.makeSvgSpan([], [svgNode2], options),
                minWidth: 0,
                height: height2
              };
            } else {
              const spans = [];
              const data2 = katexImagesData[label];
              const [paths, minWidth2, viewBoxHeight] = data2;
              const height2 = viewBoxHeight / 1e3;
              const numSvgChildren = paths.length;
              let widthClasses;
              let aligns;
              if (numSvgChildren === 1) {
                const align1 = data2[3];
                widthClasses = ["hide-tail"];
                aligns = [align1];
              } else if (numSvgChildren === 2) {
                widthClasses = ["halfarrow-left", "halfarrow-right"];
                aligns = ["xMinYMin", "xMaxYMin"];
              } else if (numSvgChildren === 3) {
                widthClasses = ["brace-left", "brace-center", "brace-right"];
                aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
              } else {
                throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
              }
              for (let i = 0; i < numSvgChildren; i++) {
                const path3 = new PathNode(paths[i]);
                const svgNode2 = new SvgNode([path3], {
                  "width": "400em",
                  "height": makeEm(height2),
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                  "preserveAspectRatio": aligns[i] + " slice"
                });
                const span2 = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode2], options);
                if (numSvgChildren === 1) {
                  return {
                    span: span2,
                    minWidth: minWidth2,
                    height: height2
                  };
                } else {
                  span2.style.height = makeEm(height2);
                  spans.push(span2);
                }
              }
              return {
                span: buildCommon.makeSpan(["stretchy"], spans, options),
                minWidth: minWidth2,
                height: height2
              };
            }
          }
          const {
            span,
            minWidth,
            height
          } = buildSvgSpan_();
          span.height = height;
          span.style.height = makeEm(height);
          if (minWidth > 0) {
            span.style.minWidth = makeEm(minWidth);
          }
          return span;
        };
        const encloseSpan = function(inner2, label, topPad, bottomPad, options) {
          let img;
          const totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
          if (/fbox|color|angl/.test(label)) {
            img = buildCommon.makeSpan(["stretchy", label], [], options);
            if (label === "fbox") {
              const color2 = options.color && options.getColor();
              if (color2) {
                img.style.borderColor = color2;
              }
            }
          } else {
            const lines = [];
            if (/^[bx]cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "0",
                "x2": "100%",
                "y2": "100%",
                "stroke-width": "0.046em"
              }));
            }
            if (/^x?cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "100%",
                "x2": "100%",
                "y2": "0",
                "stroke-width": "0.046em"
              }));
            }
            const svgNode2 = new SvgNode(lines, {
              "width": "100%",
              "height": makeEm(totalHeight)
            });
            img = buildCommon.makeSvgSpan([], [svgNode2], options);
          }
          img.height = totalHeight;
          img.style.height = makeEm(totalHeight);
          return img;
        };
        var stretchy = {
          encloseSpan,
          mathMLnode,
          svgSpan
        };
        function assertNodeType(node2, type) {
          if (!node2 || node2.type !== type) {
            throw new Error("Expected node of type " + type + ", but got " + (node2 ? "node of type " + node2.type : String(node2)));
          }
          return node2;
        }
        function assertSymbolNodeType(node2) {
          const typedNode = checkSymbolNodeType(node2);
          if (!typedNode) {
            throw new Error("Expected node of symbol group type, but got " + (node2 ? "node of type " + node2.type : String(node2)));
          }
          return typedNode;
        }
        function checkSymbolNodeType(node2) {
          if (node2 && (node2.type === "atom" || NON_ATOMS.hasOwnProperty(node2.type))) {
            return node2;
          }
          return null;
        }
        const htmlBuilder = (grp, options) => {
          let base2;
          let group;
          let supSubGroup;
          if (grp && grp.type === "supsub") {
            group = assertNodeType(grp.base, "accent");
            base2 = group.base;
            grp.base = base2;
            supSubGroup = assertSpan(buildGroup(grp, options));
            grp.base = group;
          } else {
            group = assertNodeType(grp, "accent");
            base2 = group.base;
          }
          const body = buildGroup(base2, options.havingCrampedStyle());
          const mustShift = group.isShifty && utils2.isCharacterBox(base2);
          let skew2 = 0;
          if (mustShift) {
            const baseChar = utils2.getBaseElem(base2);
            const baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
            skew2 = assertSymbolDomNode(baseGroup).skew;
          }
          const accentBelow = group.label === "\\c";
          let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
          let accentBody;
          if (!group.isStretchy) {
            let accent2;
            let width;
            if (group.label === "\\vec") {
              accent2 = buildCommon.staticSvg("vec", options);
              width = buildCommon.svgData.vec[1];
            } else {
              accent2 = buildCommon.makeOrd({
                mode: group.mode,
                text: group.label
              }, options, "textord");
              accent2 = assertSymbolDomNode(accent2);
              accent2.italic = 0;
              width = accent2.width;
              if (accentBelow) {
                clearance += accent2.depth;
              }
            }
            accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
            const accentFull = group.label === "\\textcircled";
            if (accentFull) {
              accentBody.classes.push("accent-full");
              clearance = body.height;
            }
            let left = skew2;
            if (!accentFull) {
              left -= width / 2;
            }
            accentBody.style.left = makeEm(left);
            if (group.label === "\\textcircled") {
              accentBody.style.top = ".2em";
            }
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: -clearance
              }, {
                type: "elem",
                elem: accentBody
              }]
            }, options);
          } else {
            accentBody = stretchy.svgSpan(group, options);
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"],
                wrapperStyle: skew2 > 0 ? {
                  width: "calc(100% - " + makeEm(2 * skew2) + ")",
                  marginLeft: makeEm(2 * skew2)
                } : void 0
              }]
            }, options);
          }
          const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
          if (supSubGroup) {
            supSubGroup.children[0] = accentWrap;
            supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
            supSubGroup.classes[0] = "mord";
            return supSubGroup;
          } else {
            return accentWrap;
          }
        };
        const mathmlBuilder = (group, options) => {
          const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
          const node2 = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
          node2.setAttribute("accent", "true");
          return node2;
        };
        const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
        defineFunction({
          type: "accent",
          names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
          props: {
            numArgs: 1
          },
          handler: (context, args) => {
            const base2 = normalizeArgument(args[0]);
            const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
            const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
            return {
              type: "accent",
              mode: context.parser.mode,
              label: context.funcName,
              isStretchy,
              isShifty,
              base: base2
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        defineFunction({
          type: "accent",
          names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
          props: {
            numArgs: 1,
            allowedInText: true,
            allowedInMath: true,
            // unless in strict mode
            argTypes: ["primitive"]
          },
          handler: (context, args) => {
            const base2 = args[0];
            let mode = context.parser.mode;
            if (mode === "math") {
              context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
              mode = "text";
            }
            return {
              type: "accent",
              mode,
              label: context.funcName,
              isStretchy: false,
              isShifty: true,
              base: base2
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        defineFunction({
          type: "accentUnder",
          names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
          props: {
            numArgs: 1
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const base2 = args[0];
            return {
              type: "accentUnder",
              mode: parser.mode,
              label: funcName,
              base: base2
            };
          },
          htmlBuilder: (group, options) => {
            const innerGroup = buildGroup(group.base, options);
            const accentBody = stretchy.svgSpan(group, options);
            const kern = group.label === "\\utilde" ? 0.12 : 0;
            const vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: kern
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
          },
          mathmlBuilder: (group, options) => {
            const accentNode = stretchy.mathMLnode(group.label);
            const node2 = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            node2.setAttribute("accentunder", "true");
            return node2;
          }
        });
        const paddedNode = (group) => {
          const node2 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
          node2.setAttribute("width", "+0.6em");
          node2.setAttribute("lspace", "0.3em");
          return node2;
        };
        defineFunction({
          type: "xArrow",
          names: [
            "\\xleftarrow",
            "\\xrightarrow",
            "\\xLeftarrow",
            "\\xRightarrow",
            "\\xleftrightarrow",
            "\\xLeftrightarrow",
            "\\xhookleftarrow",
            "\\xhookrightarrow",
            "\\xmapsto",
            "\\xrightharpoondown",
            "\\xrightharpoonup",
            "\\xleftharpoondown",
            "\\xleftharpoonup",
            "\\xrightleftharpoons",
            "\\xleftrightharpoons",
            "\\xlongequal",
            "\\xtwoheadrightarrow",
            "\\xtwoheadleftarrow",
            "\\xtofrom",
            // The next 3 functions are here to support the mhchem extension.
            // Direct use of these functions is discouraged and may break someday.
            "\\xrightleftarrows",
            "\\xrightequilibrium",
            "\\xleftequilibrium",
            // The next 3 functions are here only to support the {CD} environment.
            "\\\\cdrightarrow",
            "\\\\cdleftarrow",
            "\\\\cdlongequal"
          ],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler(_ref, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "xArrow",
              mode: parser.mode,
              label: funcName,
              body: args[0],
              below: optArgs[0]
            };
          },
          // Flow is unable to correctly infer the type of `group`, even though it's
          // unambiguously determined from the passed-in `type` above.
          htmlBuilder(group, options) {
            const style = options.style;
            let newOptions = options.havingStyle(style.sup());
            const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
            const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
            upperGroup.classes.push(arrowPrefix + "-arrow-pad");
            let lowerGroup;
            if (group.below) {
              newOptions = options.havingStyle(style.sub());
              lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
              lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
            }
            const arrowBody = stretchy.svgSpan(group, options);
            const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
            let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
            if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
              upperShift -= upperGroup.depth;
            }
            let vlist;
            if (lowerGroup) {
              const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }, {
                  type: "elem",
                  elem: lowerGroup,
                  shift: lowerShift
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }]
              }, options);
            }
            vlist.children[0].children[0].children[1].classes.push("svg-align");
            return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const arrowNode = stretchy.mathMLnode(group.label);
            arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
            let node2;
            if (group.body) {
              const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
              if (group.below) {
                const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                node2 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
              } else {
                node2 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
              }
            } else if (group.below) {
              const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node2 = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
            } else {
              node2 = paddedNode();
              node2 = new mathMLTree.MathNode("mover", [arrowNode, node2]);
            }
            return node2;
          }
        });
        const mclass_makeSpan = buildCommon.makeSpan;
        function mclass_htmlBuilder(group, options) {
          const elements = buildExpression(group.body, options, true);
          return mclass_makeSpan([group.mclass], elements, options);
        }
        function mclass_mathmlBuilder(group, options) {
          let node2;
          const inner2 = buildMathML_buildExpression(group.body, options);
          if (group.mclass === "minner") {
            node2 = new mathMLTree.MathNode("mpadded", inner2);
          } else if (group.mclass === "mord") {
            if (group.isCharacterBox) {
              node2 = inner2[0];
              node2.type = "mi";
            } else {
              node2 = new mathMLTree.MathNode("mi", inner2);
            }
          } else {
            if (group.isCharacterBox) {
              node2 = inner2[0];
              node2.type = "mo";
            } else {
              node2 = new mathMLTree.MathNode("mo", inner2);
            }
            if (group.mclass === "mbin") {
              node2.attributes.lspace = "0.22em";
              node2.attributes.rspace = "0.22em";
            } else if (group.mclass === "mpunct") {
              node2.attributes.lspace = "0em";
              node2.attributes.rspace = "0.17em";
            } else if (group.mclass === "mopen" || group.mclass === "mclose") {
              node2.attributes.lspace = "0em";
              node2.attributes.rspace = "0em";
            } else if (group.mclass === "minner") {
              node2.attributes.lspace = "0.0556em";
              node2.attributes.width = "+0.1111em";
            }
          }
          return node2;
        }
        defineFunction({
          type: "mclass",
          names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: "m" + funcName.slice(5),
              // TODO(kevinb): don't prefix with 'm'
              body: ordargument(body),
              isCharacterBox: utils2.isCharacterBox(body)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        const binrelClass = (arg) => {
          const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
          if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
            return "m" + atom.family;
          } else {
            return "mord";
          }
        };
        defineFunction({
          type: "mclass",
          names: ["\\@binrel"],
          props: {
            numArgs: 2
          },
          handler(_ref2, args) {
            let {
              parser
            } = _ref2;
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: binrelClass(args[0]),
              body: ordargument(args[1]),
              isCharacterBox: utils2.isCharacterBox(args[1])
            };
          }
        });
        defineFunction({
          type: "mclass",
          names: ["\\stackrel", "\\overset", "\\underset"],
          props: {
            numArgs: 2
          },
          handler(_ref3, args) {
            let {
              parser,
              funcName
            } = _ref3;
            const baseArg = args[1];
            const shiftedArg = args[0];
            let mclass;
            if (funcName !== "\\stackrel") {
              mclass = binrelClass(baseArg);
            } else {
              mclass = "mrel";
            }
            const baseOp = {
              type: "op",
              mode: baseArg.mode,
              limits: true,
              alwaysHandleSupSub: true,
              parentIsSupSub: false,
              symbol: false,
              suppressBaseShift: funcName !== "\\stackrel",
              body: ordargument(baseArg)
            };
            const supsub = {
              type: "supsub",
              mode: shiftedArg.mode,
              base: baseOp,
              sup: funcName === "\\underset" ? null : shiftedArg,
              sub: funcName === "\\underset" ? shiftedArg : null
            };
            return {
              type: "mclass",
              mode: parser.mode,
              mclass,
              body: [supsub],
              isCharacterBox: utils2.isCharacterBox(supsub)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        defineFunction({
          type: "pmb",
          names: ["\\pmb"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "pmb",
              mode: parser.mode,
              mclass: binrelClass(args[0]),
              body: ordargument(args[0])
            };
          },
          htmlBuilder(group, options) {
            const elements = buildExpression(group.body, options, true);
            const node2 = buildCommon.makeSpan([group.mclass], elements, options);
            node2.style.textShadow = "0.02em 0.01em 0.04px";
            return node2;
          },
          mathmlBuilder(group, style) {
            const inner2 = buildMathML_buildExpression(group.body, style);
            const node2 = new mathMLTree.MathNode("mstyle", inner2);
            node2.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
            return node2;
          }
        });
        const cdArrowFunctionName = {
          ">": "\\\\cdrightarrow",
          "<": "\\\\cdleftarrow",
          "=": "\\\\cdlongequal",
          "A": "\\uparrow",
          "V": "\\downarrow",
          "|": "\\Vert",
          ".": "no arrow"
        };
        const newCell = () => {
          return {
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          };
        };
        const isStartOfArrow = (node2) => {
          return node2.type === "textord" && node2.text === "@";
        };
        const isLabelEnd = (node2, endChar) => {
          return (node2.type === "mathord" || node2.type === "atom") && node2.text === endChar;
        };
        function cdArrow(arrowChar, labels, parser) {
          const funcName = cdArrowFunctionName[arrowChar];
          switch (funcName) {
            case "\\\\cdrightarrow":
            case "\\\\cdleftarrow":
              return parser.callFunction(funcName, [labels[0]], [labels[1]]);
            case "\\uparrow":
            case "\\downarrow": {
              const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
              const bareArrow = {
                type: "atom",
                text: funcName,
                mode: "math",
                family: "rel"
              };
              const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
              const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
              const arrowGroup = {
                type: "ordgroup",
                mode: "math",
                body: [leftLabel, sizedArrow, rightLabel]
              };
              return parser.callFunction("\\\\cdparent", [arrowGroup], []);
            }
            case "\\\\cdlongequal":
              return parser.callFunction("\\\\cdlongequal", [], []);
            case "\\Vert": {
              const arrow = {
                type: "textord",
                text: "\\Vert",
                mode: "math"
              };
              return parser.callFunction("\\Big", [arrow], []);
            }
            default:
              return {
                type: "textord",
                text: " ",
                mode: "math"
              };
          }
        }
        function parseCD(parser) {
          const parsedRows = [];
          parser.gullet.beginGroup();
          parser.gullet.macros.set("\\cr", "\\\\\\relax");
          parser.gullet.beginGroup();
          while (true) {
            parsedRows.push(parser.parseExpression(false, "\\\\"));
            parser.gullet.endGroup();
            parser.gullet.beginGroup();
            const next3 = parser.fetch().text;
            if (next3 === "&" || next3 === "\\\\") {
              parser.consume();
            } else if (next3 === "\\end") {
              if (parsedRows[parsedRows.length - 1].length === 0) {
                parsedRows.pop();
              }
              break;
            } else {
              throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
            }
          }
          let row = [];
          const body = [row];
          for (let i = 0; i < parsedRows.length; i++) {
            const rowNodes = parsedRows[i];
            let cell = newCell();
            for (let j2 = 0; j2 < rowNodes.length; j2++) {
              if (!isStartOfArrow(rowNodes[j2])) {
                cell.body.push(rowNodes[j2]);
              } else {
                row.push(cell);
                j2 += 1;
                const arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
                const labels = new Array(2);
                labels[0] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                labels[1] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                if ("=|.".indexOf(arrowChar) > -1)
                  ;
                else if ("<>AV".indexOf(arrowChar) > -1) {
                  for (let labelNum = 0; labelNum < 2; labelNum++) {
                    let inLabel = true;
                    for (let k = j2 + 1; k < rowNodes.length; k++) {
                      if (isLabelEnd(rowNodes[k], arrowChar)) {
                        inLabel = false;
                        j2 = k;
                        break;
                      }
                      if (isStartOfArrow(rowNodes[k])) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                      }
                      labels[labelNum].body.push(rowNodes[k]);
                    }
                    if (inLabel) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
                    }
                  }
                } else {
                  throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
                }
                const arrow = cdArrow(arrowChar, labels, parser);
                const wrappedArrow = {
                  type: "styling",
                  body: [arrow],
                  mode: "math",
                  style: "display"
                  // CD is always displaystyle.
                };
                row.push(wrappedArrow);
                cell = newCell();
              }
            }
            if (i % 2 === 0) {
              row.push(cell);
            } else {
              row.shift();
            }
            row = [];
            body.push(row);
          }
          parser.gullet.endGroup();
          parser.gullet.endGroup();
          const cols = new Array(body[0].length).fill({
            type: "align",
            align: "c",
            pregap: 0.25,
            // CD package sets \enskip between columns.
            postgap: 0.25
            // So pre and post each get half an \enskip, i.e. 0.25em.
          });
          return {
            type: "array",
            mode: "math",
            body,
            arraystretch: 1,
            addJot: true,
            rowGaps: [null],
            cols,
            colSeparationType: "CD",
            hLinesBeforeRow: new Array(body.length + 1).fill([])
          };
        }
        defineFunction({
          type: "cdlabel",
          names: ["\\\\cdleft", "\\\\cdright"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "cdlabel",
              mode: parser.mode,
              side: funcName.slice(4),
              label: args[0]
            };
          },
          htmlBuilder(group, options) {
            const newOptions = options.havingStyle(options.style.sup());
            const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
            label.classes.push("cd-label-" + group.side);
            label.style.bottom = makeEm(0.8 - label.depth);
            label.height = 0;
            label.depth = 0;
            return label;
          },
          mathmlBuilder(group, options) {
            let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
            label = new mathMLTree.MathNode("mpadded", [label]);
            label.setAttribute("width", "0");
            if (group.side === "left") {
              label.setAttribute("lspace", "-1width");
            }
            label.setAttribute("voffset", "0.7em");
            label = new mathMLTree.MathNode("mstyle", [label]);
            label.setAttribute("displaystyle", "false");
            label.setAttribute("scriptlevel", "1");
            return label;
          }
        });
        defineFunction({
          type: "cdlabelparent",
          names: ["\\\\cdparent"],
          props: {
            numArgs: 1
          },
          handler(_ref2, args) {
            let {
              parser
            } = _ref2;
            return {
              type: "cdlabelparent",
              mode: parser.mode,
              fragment: args[0]
            };
          },
          htmlBuilder(group, options) {
            const parent2 = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
            parent2.classes.push("cd-vert-arrow");
            return parent2;
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
          }
        });
        defineFunction({
          type: "textord",
          names: ["\\@char"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const arg = assertNodeType(args[0], "ordgroup");
            const group = arg.body;
            let number2 = "";
            for (let i = 0; i < group.length; i++) {
              const node2 = assertNodeType(group[i], "textord");
              number2 += node2.text;
            }
            let code2 = parseInt(number2);
            let text2;
            if (isNaN(code2)) {
              throw new src_ParseError("\\@char has non-numeric argument " + number2);
            } else if (code2 < 0 || code2 >= 1114111) {
              throw new src_ParseError("\\@char with invalid code point " + number2);
            } else if (code2 <= 65535) {
              text2 = String.fromCharCode(code2);
            } else {
              code2 -= 65536;
              text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
            }
            return {
              type: "textord",
              mode: parser.mode,
              text: text2
            };
          }
        });
        const color_htmlBuilder = (group, options) => {
          const elements = buildExpression(group.body, options.withColor(group.color), false);
          return buildCommon.makeFragment(elements);
        };
        const color_mathmlBuilder = (group, options) => {
          const inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
          const node2 = new mathMLTree.MathNode("mstyle", inner2);
          node2.setAttribute("mathcolor", group.color);
          return node2;
        };
        defineFunction({
          type: "color",
          names: ["\\textcolor"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "original"]
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const color2 = assertNodeType(args[0], "color-token").color;
            const body = args[1];
            return {
              type: "color",
              mode: parser.mode,
              color: color2,
              body: ordargument(body)
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        defineFunction({
          type: "color",
          names: ["\\color"],
          props: {
            numArgs: 1,
            allowedInText: true,
            argTypes: ["color"]
          },
          handler(_ref2, args) {
            let {
              parser,
              breakOnTokenText
            } = _ref2;
            const color2 = assertNodeType(args[0], "color-token").color;
            parser.gullet.macros.set("\\current@color", color2);
            const body = parser.parseExpression(true, breakOnTokenText);
            return {
              type: "color",
              mode: parser.mode,
              color: color2,
              body
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        defineFunction({
          type: "cr",
          names: ["\\\\"],
          props: {
            numArgs: 0,
            numOptionalArgs: 0,
            allowedInText: true
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
            const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
            return {
              type: "cr",
              mode: parser.mode,
              newLine,
              size: size && assertNodeType(size, "size").value
            };
          },
          // The following builders are called only at the top level,
          // not within tabular/array environments.
          htmlBuilder(group, options) {
            const span = buildCommon.makeSpan(["mspace"], [], options);
            if (group.newLine) {
              span.classes.push("newline");
              if (group.size) {
                span.style.marginTop = makeEm(calculateSize(group.size, options));
              }
            }
            return span;
          },
          mathmlBuilder(group, options) {
            const node2 = new mathMLTree.MathNode("mspace");
            if (group.newLine) {
              node2.setAttribute("linebreak", "newline");
              if (group.size) {
                node2.setAttribute("height", makeEm(calculateSize(group.size, options)));
              }
            }
            return node2;
          }
        });
        const globalMap = {
          "\\global": "\\global",
          "\\long": "\\\\globallong",
          "\\\\globallong": "\\\\globallong",
          "\\def": "\\gdef",
          "\\gdef": "\\gdef",
          "\\edef": "\\xdef",
          "\\xdef": "\\xdef",
          "\\let": "\\\\globallet",
          "\\futurelet": "\\\\globalfuture"
        };
        const checkControlSequence = (tok) => {
          const name2 = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          return name2;
        };
        const getRHS = (parser) => {
          let tok = parser.gullet.popToken();
          if (tok.text === "=") {
            tok = parser.gullet.popToken();
            if (tok.text === " ") {
              tok = parser.gullet.popToken();
            }
          }
          return tok;
        };
        const letCommand = (parser, name2, tok, global2) => {
          let macro = parser.gullet.macros.get(tok.text);
          if (macro == null) {
            tok.noexpand = true;
            macro = {
              tokens: [tok],
              numArgs: 0,
              // reproduce the same behavior in expansion
              unexpandable: !parser.gullet.isExpandable(tok.text)
            };
          }
          parser.gullet.macros.set(name2, macro, global2);
        };
        defineFunction({
          type: "internal",
          names: [
            "\\global",
            "\\long",
            "\\\\globallong"
            // can’t be entered directly
          ],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler(_ref) {
            let {
              parser,
              funcName
            } = _ref;
            parser.consumeSpaces();
            const token2 = parser.fetch();
            if (globalMap[token2.text]) {
              if (funcName === "\\global" || funcName === "\\\\globallong") {
                token2.text = globalMap[token2.text];
              }
              return assertNodeType(parser.parseFunction(), "internal");
            }
            throw new src_ParseError("Invalid token after macro prefix", token2);
          }
        });
        defineFunction({
          type: "internal",
          names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref2) {
            let {
              parser,
              funcName
            } = _ref2;
            let tok = parser.gullet.popToken();
            const name2 = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            let numArgs = 0;
            let insert;
            const delimiters2 = [[]];
            while (parser.gullet.future().text !== "{") {
              tok = parser.gullet.popToken();
              if (tok.text === "#") {
                if (parser.gullet.future().text === "{") {
                  insert = parser.gullet.future();
                  delimiters2[numArgs].push("{");
                  break;
                }
                tok = parser.gullet.popToken();
                if (!/^[1-9]$/.test(tok.text)) {
                  throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                }
                if (parseInt(tok.text) !== numArgs + 1) {
                  throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                }
                numArgs++;
                delimiters2.push([]);
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Expected a macro definition");
              } else {
                delimiters2[numArgs].push(tok.text);
              }
            }
            let {
              tokens
            } = parser.gullet.consumeArg();
            if (insert) {
              tokens.unshift(insert);
            }
            if (funcName === "\\edef" || funcName === "\\xdef") {
              tokens = parser.gullet.expandTokens(tokens);
              tokens.reverse();
            }
            parser.gullet.macros.set(name2, {
              tokens,
              numArgs,
              delimiters: delimiters2
            }, funcName === globalMap[funcName]);
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\let",
            "\\\\globallet"
            // can’t be entered directly
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref3) {
            let {
              parser,
              funcName
            } = _ref3;
            const name2 = checkControlSequence(parser.gullet.popToken());
            parser.gullet.consumeSpaces();
            const tok = getRHS(parser);
            letCommand(parser, name2, tok, funcName === "\\\\globallet");
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\futurelet",
            "\\\\globalfuture"
            // can’t be entered directly
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref4) {
            let {
              parser,
              funcName
            } = _ref4;
            const name2 = checkControlSequence(parser.gullet.popToken());
            const middle = parser.gullet.popToken();
            const tok = parser.gullet.popToken();
            letCommand(parser, name2, tok, funcName === "\\\\globalfuture");
            parser.gullet.pushToken(tok);
            parser.gullet.pushToken(middle);
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        const getMetrics = function(symbol2, font, mode) {
          const replace2 = src_symbols.math[symbol2] && src_symbols.math[symbol2].replace;
          const metrics = getCharacterMetrics(replace2 || symbol2, font, mode);
          if (!metrics) {
            throw new Error("Unsupported symbol " + symbol2 + " and font size " + font + ".");
          }
          return metrics;
        };
        const styleWrap = function(delim, toStyle, options, classes) {
          const newOptions = options.havingBaseStyle(toStyle);
          const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
          const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
          span.height *= delimSizeMultiplier;
          span.depth *= delimSizeMultiplier;
          span.maxFontSize = newOptions.sizeMultiplier;
          return span;
        };
        const centerSpan = function(span, options, style) {
          const newOptions = options.havingBaseStyle(style);
          const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
          span.classes.push("delimcenter");
          span.style.top = makeEm(shift);
          span.height -= shift;
          span.depth += shift;
        };
        const makeSmallDelim = function(delim, style, center, options, mode, classes) {
          const text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
          const span = styleWrap(text2, style, options, classes);
          if (center) {
            centerSpan(span, options, style);
          }
          return span;
        };
        const mathrmSize = function(value, size, mode, options) {
          return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
        };
        const makeLargeDelim = function(delim, size, center, options, mode, classes) {
          const inner2 = mathrmSize(delim, size, mode, options);
          const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
          if (center) {
            centerSpan(span, options, src_Style.TEXT);
          }
          return span;
        };
        const makeGlyphSpan = function(symbol2, font, mode) {
          let sizeClass;
          if (font === "Size1-Regular") {
            sizeClass = "delim-size1";
          } else {
            sizeClass = "delim-size4";
          }
          const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol2, font, mode)])]);
          return {
            type: "elem",
            elem: corner
          };
        };
        const makeInner = function(ch, height, options) {
          const width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
          const path3 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
          const svgNode2 = new SvgNode([path3], {
            "width": makeEm(width),
            "height": makeEm(height),
            // Override CSS rule `.katex svg { width: 100% }`
            "style": "width:" + makeEm(width),
            "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
            "preserveAspectRatio": "xMinYMin"
          });
          const span = buildCommon.makeSvgSpan([], [svgNode2], options);
          span.height = height;
          span.style.height = makeEm(height);
          span.style.width = makeEm(width);
          return {
            type: "elem",
            elem: span
          };
        };
        const lapInEms = 8e-3;
        const lap = {
          type: "kern",
          size: -1 * lapInEms
        };
        const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
        const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
        const makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
          let top;
          let middle;
          let repeat2;
          let bottom;
          let svgLabel = "";
          let viewBoxWidth = 0;
          top = repeat2 = bottom = delim;
          middle = null;
          let font = "Size1-Regular";
          if (delim === "\\uparrow") {
            repeat2 = bottom = "⏐";
          } else if (delim === "\\Uparrow") {
            repeat2 = bottom = "‖";
          } else if (delim === "\\downarrow") {
            top = repeat2 = "⏐";
          } else if (delim === "\\Downarrow") {
            top = repeat2 = "‖";
          } else if (delim === "\\updownarrow") {
            top = "\\uparrow";
            repeat2 = "⏐";
            bottom = "\\downarrow";
          } else if (delim === "\\Updownarrow") {
            top = "\\Uparrow";
            repeat2 = "‖";
            bottom = "\\Downarrow";
          } else if (utils2.contains(verts, delim)) {
            repeat2 = "∣";
            svgLabel = "vert";
            viewBoxWidth = 333;
          } else if (utils2.contains(doubleVerts, delim)) {
            repeat2 = "∥";
            svgLabel = "doublevert";
            viewBoxWidth = 556;
          } else if (delim === "[" || delim === "\\lbrack") {
            top = "⎡";
            repeat2 = "⎢";
            bottom = "⎣";
            font = "Size4-Regular";
            svgLabel = "lbrack";
            viewBoxWidth = 667;
          } else if (delim === "]" || delim === "\\rbrack") {
            top = "⎤";
            repeat2 = "⎥";
            bottom = "⎦";
            font = "Size4-Regular";
            svgLabel = "rbrack";
            viewBoxWidth = 667;
          } else if (delim === "\\lfloor" || delim === "⌊") {
            repeat2 = top = "⎢";
            bottom = "⎣";
            font = "Size4-Regular";
            svgLabel = "lfloor";
            viewBoxWidth = 667;
          } else if (delim === "\\lceil" || delim === "⌈") {
            top = "⎡";
            repeat2 = bottom = "⎢";
            font = "Size4-Regular";
            svgLabel = "lceil";
            viewBoxWidth = 667;
          } else if (delim === "\\rfloor" || delim === "⌋") {
            repeat2 = top = "⎥";
            bottom = "⎦";
            font = "Size4-Regular";
            svgLabel = "rfloor";
            viewBoxWidth = 667;
          } else if (delim === "\\rceil" || delim === "⌉") {
            top = "⎤";
            repeat2 = bottom = "⎥";
            font = "Size4-Regular";
            svgLabel = "rceil";
            viewBoxWidth = 667;
          } else if (delim === "(" || delim === "\\lparen") {
            top = "⎛";
            repeat2 = "⎜";
            bottom = "⎝";
            font = "Size4-Regular";
            svgLabel = "lparen";
            viewBoxWidth = 875;
          } else if (delim === ")" || delim === "\\rparen") {
            top = "⎞";
            repeat2 = "⎟";
            bottom = "⎠";
            font = "Size4-Regular";
            svgLabel = "rparen";
            viewBoxWidth = 875;
          } else if (delim === "\\{" || delim === "\\lbrace") {
            top = "⎧";
            middle = "⎨";
            bottom = "⎩";
            repeat2 = "⎪";
            font = "Size4-Regular";
          } else if (delim === "\\}" || delim === "\\rbrace") {
            top = "⎫";
            middle = "⎬";
            bottom = "⎭";
            repeat2 = "⎪";
            font = "Size4-Regular";
          } else if (delim === "\\lgroup" || delim === "⟮") {
            top = "⎧";
            bottom = "⎩";
            repeat2 = "⎪";
            font = "Size4-Regular";
          } else if (delim === "\\rgroup" || delim === "⟯") {
            top = "⎫";
            bottom = "⎭";
            repeat2 = "⎪";
            font = "Size4-Regular";
          } else if (delim === "\\lmoustache" || delim === "⎰") {
            top = "⎧";
            bottom = "⎭";
            repeat2 = "⎪";
            font = "Size4-Regular";
          } else if (delim === "\\rmoustache" || delim === "⎱") {
            top = "⎫";
            bottom = "⎩";
            repeat2 = "⎪";
            font = "Size4-Regular";
          }
          const topMetrics = getMetrics(top, font, mode);
          const topHeightTotal = topMetrics.height + topMetrics.depth;
          const repeatMetrics = getMetrics(repeat2, font, mode);
          const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
          const bottomMetrics = getMetrics(bottom, font, mode);
          const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
          let middleHeightTotal = 0;
          let middleFactor = 1;
          if (middle !== null) {
            const middleMetrics = getMetrics(middle, font, mode);
            middleHeightTotal = middleMetrics.height + middleMetrics.depth;
            middleFactor = 2;
          }
          const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
          const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
          const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
          let axisHeight = options.fontMetrics().axisHeight;
          if (center) {
            axisHeight *= options.sizeMultiplier;
          }
          const depth = realHeightTotal / 2 - axisHeight;
          const stack = [];
          if (svgLabel.length > 0) {
            const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
            const viewBoxHeight = Math.round(realHeightTotal * 1e3);
            const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
            const path3 = new PathNode(svgLabel, pathStr);
            const width = (viewBoxWidth / 1e3).toFixed(3) + "em";
            const height = (viewBoxHeight / 1e3).toFixed(3) + "em";
            const svg = new SvgNode([path3], {
              "width": width,
              "height": height,
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
            });
            const wrapper2 = buildCommon.makeSvgSpan([], [svg], options);
            wrapper2.height = viewBoxHeight / 1e3;
            wrapper2.style.width = width;
            wrapper2.style.height = height;
            stack.push({
              type: "elem",
              elem: wrapper2
            });
          } else {
            stack.push(makeGlyphSpan(bottom, font, mode));
            stack.push(lap);
            if (middle === null) {
              const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
              stack.push(makeInner(repeat2, innerHeight, options));
            } else {
              const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
              stack.push(makeInner(repeat2, innerHeight, options));
              stack.push(lap);
              stack.push(makeGlyphSpan(middle, font, mode));
              stack.push(lap);
              stack.push(makeInner(repeat2, innerHeight, options));
            }
            stack.push(lap);
            stack.push(makeGlyphSpan(top, font, mode));
          }
          const newOptions = options.havingBaseStyle(src_Style.TEXT);
          const inner2 = buildCommon.makeVList({
            positionType: "bottom",
            positionData: depth,
            children: stack
          }, newOptions);
          return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
        };
        const vbPad = 80;
        const emPad = 0.08;
        const sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
          const path3 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
          const pathNode = new PathNode(sqrtName, path3);
          const svg = new SvgNode([pathNode], {
            // Note: 1000:1 ratio of viewBox to document em width.
            "width": "400em",
            "height": makeEm(height),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
        };
        const makeSqrtImage = function(height, options) {
          const newOptions = options.havingBaseSizing();
          const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
          let sizeMultiplier = newOptions.sizeMultiplier;
          const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
          let span;
          let spanHeight = 0;
          let texHeight = 0;
          let viewBoxHeight = 0;
          let advanceWidth;
          if (delim.type === "small") {
            viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
            if (height < 1) {
              sizeMultiplier = 1;
            } else if (height < 1.4) {
              sizeMultiplier = 0.7;
            }
            spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
            texHeight = (1 + extraVinculum) / sizeMultiplier;
            span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "0.853em";
            advanceWidth = 0.833 / sizeMultiplier;
          } else if (delim.type === "large") {
            viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
            texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
            spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
            span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "1.02em";
            advanceWidth = 1 / sizeMultiplier;
          } else {
            spanHeight = height + extraVinculum + emPad;
            texHeight = height + extraVinculum;
            viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
            span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
            span.style.minWidth = "0.742em";
            advanceWidth = 1.056;
          }
          span.height = texHeight;
          span.style.height = makeEm(spanHeight);
          return {
            span,
            advanceWidth,
            // Calculate the actual line width.
            // This actually should depend on the chosen font -- e.g. \boldmath
            // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
            // have thicker rules.
            ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
          };
        };
        const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"];
        const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"];
        const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
        const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
        const makeSizedDelim = function(delim, size, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "⟨") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
            delim = "\\rangle";
          }
          if (utils2.contains(stackLargeDelimiters, delim) || utils2.contains(stackNeverDelimiters, delim)) {
            return makeLargeDelim(delim, size, false, options, mode, classes);
          } else if (utils2.contains(stackAlwaysDelimiters, delim)) {
            return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
          } else {
            throw new src_ParseError("Illegal delimiter: '" + delim + "'");
          }
        };
        const stackNeverDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }];
        const stackAlwaysDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "stack"
        }];
        const stackLargeDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }, {
          type: "stack"
        }];
        const delimTypeToFont = function(type) {
          if (type.type === "small") {
            return "Main-Regular";
          } else if (type.type === "large") {
            return "Size" + type.size + "-Regular";
          } else if (type.type === "stack") {
            return "Size4-Regular";
          } else {
            throw new Error("Add support for delim type '" + type.type + "' here.");
          }
        };
        const traverseSequence = function(delim, height, sequence, options) {
          const start2 = Math.min(2, 3 - options.style.size);
          for (let i = start2; i < sequence.length; i++) {
            if (sequence[i].type === "stack") {
              break;
            }
            const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
            let heightDepth = metrics.height + metrics.depth;
            if (sequence[i].type === "small") {
              const newOptions = options.havingBaseStyle(sequence[i].style);
              heightDepth *= newOptions.sizeMultiplier;
            }
            if (heightDepth > height) {
              return sequence[i];
            }
          }
          return sequence[sequence.length - 1];
        };
        const makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "⟨") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
            delim = "\\rangle";
          }
          let sequence;
          if (utils2.contains(stackNeverDelimiters, delim)) {
            sequence = stackNeverDelimiterSequence;
          } else if (utils2.contains(stackLargeDelimiters, delim)) {
            sequence = stackLargeDelimiterSequence;
          } else {
            sequence = stackAlwaysDelimiterSequence;
          }
          const delimType = traverseSequence(delim, height, sequence, options);
          if (delimType.type === "small") {
            return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
          } else if (delimType.type === "large") {
            return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
          } else {
            return makeStackedDelim(delim, height, center, options, mode, classes);
          }
        };
        const makeLeftRightDelim = function(delim, height, depth, options, mode, classes) {
          const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
          const delimiterFactor = 901;
          const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
          const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
          const totalHeight = Math.max(
            // In real TeX, calculations are done using integral values which are
            // 65536 per pt, or 655360 per em. So, the division here truncates in
            // TeX but doesn't here, producing different results. If we wanted to
            // exactly match TeX's calculation, we could do
            //   Math.floor(655360 * maxDistFromAxis / 500) *
            //    delimiterFactor / 655360
            // (To see the difference, compare
            //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
            // in TeX and KaTeX)
            maxDistFromAxis / 500 * delimiterFactor,
            2 * maxDistFromAxis - delimiterExtend
          );
          return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
        };
        var delimiter2 = {
          sqrtImage: makeSqrtImage,
          sizedDelim: makeSizedDelim,
          sizeToMaxHeight,
          customSizedDelim: makeCustomSizedDelim,
          leftRightDelim: makeLeftRightDelim
        };
        const delimiterSizes = {
          "\\bigl": {
            mclass: "mopen",
            size: 1
          },
          "\\Bigl": {
            mclass: "mopen",
            size: 2
          },
          "\\biggl": {
            mclass: "mopen",
            size: 3
          },
          "\\Biggl": {
            mclass: "mopen",
            size: 4
          },
          "\\bigr": {
            mclass: "mclose",
            size: 1
          },
          "\\Bigr": {
            mclass: "mclose",
            size: 2
          },
          "\\biggr": {
            mclass: "mclose",
            size: 3
          },
          "\\Biggr": {
            mclass: "mclose",
            size: 4
          },
          "\\bigm": {
            mclass: "mrel",
            size: 1
          },
          "\\Bigm": {
            mclass: "mrel",
            size: 2
          },
          "\\biggm": {
            mclass: "mrel",
            size: 3
          },
          "\\Biggm": {
            mclass: "mrel",
            size: 4
          },
          "\\big": {
            mclass: "mord",
            size: 1
          },
          "\\Big": {
            mclass: "mord",
            size: 2
          },
          "\\bigg": {
            mclass: "mord",
            size: 3
          },
          "\\Bigg": {
            mclass: "mord",
            size: 4
          }
        };
        const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
        function checkDelimiter(delim, context) {
          const symDelim = checkSymbolNodeType(delim);
          if (symDelim && utils2.contains(delimiters, symDelim.text)) {
            return symDelim;
          } else if (symDelim) {
            throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
          } else {
            throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
          }
        }
        defineFunction({
          type: "delimsizing",
          names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
          props: {
            numArgs: 1,
            argTypes: ["primitive"]
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            return {
              type: "delimsizing",
              mode: context.parser.mode,
              size: delimiterSizes[context.funcName].size,
              mclass: delimiterSizes[context.funcName].mclass,
              delim: delim.text
            };
          },
          htmlBuilder: (group, options) => {
            if (group.delim === ".") {
              return buildCommon.makeSpan([group.mclass]);
            }
            return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
          },
          mathmlBuilder: (group) => {
            const children2 = [];
            if (group.delim !== ".") {
              children2.push(makeText(group.delim, group.mode));
            }
            const node2 = new mathMLTree.MathNode("mo", children2);
            if (group.mclass === "mopen" || group.mclass === "mclose") {
              node2.setAttribute("fence", "true");
            } else {
              node2.setAttribute("fence", "false");
            }
            node2.setAttribute("stretchy", "true");
            const size = makeEm(delimiter2.sizeToMaxHeight[group.size]);
            node2.setAttribute("minsize", size);
            node2.setAttribute("maxsize", size);
            return node2;
          }
        });
        function assertParsed(group) {
          if (!group.body) {
            throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
        }
        defineFunction({
          type: "leftright-right",
          names: ["\\right"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const color2 = context.parser.gullet.macros.get("\\current@color");
            if (color2 && typeof color2 !== "string") {
              throw new src_ParseError("\\current@color set to non-string in \\right");
            }
            return {
              type: "leftright-right",
              mode: context.parser.mode,
              delim: checkDelimiter(args[0], context).text,
              color: color2
              // undefined if not set via \color
            };
          }
        });
        defineFunction({
          type: "leftright",
          names: ["\\left"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            const parser = context.parser;
            ++parser.leftrightDepth;
            const body = parser.parseExpression(false);
            --parser.leftrightDepth;
            parser.expect("\\right", false);
            const right = assertNodeType(parser.parseFunction(), "leftright-right");
            return {
              type: "leftright",
              mode: parser.mode,
              body,
              left: delim.text,
              right: right.delim,
              rightColor: right.color
            };
          },
          htmlBuilder: (group, options) => {
            assertParsed(group);
            const inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
            let innerHeight = 0;
            let innerDepth = 0;
            let hadMiddle = false;
            for (let i = 0; i < inner2.length; i++) {
              if (inner2[i].isMiddle) {
                hadMiddle = true;
              } else {
                innerHeight = Math.max(inner2[i].height, innerHeight);
                innerDepth = Math.max(inner2[i].depth, innerDepth);
              }
            }
            innerHeight *= options.sizeMultiplier;
            innerDepth *= options.sizeMultiplier;
            let leftDelim;
            if (group.left === ".") {
              leftDelim = makeNullDelimiter(options, ["mopen"]);
            } else {
              leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
            }
            inner2.unshift(leftDelim);
            if (hadMiddle) {
              for (let i = 1; i < inner2.length; i++) {
                const middleDelim = inner2[i];
                const isMiddle = middleDelim.isMiddle;
                if (isMiddle) {
                  inner2[i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                }
              }
            }
            let rightDelim;
            if (group.right === ".") {
              rightDelim = makeNullDelimiter(options, ["mclose"]);
            } else {
              const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
              rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
            }
            inner2.push(rightDelim);
            return buildCommon.makeSpan(["minner"], inner2, options);
          },
          mathmlBuilder: (group, options) => {
            assertParsed(group);
            const inner2 = buildMathML_buildExpression(group.body, options);
            if (group.left !== ".") {
              const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
              leftNode.setAttribute("fence", "true");
              inner2.unshift(leftNode);
            }
            if (group.right !== ".") {
              const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
              rightNode.setAttribute("fence", "true");
              if (group.rightColor) {
                rightNode.setAttribute("mathcolor", group.rightColor);
              }
              inner2.push(rightNode);
            }
            return makeRow(inner2);
          }
        });
        defineFunction({
          type: "middle",
          names: ["\\middle"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (context, args) => {
            const delim = checkDelimiter(args[0], context);
            if (!context.parser.leftrightDepth) {
              throw new src_ParseError("\\middle without preceding \\left", delim);
            }
            return {
              type: "middle",
              mode: context.parser.mode,
              delim: delim.text
            };
          },
          htmlBuilder: (group, options) => {
            let middleDelim;
            if (group.delim === ".") {
              middleDelim = makeNullDelimiter(options, []);
            } else {
              middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
              const isMiddle = {
                delim: group.delim,
                options
              };
              middleDelim.isMiddle = isMiddle;
            }
            return middleDelim;
          },
          mathmlBuilder: (group, options) => {
            const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
            const middleNode = new mathMLTree.MathNode("mo", [textNode]);
            middleNode.setAttribute("fence", "true");
            middleNode.setAttribute("lspace", "0.05em");
            middleNode.setAttribute("rspace", "0.05em");
            return middleNode;
          }
        });
        const enclose_htmlBuilder = (group, options) => {
          const inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
          const label = group.label.slice(1);
          let scale = options.sizeMultiplier;
          let img;
          let imgShift = 0;
          const isSingleChar = utils2.isCharacterBox(group.body);
          if (label === "sout") {
            img = buildCommon.makeSpan(["stretchy", "sout"]);
            img.height = options.fontMetrics().defaultRuleThickness / scale;
            imgShift = -0.5 * options.fontMetrics().xHeight;
          } else if (label === "phase") {
            const lineWeight = calculateSize({
              number: 0.6,
              unit: "pt"
            }, options);
            const clearance = calculateSize({
              number: 0.35,
              unit: "ex"
            }, options);
            const newOptions = options.havingBaseSizing();
            scale = scale / newOptions.sizeMultiplier;
            const angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
            inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
            const viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
            const path3 = phasePath(viewBoxHeight);
            const svgNode2 = new SvgNode([new PathNode("phase", path3)], {
              "width": "400em",
              "height": makeEm(viewBoxHeight / 1e3),
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode2], options);
            img.style.height = makeEm(angleHeight);
            imgShift = inner2.depth + lineWeight + clearance;
          } else {
            if (/cancel/.test(label)) {
              if (!isSingleChar) {
                inner2.classes.push("cancel-pad");
              }
            } else if (label === "angl") {
              inner2.classes.push("anglpad");
            } else {
              inner2.classes.push("boxpad");
            }
            let topPad = 0;
            let bottomPad = 0;
            let ruleThickness = 0;
            if (/box/.test(label)) {
              ruleThickness = Math.max(
                options.fontMetrics().fboxrule,
                // default
                options.minRuleThickness
                // User override.
              );
              topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
              bottomPad = topPad;
            } else if (label === "angl") {
              ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
              topPad = 4 * ruleThickness;
              bottomPad = Math.max(0, 0.25 - inner2.depth);
            } else {
              topPad = isSingleChar ? 0.2 : 0;
              bottomPad = topPad;
            }
            img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
            if (/fbox|boxed|fcolorbox/.test(label)) {
              img.style.borderStyle = "solid";
              img.style.borderWidth = makeEm(ruleThickness);
            } else if (label === "angl" && ruleThickness !== 0.049) {
              img.style.borderTopWidth = makeEm(ruleThickness);
              img.style.borderRightWidth = makeEm(ruleThickness);
            }
            imgShift = inner2.depth + bottomPad;
            if (group.backgroundColor) {
              img.style.backgroundColor = group.backgroundColor;
              if (group.borderColor) {
                img.style.borderColor = group.borderColor;
              }
            }
          }
          let vlist;
          if (group.backgroundColor) {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                // Put the color background behind inner;
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift
                },
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                }
              ]
            }, options);
          } else {
            const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                // Write the \cancel stroke on top of inner.
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                },
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift,
                  wrapperClasses: classes
                }
              ]
            }, options);
          }
          if (/cancel/.test(label)) {
            vlist.height = inner2.height;
            vlist.depth = inner2.depth;
          }
          if (/cancel/.test(label) && !isSingleChar) {
            return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
          } else {
            return buildCommon.makeSpan(["mord"], [vlist], options);
          }
        };
        const enclose_mathmlBuilder = (group, options) => {
          let fboxsep = 0;
          const node2 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
          switch (group.label) {
            case "\\cancel":
              node2.setAttribute("notation", "updiagonalstrike");
              break;
            case "\\bcancel":
              node2.setAttribute("notation", "downdiagonalstrike");
              break;
            case "\\phase":
              node2.setAttribute("notation", "phasorangle");
              break;
            case "\\sout":
              node2.setAttribute("notation", "horizontalstrike");
              break;
            case "\\fbox":
              node2.setAttribute("notation", "box");
              break;
            case "\\angl":
              node2.setAttribute("notation", "actuarial");
              break;
            case "\\fcolorbox":
            case "\\colorbox":
              fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
              node2.setAttribute("width", "+" + 2 * fboxsep + "pt");
              node2.setAttribute("height", "+" + 2 * fboxsep + "pt");
              node2.setAttribute("lspace", fboxsep + "pt");
              node2.setAttribute("voffset", fboxsep + "pt");
              if (group.label === "\\fcolorbox") {
                const thk = Math.max(
                  options.fontMetrics().fboxrule,
                  // default
                  options.minRuleThickness
                  // user override
                );
                node2.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
              }
              break;
            case "\\xcancel":
              node2.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
              break;
          }
          if (group.backgroundColor) {
            node2.setAttribute("mathbackground", group.backgroundColor);
          }
          return node2;
        };
        defineFunction({
          type: "enclose",
          names: ["\\colorbox"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "text"]
          },
          handler(_ref, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref;
            const color2 = assertNodeType(args[0], "color-token").color;
            const body = args[1];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              backgroundColor: color2,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fcolorbox"],
          props: {
            numArgs: 3,
            allowedInText: true,
            argTypes: ["color", "color", "text"]
          },
          handler(_ref2, args, optArgs) {
            let {
              parser,
              funcName
            } = _ref2;
            const borderColor = assertNodeType(args[0], "color-token").color;
            const backgroundColor = assertNodeType(args[1], "color-token").color;
            const body = args[2];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              backgroundColor,
              borderColor,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fbox"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: true
          },
          handler(_ref3, args) {
            let {
              parser
            } = _ref3;
            return {
              type: "enclose",
              mode: parser.mode,
              label: "\\fbox",
              body: args[0]
            };
          }
        });
        defineFunction({
          type: "enclose",
          names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
          props: {
            numArgs: 1
          },
          handler(_ref4, args) {
            let {
              parser,
              funcName
            } = _ref4;
            const body = args[0];
            return {
              type: "enclose",
              mode: parser.mode,
              label: funcName,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\angl"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: false
          },
          handler(_ref5, args) {
            let {
              parser
            } = _ref5;
            return {
              type: "enclose",
              mode: parser.mode,
              label: "\\angl",
              body: args[0]
            };
          }
        });
        const _environments = {};
        function defineEnvironment(_ref) {
          let {
            type,
            names,
            props,
            handler,
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          } = _ref;
          const data2 = {
            type,
            numArgs: props.numArgs || 0,
            allowedInText: false,
            numOptionalArgs: 0,
            handler
          };
          for (let i = 0; i < names.length; ++i) {
            _environments[names[i]] = data2;
          }
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
        const _macros = {};
        function defineMacro(name2, body) {
          _macros[name2] = body;
        }
        class SourceLocation {
          // The + prefix indicates that these fields aren't writeable
          // Lexer holding the input string.
          // Start offset, zero-based inclusive.
          // End offset, zero-based exclusive.
          constructor(lexer, start2, end2) {
            this.lexer = void 0;
            this.start = void 0;
            this.end = void 0;
            this.lexer = lexer;
            this.start = start2;
            this.end = end2;
          }
          /**
           * Merges two `SourceLocation`s from location providers, given they are
           * provided in order of appearance.
           * - Returns the first one's location if only the first is provided.
           * - Returns a merged range of the first and the last if both are provided
           *   and their lexers match.
           * - Otherwise, returns null.
           */
          static range(first2, second) {
            if (!second) {
              return first2 && first2.loc;
            } else if (!first2 || !first2.loc || !second.loc || first2.loc.lexer !== second.loc.lexer) {
              return null;
            } else {
              return new SourceLocation(first2.loc.lexer, first2.loc.start, second.loc.end);
            }
          }
        }
        class Token2 {
          // don't expand the token
          // used in \noexpand
          constructor(text2, loc) {
            this.text = void 0;
            this.loc = void 0;
            this.noexpand = void 0;
            this.treatAsRelax = void 0;
            this.text = text2;
            this.loc = loc;
          }
          /**
           * Given a pair of tokens (this and endToken), compute a `Token` encompassing
           * the whole input range enclosed by these two.
           */
          range(endToken, text2) {
            return new Token2(text2, SourceLocation.range(this, endToken));
          }
        }
        function getHLines(parser) {
          const hlineInfo = [];
          parser.consumeSpaces();
          let nxt = parser.fetch().text;
          if (nxt === "\\relax") {
            parser.consume();
            parser.consumeSpaces();
            nxt = parser.fetch().text;
          }
          while (nxt === "\\hline" || nxt === "\\hdashline") {
            parser.consume();
            hlineInfo.push(nxt === "\\hdashline");
            parser.consumeSpaces();
            nxt = parser.fetch().text;
          }
          return hlineInfo;
        }
        const validateAmsEnvironmentContext = (context) => {
          const settings = context.parser.settings;
          if (!settings.displayMode) {
            throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
          }
        };
        function getAutoTag(name2) {
          if (name2.indexOf("ed") === -1) {
            return name2.indexOf("*") === -1;
          }
        }
        function parseArray(parser, _ref, style) {
          let {
            hskipBeforeAndAfter,
            addJot,
            cols,
            arraystretch,
            colSeparationType,
            autoTag,
            singleRow,
            emptySingleRow,
            maxNumCols,
            leqno
          } = _ref;
          parser.gullet.beginGroup();
          if (!singleRow) {
            parser.gullet.macros.set("\\cr", "\\\\\\relax");
          }
          if (!arraystretch) {
            const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
            if (stretch == null) {
              arraystretch = 1;
            } else {
              arraystretch = parseFloat(stretch);
              if (!arraystretch || arraystretch < 0) {
                throw new src_ParseError("Invalid \\arraystretch: " + stretch);
              }
            }
          }
          parser.gullet.beginGroup();
          let row = [];
          const body = [row];
          const rowGaps = [];
          const hLinesBeforeRow = [];
          const tags = autoTag != null ? [] : void 0;
          function beginRow() {
            if (autoTag) {
              parser.gullet.macros.set("\\@eqnsw", "1", true);
            }
          }
          function endRow() {
            if (tags) {
              if (parser.gullet.macros.get("\\df@tag")) {
                tags.push(parser.subparse([new Token2("\\df@tag")]));
                parser.gullet.macros.set("\\df@tag", void 0, true);
              } else {
                tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
              }
            }
          }
          beginRow();
          hLinesBeforeRow.push(getHLines(parser));
          while (true) {
            let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
            parser.gullet.endGroup();
            parser.gullet.beginGroup();
            cell = {
              type: "ordgroup",
              mode: parser.mode,
              body: cell
            };
            if (style) {
              cell = {
                type: "styling",
                mode: parser.mode,
                style,
                body: [cell]
              };
            }
            row.push(cell);
            const next3 = parser.fetch().text;
            if (next3 === "&") {
              if (maxNumCols && row.length === maxNumCols) {
                if (singleRow || colSeparationType) {
                  throw new src_ParseError("Too many tab characters: &", parser.nextToken);
                } else {
                  parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
              }
              parser.consume();
            } else if (next3 === "\\end") {
              endRow();
              if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                body.pop();
              }
              if (hLinesBeforeRow.length < body.length + 1) {
                hLinesBeforeRow.push([]);
              }
              break;
            } else if (next3 === "\\\\") {
              parser.consume();
              let size;
              if (parser.gullet.future().text !== " ") {
                size = parser.parseSizeGroup(true);
              }
              rowGaps.push(size ? size.value : null);
              endRow();
              hLinesBeforeRow.push(getHLines(parser));
              row = [];
              body.push(row);
              beginRow();
            } else {
              throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
            }
          }
          parser.gullet.endGroup();
          parser.gullet.endGroup();
          return {
            type: "array",
            mode: parser.mode,
            addJot,
            arraystretch,
            body,
            cols,
            rowGaps,
            hskipBeforeAndAfter,
            hLinesBeforeRow,
            colSeparationType,
            tags,
            leqno
          };
        }
        function dCellStyle(envName) {
          if (envName.slice(0, 1) === "d") {
            return "display";
          } else {
            return "text";
          }
        }
        const array_htmlBuilder = function(group, options) {
          let r;
          let c2;
          const nr = group.body.length;
          const hLinesBeforeRow = group.hLinesBeforeRow;
          let nc = 0;
          let body = new Array(nr);
          const hlines = [];
          const ruleThickness = Math.max(
            // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
            options.fontMetrics().arrayRuleWidth,
            options.minRuleThickness
            // User override.
          );
          const pt2 = 1 / options.fontMetrics().ptPerEm;
          let arraycolsep = 5 * pt2;
          if (group.colSeparationType && group.colSeparationType === "small") {
            const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
            arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
          }
          const baselineskip = group.colSeparationType === "CD" ? calculateSize({
            number: 3,
            unit: "ex"
          }, options) : 12 * pt2;
          const jot = 3 * pt2;
          const arrayskip = group.arraystretch * baselineskip;
          const arstrutHeight = 0.7 * arrayskip;
          const arstrutDepth = 0.3 * arrayskip;
          let totalHeight = 0;
          function setHLinePos(hlinesInGap) {
            for (let i = 0; i < hlinesInGap.length; ++i) {
              if (i > 0) {
                totalHeight += 0.25;
              }
              hlines.push({
                pos: totalHeight,
                isDashed: hlinesInGap[i]
              });
            }
          }
          setHLinePos(hLinesBeforeRow[0]);
          for (r = 0; r < group.body.length; ++r) {
            const inrow = group.body[r];
            let height = arstrutHeight;
            let depth = arstrutDepth;
            if (nc < inrow.length) {
              nc = inrow.length;
            }
            const outrow = new Array(inrow.length);
            for (c2 = 0; c2 < inrow.length; ++c2) {
              const elt = buildGroup(inrow[c2], options);
              if (depth < elt.depth) {
                depth = elt.depth;
              }
              if (height < elt.height) {
                height = elt.height;
              }
              outrow[c2] = elt;
            }
            const rowGap = group.rowGaps[r];
            let gap = 0;
            if (rowGap) {
              gap = calculateSize(rowGap, options);
              if (gap > 0) {
                gap += arstrutDepth;
                if (depth < gap) {
                  depth = gap;
                }
                gap = 0;
              }
            }
            if (group.addJot) {
              depth += jot;
            }
            outrow.height = height;
            outrow.depth = depth;
            totalHeight += height;
            outrow.pos = totalHeight;
            totalHeight += depth + gap;
            body[r] = outrow;
            setHLinePos(hLinesBeforeRow[r + 1]);
          }
          const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
          const colDescriptions = group.cols || [];
          const cols = [];
          let colSep;
          let colDescrNum;
          const tagSpans = [];
          if (group.tags && group.tags.some((tag) => tag)) {
            for (r = 0; r < nr; ++r) {
              const rw = body[r];
              const shift = rw.pos - offset;
              const tag = group.tags[r];
              let tagSpan;
              if (tag === true) {
                tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
              } else if (tag === false) {
                tagSpan = buildCommon.makeSpan([], [], options);
              } else {
                tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
              }
              tagSpan.depth = rw.depth;
              tagSpan.height = rw.height;
              tagSpans.push({
                type: "elem",
                elem: tagSpan,
                shift
              });
            }
          }
          for (
            c2 = 0, colDescrNum = 0;
            // Continue while either there are more columns or more column
            // descriptions, so trailing separators don't get lost.
            c2 < nc || colDescrNum < colDescriptions.length;
            ++c2, ++colDescrNum
          ) {
            let colDescr = colDescriptions[colDescrNum] || {};
            let firstSeparator = true;
            while (colDescr.type === "separator") {
              if (!firstSeparator) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
                cols.push(colSep);
              }
              if (colDescr.separator === "|" || colDescr.separator === ":") {
                const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                separator.style.height = makeEm(totalHeight);
                separator.style.borderRightWidth = makeEm(ruleThickness);
                separator.style.borderRightStyle = lineType;
                separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
                const shift = totalHeight - offset;
                if (shift) {
                  separator.style.verticalAlign = makeEm(-shift);
                }
                cols.push(separator);
              } else {
                throw new src_ParseError("Invalid separator type: " + colDescr.separator);
              }
              colDescrNum++;
              colDescr = colDescriptions[colDescrNum] || {};
              firstSeparator = false;
            }
            if (c2 >= nc) {
              continue;
            }
            let sepwidth;
            if (c2 > 0 || group.hskipBeforeAndAfter) {
              sepwidth = utils2.deflt(colDescr.pregap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(sepwidth);
                cols.push(colSep);
              }
            }
            let col = [];
            for (r = 0; r < nr; ++r) {
              const row = body[r];
              const elem = row[c2];
              if (!elem) {
                continue;
              }
              const shift = row.pos - offset;
              elem.depth = row.depth;
              elem.height = row.height;
              col.push({
                type: "elem",
                elem,
                shift
              });
            }
            col = buildCommon.makeVList({
              positionType: "individualShift",
              children: col
            }, options);
            col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
            cols.push(col);
            if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
              sepwidth = utils2.deflt(colDescr.postgap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = makeEm(sepwidth);
                cols.push(colSep);
              }
            }
          }
          body = buildCommon.makeSpan(["mtable"], cols);
          if (hlines.length > 0) {
            const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
            const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
            const vListElems = [{
              type: "elem",
              elem: body,
              shift: 0
            }];
            while (hlines.length > 0) {
              const hline = hlines.pop();
              const lineShift = hline.pos - offset;
              if (hline.isDashed) {
                vListElems.push({
                  type: "elem",
                  elem: dashes,
                  shift: lineShift
                });
              } else {
                vListElems.push({
                  type: "elem",
                  elem: line,
                  shift: lineShift
                });
              }
            }
            body = buildCommon.makeVList({
              positionType: "individualShift",
              children: vListElems
            }, options);
          }
          if (tagSpans.length === 0) {
            return buildCommon.makeSpan(["mord"], [body], options);
          } else {
            let eqnNumCol = buildCommon.makeVList({
              positionType: "individualShift",
              children: tagSpans
            }, options);
            eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
            return buildCommon.makeFragment([body, eqnNumCol]);
          }
        };
        const alignMap = {
          c: "center ",
          l: "left ",
          r: "right "
        };
        const array_mathmlBuilder = function(group, options) {
          const tbl = [];
          const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
          const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
          for (let i = 0; i < group.body.length; i++) {
            const rw = group.body[i];
            const row = [];
            for (let j2 = 0; j2 < rw.length; j2++) {
              row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j2], options)]));
            }
            if (group.tags && group.tags[i]) {
              row.unshift(glue);
              row.push(glue);
              if (group.leqno) {
                row.unshift(tag);
              } else {
                row.push(tag);
              }
            }
            tbl.push(new mathMLTree.MathNode("mtr", row));
          }
          let table2 = new mathMLTree.MathNode("mtable", tbl);
          const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
          table2.setAttribute("rowspacing", makeEm(gap));
          let menclose = "";
          let align = "";
          if (group.cols && group.cols.length > 0) {
            const cols = group.cols;
            let columnLines = "";
            let prevTypeWasAlign = false;
            let iStart = 0;
            let iEnd = cols.length;
            if (cols[0].type === "separator") {
              menclose += "top ";
              iStart = 1;
            }
            if (cols[cols.length - 1].type === "separator") {
              menclose += "bottom ";
              iEnd -= 1;
            }
            for (let i = iStart; i < iEnd; i++) {
              if (cols[i].type === "align") {
                align += alignMap[cols[i].align];
                if (prevTypeWasAlign) {
                  columnLines += "none ";
                }
                prevTypeWasAlign = true;
              } else if (cols[i].type === "separator") {
                if (prevTypeWasAlign) {
                  columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                  prevTypeWasAlign = false;
                }
              }
            }
            table2.setAttribute("columnalign", align.trim());
            if (/[sd]/.test(columnLines)) {
              table2.setAttribute("columnlines", columnLines.trim());
            }
          }
          if (group.colSeparationType === "align") {
            const cols = group.cols || [];
            let spacing2 = "";
            for (let i = 1; i < cols.length; i++) {
              spacing2 += i % 2 ? "0em " : "1em ";
            }
            table2.setAttribute("columnspacing", spacing2.trim());
          } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
            table2.setAttribute("columnspacing", "0em");
          } else if (group.colSeparationType === "small") {
            table2.setAttribute("columnspacing", "0.2778em");
          } else if (group.colSeparationType === "CD") {
            table2.setAttribute("columnspacing", "0.5em");
          } else {
            table2.setAttribute("columnspacing", "1em");
          }
          let rowLines = "";
          const hlines = group.hLinesBeforeRow;
          menclose += hlines[0].length > 0 ? "left " : "";
          menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
          for (let i = 1; i < hlines.length - 1; i++) {
            rowLines += hlines[i].length === 0 ? "none " : hlines[i][0] ? "dashed " : "solid ";
          }
          if (/[sd]/.test(rowLines)) {
            table2.setAttribute("rowlines", rowLines.trim());
          }
          if (menclose !== "") {
            table2 = new mathMLTree.MathNode("menclose", [table2]);
            table2.setAttribute("notation", menclose.trim());
          }
          if (group.arraystretch && group.arraystretch < 1) {
            table2 = new mathMLTree.MathNode("mstyle", [table2]);
            table2.setAttribute("scriptlevel", "1");
          }
          return table2;
        };
        const alignedHandler = function(context, args) {
          if (context.envName.indexOf("ed") === -1) {
            validateAmsEnvironmentContext(context);
          }
          const cols = [];
          const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
          const isSplit = context.envName === "split";
          const res = parseArray(context.parser, {
            cols,
            addJot: true,
            autoTag: isSplit ? void 0 : getAutoTag(context.envName),
            emptySingleRow: true,
            colSeparationType: separationType,
            maxNumCols: isSplit ? 2 : void 0,
            leqno: context.parser.settings.leqno
          }, "display");
          let numMaths;
          let numCols = 0;
          const emptyGroup = {
            type: "ordgroup",
            mode: context.mode,
            body: []
          };
          if (args[0] && args[0].type === "ordgroup") {
            let arg0 = "";
            for (let i = 0; i < args[0].body.length; i++) {
              const textord2 = assertNodeType(args[0].body[i], "textord");
              arg0 += textord2.text;
            }
            numMaths = Number(arg0);
            numCols = numMaths * 2;
          }
          const isAligned = !numCols;
          res.body.forEach(function(row) {
            for (let i = 1; i < row.length; i += 2) {
              const styling = assertNodeType(row[i], "styling");
              const ordgroup = assertNodeType(styling.body[0], "ordgroup");
              ordgroup.body.unshift(emptyGroup);
            }
            if (!isAligned) {
              const curMaths = row.length / 2;
              if (numMaths < curMaths) {
                throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
              }
            } else if (numCols < row.length) {
              numCols = row.length;
            }
          });
          for (let i = 0; i < numCols; ++i) {
            let align = "r";
            let pregap = 0;
            if (i % 2 === 1) {
              align = "l";
            } else if (i > 0 && isAligned) {
              pregap = 1;
            }
            cols[i] = {
              type: "align",
              align,
              pregap,
              postgap: 0
            };
          }
          res.colSeparationType = isAligned ? "align" : "alignat";
          return res;
        };
        defineEnvironment({
          type: "array",
          names: ["array", "darray"],
          props: {
            numArgs: 1
          },
          handler(context, args) {
            const symNode = checkSymbolNodeType(args[0]);
            const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            const cols = colalign.map(function(nde) {
              const node2 = assertSymbolNodeType(nde);
              const ca = node2.text;
              if ("lcr".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              } else if (ca === "|") {
                return {
                  type: "separator",
                  separator: "|"
                };
              } else if (ca === ":") {
                return {
                  type: "separator",
                  separator: ":"
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            const res = {
              cols,
              hskipBeforeAndAfter: true,
              // \@preamble in lttab.dtx
              maxNumCols: cols.length
            };
            return parseArray(context.parser, res, dCellStyle(context.envName));
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const delimiters2 = {
              "matrix": null,
              "pmatrix": ["(", ")"],
              "bmatrix": ["[", "]"],
              "Bmatrix": ["\\{", "\\}"],
              "vmatrix": ["|", "|"],
              "Vmatrix": ["\\Vert", "\\Vert"]
            }[context.envName.replace("*", "")];
            let colAlign = "c";
            const payload = {
              hskipBeforeAndAfter: false,
              cols: [{
                type: "align",
                align: colAlign
              }]
            };
            if (context.envName.charAt(context.envName.length - 1) === "*") {
              const parser = context.parser;
              parser.consumeSpaces();
              if (parser.fetch().text === "[") {
                parser.consume();
                parser.consumeSpaces();
                colAlign = parser.fetch().text;
                if ("lcr".indexOf(colAlign) === -1) {
                  throw new src_ParseError("Expected l or c or r", parser.nextToken);
                }
                parser.consume();
                parser.consumeSpaces();
                parser.expect("]");
                parser.consume();
                payload.cols = [{
                  type: "align",
                  align: colAlign
                }];
              }
            }
            const res = parseArray(context.parser, payload, dCellStyle(context.envName));
            const numCols = Math.max(0, ...res.body.map((row) => row.length));
            res.cols = new Array(numCols).fill({
              type: "align",
              align: colAlign
            });
            return delimiters2 ? {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: delimiters2[0],
              right: delimiters2[1],
              rightColor: void 0
              // \right uninfluenced by \color in array
            } : res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["smallmatrix"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const payload = {
              arraystretch: 0.5
            };
            const res = parseArray(context.parser, payload, "script");
            res.colSeparationType = "small";
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["subarray"],
          props: {
            numArgs: 1
          },
          handler(context, args) {
            const symNode = checkSymbolNodeType(args[0]);
            const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            const cols = colalign.map(function(nde) {
              const node2 = assertSymbolNodeType(nde);
              const ca = node2.text;
              if ("lc".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            if (cols.length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            let res = {
              cols,
              hskipBeforeAndAfter: false,
              arraystretch: 0.5
            };
            res = parseArray(context.parser, res, "script");
            if (res.body.length > 0 && res.body[0].length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["cases", "dcases", "rcases", "drcases"],
          props: {
            numArgs: 0
          },
          handler(context) {
            const payload = {
              arraystretch: 1.2,
              cols: [{
                type: "align",
                align: "l",
                pregap: 0,
                // TODO(kevinb) get the current style.
                // For now we use the metrics for TEXT style which is what we were
                // doing before.  Before attempting to get the current style we
                // should look at TeX's behavior especially for \over and matrices.
                postgap: 1
                /* 1em quad */
              }, {
                type: "align",
                align: "l",
                pregap: 0,
                postgap: 0
              }]
            };
            const res = parseArray(context.parser, payload, dCellStyle(context.envName));
            return {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: context.envName.indexOf("r") > -1 ? "." : "\\{",
              right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
              rightColor: void 0
            };
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["align", "align*", "aligned", "split"],
          props: {
            numArgs: 0
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["gathered", "gather", "gather*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            if (utils2.contains(["gather", "gather*"], context.envName)) {
              validateAmsEnvironmentContext(context);
            }
            const res = {
              cols: [{
                type: "align",
                align: "c"
              }],
              addJot: true,
              colSeparationType: "gather",
              autoTag: getAutoTag(context.envName),
              emptySingleRow: true,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["alignat", "alignat*", "alignedat"],
          props: {
            numArgs: 1
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["equation", "equation*"],
          props: {
            numArgs: 0
          },
          handler(context) {
            validateAmsEnvironmentContext(context);
            const res = {
              autoTag: getAutoTag(context.envName),
              emptySingleRow: true,
              singleRow: true,
              maxNumCols: 1,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["CD"],
          props: {
            numArgs: 0
          },
          handler(context) {
            validateAmsEnvironmentContext(context);
            return parseCD(context.parser);
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
        defineMacro("\\notag", "\\nonumber");
        defineFunction({
          type: "text",
          // Doesn't matter what this is.
          names: ["\\hline", "\\hdashline"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: true
          },
          handler(context, args) {
            throw new src_ParseError(context.funcName + " valid only within array environment");
          }
        });
        const environments = _environments;
        var src_environments = environments;
        defineFunction({
          type: "environment",
          names: ["\\begin", "\\end"],
          props: {
            numArgs: 1,
            argTypes: ["text"]
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const nameGroup = args[0];
            if (nameGroup.type !== "ordgroup") {
              throw new src_ParseError("Invalid environment name", nameGroup);
            }
            let envName = "";
            for (let i = 0; i < nameGroup.body.length; ++i) {
              envName += assertNodeType(nameGroup.body[i], "textord").text;
            }
            if (funcName === "\\begin") {
              if (!src_environments.hasOwnProperty(envName)) {
                throw new src_ParseError("No such environment: " + envName, nameGroup);
              }
              const env = src_environments[envName];
              const {
                args: args2,
                optArgs
              } = parser.parseArguments("\\begin{" + envName + "}", env);
              const context = {
                mode: parser.mode,
                envName,
                parser
              };
              const result = env.handler(context, args2, optArgs);
              parser.expect("\\end", false);
              const endNameToken = parser.nextToken;
              const end2 = assertNodeType(parser.parseFunction(), "environment");
              if (end2.name !== envName) {
                throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
              }
              return result;
            }
            return {
              type: "environment",
              mode: parser.mode,
              name: envName,
              nameGroup
            };
          }
        });
        const font_htmlBuilder = (group, options) => {
          const font = group.font;
          const newOptions = options.withFont(font);
          return buildGroup(group.body, newOptions);
        };
        const font_mathmlBuilder = (group, options) => {
          const font = group.font;
          const newOptions = options.withFont(font);
          return buildMathML_buildGroup(group.body, newOptions);
        };
        const fontAliases = {
          "\\Bbb": "\\mathbb",
          "\\bold": "\\mathbf",
          "\\frak": "\\mathfrak",
          "\\bm": "\\boldsymbol"
        };
        defineFunction({
          type: "font",
          names: [
            // styles, except \boldsymbol defined below
            "\\mathrm",
            "\\mathit",
            "\\mathbf",
            "\\mathnormal",
            "\\mathsfit",
            // families
            "\\mathbb",
            "\\mathcal",
            "\\mathfrak",
            "\\mathscr",
            "\\mathsf",
            "\\mathtt",
            // aliases, except \bm defined below
            "\\Bbb",
            "\\bold",
            "\\frak"
          ],
          props: {
            numArgs: 1,
            allowedInArgument: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = normalizeArgument(args[0]);
            let func = funcName;
            if (func in fontAliases) {
              func = fontAliases[func];
            }
            return {
              type: "font",
              mode: parser.mode,
              font: func.slice(1),
              body
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        defineFunction({
          type: "mclass",
          names: ["\\boldsymbol", "\\bm"],
          props: {
            numArgs: 1
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            const isCharacterBox2 = utils2.isCharacterBox(body);
            return {
              type: "mclass",
              mode: parser.mode,
              mclass: binrelClass(body),
              body: [{
                type: "font",
                mode: parser.mode,
                font: "boldsymbol",
                body
              }],
              isCharacterBox: isCharacterBox2
            };
          }
        });
        defineFunction({
          type: "font",
          names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: (_ref3, args) => {
            let {
              parser,
              funcName,
              breakOnTokenText
            } = _ref3;
            const {
              mode
            } = parser;
            const body = parser.parseExpression(true, breakOnTokenText);
            const style = "math" + funcName.slice(1);
            return {
              type: "font",
              mode,
              font: style,
              body: {
                type: "ordgroup",
                mode: parser.mode,
                body
              }
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        const adjustStyle = (size, originalStyle) => {
          let style = originalStyle;
          if (size === "display") {
            style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
          } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
            style = src_Style.TEXT;
          } else if (size === "script") {
            style = src_Style.SCRIPT;
          } else if (size === "scriptscript") {
            style = src_Style.SCRIPTSCRIPT;
          }
          return style;
        };
        const genfrac_htmlBuilder = (group, options) => {
          const style = adjustStyle(group.size, options.style);
          const nstyle = style.fracNum();
          const dstyle = style.fracDen();
          let newOptions;
          newOptions = options.havingStyle(nstyle);
          const numerm = buildGroup(group.numer, newOptions, options);
          if (group.continued) {
            const hStrut = 8.5 / options.fontMetrics().ptPerEm;
            const dStrut = 3.5 / options.fontMetrics().ptPerEm;
            numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
            numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
          }
          newOptions = options.havingStyle(dstyle);
          const denomm = buildGroup(group.denom, newOptions, options);
          let rule;
          let ruleWidth;
          let ruleSpacing;
          if (group.hasBarLine) {
            if (group.barSize) {
              ruleWidth = calculateSize(group.barSize, options);
              rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
            } else {
              rule = buildCommon.makeLineSpan("frac-line", options);
            }
            ruleWidth = rule.height;
            ruleSpacing = rule.height;
          } else {
            rule = null;
            ruleWidth = 0;
            ruleSpacing = options.fontMetrics().defaultRuleThickness;
          }
          let numShift;
          let clearance;
          let denomShift;
          if (style.size === src_Style.DISPLAY.size || group.size === "display") {
            numShift = options.fontMetrics().num1;
            if (ruleWidth > 0) {
              clearance = 3 * ruleSpacing;
            } else {
              clearance = 7 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom1;
          } else {
            if (ruleWidth > 0) {
              numShift = options.fontMetrics().num2;
              clearance = ruleSpacing;
            } else {
              numShift = options.fontMetrics().num3;
              clearance = 3 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom2;
          }
          let frac;
          if (!rule) {
            const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
            if (candidateClearance < clearance) {
              numShift += 0.5 * (clearance - candidateClearance);
              denomShift += 0.5 * (clearance - candidateClearance);
            }
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          } else {
            const axisHeight = options.fontMetrics().axisHeight;
            if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
              numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
            }
            if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
              denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
            }
            const midShift = -(axisHeight - 0.5 * ruleWidth);
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: rule,
                shift: midShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          }
          newOptions = options.havingStyle(style);
          frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
          frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
          let delimSize;
          if (style.size === src_Style.DISPLAY.size) {
            delimSize = options.fontMetrics().delim1;
          } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
            delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
          } else {
            delimSize = options.fontMetrics().delim2;
          }
          let leftDelim;
          let rightDelim;
          if (group.leftDelim == null) {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
          }
          if (group.continued) {
            rightDelim = buildCommon.makeSpan([]);
          } else if (group.rightDelim == null) {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
          }
          return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
        };
        const genfrac_mathmlBuilder = (group, options) => {
          let node2 = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
          if (!group.hasBarLine) {
            node2.setAttribute("linethickness", "0px");
          } else if (group.barSize) {
            const ruleWidth = calculateSize(group.barSize, options);
            node2.setAttribute("linethickness", makeEm(ruleWidth));
          }
          const style = adjustStyle(group.size, options.style);
          if (style.size !== options.style.size) {
            node2 = new mathMLTree.MathNode("mstyle", [node2]);
            const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
            node2.setAttribute("displaystyle", isDisplay);
            node2.setAttribute("scriptlevel", "0");
          }
          if (group.leftDelim != null || group.rightDelim != null) {
            const withDelims = [];
            if (group.leftDelim != null) {
              const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
              leftOp.setAttribute("fence", "true");
              withDelims.push(leftOp);
            }
            withDelims.push(node2);
            if (group.rightDelim != null) {
              const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
              rightOp.setAttribute("fence", "true");
              withDelims.push(rightOp);
            }
            return makeRow(withDelims);
          }
          return node2;
        };
        defineFunction({
          type: "genfrac",
          names: [
            "\\dfrac",
            "\\frac",
            "\\tfrac",
            "\\dbinom",
            "\\binom",
            "\\tbinom",
            "\\\\atopfrac",
            // can’t be entered directly
            "\\\\bracefrac",
            "\\\\brackfrac"
            // ditto
          ],
          props: {
            numArgs: 2,
            allowedInArgument: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const numer = args[0];
            const denom = args[1];
            let hasBarLine;
            let leftDelim = null;
            let rightDelim = null;
            let size = "auto";
            switch (funcName) {
              case "\\dfrac":
              case "\\frac":
              case "\\tfrac":
                hasBarLine = true;
                break;
              case "\\\\atopfrac":
                hasBarLine = false;
                break;
              case "\\dbinom":
              case "\\binom":
              case "\\tbinom":
                hasBarLine = false;
                leftDelim = "(";
                rightDelim = ")";
                break;
              case "\\\\bracefrac":
                hasBarLine = false;
                leftDelim = "\\{";
                rightDelim = "\\}";
                break;
              case "\\\\brackfrac":
                hasBarLine = false;
                leftDelim = "[";
                rightDelim = "]";
                break;
              default:
                throw new Error("Unrecognized genfrac command");
            }
            switch (funcName) {
              case "\\dfrac":
              case "\\dbinom":
                size = "display";
                break;
              case "\\tfrac":
              case "\\tbinom":
                size = "text";
                break;
            }
            return {
              type: "genfrac",
              mode: parser.mode,
              continued: false,
              numer,
              denom,
              hasBarLine,
              leftDelim,
              rightDelim,
              size,
              barSize: null
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "genfrac",
          names: ["\\cfrac"],
          props: {
            numArgs: 2
          },
          handler: (_ref2, args) => {
            let {
              parser,
              funcName
            } = _ref2;
            const numer = args[0];
            const denom = args[1];
            return {
              type: "genfrac",
              mode: parser.mode,
              continued: true,
              numer,
              denom,
              hasBarLine: true,
              leftDelim: null,
              rightDelim: null,
              size: "display",
              barSize: null
            };
          }
        });
        defineFunction({
          type: "infix",
          names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
          props: {
            numArgs: 0,
            infix: true
          },
          handler(_ref3) {
            let {
              parser,
              funcName,
              token: token2
            } = _ref3;
            let replaceWith2;
            switch (funcName) {
              case "\\over":
                replaceWith2 = "\\frac";
                break;
              case "\\choose":
                replaceWith2 = "\\binom";
                break;
              case "\\atop":
                replaceWith2 = "\\\\atopfrac";
                break;
              case "\\brace":
                replaceWith2 = "\\\\bracefrac";
                break;
              case "\\brack":
                replaceWith2 = "\\\\brackfrac";
                break;
              default:
                throw new Error("Unrecognized infix genfrac command");
            }
            return {
              type: "infix",
              mode: parser.mode,
              replaceWith: replaceWith2,
              token: token2
            };
          }
        });
        const stylArray = ["display", "text", "script", "scriptscript"];
        const delimFromValue = function(delimString) {
          let delim = null;
          if (delimString.length > 0) {
            delim = delimString;
            delim = delim === "." ? null : delim;
          }
          return delim;
        };
        defineFunction({
          type: "genfrac",
          names: ["\\genfrac"],
          props: {
            numArgs: 6,
            allowedInArgument: true,
            argTypes: ["math", "math", "size", "text", "math", "math"]
          },
          handler(_ref4, args) {
            let {
              parser
            } = _ref4;
            const numer = args[4];
            const denom = args[5];
            const leftNode = normalizeArgument(args[0]);
            const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
            const rightNode = normalizeArgument(args[1]);
            const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
            const barNode = assertNodeType(args[2], "size");
            let hasBarLine;
            let barSize = null;
            if (barNode.isBlank) {
              hasBarLine = true;
            } else {
              barSize = barNode.value;
              hasBarLine = barSize.number > 0;
            }
            let size = "auto";
            let styl = args[3];
            if (styl.type === "ordgroup") {
              if (styl.body.length > 0) {
                const textOrd = assertNodeType(styl.body[0], "textord");
                size = stylArray[Number(textOrd.text)];
              }
            } else {
              styl = assertNodeType(styl, "textord");
              size = stylArray[Number(styl.text)];
            }
            return {
              type: "genfrac",
              mode: parser.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim,
              rightDelim,
              size
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "infix",
          names: ["\\above"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            infix: true
          },
          handler(_ref5, args) {
            let {
              parser,
              funcName,
              token: token2
            } = _ref5;
            return {
              type: "infix",
              mode: parser.mode,
              replaceWith: "\\\\abovefrac",
              size: assertNodeType(args[0], "size").value,
              token: token2
            };
          }
        });
        defineFunction({
          type: "genfrac",
          names: ["\\\\abovefrac"],
          props: {
            numArgs: 3,
            argTypes: ["math", "size", "math"]
          },
          handler: (_ref6, args) => {
            let {
              parser,
              funcName
            } = _ref6;
            const numer = args[0];
            const barSize = assert(assertNodeType(args[1], "infix").size);
            const denom = args[2];
            const hasBarLine = barSize.number > 0;
            return {
              type: "genfrac",
              mode: parser.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim: null,
              rightDelim: null,
              size: "auto"
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        const horizBrace_htmlBuilder = (grp, options) => {
          const style = options.style;
          let supSubGroup;
          let group;
          if (grp.type === "supsub") {
            supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
            group = assertNodeType(grp.base, "horizBrace");
          } else {
            group = assertNodeType(grp, "horizBrace");
          }
          const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
          const braceBody = stretchy.svgSpan(group, options);
          let vlist;
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: braceBody
              }]
            }, options);
            vlist.children[0].children[0].children[1].classes.push("svg-align");
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: body.depth + 0.1 + braceBody.height,
              children: [{
                type: "elem",
                elem: braceBody
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: body
              }]
            }, options);
            vlist.children[0].children[0].children[0].classes.push("svg-align");
          }
          if (supSubGroup) {
            const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            if (group.isOver) {
              vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: vSpan
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: supSubGroup
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "bottom",
                positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                children: [{
                  type: "elem",
                  elem: supSubGroup
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: vSpan
                }]
              }, options);
            }
          }
          return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
        };
        const horizBrace_mathmlBuilder = (group, options) => {
          const accentNode = stretchy.mathMLnode(group.label);
          return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
        };
        defineFunction({
          type: "horizBrace",
          names: ["\\overbrace", "\\underbrace"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            return {
              type: "horizBrace",
              mode: parser.mode,
              label: funcName,
              isOver: /^\\over/.test(funcName),
              base: args[0]
            };
          },
          htmlBuilder: horizBrace_htmlBuilder,
          mathmlBuilder: horizBrace_mathmlBuilder
        });
        defineFunction({
          type: "href",
          names: ["\\href"],
          props: {
            numArgs: 2,
            argTypes: ["url", "original"],
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            const body = args[1];
            const href = assertNodeType(args[0], "url").url;
            if (!parser.settings.isTrusted({
              command: "\\href",
              url: href
            })) {
              return parser.formatUnsupportedCmd("\\href");
            }
            return {
              type: "href",
              mode: parser.mode,
              href,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options, false);
            return buildCommon.makeAnchor(group.href, [], elements, options);
          },
          mathmlBuilder: (group, options) => {
            let math2 = buildExpressionRow(group.body, options);
            if (!(math2 instanceof MathNode)) {
              math2 = new MathNode("mrow", [math2]);
            }
            math2.setAttribute("href", group.href);
            return math2;
          }
        });
        defineFunction({
          type: "href",
          names: ["\\url"],
          props: {
            numArgs: 1,
            argTypes: ["url"],
            allowedInText: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const href = assertNodeType(args[0], "url").url;
            if (!parser.settings.isTrusted({
              command: "\\url",
              url: href
            })) {
              return parser.formatUnsupportedCmd("\\url");
            }
            const chars = [];
            for (let i = 0; i < href.length; i++) {
              let c2 = href[i];
              if (c2 === "~") {
                c2 = "\\textasciitilde";
              }
              chars.push({
                type: "textord",
                mode: "text",
                text: c2
              });
            }
            const body = {
              type: "text",
              mode: parser.mode,
              font: "\\texttt",
              body: chars
            };
            return {
              type: "href",
              mode: parser.mode,
              href,
              body: ordargument(body)
            };
          }
        });
        defineFunction({
          type: "hbox",
          names: ["\\hbox"],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInText: true,
            primitive: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "hbox",
              mode: parser.mode,
              body: ordargument(args[0])
            };
          },
          htmlBuilder(group, options) {
            const elements = buildExpression(group.body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
          }
        });
        defineFunction({
          type: "html",
          names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
          props: {
            numArgs: 2,
            argTypes: ["raw", "original"],
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName,
              token: token2
            } = _ref;
            const value = assertNodeType(args[0], "raw").string;
            const body = args[1];
            if (parser.settings.strict) {
              parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
            }
            let trustContext;
            const attributes2 = {};
            switch (funcName) {
              case "\\htmlClass":
                attributes2.class = value;
                trustContext = {
                  command: "\\htmlClass",
                  class: value
                };
                break;
              case "\\htmlId":
                attributes2.id = value;
                trustContext = {
                  command: "\\htmlId",
                  id: value
                };
                break;
              case "\\htmlStyle":
                attributes2.style = value;
                trustContext = {
                  command: "\\htmlStyle",
                  style: value
                };
                break;
              case "\\htmlData": {
                const data2 = value.split(",");
                for (let i = 0; i < data2.length; i++) {
                  const keyVal = data2[i].split("=");
                  if (keyVal.length !== 2) {
                    throw new src_ParseError("Error parsing key-value for \\htmlData");
                  }
                  attributes2["data-" + keyVal[0].trim()] = keyVal[1].trim();
                }
                trustContext = {
                  command: "\\htmlData",
                  attributes: attributes2
                };
                break;
              }
              default:
                throw new Error("Unrecognized html command");
            }
            if (!parser.settings.isTrusted(trustContext)) {
              return parser.formatUnsupportedCmd(funcName);
            }
            return {
              type: "html",
              mode: parser.mode,
              attributes: attributes2,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options, false);
            const classes = ["enclosing"];
            if (group.attributes.class) {
              classes.push(...group.attributes.class.trim().split(/\s+/));
            }
            const span = buildCommon.makeSpan(classes, elements, options);
            for (const attr2 in group.attributes) {
              if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
                span.setAttribute(attr2, group.attributes[attr2]);
              }
            }
            return span;
          },
          mathmlBuilder: (group, options) => {
            return buildExpressionRow(group.body, options);
          }
        });
        defineFunction({
          type: "htmlmathml",
          names: ["\\html@mathml"],
          props: {
            numArgs: 2,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            return {
              type: "htmlmathml",
              mode: parser.mode,
              html: ordargument(args[0]),
              mathml: ordargument(args[1])
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.html, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            return buildExpressionRow(group.mathml, options);
          }
        });
        const sizeData = function(str) {
          if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
            return {
              number: +str,
              unit: "bp"
            };
          } else {
            const match3 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
            if (!match3) {
              throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
            }
            const data2 = {
              number: +(match3[1] + match3[2]),
              // sign + magnitude, cast to number
              unit: match3[3]
            };
            if (!validUnit(data2)) {
              throw new src_ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
            }
            return data2;
          }
        };
        defineFunction({
          type: "includegraphics",
          names: ["\\includegraphics"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            argTypes: ["raw", "url"],
            allowedInText: false
          },
          handler: (_ref, args, optArgs) => {
            let {
              parser
            } = _ref;
            let width = {
              number: 0,
              unit: "em"
            };
            let height = {
              number: 0.9,
              unit: "em"
            };
            let totalheight = {
              number: 0,
              unit: "em"
            };
            let alt = "";
            if (optArgs[0]) {
              const attributeStr = assertNodeType(optArgs[0], "raw").string;
              const attributes2 = attributeStr.split(",");
              for (let i = 0; i < attributes2.length; i++) {
                const keyVal = attributes2[i].split("=");
                if (keyVal.length === 2) {
                  const str = keyVal[1].trim();
                  switch (keyVal[0].trim()) {
                    case "alt":
                      alt = str;
                      break;
                    case "width":
                      width = sizeData(str);
                      break;
                    case "height":
                      height = sizeData(str);
                      break;
                    case "totalheight":
                      totalheight = sizeData(str);
                      break;
                    default:
                      throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                  }
                }
              }
            }
            const src = assertNodeType(args[0], "url").url;
            if (alt === "") {
              alt = src;
              alt = alt.replace(/^.*[\\/]/, "");
              alt = alt.substring(0, alt.lastIndexOf("."));
            }
            if (!parser.settings.isTrusted({
              command: "\\includegraphics",
              url: src
            })) {
              return parser.formatUnsupportedCmd("\\includegraphics");
            }
            return {
              type: "includegraphics",
              mode: parser.mode,
              alt,
              width,
              height,
              totalheight,
              src
            };
          },
          htmlBuilder: (group, options) => {
            const height = calculateSize(group.height, options);
            let depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
            }
            let width = 0;
            if (group.width.number > 0) {
              width = calculateSize(group.width, options);
            }
            const style = {
              height: makeEm(height + depth)
            };
            if (width > 0) {
              style.width = makeEm(width);
            }
            if (depth > 0) {
              style.verticalAlign = makeEm(-depth);
            }
            const node2 = new Img(group.src, group.alt, style);
            node2.height = height;
            node2.depth = depth;
            return node2;
          },
          mathmlBuilder: (group, options) => {
            const node2 = new mathMLTree.MathNode("mglyph", []);
            node2.setAttribute("alt", group.alt);
            const height = calculateSize(group.height, options);
            let depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
              node2.setAttribute("valign", makeEm(-depth));
            }
            node2.setAttribute("height", makeEm(height + depth));
            if (group.width.number > 0) {
              const width = calculateSize(group.width, options);
              node2.setAttribute("width", makeEm(width));
            }
            node2.setAttribute("src", group.src);
            return node2;
          }
        });
        defineFunction({
          type: "kern",
          names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            primitive: true,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const size = assertNodeType(args[0], "size");
            if (parser.settings.strict) {
              const mathFunction = funcName[1] === "m";
              const muUnit = size.value.unit === "mu";
              if (mathFunction) {
                if (!muUnit) {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                }
                if (parser.mode !== "math") {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                }
              } else {
                if (muUnit) {
                  parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                }
              }
            }
            return {
              type: "kern",
              mode: parser.mode,
              dimension: size.value
            };
          },
          htmlBuilder(group, options) {
            return buildCommon.makeGlue(group.dimension, options);
          },
          mathmlBuilder(group, options) {
            const dimension = calculateSize(group.dimension, options);
            return new mathMLTree.SpaceNode(dimension);
          }
        });
        defineFunction({
          type: "lap",
          names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "lap",
              mode: parser.mode,
              alignment: funcName.slice(5),
              body
            };
          },
          htmlBuilder: (group, options) => {
            let inner2;
            if (group.alignment === "clap") {
              inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
              inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
            } else {
              inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
            }
            const fix = buildCommon.makeSpan(["fix"], []);
            let node2 = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
            const strut = buildCommon.makeSpan(["strut"]);
            strut.style.height = makeEm(node2.height + node2.depth);
            if (node2.depth) {
              strut.style.verticalAlign = makeEm(-node2.depth);
            }
            node2.children.unshift(strut);
            node2 = buildCommon.makeSpan(["thinbox"], [node2], options);
            return buildCommon.makeSpan(["mord", "vbox"], [node2], options);
          },
          mathmlBuilder: (group, options) => {
            const node2 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.alignment !== "rlap") {
              const offset = group.alignment === "llap" ? "-1" : "-0.5";
              node2.setAttribute("lspace", offset + "width");
            }
            node2.setAttribute("width", "0px");
            return node2;
          }
        });
        defineFunction({
          type: "styling",
          names: ["\\(", "$"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler(_ref, args) {
            let {
              funcName,
              parser
            } = _ref;
            const outerMode = parser.mode;
            parser.switchMode("math");
            const close = funcName === "\\(" ? "\\)" : "$";
            const body = parser.parseExpression(false, close);
            parser.expect(close);
            parser.switchMode(outerMode);
            return {
              type: "styling",
              mode: parser.mode,
              style: "text",
              body
            };
          }
        });
        defineFunction({
          type: "text",
          // Doesn't matter what this is.
          names: ["\\)", "\\]"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler(context, args) {
            throw new src_ParseError("Mismatched " + context.funcName);
          }
        });
        const chooseMathStyle = (group, options) => {
          switch (options.style.size) {
            case src_Style.DISPLAY.size:
              return group.display;
            case src_Style.TEXT.size:
              return group.text;
            case src_Style.SCRIPT.size:
              return group.script;
            case src_Style.SCRIPTSCRIPT.size:
              return group.scriptscript;
            default:
              return group.text;
          }
        };
        defineFunction({
          type: "mathchoice",
          names: ["\\mathchoice"],
          props: {
            numArgs: 4,
            primitive: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            return {
              type: "mathchoice",
              mode: parser.mode,
              display: ordargument(args[0]),
              text: ordargument(args[1]),
              script: ordargument(args[2]),
              scriptscript: ordargument(args[3])
            };
          },
          htmlBuilder: (group, options) => {
            const body = chooseMathStyle(group, options);
            const elements = buildExpression(body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            const body = chooseMathStyle(group, options);
            return buildExpressionRow(body, options);
          }
        });
        const assembleSupSub = (base2, supGroup, subGroup, options, style, slant, baseShift) => {
          base2 = buildCommon.makeSpan([], [base2]);
          const subIsSingleCharacter = subGroup && utils2.isCharacterBox(subGroup);
          let sub2;
          let sup2;
          if (supGroup) {
            const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
            sup2 = {
              elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
            };
          }
          if (subGroup) {
            const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
            sub2 = {
              elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
            };
          }
          let finalGroup;
          if (sup2 && sub2) {
            const bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base2.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: bottom,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub2.elem,
                marginLeft: makeEm(-slant)
              }, {
                type: "kern",
                size: sub2.kern
              }, {
                type: "elem",
                elem: base2
              }, {
                type: "kern",
                size: sup2.kern
              }, {
                type: "elem",
                elem: sup2.elem,
                marginLeft: makeEm(slant)
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else if (sub2) {
            const top = base2.height - baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "top",
              positionData: top,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub2.elem,
                marginLeft: makeEm(-slant)
              }, {
                type: "kern",
                size: sub2.kern
              }, {
                type: "elem",
                elem: base2
              }]
            }, options);
          } else if (sup2) {
            const bottom = base2.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: bottom,
              children: [{
                type: "elem",
                elem: base2
              }, {
                type: "kern",
                size: sup2.kern
              }, {
                type: "elem",
                elem: sup2.elem,
                marginLeft: makeEm(slant)
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else {
            return base2;
          }
          const parts = [finalGroup];
          if (sub2 && slant !== 0 && !subIsSingleCharacter) {
            const spacer = buildCommon.makeSpan(["mspace"], [], options);
            spacer.style.marginRight = makeEm(slant);
            parts.unshift(spacer);
          }
          return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
        };
        const noSuccessor = ["\\smallint"];
        const op_htmlBuilder = (grp, options) => {
          let supGroup;
          let subGroup;
          let hasLimits = false;
          let group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "op");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "op");
          }
          const style = options.style;
          let large = false;
          if (style.size === src_Style.DISPLAY.size && group.symbol && !utils2.contains(noSuccessor, group.name)) {
            large = true;
          }
          let base2;
          if (group.symbol) {
            const fontName = large ? "Size2-Regular" : "Size1-Regular";
            let stash = "";
            if (group.name === "\\oiint" || group.name === "\\oiiint") {
              stash = group.name.slice(1);
              group.name = stash === "oiint" ? "\\iint" : "\\iiint";
            }
            base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
            if (stash.length > 0) {
              const italic = base2.italic;
              const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
              base2 = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: base2,
                  shift: 0
                }, {
                  type: "elem",
                  elem: oval,
                  shift: large ? 0.08 : 0
                }]
              }, options);
              group.name = "\\" + stash;
              base2.classes.unshift("mop");
              base2.italic = italic;
            }
          } else if (group.body) {
            const inner2 = buildExpression(group.body, options, true);
            if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
              base2 = inner2[0];
              base2.classes[0] = "mop";
            } else {
              base2 = buildCommon.makeSpan(["mop"], inner2, options);
            }
          } else {
            const output = [];
            for (let i = 1; i < group.name.length; i++) {
              output.push(buildCommon.mathsym(group.name[i], group.mode, options));
            }
            base2 = buildCommon.makeSpan(["mop"], output, options);
          }
          let baseShift = 0;
          let slant = 0;
          if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
            baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
            slant = base2.italic;
          }
          if (hasLimits) {
            return assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
          } else {
            if (baseShift) {
              base2.style.position = "relative";
              base2.style.top = makeEm(baseShift);
            }
            return base2;
          }
        };
        const op_mathmlBuilder = (group, options) => {
          let node2;
          if (group.symbol) {
            node2 = new MathNode("mo", [makeText(group.name, group.mode)]);
            if (utils2.contains(noSuccessor, group.name)) {
              node2.setAttribute("largeop", "false");
            }
          } else if (group.body) {
            node2 = new MathNode("mo", buildMathML_buildExpression(group.body, options));
          } else {
            node2 = new MathNode("mi", [new TextNode(group.name.slice(1))]);
            const operator = new MathNode("mo", [makeText("⁡", "text")]);
            if (group.parentIsSupSub) {
              node2 = new MathNode("mrow", [node2, operator]);
            } else {
              node2 = newDocumentFragment([node2, operator]);
            }
          }
          return node2;
        };
        const singleCharBigOps = {
          "∏": "\\prod",
          "∐": "\\coprod",
          "∑": "\\sum",
          "⋀": "\\bigwedge",
          "⋁": "\\bigvee",
          "⋂": "\\bigcap",
          "⋃": "\\bigcup",
          "⨀": "\\bigodot",
          "⨁": "\\bigoplus",
          "⨂": "\\bigotimes",
          "⨄": "\\biguplus",
          "⨆": "\\bigsqcup"
        };
        defineFunction({
          type: "op",
          names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
          props: {
            numArgs: 0
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            let fName = funcName;
            if (fName.length === 1) {
              fName = singleCharBigOps[fName];
            }
            return {
              type: "op",
              mode: parser.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\mathop"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              body: ordargument(body)
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        const singleCharIntegrals = {
          "∫": "\\int",
          "∬": "\\iint",
          "∭": "\\iiint",
          "∮": "\\oint",
          "∯": "\\oiint",
          "∰": "\\oiiint"
        };
        defineFunction({
          type: "op",
          names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
          props: {
            numArgs: 0
          },
          handler(_ref3) {
            let {
              parser,
              funcName
            } = _ref3;
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
          props: {
            numArgs: 0
          },
          handler(_ref4) {
            let {
              parser,
              funcName
            } = _ref4;
            return {
              type: "op",
              mode: parser.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
          props: {
            numArgs: 0
          },
          handler(_ref5) {
            let {
              parser,
              funcName
            } = _ref5;
            let fName = funcName;
            if (fName.length === 1) {
              fName = singleCharIntegrals[fName];
            }
            return {
              type: "op",
              mode: parser.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        const operatorname_htmlBuilder = (grp, options) => {
          let supGroup;
          let subGroup;
          let hasLimits = false;
          let group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "operatorname");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "operatorname");
          }
          let base2;
          if (group.body.length > 0) {
            const body = group.body.map((child) => {
              const childText = child.text;
              if (typeof childText === "string") {
                return {
                  type: "textord",
                  mode: child.mode,
                  text: childText
                };
              } else {
                return child;
              }
            });
            const expression = buildExpression(body, options.withFont("mathrm"), true);
            for (let i = 0; i < expression.length; i++) {
              const child = expression[i];
              if (child instanceof SymbolNode) {
                child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
              }
            }
            base2 = buildCommon.makeSpan(["mop"], expression, options);
          } else {
            base2 = buildCommon.makeSpan(["mop"], [], options);
          }
          if (hasLimits) {
            return assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
          } else {
            return base2;
          }
        };
        const operatorname_mathmlBuilder = (group, options) => {
          let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
          let isAllString = true;
          for (let i = 0; i < expression.length; i++) {
            const node2 = expression[i];
            if (node2 instanceof mathMLTree.SpaceNode)
              ;
            else if (node2 instanceof mathMLTree.MathNode) {
              switch (node2.type) {
                case "mi":
                case "mn":
                case "ms":
                case "mspace":
                case "mtext":
                  break;
                case "mo": {
                  const child = node2.children[0];
                  if (node2.children.length === 1 && child instanceof mathMLTree.TextNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  } else {
                    isAllString = false;
                  }
                  break;
                }
                default:
                  isAllString = false;
              }
            } else {
              isAllString = false;
            }
          }
          if (isAllString) {
            const word = expression.map((node2) => node2.toText()).join("");
            expression = [new mathMLTree.TextNode(word)];
          }
          const identifier = new mathMLTree.MathNode("mi", expression);
          identifier.setAttribute("mathvariant", "normal");
          const operator = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
          if (group.parentIsSupSub) {
            return new mathMLTree.MathNode("mrow", [identifier, operator]);
          } else {
            return mathMLTree.newDocumentFragment([identifier, operator]);
          }
        };
        defineFunction({
          type: "operatorname",
          names: ["\\operatorname@", "\\operatornamewithlimits"],
          props: {
            numArgs: 1
          },
          handler: (_ref, args) => {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "operatorname",
              mode: parser.mode,
              body: ordargument(body),
              alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
              limits: false,
              parentIsSupSub: false
            };
          },
          htmlBuilder: operatorname_htmlBuilder,
          mathmlBuilder: operatorname_mathmlBuilder
        });
        defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
        defineFunctionBuilders({
          type: "ordgroup",
          htmlBuilder(group, options) {
            if (group.semisimple) {
              return buildCommon.makeFragment(buildExpression(group.body, options, false));
            }
            return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
          },
          mathmlBuilder(group, options) {
            return buildExpressionRow(group.body, options, true);
          }
        });
        defineFunction({
          type: "overline",
          names: ["\\overline"],
          props: {
            numArgs: 1
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const body = args[0];
            return {
              type: "overline",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder(group, options) {
            const innerGroup = buildGroup(group.body, options.havingCrampedStyle());
            const line = buildCommon.makeLineSpan("overline-line", options);
            const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            const vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: innerGroup
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: defaultRuleThickness
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
            operator.setAttribute("stretchy", "true");
            const node2 = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
            node2.setAttribute("accent", "true");
            return node2;
          }
        });
        defineFunction({
          type: "phantom",
          names: ["\\phantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              parser
            } = _ref;
            const body = args[0];
            return {
              type: "phantom",
              mode: parser.mode,
              body: ordargument(body)
            };
          },
          htmlBuilder: (group, options) => {
            const elements = buildExpression(group.body, options.withPhantom(), false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(group.body, options);
            return new mathMLTree.MathNode("mphantom", inner2);
          }
        });
        defineFunction({
          type: "hphantom",
          names: ["\\hphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref2, args) => {
            let {
              parser
            } = _ref2;
            const body = args[0];
            return {
              type: "hphantom",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder: (group, options) => {
            let node2 = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
            node2.height = 0;
            node2.depth = 0;
            if (node2.children) {
              for (let i = 0; i < node2.children.length; i++) {
                node2.children[i].height = 0;
                node2.children[i].depth = 0;
              }
            }
            node2 = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node2
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [node2], options);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            const phantom = new mathMLTree.MathNode("mphantom", inner2);
            const node2 = new mathMLTree.MathNode("mpadded", [phantom]);
            node2.setAttribute("height", "0px");
            node2.setAttribute("depth", "0px");
            return node2;
          }
        });
        defineFunction({
          type: "vphantom",
          names: ["\\vphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: (_ref3, args) => {
            let {
              parser
            } = _ref3;
            const body = args[0];
            return {
              type: "vphantom",
              mode: parser.mode,
              body
            };
          },
          htmlBuilder: (group, options) => {
            const inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
            const fix = buildCommon.makeSpan(["fix"], []);
            return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
          },
          mathmlBuilder: (group, options) => {
            const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            const phantom = new mathMLTree.MathNode("mphantom", inner2);
            const node2 = new mathMLTree.MathNode("mpadded", [phantom]);
            node2.setAttribute("width", "0px");
            return node2;
          }
        });
        defineFunction({
          type: "raisebox",
          names: ["\\raisebox"],
          props: {
            numArgs: 2,
            argTypes: ["size", "hbox"],
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            const amount = assertNodeType(args[0], "size").value;
            const body = args[1];
            return {
              type: "raisebox",
              mode: parser.mode,
              dy: amount,
              body
            };
          },
          htmlBuilder(group, options) {
            const body = buildGroup(group.body, options);
            const dy = calculateSize(group.dy, options);
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: -dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder(group, options) {
            const node2 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            const dy = group.dy.number + group.dy.unit;
            node2.setAttribute("voffset", dy);
            return node2;
          }
        });
        defineFunction({
          type: "internal",
          names: ["\\relax"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler(_ref) {
            let {
              parser
            } = _ref;
            return {
              type: "internal",
              mode: parser.mode
            };
          }
        });
        defineFunction({
          type: "rule",
          names: ["\\rule"],
          props: {
            numArgs: 2,
            numOptionalArgs: 1,
            allowedInText: true,
            allowedInMath: true,
            argTypes: ["size", "size", "size"]
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const shift = optArgs[0];
            const width = assertNodeType(args[0], "size");
            const height = assertNodeType(args[1], "size");
            return {
              type: "rule",
              mode: parser.mode,
              shift: shift && assertNodeType(shift, "size").value,
              width: width.value,
              height: height.value
            };
          },
          htmlBuilder(group, options) {
            const rule = buildCommon.makeSpan(["mord", "rule"], [], options);
            const width = calculateSize(group.width, options);
            const height = calculateSize(group.height, options);
            const shift = group.shift ? calculateSize(group.shift, options) : 0;
            rule.style.borderRightWidth = makeEm(width);
            rule.style.borderTopWidth = makeEm(height);
            rule.style.bottom = makeEm(shift);
            rule.width = width;
            rule.height = height + shift;
            rule.depth = -shift;
            rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
            return rule;
          },
          mathmlBuilder(group, options) {
            const width = calculateSize(group.width, options);
            const height = calculateSize(group.height, options);
            const shift = group.shift ? calculateSize(group.shift, options) : 0;
            const color2 = options.color && options.getColor() || "black";
            const rule = new mathMLTree.MathNode("mspace");
            rule.setAttribute("mathbackground", color2);
            rule.setAttribute("width", makeEm(width));
            rule.setAttribute("height", makeEm(height));
            const wrapper2 = new mathMLTree.MathNode("mpadded", [rule]);
            if (shift >= 0) {
              wrapper2.setAttribute("height", makeEm(shift));
            } else {
              wrapper2.setAttribute("height", makeEm(shift));
              wrapper2.setAttribute("depth", makeEm(-shift));
            }
            wrapper2.setAttribute("voffset", makeEm(shift));
            return wrapper2;
          }
        });
        function sizingGroup(value, options, baseOptions) {
          const inner2 = buildExpression(value, options, false);
          const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          for (let i = 0; i < inner2.length; i++) {
            const pos = inner2[i].classes.indexOf("sizing");
            if (pos < 0) {
              Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
            } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
              inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
            }
            inner2[i].height *= multiplier;
            inner2[i].depth *= multiplier;
          }
          return buildCommon.makeFragment(inner2);
        }
        const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
        const sizing_htmlBuilder = (group, options) => {
          const newOptions = options.havingSize(group.size);
          return sizingGroup(group.body, newOptions, options);
        };
        defineFunction({
          type: "sizing",
          names: sizeFuncs,
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: (_ref, args) => {
            let {
              breakOnTokenText,
              funcName,
              parser
            } = _ref;
            const body = parser.parseExpression(false, breakOnTokenText);
            return {
              type: "sizing",
              mode: parser.mode,
              // Figure out what size to use based on the list of functions above
              size: sizeFuncs.indexOf(funcName) + 1,
              body
            };
          },
          htmlBuilder: sizing_htmlBuilder,
          mathmlBuilder: (group, options) => {
            const newOptions = options.havingSize(group.size);
            const inner2 = buildMathML_buildExpression(group.body, newOptions);
            const node2 = new mathMLTree.MathNode("mstyle", inner2);
            node2.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
            return node2;
          }
        });
        defineFunction({
          type: "smash",
          names: ["\\smash"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            allowedInText: true
          },
          handler: (_ref, args, optArgs) => {
            let {
              parser
            } = _ref;
            let smashHeight = false;
            let smashDepth = false;
            const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
            if (tbArg) {
              let letter = "";
              for (let i = 0; i < tbArg.body.length; ++i) {
                const node2 = tbArg.body[i];
                letter = node2.text;
                if (letter === "t") {
                  smashHeight = true;
                } else if (letter === "b") {
                  smashDepth = true;
                } else {
                  smashHeight = false;
                  smashDepth = false;
                  break;
                }
              }
            } else {
              smashHeight = true;
              smashDepth = true;
            }
            const body = args[0];
            return {
              type: "smash",
              mode: parser.mode,
              body,
              smashHeight,
              smashDepth
            };
          },
          htmlBuilder: (group, options) => {
            const node2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            if (!group.smashHeight && !group.smashDepth) {
              return node2;
            }
            if (group.smashHeight) {
              node2.height = 0;
              if (node2.children) {
                for (let i = 0; i < node2.children.length; i++) {
                  node2.children[i].height = 0;
                }
              }
            }
            if (group.smashDepth) {
              node2.depth = 0;
              if (node2.children) {
                for (let i = 0; i < node2.children.length; i++) {
                  node2.children[i].depth = 0;
                }
              }
            }
            const smashedNode = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node2
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [smashedNode], options);
          },
          mathmlBuilder: (group, options) => {
            const node2 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.smashHeight) {
              node2.setAttribute("height", "0px");
            }
            if (group.smashDepth) {
              node2.setAttribute("depth", "0px");
            }
            return node2;
          }
        });
        defineFunction({
          type: "sqrt",
          names: ["\\sqrt"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler(_ref, args, optArgs) {
            let {
              parser
            } = _ref;
            const index2 = optArgs[0];
            const body = args[0];
            return {
              type: "sqrt",
              mode: parser.mode,
              body,
              index: index2
            };
          },
          htmlBuilder(group, options) {
            let inner2 = buildGroup(group.body, options.havingCrampedStyle());
            if (inner2.height === 0) {
              inner2.height = options.fontMetrics().xHeight;
            }
            inner2 = buildCommon.wrapFragment(inner2, options);
            const metrics = options.fontMetrics();
            const theta = metrics.defaultRuleThickness;
            let phi = theta;
            if (options.style.id < src_Style.TEXT.id) {
              phi = options.fontMetrics().xHeight;
            }
            let lineClearance = theta + phi / 4;
            const minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
            const {
              span: img,
              ruleWidth,
              advanceWidth
            } = delimiter2.sqrtImage(minDelimiterHeight, options);
            const delimDepth = img.height - ruleWidth;
            if (delimDepth > inner2.height + inner2.depth + lineClearance) {
              lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
            }
            const imgShift = img.height - inner2.height - lineClearance - ruleWidth;
            inner2.style.paddingLeft = makeEm(advanceWidth);
            const body = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: inner2,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: -(inner2.height + imgShift)
              }, {
                type: "elem",
                elem: img
              }, {
                type: "kern",
                size: ruleWidth
              }]
            }, options);
            if (!group.index) {
              return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
            } else {
              const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
              const rootm = buildGroup(group.index, newOptions, options);
              const toShift = 0.6 * (body.height - body.depth);
              const rootVList = buildCommon.makeVList({
                positionType: "shift",
                positionData: -toShift,
                children: [{
                  type: "elem",
                  elem: rootm
                }]
              }, options);
              const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
              return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
            }
          },
          mathmlBuilder(group, options) {
            const {
              body,
              index: index2
            } = group;
            return index2 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
          }
        });
        const styling_styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        defineFunction({
          type: "styling",
          names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler(_ref, args) {
            let {
              breakOnTokenText,
              funcName,
              parser
            } = _ref;
            const body = parser.parseExpression(true, breakOnTokenText);
            const style = funcName.slice(1, funcName.length - 5);
            return {
              type: "styling",
              mode: parser.mode,
              // Figure out what style to use by pulling out the style from
              // the function name
              style,
              body
            };
          },
          htmlBuilder(group, options) {
            const newStyle = styling_styleMap[group.style];
            const newOptions = options.havingStyle(newStyle).withFont("");
            return sizingGroup(group.body, newOptions, options);
          },
          mathmlBuilder(group, options) {
            const newStyle = styling_styleMap[group.style];
            const newOptions = options.havingStyle(newStyle);
            const inner2 = buildMathML_buildExpression(group.body, newOptions);
            const node2 = new mathMLTree.MathNode("mstyle", inner2);
            const styleAttributes = {
              "display": ["0", "true"],
              "text": ["0", "false"],
              "script": ["1", "false"],
              "scriptscript": ["2", "false"]
            };
            const attr2 = styleAttributes[group.style];
            node2.setAttribute("scriptlevel", attr2[0]);
            node2.setAttribute("displaystyle", attr2[1]);
            return node2;
          }
        });
        const htmlBuilderDelegate = function(group, options) {
          const base2 = group.base;
          if (!base2) {
            return null;
          } else if (base2.type === "op") {
            const delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
            return delegate ? op_htmlBuilder : null;
          } else if (base2.type === "operatorname") {
            const delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
            return delegate ? operatorname_htmlBuilder : null;
          } else if (base2.type === "accent") {
            return utils2.isCharacterBox(base2.base) ? htmlBuilder : null;
          } else if (base2.type === "horizBrace") {
            const isSup = !group.sub;
            return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
          } else {
            return null;
          }
        };
        defineFunctionBuilders({
          type: "supsub",
          htmlBuilder(group, options) {
            const builderDelegate = htmlBuilderDelegate(group, options);
            if (builderDelegate) {
              return builderDelegate(group, options);
            }
            const {
              base: valueBase,
              sup: valueSup,
              sub: valueSub
            } = group;
            const base2 = buildGroup(valueBase, options);
            let supm;
            let subm;
            const metrics = options.fontMetrics();
            let supShift = 0;
            let subShift = 0;
            const isCharacterBox2 = valueBase && utils2.isCharacterBox(valueBase);
            if (valueSup) {
              const newOptions = options.havingStyle(options.style.sup());
              supm = buildGroup(valueSup, newOptions, options);
              if (!isCharacterBox2) {
                supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            if (valueSub) {
              const newOptions = options.havingStyle(options.style.sub());
              subm = buildGroup(valueSub, newOptions, options);
              if (!isCharacterBox2) {
                subShift = base2.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            let minSupShift;
            if (options.style === src_Style.DISPLAY) {
              minSupShift = metrics.sup1;
            } else if (options.style.cramped) {
              minSupShift = metrics.sup3;
            } else {
              minSupShift = metrics.sup2;
            }
            const multiplier = options.sizeMultiplier;
            const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
            let marginLeft = null;
            if (subm) {
              const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
              if (base2 instanceof SymbolNode || isOiint) {
                marginLeft = makeEm(-base2.italic);
              }
            }
            let supsub;
            if (supm && subm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              subShift = Math.max(subShift, metrics.sub2);
              const ruleWidth = metrics.defaultRuleThickness;
              const maxWidth = 4 * ruleWidth;
              if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                subShift = maxWidth - (supShift - supm.depth) + subm.height;
                const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                if (psi > 0) {
                  supShift += psi;
                  subShift -= psi;
                }
              }
              const vlistElem = [{
                type: "elem",
                elem: subm,
                shift: subShift,
                marginRight,
                marginLeft
              }, {
                type: "elem",
                elem: supm,
                shift: -supShift,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "individualShift",
                children: vlistElem
              }, options);
            } else if (subm) {
              subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
              const vlistElem = [{
                type: "elem",
                elem: subm,
                marginLeft,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: subShift,
                children: vlistElem
              }, options);
            } else if (supm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: -supShift,
                children: [{
                  type: "elem",
                  elem: supm,
                  marginRight
                }]
              }, options);
            } else {
              throw new Error("supsub must have either sup or sub.");
            }
            const mclass = getTypeOfDomTree(base2, "right") || "mord";
            return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
          },
          mathmlBuilder(group, options) {
            let isBrace = false;
            let isOver;
            let isSup;
            if (group.base && group.base.type === "horizBrace") {
              isSup = !!group.sup;
              if (isSup === group.base.isOver) {
                isBrace = true;
                isOver = group.base.isOver;
              }
            }
            if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
              group.base.parentIsSupSub = true;
            }
            const children2 = [buildMathML_buildGroup(group.base, options)];
            if (group.sub) {
              children2.push(buildMathML_buildGroup(group.sub, options));
            }
            if (group.sup) {
              children2.push(buildMathML_buildGroup(group.sup, options));
            }
            let nodeType;
            if (isBrace) {
              nodeType = isOver ? "mover" : "munder";
            } else if (!group.sub) {
              const base2 = group.base;
              if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                nodeType = "mover";
              } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "mover";
              } else {
                nodeType = "msup";
              }
            } else if (!group.sup) {
              const base2 = group.base;
              if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                nodeType = "munder";
              } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "munder";
              } else {
                nodeType = "msub";
              }
            } else {
              const base2 = group.base;
              if (base2 && base2.type === "op" && base2.limits && options.style === src_Style.DISPLAY) {
                nodeType = "munderover";
              } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base2.limits)) {
                nodeType = "munderover";
              } else {
                nodeType = "msubsup";
              }
            }
            return new mathMLTree.MathNode(nodeType, children2);
          }
        });
        defineFunctionBuilders({
          type: "atom",
          htmlBuilder(group, options) {
            return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
          },
          mathmlBuilder(group, options) {
            const node2 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
            if (group.family === "bin") {
              const variant = getVariant(group, options);
              if (variant === "bold-italic") {
                node2.setAttribute("mathvariant", variant);
              }
            } else if (group.family === "punct") {
              node2.setAttribute("separator", "true");
            } else if (group.family === "open" || group.family === "close") {
              node2.setAttribute("stretchy", "false");
            }
            return node2;
          }
        });
        const defaultVariant = {
          "mi": "italic",
          "mn": "normal",
          "mtext": "normal"
        };
        defineFunctionBuilders({
          type: "mathord",
          htmlBuilder(group, options) {
            return buildCommon.makeOrd(group, options, "mathord");
          },
          mathmlBuilder(group, options) {
            const node2 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
            const variant = getVariant(group, options) || "italic";
            if (variant !== defaultVariant[node2.type]) {
              node2.setAttribute("mathvariant", variant);
            }
            return node2;
          }
        });
        defineFunctionBuilders({
          type: "textord",
          htmlBuilder(group, options) {
            return buildCommon.makeOrd(group, options, "textord");
          },
          mathmlBuilder(group, options) {
            const text2 = makeText(group.text, group.mode, options);
            const variant = getVariant(group, options) || "normal";
            let node2;
            if (group.mode === "text") {
              node2 = new mathMLTree.MathNode("mtext", [text2]);
            } else if (/[0-9]/.test(group.text)) {
              node2 = new mathMLTree.MathNode("mn", [text2]);
            } else if (group.text === "\\prime") {
              node2 = new mathMLTree.MathNode("mo", [text2]);
            } else {
              node2 = new mathMLTree.MathNode("mi", [text2]);
            }
            if (variant !== defaultVariant[node2.type]) {
              node2.setAttribute("mathvariant", variant);
            }
            return node2;
          }
        });
        const cssSpace = {
          "\\nobreak": "nobreak",
          "\\allowbreak": "allowbreak"
        };
        const regularSpace = {
          " ": {},
          "\\ ": {},
          "~": {
            className: "nobreak"
          },
          "\\space": {},
          "\\nobreakspace": {
            className: "nobreak"
          }
        };
        defineFunctionBuilders({
          type: "spacing",
          htmlBuilder(group, options) {
            if (regularSpace.hasOwnProperty(group.text)) {
              const className = regularSpace[group.text].className || "";
              if (group.mode === "text") {
                const ord = buildCommon.makeOrd(group, options, "textord");
                ord.classes.push(className);
                return ord;
              } else {
                return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
              }
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
          },
          mathmlBuilder(group, options) {
            let node2;
            if (regularSpace.hasOwnProperty(group.text)) {
              node2 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return new mathMLTree.MathNode("mspace");
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
            return node2;
          }
        });
        const pad = () => {
          const padNode = new mathMLTree.MathNode("mtd", []);
          padNode.setAttribute("width", "50%");
          return padNode;
        };
        defineFunctionBuilders({
          type: "tag",
          mathmlBuilder(group, options) {
            const table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
            table2.setAttribute("width", "100%");
            return table2;
          }
        });
        const textFontFamilies = {
          "\\text": void 0,
          "\\textrm": "textrm",
          "\\textsf": "textsf",
          "\\texttt": "texttt",
          "\\textnormal": "textrm"
        };
        const textFontWeights = {
          "\\textbf": "textbf",
          "\\textmd": "textmd"
        };
        const textFontShapes = {
          "\\textit": "textit",
          "\\textup": "textup"
        };
        const optionsWithFont = (group, options) => {
          const font = group.font;
          if (!font) {
            return options;
          } else if (textFontFamilies[font]) {
            return options.withTextFontFamily(textFontFamilies[font]);
          } else if (textFontWeights[font]) {
            return options.withTextFontWeight(textFontWeights[font]);
          } else if (font === "\\emph") {
            return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
          }
          return options.withTextFontShape(textFontShapes[font]);
        };
        defineFunction({
          type: "text",
          names: [
            // Font families
            "\\text",
            "\\textrm",
            "\\textsf",
            "\\texttt",
            "\\textnormal",
            // Font weights
            "\\textbf",
            "\\textmd",
            // Font Shapes
            "\\textit",
            "\\textup",
            "\\emph"
          ],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInArgument: true,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser,
              funcName
            } = _ref;
            const body = args[0];
            return {
              type: "text",
              mode: parser.mode,
              body: ordargument(body),
              font: funcName
            };
          },
          htmlBuilder(group, options) {
            const newOptions = optionsWithFont(group, options);
            const inner2 = buildExpression(group.body, newOptions, true);
            return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
          },
          mathmlBuilder(group, options) {
            const newOptions = optionsWithFont(group, options);
            return buildExpressionRow(group.body, newOptions);
          }
        });
        defineFunction({
          type: "underline",
          names: ["\\underline"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "underline",
              mode: parser.mode,
              body: args[0]
            };
          },
          htmlBuilder(group, options) {
            const innerGroup = buildGroup(group.body, options);
            const line = buildCommon.makeLineSpan("underline-line", options);
            const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            const vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "kern",
                size: defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
          },
          mathmlBuilder(group, options) {
            const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
            operator.setAttribute("stretchy", "true");
            const node2 = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
            node2.setAttribute("accentunder", "true");
            return node2;
          }
        });
        defineFunction({
          type: "vcenter",
          names: ["\\vcenter"],
          props: {
            numArgs: 1,
            argTypes: ["original"],
            // In LaTeX, \vcenter can act only on a box.
            allowedInText: false
          },
          handler(_ref, args) {
            let {
              parser
            } = _ref;
            return {
              type: "vcenter",
              mode: parser.mode,
              body: args[0]
            };
          },
          htmlBuilder(group, options) {
            const body = buildGroup(group.body, options);
            const axisHeight = options.fontMetrics().axisHeight;
            const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder(group, options) {
            return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
          }
        });
        defineFunction({
          type: "verb",
          names: ["\\verb"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler(context, args, optArgs) {
            throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
          },
          htmlBuilder(group, options) {
            const text2 = makeVerb(group);
            const body = [];
            const newOptions = options.havingStyle(options.style.text());
            for (let i = 0; i < text2.length; i++) {
              let c2 = text2[i];
              if (c2 === "~") {
                c2 = "\\textasciitilde";
              }
              body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
            }
            return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
          },
          mathmlBuilder(group, options) {
            const text2 = new mathMLTree.TextNode(makeVerb(group));
            const node2 = new mathMLTree.MathNode("mtext", [text2]);
            node2.setAttribute("mathvariant", "monospace");
            return node2;
          }
        });
        const makeVerb = (group) => group.body.replace(/ /g, group.star ? "␣" : " ");
        const functions = _functions;
        var src_functions = functions;
        const spaceRegexString = "[ \r\n	]";
        const controlWordRegexString = "\\\\[a-zA-Z@]+";
        const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
        const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
        const controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
        const combiningDiacriticalMarkString = "[̀-ͯ]";
        const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
        const tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
        (controlSpaceRegexString + "|") + // \whitespace
        "([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
        (combiningDiacriticalMarkString + "*") + // ...plus accents
        "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
        (combiningDiacriticalMarkString + "*") + // ...plus accents
        "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
        ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
        ("|" + controlSymbolRegexString + ")");
        class Lexer2 {
          // Category codes. The lexer only supports comment characters (14) for now.
          // MacroExpander additionally distinguishes active (13).
          constructor(input, settings) {
            this.input = void 0;
            this.settings = void 0;
            this.tokenRegex = void 0;
            this.catcodes = void 0;
            this.input = input;
            this.settings = settings;
            this.tokenRegex = new RegExp(tokenRegexString, "g");
            this.catcodes = {
              "%": 14,
              // comment character
              "~": 13
              // active character
            };
          }
          setCatcode(char, code2) {
            this.catcodes[char] = code2;
          }
          /**
           * This function lexes a single token.
           */
          lex() {
            const input = this.input;
            const pos = this.tokenRegex.lastIndex;
            if (pos === input.length) {
              return new Token2("EOF", new SourceLocation(this, pos, pos));
            }
            const match3 = this.tokenRegex.exec(input);
            if (match3 === null || match3.index !== pos) {
              throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation(this, pos, pos + 1)));
            }
            const text2 = match3[6] || match3[3] || (match3[2] ? "\\ " : " ");
            if (this.catcodes[text2] === 14) {
              const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
              if (nlIndex === -1) {
                this.tokenRegex.lastIndex = input.length;
                this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
              } else {
                this.tokenRegex.lastIndex = nlIndex + 1;
              }
              return this.lex();
            }
            return new Token2(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
          }
        }
        class Namespace {
          /**
           * Both arguments are optional.  The first argument is an object of
           * built-in mappings which never change.  The second argument is an object
           * of initial (global-level) mappings, which will constantly change
           * according to any global/top-level `set`s done.
           */
          constructor(builtins, globalMacros) {
            if (builtins === void 0) {
              builtins = {};
            }
            if (globalMacros === void 0) {
              globalMacros = {};
            }
            this.current = void 0;
            this.builtins = void 0;
            this.undefStack = void 0;
            this.current = globalMacros;
            this.builtins = builtins;
            this.undefStack = [];
          }
          /**
           * Start a new nested group, affecting future local `set`s.
           */
          beginGroup() {
            this.undefStack.push({});
          }
          /**
           * End current nested group, restoring values before the group began.
           */
          endGroup() {
            if (this.undefStack.length === 0) {
              throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
            }
            const undefs = this.undefStack.pop();
            for (const undef in undefs) {
              if (undefs.hasOwnProperty(undef)) {
                if (undefs[undef] == null) {
                  delete this.current[undef];
                } else {
                  this.current[undef] = undefs[undef];
                }
              }
            }
          }
          /**
           * Ends all currently nested groups (if any), restoring values before the
           * groups began.  Useful in case of an error in the middle of parsing.
           */
          endGroups() {
            while (this.undefStack.length > 0) {
              this.endGroup();
            }
          }
          /**
           * Detect whether `name` has a definition.  Equivalent to
           * `get(name) != null`.
           */
          has(name2) {
            return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
          }
          /**
           * Get the current value of a name, or `undefined` if there is no value.
           *
           * Note: Do not use `if (namespace.get(...))` to detect whether a macro
           * is defined, as the definition may be the empty string which evaluates
           * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
           * `if (namespace.has(...))`.
           */
          get(name2) {
            if (this.current.hasOwnProperty(name2)) {
              return this.current[name2];
            } else {
              return this.builtins[name2];
            }
          }
          /**
           * Set the current value of a name, and optionally set it globally too.
           * Local set() sets the current value and (when appropriate) adds an undo
           * operation to the undo stack.  Global set() may change the undo
           * operation at every level, so takes time linear in their number.
           * A value of undefined means to delete existing definitions.
           */
          set(name2, value, global2) {
            if (global2 === void 0) {
              global2 = false;
            }
            if (global2) {
              for (let i = 0; i < this.undefStack.length; i++) {
                delete this.undefStack[i][name2];
              }
              if (this.undefStack.length > 0) {
                this.undefStack[this.undefStack.length - 1][name2] = value;
              }
            } else {
              const top = this.undefStack[this.undefStack.length - 1];
              if (top && !top.hasOwnProperty(name2)) {
                top[name2] = this.current[name2];
              }
            }
            if (value == null) {
              delete this.current[name2];
            } else {
              this.current[name2] = value;
            }
          }
        }
        const macros = _macros;
        var src_macros = macros;
        defineMacro("\\noexpand", function(context) {
          const t = context.popToken();
          if (context.isExpandable(t.text)) {
            t.noexpand = true;
            t.treatAsRelax = true;
          }
          return {
            tokens: [t],
            numArgs: 0
          };
        });
        defineMacro("\\expandafter", function(context) {
          const t = context.popToken();
          context.expandOnce(true);
          return {
            tokens: [t],
            numArgs: 0
          };
        });
        defineMacro("\\@firstoftwo", function(context) {
          const args = context.consumeArgs(2);
          return {
            tokens: args[0],
            numArgs: 0
          };
        });
        defineMacro("\\@secondoftwo", function(context) {
          const args = context.consumeArgs(2);
          return {
            tokens: args[1],
            numArgs: 0
          };
        });
        defineMacro("\\@ifnextchar", function(context) {
          const args = context.consumeArgs(3);
          context.consumeSpaces();
          const nextToken = context.future();
          if (args[0].length === 1 && args[0][0].text === nextToken.text) {
            return {
              tokens: args[1],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[2],
              numArgs: 0
            };
          }
        });
        defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
        defineMacro("\\TextOrMath", function(context) {
          const args = context.consumeArgs(2);
          if (context.mode === "text") {
            return {
              tokens: args[0],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[1],
              numArgs: 0
            };
          }
        });
        const digitToNumber = {
          "0": 0,
          "1": 1,
          "2": 2,
          "3": 3,
          "4": 4,
          "5": 5,
          "6": 6,
          "7": 7,
          "8": 8,
          "9": 9,
          "a": 10,
          "A": 10,
          "b": 11,
          "B": 11,
          "c": 12,
          "C": 12,
          "d": 13,
          "D": 13,
          "e": 14,
          "E": 14,
          "f": 15,
          "F": 15
        };
        defineMacro("\\char", function(context) {
          let token2 = context.popToken();
          let base2;
          let number2 = "";
          if (token2.text === "'") {
            base2 = 8;
            token2 = context.popToken();
          } else if (token2.text === '"') {
            base2 = 16;
            token2 = context.popToken();
          } else if (token2.text === "`") {
            token2 = context.popToken();
            if (token2.text[0] === "\\") {
              number2 = token2.text.charCodeAt(1);
            } else if (token2.text === "EOF") {
              throw new src_ParseError("\\char` missing argument");
            } else {
              number2 = token2.text.charCodeAt(0);
            }
          } else {
            base2 = 10;
          }
          if (base2) {
            number2 = digitToNumber[token2.text];
            if (number2 == null || number2 >= base2) {
              throw new src_ParseError("Invalid base-" + base2 + " digit " + token2.text);
            }
            let digit;
            while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
              number2 *= base2;
              number2 += digit;
              context.popToken();
            }
          }
          return "\\@char{" + number2 + "}";
        });
        const newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
          let arg = context.consumeArg().tokens;
          if (arg.length !== 1) {
            throw new src_ParseError("\\newcommand's first argument must be a macro name");
          }
          const name2 = arg[0].text;
          const exists = context.isDefined(name2);
          if (exists && !existsOK) {
            throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
          }
          if (!exists && !nonexistsOK) {
            throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
          }
          let numArgs = 0;
          arg = context.consumeArg().tokens;
          if (arg.length === 1 && arg[0].text === "[") {
            let argText = "";
            let token2 = context.expandNextToken();
            while (token2.text !== "]" && token2.text !== "EOF") {
              argText += token2.text;
              token2 = context.expandNextToken();
            }
            if (!argText.match(/^\s*[0-9]+\s*$/)) {
              throw new src_ParseError("Invalid number of arguments: " + argText);
            }
            numArgs = parseInt(argText);
            arg = context.consumeArg().tokens;
          }
          if (!(exists && skipIfExists)) {
            context.macros.set(name2, {
              tokens: arg,
              numArgs
            });
          }
          return "";
        };
        defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
        defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
        defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
        defineMacro("\\message", (context) => {
          const arg = context.consumeArgs(1)[0];
          console.log(arg.reverse().map((token2) => token2.text).join(""));
          return "";
        });
        defineMacro("\\errmessage", (context) => {
          const arg = context.consumeArgs(1)[0];
          console.error(arg.reverse().map((token2) => token2.text).join(""));
          return "";
        });
        defineMacro("\\show", (context) => {
          const tok = context.popToken();
          const name2 = tok.text;
          console.log(tok, context.macros.get(name2), src_functions[name2], src_symbols.math[name2], src_symbols.text[name2]);
          return "";
        });
        defineMacro("\\bgroup", "{");
        defineMacro("\\egroup", "}");
        defineMacro("~", "\\nobreakspace");
        defineMacro("\\lq", "`");
        defineMacro("\\rq", "'");
        defineMacro("\\aa", "\\r a");
        defineMacro("\\AA", "\\r A");
        defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
        defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
        defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
        defineMacro("ℬ", "\\mathscr{B}");
        defineMacro("ℰ", "\\mathscr{E}");
        defineMacro("ℱ", "\\mathscr{F}");
        defineMacro("ℋ", "\\mathscr{H}");
        defineMacro("ℐ", "\\mathscr{I}");
        defineMacro("ℒ", "\\mathscr{L}");
        defineMacro("ℳ", "\\mathscr{M}");
        defineMacro("ℛ", "\\mathscr{R}");
        defineMacro("ℭ", "\\mathfrak{C}");
        defineMacro("ℌ", "\\mathfrak{H}");
        defineMacro("ℨ", "\\mathfrak{Z}");
        defineMacro("\\Bbbk", "\\Bbb{k}");
        defineMacro("·", "\\cdotp");
        defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
        defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
        defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
        defineMacro("\\mathstrut", "\\vphantom{(}");
        defineMacro("\\underbar", "\\underline{\\text{#1}}");
        defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
        defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
        defineMacro("\\ne", "\\neq");
        defineMacro("≠", "\\neq");
        defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
        defineMacro("∉", "\\notin");
        defineMacro("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
        defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
        defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
        defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
        defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
        defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
        defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
        defineMacro("⟂", "\\perp");
        defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
        defineMacro("∌", "\\notni");
        defineMacro("⌜", "\\ulcorner");
        defineMacro("⌝", "\\urcorner");
        defineMacro("⌞", "\\llcorner");
        defineMacro("⌟", "\\lrcorner");
        defineMacro("©", "\\copyright");
        defineMacro("®", "\\textregistered");
        defineMacro("️", "\\textregistered");
        defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
        defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
        defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
        defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
        defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
        defineMacro("⋮", "\\vdots");
        defineMacro("\\varGamma", "\\mathit{\\Gamma}");
        defineMacro("\\varDelta", "\\mathit{\\Delta}");
        defineMacro("\\varTheta", "\\mathit{\\Theta}");
        defineMacro("\\varLambda", "\\mathit{\\Lambda}");
        defineMacro("\\varXi", "\\mathit{\\Xi}");
        defineMacro("\\varPi", "\\mathit{\\Pi}");
        defineMacro("\\varSigma", "\\mathit{\\Sigma}");
        defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
        defineMacro("\\varPhi", "\\mathit{\\Phi}");
        defineMacro("\\varPsi", "\\mathit{\\Psi}");
        defineMacro("\\varOmega", "\\mathit{\\Omega}");
        defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
        defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
        defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
        defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
        defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
        defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
        defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
        defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
        const dotsByToken = {
          ",": "\\dotsc",
          "\\not": "\\dotsb",
          // \keybin@ checks for the following:
          "+": "\\dotsb",
          "=": "\\dotsb",
          "<": "\\dotsb",
          ">": "\\dotsb",
          "-": "\\dotsb",
          "*": "\\dotsb",
          ":": "\\dotsb",
          // Symbols whose definition starts with \DOTSB:
          "\\DOTSB": "\\dotsb",
          "\\coprod": "\\dotsb",
          "\\bigvee": "\\dotsb",
          "\\bigwedge": "\\dotsb",
          "\\biguplus": "\\dotsb",
          "\\bigcap": "\\dotsb",
          "\\bigcup": "\\dotsb",
          "\\prod": "\\dotsb",
          "\\sum": "\\dotsb",
          "\\bigotimes": "\\dotsb",
          "\\bigoplus": "\\dotsb",
          "\\bigodot": "\\dotsb",
          "\\bigsqcup": "\\dotsb",
          "\\And": "\\dotsb",
          "\\longrightarrow": "\\dotsb",
          "\\Longrightarrow": "\\dotsb",
          "\\longleftarrow": "\\dotsb",
          "\\Longleftarrow": "\\dotsb",
          "\\longleftrightarrow": "\\dotsb",
          "\\Longleftrightarrow": "\\dotsb",
          "\\mapsto": "\\dotsb",
          "\\longmapsto": "\\dotsb",
          "\\hookrightarrow": "\\dotsb",
          "\\doteq": "\\dotsb",
          // Symbols whose definition starts with \mathbin:
          "\\mathbin": "\\dotsb",
          // Symbols whose definition starts with \mathrel:
          "\\mathrel": "\\dotsb",
          "\\relbar": "\\dotsb",
          "\\Relbar": "\\dotsb",
          "\\xrightarrow": "\\dotsb",
          "\\xleftarrow": "\\dotsb",
          // Symbols whose definition starts with \DOTSI:
          "\\DOTSI": "\\dotsi",
          "\\int": "\\dotsi",
          "\\oint": "\\dotsi",
          "\\iint": "\\dotsi",
          "\\iiint": "\\dotsi",
          "\\iiiint": "\\dotsi",
          "\\idotsint": "\\dotsi",
          // Symbols whose definition starts with \DOTSX:
          "\\DOTSX": "\\dotsx"
        };
        defineMacro("\\dots", function(context) {
          let thedots = "\\dotso";
          const next3 = context.expandAfterFuture().text;
          if (next3 in dotsByToken) {
            thedots = dotsByToken[next3];
          } else if (next3.slice(0, 4) === "\\not") {
            thedots = "\\dotsb";
          } else if (next3 in src_symbols.math) {
            if (utils2.contains(["bin", "rel"], src_symbols.math[next3].group)) {
              thedots = "\\dotsb";
            }
          }
          return thedots;
        });
        const spaceAfterDots = {
          // \rightdelim@ checks for the following:
          ")": true,
          "]": true,
          "\\rbrack": true,
          "\\}": true,
          "\\rbrace": true,
          "\\rangle": true,
          "\\rceil": true,
          "\\rfloor": true,
          "\\rgroup": true,
          "\\rmoustache": true,
          "\\right": true,
          "\\bigr": true,
          "\\biggr": true,
          "\\Bigr": true,
          "\\Biggr": true,
          // \extra@ also tests for the following:
          "$": true,
          // \extrap@ checks for the following:
          ";": true,
          ".": true,
          ",": true
        };
        defineMacro("\\dotso", function(context) {
          const next3 = context.future().text;
          if (next3 in spaceAfterDots) {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\dotsc", function(context) {
          const next3 = context.future().text;
          if (next3 in spaceAfterDots && next3 !== ",") {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\cdots", function(context) {
          const next3 = context.future().text;
          if (next3 in spaceAfterDots) {
            return "\\@cdots\\,";
          } else {
            return "\\@cdots";
          }
        });
        defineMacro("\\dotsb", "\\cdots");
        defineMacro("\\dotsm", "\\cdots");
        defineMacro("\\dotsi", "\\!\\cdots");
        defineMacro("\\dotsx", "\\ldots\\,");
        defineMacro("\\DOTSI", "\\relax");
        defineMacro("\\DOTSB", "\\relax");
        defineMacro("\\DOTSX", "\\relax");
        defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
        defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
        defineMacro("\\thinspace", "\\,");
        defineMacro("\\>", "\\mskip{4mu}");
        defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
        defineMacro("\\medspace", "\\:");
        defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
        defineMacro("\\thickspace", "\\;");
        defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
        defineMacro("\\negthinspace", "\\!");
        defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
        defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
        defineMacro("\\enspace", "\\kern.5em ");
        defineMacro("\\enskip", "\\hskip.5em\\relax");
        defineMacro("\\quad", "\\hskip1em\\relax");
        defineMacro("\\qquad", "\\hskip2em\\relax");
        defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
        defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
        defineMacro("\\tag@literal", (context) => {
          if (context.macros.get("\\df@tag")) {
            throw new src_ParseError("Multiple \\tag");
          }
          return "\\gdef\\df@tag{\\text{#1}}";
        });
        defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
        defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
        defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
        defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
        defineMacro("\\newline", "\\\\\\relax");
        defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
        const latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
        defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
        defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
        defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
        defineMacro("\\@hspace", "\\hskip #1\\relax");
        defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
        defineMacro("\\ordinarycolon", ":");
        defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
        defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
        defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
        defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
        defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
        defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
        defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
        defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
        defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
        defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
        defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
        defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
        defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
        defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
        defineMacro("∷", "\\dblcolon");
        defineMacro("∹", "\\eqcolon");
        defineMacro("≔", "\\coloneqq");
        defineMacro("≕", "\\eqqcolon");
        defineMacro("⩴", "\\Coloneqq");
        defineMacro("\\ratio", "\\vcentcolon");
        defineMacro("\\coloncolon", "\\dblcolon");
        defineMacro("\\colonequals", "\\coloneqq");
        defineMacro("\\coloncolonequals", "\\Coloneqq");
        defineMacro("\\equalscolon", "\\eqqcolon");
        defineMacro("\\equalscoloncolon", "\\Eqqcolon");
        defineMacro("\\colonminus", "\\coloneq");
        defineMacro("\\coloncolonminus", "\\Coloneq");
        defineMacro("\\minuscolon", "\\eqcolon");
        defineMacro("\\minuscoloncolon", "\\Eqcolon");
        defineMacro("\\coloncolonapprox", "\\Colonapprox");
        defineMacro("\\coloncolonsim", "\\Colonsim");
        defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
        defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
        defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
        defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
        defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
        defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
        defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
        defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
        defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
        defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
        defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
        defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
        defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
        defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
        defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
        defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
        defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
        defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
        defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
        defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
        defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
        defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
        defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
        defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
        defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
        defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
        defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
        defineMacro("⟦", "\\llbracket");
        defineMacro("⟧", "\\rrbracket");
        defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
        defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
        defineMacro("⦃", "\\lBrace");
        defineMacro("⦄", "\\rBrace");
        defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
        defineMacro("⦵", "\\minuso");
        defineMacro("\\darr", "\\downarrow");
        defineMacro("\\dArr", "\\Downarrow");
        defineMacro("\\Darr", "\\Downarrow");
        defineMacro("\\lang", "\\langle");
        defineMacro("\\rang", "\\rangle");
        defineMacro("\\uarr", "\\uparrow");
        defineMacro("\\uArr", "\\Uparrow");
        defineMacro("\\Uarr", "\\Uparrow");
        defineMacro("\\N", "\\mathbb{N}");
        defineMacro("\\R", "\\mathbb{R}");
        defineMacro("\\Z", "\\mathbb{Z}");
        defineMacro("\\alef", "\\aleph");
        defineMacro("\\alefsym", "\\aleph");
        defineMacro("\\Alpha", "\\mathrm{A}");
        defineMacro("\\Beta", "\\mathrm{B}");
        defineMacro("\\bull", "\\bullet");
        defineMacro("\\Chi", "\\mathrm{X}");
        defineMacro("\\clubs", "\\clubsuit");
        defineMacro("\\cnums", "\\mathbb{C}");
        defineMacro("\\Complex", "\\mathbb{C}");
        defineMacro("\\Dagger", "\\ddagger");
        defineMacro("\\diamonds", "\\diamondsuit");
        defineMacro("\\empty", "\\emptyset");
        defineMacro("\\Epsilon", "\\mathrm{E}");
        defineMacro("\\Eta", "\\mathrm{H}");
        defineMacro("\\exist", "\\exists");
        defineMacro("\\harr", "\\leftrightarrow");
        defineMacro("\\hArr", "\\Leftrightarrow");
        defineMacro("\\Harr", "\\Leftrightarrow");
        defineMacro("\\hearts", "\\heartsuit");
        defineMacro("\\image", "\\Im");
        defineMacro("\\infin", "\\infty");
        defineMacro("\\Iota", "\\mathrm{I}");
        defineMacro("\\isin", "\\in");
        defineMacro("\\Kappa", "\\mathrm{K}");
        defineMacro("\\larr", "\\leftarrow");
        defineMacro("\\lArr", "\\Leftarrow");
        defineMacro("\\Larr", "\\Leftarrow");
        defineMacro("\\lrarr", "\\leftrightarrow");
        defineMacro("\\lrArr", "\\Leftrightarrow");
        defineMacro("\\Lrarr", "\\Leftrightarrow");
        defineMacro("\\Mu", "\\mathrm{M}");
        defineMacro("\\natnums", "\\mathbb{N}");
        defineMacro("\\Nu", "\\mathrm{N}");
        defineMacro("\\Omicron", "\\mathrm{O}");
        defineMacro("\\plusmn", "\\pm");
        defineMacro("\\rarr", "\\rightarrow");
        defineMacro("\\rArr", "\\Rightarrow");
        defineMacro("\\Rarr", "\\Rightarrow");
        defineMacro("\\real", "\\Re");
        defineMacro("\\reals", "\\mathbb{R}");
        defineMacro("\\Reals", "\\mathbb{R}");
        defineMacro("\\Rho", "\\mathrm{P}");
        defineMacro("\\sdot", "\\cdot");
        defineMacro("\\sect", "\\S");
        defineMacro("\\spades", "\\spadesuit");
        defineMacro("\\sub", "\\subset");
        defineMacro("\\sube", "\\subseteq");
        defineMacro("\\supe", "\\supseteq");
        defineMacro("\\Tau", "\\mathrm{T}");
        defineMacro("\\thetasym", "\\vartheta");
        defineMacro("\\weierp", "\\wp");
        defineMacro("\\Zeta", "\\mathrm{Z}");
        defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
        defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
        defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
        defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
        defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
        defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
        defineMacro("\\Bra", "\\left\\langle#1\\right|");
        defineMacro("\\Ket", "\\left|#1\\right\\rangle");
        const braketHelper = (one2) => (context) => {
          const left = context.consumeArg().tokens;
          const middle = context.consumeArg().tokens;
          const middleDouble = context.consumeArg().tokens;
          const right = context.consumeArg().tokens;
          const oldMiddle = context.macros.get("|");
          const oldMiddleDouble = context.macros.get("\\|");
          context.macros.beginGroup();
          const midMacro = (double) => (context2) => {
            if (one2) {
              context2.macros.set("|", oldMiddle);
              if (middleDouble.length) {
                context2.macros.set("\\|", oldMiddleDouble);
              }
            }
            let doubled = double;
            if (!double && middleDouble.length) {
              const nextToken = context2.future();
              if (nextToken.text === "|") {
                context2.popToken();
                doubled = true;
              }
            }
            return {
              tokens: doubled ? middleDouble : middle,
              numArgs: 0
            };
          };
          context.macros.set("|", midMacro(false));
          if (middleDouble.length) {
            context.macros.set("\\|", midMacro(true));
          }
          const arg = context.consumeArg().tokens;
          const expanded = context.expandTokens([
            ...right,
            ...arg,
            ...left
            // reversed
          ]);
          context.macros.endGroup();
          return {
            tokens: expanded.reverse(),
            numArgs: 0
          };
        };
        defineMacro("\\bra@ket", braketHelper(false));
        defineMacro("\\bra@set", braketHelper(true));
        defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
        defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
        defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
        defineMacro("\\angln", "{\\angl n}");
        defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
        defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
        defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
        defineMacro("\\red", "\\textcolor{##df0030}{#1}");
        defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
        defineMacro("\\gray", "\\textcolor{gray}{#1}");
        defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
        defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
        defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
        defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
        defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
        defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
        defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
        defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
        defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
        defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
        defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
        defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
        defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
        defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
        defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
        defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
        defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
        defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
        defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
        defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
        defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
        defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
        defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
        defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
        defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
        defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
        defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
        defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
        defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
        defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
        defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
        defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
        defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
        defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
        defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
        defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
        defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
        defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
        defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
        defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
        defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
        defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
        defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
        defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
        defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
        defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
        defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
        defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
        defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
        defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
        const implicitCommands = {
          "^": true,
          // Parser.js
          "_": true,
          // Parser.js
          "\\limits": true,
          // Parser.js
          "\\nolimits": true
          // Parser.js
        };
        class MacroExpander {
          constructor(input, settings, mode) {
            this.settings = void 0;
            this.expansionCount = void 0;
            this.lexer = void 0;
            this.macros = void 0;
            this.stack = void 0;
            this.mode = void 0;
            this.settings = settings;
            this.expansionCount = 0;
            this.feed(input);
            this.macros = new Namespace(src_macros, settings.macros);
            this.mode = mode;
            this.stack = [];
          }
          /**
           * Feed a new input string to the same MacroExpander
           * (with existing macros etc.).
           */
          feed(input) {
            this.lexer = new Lexer2(input, this.settings);
          }
          /**
           * Switches between "text" and "math" modes.
           */
          switchMode(newMode) {
            this.mode = newMode;
          }
          /**
           * Start a new group nesting within all namespaces.
           */
          beginGroup() {
            this.macros.beginGroup();
          }
          /**
           * End current group nesting within all namespaces.
           */
          endGroup() {
            this.macros.endGroup();
          }
          /**
           * Ends all currently nested groups (if any), restoring values before the
           * groups began.  Useful in case of an error in the middle of parsing.
           */
          endGroups() {
            this.macros.endGroups();
          }
          /**
           * Returns the topmost token on the stack, without expanding it.
           * Similar in behavior to TeX's `\futurelet`.
           */
          future() {
            if (this.stack.length === 0) {
              this.pushToken(this.lexer.lex());
            }
            return this.stack[this.stack.length - 1];
          }
          /**
           * Remove and return the next unexpanded token.
           */
          popToken() {
            this.future();
            return this.stack.pop();
          }
          /**
           * Add a given token to the token stack.  In particular, this get be used
           * to put back a token returned from one of the other methods.
           */
          pushToken(token2) {
            this.stack.push(token2);
          }
          /**
           * Append an array of tokens to the token stack.
           */
          pushTokens(tokens) {
            this.stack.push(...tokens);
          }
          /**
           * Find an macro argument without expanding tokens and append the array of
           * tokens to the token stack. Uses Token as a container for the result.
           */
          scanArgument(isOptional) {
            let start2;
            let end2;
            let tokens;
            if (isOptional) {
              this.consumeSpaces();
              if (this.future().text !== "[") {
                return null;
              }
              start2 = this.popToken();
              ({
                tokens,
                end: end2
              } = this.consumeArg(["]"]));
            } else {
              ({
                tokens,
                start: start2,
                end: end2
              } = this.consumeArg());
            }
            this.pushToken(new Token2("EOF", end2.loc));
            this.pushTokens(tokens);
            return start2.range(end2, "");
          }
          /**
           * Consume all following space tokens, without expansion.
           */
          consumeSpaces() {
            for (; ; ) {
              const token2 = this.future();
              if (token2.text === " ") {
                this.stack.pop();
              } else {
                break;
              }
            }
          }
          /**
           * Consume an argument from the token stream, and return the resulting array
           * of tokens and start/end token.
           */
          consumeArg(delims2) {
            const tokens = [];
            const isDelimited = delims2 && delims2.length > 0;
            if (!isDelimited) {
              this.consumeSpaces();
            }
            const start2 = this.future();
            let tok;
            let depth = 0;
            let match3 = 0;
            do {
              tok = this.popToken();
              tokens.push(tok);
              if (tok.text === "{") {
                ++depth;
              } else if (tok.text === "}") {
                --depth;
                if (depth === -1) {
                  throw new src_ParseError("Extra }", tok);
                }
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims2 && isDelimited ? delims2[match3] : "}") + "'", tok);
              }
              if (delims2 && isDelimited) {
                if ((depth === 0 || depth === 1 && delims2[match3] === "{") && tok.text === delims2[match3]) {
                  ++match3;
                  if (match3 === delims2.length) {
                    tokens.splice(-match3, match3);
                    break;
                  }
                } else {
                  match3 = 0;
                }
              }
            } while (depth !== 0 || isDelimited);
            if (start2.text === "{" && tokens[tokens.length - 1].text === "}") {
              tokens.pop();
              tokens.shift();
            }
            tokens.reverse();
            return {
              tokens,
              start: start2,
              end: tok
            };
          }
          /**
           * Consume the specified number of (delimited) arguments from the token
           * stream and return the resulting array of arguments.
           */
          consumeArgs(numArgs, delimiters2) {
            if (delimiters2) {
              if (delimiters2.length !== numArgs + 1) {
                throw new src_ParseError("The length of delimiters doesn't match the number of args!");
              }
              const delims2 = delimiters2[0];
              for (let i = 0; i < delims2.length; i++) {
                const tok = this.popToken();
                if (delims2[i] !== tok.text) {
                  throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                }
              }
            }
            const args = [];
            for (let i = 0; i < numArgs; i++) {
              args.push(this.consumeArg(delimiters2 && delimiters2[i + 1]).tokens);
            }
            return args;
          }
          /**
           * Increment `expansionCount` by the specified amount.
           * Throw an error if it exceeds `maxExpand`.
           */
          countExpansion(amount) {
            this.expansionCount += amount;
            if (this.expansionCount > this.settings.maxExpand) {
              throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
          }
          /**
           * Expand the next token only once if possible.
           *
           * If the token is expanded, the resulting tokens will be pushed onto
           * the stack in reverse order, and the number of such tokens will be
           * returned.  This number might be zero or positive.
           *
           * If not, the return value is `false`, and the next token remains at the
           * top of the stack.
           *
           * In either case, the next token will be on the top of the stack,
           * or the stack will be empty (in case of empty expansion
           * and no other tokens).
           *
           * Used to implement `expandAfterFuture` and `expandNextToken`.
           *
           * If expandableOnly, only expandable tokens are expanded and
           * an undefined control sequence results in an error.
           */
          expandOnce(expandableOnly) {
            const topToken = this.popToken();
            const name2 = topToken.text;
            const expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
            if (expansion == null || expandableOnly && expansion.unexpandable) {
              if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
                throw new src_ParseError("Undefined control sequence: " + name2);
              }
              this.pushToken(topToken);
              return false;
            }
            this.countExpansion(1);
            let tokens = expansion.tokens;
            const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
            if (expansion.numArgs) {
              tokens = tokens.slice();
              for (let i = tokens.length - 1; i >= 0; --i) {
                let tok = tokens[i];
                if (tok.text === "#") {
                  if (i === 0) {
                    throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                  }
                  tok = tokens[--i];
                  if (tok.text === "#") {
                    tokens.splice(i + 1, 1);
                  } else if (/^[1-9]$/.test(tok.text)) {
                    tokens.splice(i, 2, ...args[+tok.text - 1]);
                  } else {
                    throw new src_ParseError("Not a valid argument number", tok);
                  }
                }
              }
            }
            this.pushTokens(tokens);
            return tokens.length;
          }
          /**
           * Expand the next token only once (if possible), and return the resulting
           * top token on the stack (without removing anything from the stack).
           * Similar in behavior to TeX's `\expandafter\futurelet`.
           * Equivalent to expandOnce() followed by future().
           */
          expandAfterFuture() {
            this.expandOnce();
            return this.future();
          }
          /**
           * Recursively expand first token, then return first non-expandable token.
           */
          expandNextToken() {
            for (; ; ) {
              if (this.expandOnce() === false) {
                const token2 = this.stack.pop();
                if (token2.treatAsRelax) {
                  token2.text = "\\relax";
                }
                return token2;
              }
            }
            throw new Error();
          }
          /**
           * Fully expand the given macro name and return the resulting list of
           * tokens, or return `undefined` if no such macro is defined.
           */
          expandMacro(name2) {
            return this.macros.has(name2) ? this.expandTokens([new Token2(name2)]) : void 0;
          }
          /**
           * Fully expand the given token stream and return the resulting list of
           * tokens.  Note that the input tokens are in reverse order, but the
           * output tokens are in forward order.
           */
          expandTokens(tokens) {
            const output = [];
            const oldStackLength = this.stack.length;
            this.pushTokens(tokens);
            while (this.stack.length > oldStackLength) {
              if (this.expandOnce(true) === false) {
                const token2 = this.stack.pop();
                if (token2.treatAsRelax) {
                  token2.noexpand = false;
                  token2.treatAsRelax = false;
                }
                output.push(token2);
              }
            }
            this.countExpansion(output.length);
            return output;
          }
          /**
           * Fully expand the given macro name and return the result as a string,
           * or return `undefined` if no such macro is defined.
           */
          expandMacroAsText(name2) {
            const tokens = this.expandMacro(name2);
            if (tokens) {
              return tokens.map((token2) => token2.text).join("");
            } else {
              return tokens;
            }
          }
          /**
           * Returns the expanded macro as a reversed array of tokens and a macro
           * argument count.  Or returns `null` if no such macro.
           */
          _getExpansion(name2) {
            const definition = this.macros.get(name2);
            if (definition == null) {
              return definition;
            }
            if (name2.length === 1) {
              const catcode = this.lexer.catcodes[name2];
              if (catcode != null && catcode !== 13) {
                return;
              }
            }
            const expansion = typeof definition === "function" ? definition(this) : definition;
            if (typeof expansion === "string") {
              let numArgs = 0;
              if (expansion.indexOf("#") !== -1) {
                const stripped = expansion.replace(/##/g, "");
                while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                  ++numArgs;
                }
              }
              const bodyLexer = new Lexer2(expansion, this.settings);
              const tokens = [];
              let tok = bodyLexer.lex();
              while (tok.text !== "EOF") {
                tokens.push(tok);
                tok = bodyLexer.lex();
              }
              tokens.reverse();
              const expanded = {
                tokens,
                numArgs
              };
              return expanded;
            }
            return expansion;
          }
          /**
           * Determine whether a command is currently "defined" (has some
           * functionality), meaning that it's a macro (in the current group),
           * a function, a symbol, or one of the special commands listed in
           * `implicitCommands`.
           */
          isDefined(name2) {
            return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
          }
          /**
           * Determine whether a command is expandable.
           */
          isExpandable(name2) {
            const macro = this.macros.get(name2);
            return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name2) && !src_functions[name2].primitive;
          }
        }
        const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
        const uSubsAndSups = Object.freeze({
          "₊": "+",
          "₋": "-",
          "₌": "=",
          "₍": "(",
          "₎": ")",
          "₀": "0",
          "₁": "1",
          "₂": "2",
          "₃": "3",
          "₄": "4",
          "₅": "5",
          "₆": "6",
          "₇": "7",
          "₈": "8",
          "₉": "9",
          "ₐ": "a",
          "ₑ": "e",
          "ₕ": "h",
          "ᵢ": "i",
          "ⱼ": "j",
          "ₖ": "k",
          "ₗ": "l",
          "ₘ": "m",
          "ₙ": "n",
          "ₒ": "o",
          "ₚ": "p",
          "ᵣ": "r",
          "ₛ": "s",
          "ₜ": "t",
          "ᵤ": "u",
          "ᵥ": "v",
          "ₓ": "x",
          "ᵦ": "β",
          "ᵧ": "γ",
          "ᵨ": "ρ",
          "ᵩ": "ϕ",
          "ᵪ": "χ",
          "⁺": "+",
          "⁻": "-",
          "⁼": "=",
          "⁽": "(",
          "⁾": ")",
          "⁰": "0",
          "¹": "1",
          "²": "2",
          "³": "3",
          "⁴": "4",
          "⁵": "5",
          "⁶": "6",
          "⁷": "7",
          "⁸": "8",
          "⁹": "9",
          "ᴬ": "A",
          "ᴮ": "B",
          "ᴰ": "D",
          "ᴱ": "E",
          "ᴳ": "G",
          "ᴴ": "H",
          "ᴵ": "I",
          "ᴶ": "J",
          "ᴷ": "K",
          "ᴸ": "L",
          "ᴹ": "M",
          "ᴺ": "N",
          "ᴼ": "O",
          "ᴾ": "P",
          "ᴿ": "R",
          "ᵀ": "T",
          "ᵁ": "U",
          "ⱽ": "V",
          "ᵂ": "W",
          "ᵃ": "a",
          "ᵇ": "b",
          "ᶜ": "c",
          "ᵈ": "d",
          "ᵉ": "e",
          "ᶠ": "f",
          "ᵍ": "g",
          "ʰ": "h",
          "ⁱ": "i",
          "ʲ": "j",
          "ᵏ": "k",
          "ˡ": "l",
          "ᵐ": "m",
          "ⁿ": "n",
          "ᵒ": "o",
          "ᵖ": "p",
          "ʳ": "r",
          "ˢ": "s",
          "ᵗ": "t",
          "ᵘ": "u",
          "ᵛ": "v",
          "ʷ": "w",
          "ˣ": "x",
          "ʸ": "y",
          "ᶻ": "z",
          "ᵝ": "β",
          "ᵞ": "γ",
          "ᵟ": "δ",
          "ᵠ": "ϕ",
          "ᵡ": "χ",
          "ᶿ": "θ"
        });
        const unicodeAccents = {
          "́": {
            "text": "\\'",
            "math": "\\acute"
          },
          "̀": {
            "text": "\\`",
            "math": "\\grave"
          },
          "̈": {
            "text": '\\"',
            "math": "\\ddot"
          },
          "̃": {
            "text": "\\~",
            "math": "\\tilde"
          },
          "̄": {
            "text": "\\=",
            "math": "\\bar"
          },
          "̆": {
            "text": "\\u",
            "math": "\\breve"
          },
          "̌": {
            "text": "\\v",
            "math": "\\check"
          },
          "̂": {
            "text": "\\^",
            "math": "\\hat"
          },
          "̇": {
            "text": "\\.",
            "math": "\\dot"
          },
          "̊": {
            "text": "\\r",
            "math": "\\mathring"
          },
          "̋": {
            "text": "\\H"
          },
          "̧": {
            "text": "\\c"
          }
        };
        const unicodeSymbols = {
          "á": "á",
          "à": "à",
          "ä": "ä",
          "ǟ": "ǟ",
          "ã": "ã",
          "ā": "ā",
          "ă": "ă",
          "ắ": "ắ",
          "ằ": "ằ",
          "ẵ": "ẵ",
          "ǎ": "ǎ",
          "â": "â",
          "ấ": "ấ",
          "ầ": "ầ",
          "ẫ": "ẫ",
          "ȧ": "ȧ",
          "ǡ": "ǡ",
          "å": "å",
          "ǻ": "ǻ",
          "ḃ": "ḃ",
          "ć": "ć",
          "ḉ": "ḉ",
          "č": "č",
          "ĉ": "ĉ",
          "ċ": "ċ",
          "ç": "ç",
          "ď": "ď",
          "ḋ": "ḋ",
          "ḑ": "ḑ",
          "é": "é",
          "è": "è",
          "ë": "ë",
          "ẽ": "ẽ",
          "ē": "ē",
          "ḗ": "ḗ",
          "ḕ": "ḕ",
          "ĕ": "ĕ",
          "ḝ": "ḝ",
          "ě": "ě",
          "ê": "ê",
          "ế": "ế",
          "ề": "ề",
          "ễ": "ễ",
          "ė": "ė",
          "ȩ": "ȩ",
          "ḟ": "ḟ",
          "ǵ": "ǵ",
          "ḡ": "ḡ",
          "ğ": "ğ",
          "ǧ": "ǧ",
          "ĝ": "ĝ",
          "ġ": "ġ",
          "ģ": "ģ",
          "ḧ": "ḧ",
          "ȟ": "ȟ",
          "ĥ": "ĥ",
          "ḣ": "ḣ",
          "ḩ": "ḩ",
          "í": "í",
          "ì": "ì",
          "ï": "ï",
          "ḯ": "ḯ",
          "ĩ": "ĩ",
          "ī": "ī",
          "ĭ": "ĭ",
          "ǐ": "ǐ",
          "î": "î",
          "ǰ": "ǰ",
          "ĵ": "ĵ",
          "ḱ": "ḱ",
          "ǩ": "ǩ",
          "ķ": "ķ",
          "ĺ": "ĺ",
          "ľ": "ľ",
          "ļ": "ļ",
          "ḿ": "ḿ",
          "ṁ": "ṁ",
          "ń": "ń",
          "ǹ": "ǹ",
          "ñ": "ñ",
          "ň": "ň",
          "ṅ": "ṅ",
          "ņ": "ņ",
          "ó": "ó",
          "ò": "ò",
          "ö": "ö",
          "ȫ": "ȫ",
          "õ": "õ",
          "ṍ": "ṍ",
          "ṏ": "ṏ",
          "ȭ": "ȭ",
          "ō": "ō",
          "ṓ": "ṓ",
          "ṑ": "ṑ",
          "ŏ": "ŏ",
          "ǒ": "ǒ",
          "ô": "ô",
          "ố": "ố",
          "ồ": "ồ",
          "ỗ": "ỗ",
          "ȯ": "ȯ",
          "ȱ": "ȱ",
          "ő": "ő",
          "ṕ": "ṕ",
          "ṗ": "ṗ",
          "ŕ": "ŕ",
          "ř": "ř",
          "ṙ": "ṙ",
          "ŗ": "ŗ",
          "ś": "ś",
          "ṥ": "ṥ",
          "š": "š",
          "ṧ": "ṧ",
          "ŝ": "ŝ",
          "ṡ": "ṡ",
          "ş": "ş",
          "ẗ": "ẗ",
          "ť": "ť",
          "ṫ": "ṫ",
          "ţ": "ţ",
          "ú": "ú",
          "ù": "ù",
          "ü": "ü",
          "ǘ": "ǘ",
          "ǜ": "ǜ",
          "ǖ": "ǖ",
          "ǚ": "ǚ",
          "ũ": "ũ",
          "ṹ": "ṹ",
          "ū": "ū",
          "ṻ": "ṻ",
          "ŭ": "ŭ",
          "ǔ": "ǔ",
          "û": "û",
          "ů": "ů",
          "ű": "ű",
          "ṽ": "ṽ",
          "ẃ": "ẃ",
          "ẁ": "ẁ",
          "ẅ": "ẅ",
          "ŵ": "ŵ",
          "ẇ": "ẇ",
          "ẘ": "ẘ",
          "ẍ": "ẍ",
          "ẋ": "ẋ",
          "ý": "ý",
          "ỳ": "ỳ",
          "ÿ": "ÿ",
          "ỹ": "ỹ",
          "ȳ": "ȳ",
          "ŷ": "ŷ",
          "ẏ": "ẏ",
          "ẙ": "ẙ",
          "ź": "ź",
          "ž": "ž",
          "ẑ": "ẑ",
          "ż": "ż",
          "Á": "Á",
          "À": "À",
          "Ä": "Ä",
          "Ǟ": "Ǟ",
          "Ã": "Ã",
          "Ā": "Ā",
          "Ă": "Ă",
          "Ắ": "Ắ",
          "Ằ": "Ằ",
          "Ẵ": "Ẵ",
          "Ǎ": "Ǎ",
          "Â": "Â",
          "Ấ": "Ấ",
          "Ầ": "Ầ",
          "Ẫ": "Ẫ",
          "Ȧ": "Ȧ",
          "Ǡ": "Ǡ",
          "Å": "Å",
          "Ǻ": "Ǻ",
          "Ḃ": "Ḃ",
          "Ć": "Ć",
          "Ḉ": "Ḉ",
          "Č": "Č",
          "Ĉ": "Ĉ",
          "Ċ": "Ċ",
          "Ç": "Ç",
          "Ď": "Ď",
          "Ḋ": "Ḋ",
          "Ḑ": "Ḑ",
          "É": "É",
          "È": "È",
          "Ë": "Ë",
          "Ẽ": "Ẽ",
          "Ē": "Ē",
          "Ḗ": "Ḗ",
          "Ḕ": "Ḕ",
          "Ĕ": "Ĕ",
          "Ḝ": "Ḝ",
          "Ě": "Ě",
          "Ê": "Ê",
          "Ế": "Ế",
          "Ề": "Ề",
          "Ễ": "Ễ",
          "Ė": "Ė",
          "Ȩ": "Ȩ",
          "Ḟ": "Ḟ",
          "Ǵ": "Ǵ",
          "Ḡ": "Ḡ",
          "Ğ": "Ğ",
          "Ǧ": "Ǧ",
          "Ĝ": "Ĝ",
          "Ġ": "Ġ",
          "Ģ": "Ģ",
          "Ḧ": "Ḧ",
          "Ȟ": "Ȟ",
          "Ĥ": "Ĥ",
          "Ḣ": "Ḣ",
          "Ḩ": "Ḩ",
          "Í": "Í",
          "Ì": "Ì",
          "Ï": "Ï",
          "Ḯ": "Ḯ",
          "Ĩ": "Ĩ",
          "Ī": "Ī",
          "Ĭ": "Ĭ",
          "Ǐ": "Ǐ",
          "Î": "Î",
          "İ": "İ",
          "Ĵ": "Ĵ",
          "Ḱ": "Ḱ",
          "Ǩ": "Ǩ",
          "Ķ": "Ķ",
          "Ĺ": "Ĺ",
          "Ľ": "Ľ",
          "Ļ": "Ļ",
          "Ḿ": "Ḿ",
          "Ṁ": "Ṁ",
          "Ń": "Ń",
          "Ǹ": "Ǹ",
          "Ñ": "Ñ",
          "Ň": "Ň",
          "Ṅ": "Ṅ",
          "Ņ": "Ņ",
          "Ó": "Ó",
          "Ò": "Ò",
          "Ö": "Ö",
          "Ȫ": "Ȫ",
          "Õ": "Õ",
          "Ṍ": "Ṍ",
          "Ṏ": "Ṏ",
          "Ȭ": "Ȭ",
          "Ō": "Ō",
          "Ṓ": "Ṓ",
          "Ṑ": "Ṑ",
          "Ŏ": "Ŏ",
          "Ǒ": "Ǒ",
          "Ô": "Ô",
          "Ố": "Ố",
          "Ồ": "Ồ",
          "Ỗ": "Ỗ",
          "Ȯ": "Ȯ",
          "Ȱ": "Ȱ",
          "Ő": "Ő",
          "Ṕ": "Ṕ",
          "Ṗ": "Ṗ",
          "Ŕ": "Ŕ",
          "Ř": "Ř",
          "Ṙ": "Ṙ",
          "Ŗ": "Ŗ",
          "Ś": "Ś",
          "Ṥ": "Ṥ",
          "Š": "Š",
          "Ṧ": "Ṧ",
          "Ŝ": "Ŝ",
          "Ṡ": "Ṡ",
          "Ş": "Ş",
          "Ť": "Ť",
          "Ṫ": "Ṫ",
          "Ţ": "Ţ",
          "Ú": "Ú",
          "Ù": "Ù",
          "Ü": "Ü",
          "Ǘ": "Ǘ",
          "Ǜ": "Ǜ",
          "Ǖ": "Ǖ",
          "Ǚ": "Ǚ",
          "Ũ": "Ũ",
          "Ṹ": "Ṹ",
          "Ū": "Ū",
          "Ṻ": "Ṻ",
          "Ŭ": "Ŭ",
          "Ǔ": "Ǔ",
          "Û": "Û",
          "Ů": "Ů",
          "Ű": "Ű",
          "Ṽ": "Ṽ",
          "Ẃ": "Ẃ",
          "Ẁ": "Ẁ",
          "Ẅ": "Ẅ",
          "Ŵ": "Ŵ",
          "Ẇ": "Ẇ",
          "Ẍ": "Ẍ",
          "Ẋ": "Ẋ",
          "Ý": "Ý",
          "Ỳ": "Ỳ",
          "Ÿ": "Ÿ",
          "Ỹ": "Ỹ",
          "Ȳ": "Ȳ",
          "Ŷ": "Ŷ",
          "Ẏ": "Ẏ",
          "Ź": "Ź",
          "Ž": "Ž",
          "Ẑ": "Ẑ",
          "Ż": "Ż",
          "ά": "ά",
          "ὰ": "ὰ",
          "ᾱ": "ᾱ",
          "ᾰ": "ᾰ",
          "έ": "έ",
          "ὲ": "ὲ",
          "ή": "ή",
          "ὴ": "ὴ",
          "ί": "ί",
          "ὶ": "ὶ",
          "ϊ": "ϊ",
          "ΐ": "ΐ",
          "ῒ": "ῒ",
          "ῑ": "ῑ",
          "ῐ": "ῐ",
          "ό": "ό",
          "ὸ": "ὸ",
          "ύ": "ύ",
          "ὺ": "ὺ",
          "ϋ": "ϋ",
          "ΰ": "ΰ",
          "ῢ": "ῢ",
          "ῡ": "ῡ",
          "ῠ": "ῠ",
          "ώ": "ώ",
          "ὼ": "ὼ",
          "Ύ": "Ύ",
          "Ὺ": "Ὺ",
          "Ϋ": "Ϋ",
          "Ῡ": "Ῡ",
          "Ῠ": "Ῠ",
          "Ώ": "Ώ",
          "Ὼ": "Ὼ"
        };
        class Parser3 {
          constructor(input, settings) {
            this.mode = void 0;
            this.gullet = void 0;
            this.settings = void 0;
            this.leftrightDepth = void 0;
            this.nextToken = void 0;
            this.mode = "math";
            this.gullet = new MacroExpander(input, settings, this.mode);
            this.settings = settings;
            this.leftrightDepth = 0;
          }
          /**
           * Checks a result to make sure it has the right type, and throws an
           * appropriate error otherwise.
           */
          expect(text2, consume) {
            if (consume === void 0) {
              consume = true;
            }
            if (this.fetch().text !== text2) {
              throw new src_ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
            }
            if (consume) {
              this.consume();
            }
          }
          /**
           * Discards the current lookahead token, considering it consumed.
           */
          consume() {
            this.nextToken = null;
          }
          /**
           * Return the current lookahead token, or if there isn't one (at the
           * beginning, or if the previous lookahead token was consume()d),
           * fetch the next token as the new lookahead token and return it.
           */
          fetch() {
            if (this.nextToken == null) {
              this.nextToken = this.gullet.expandNextToken();
            }
            return this.nextToken;
          }
          /**
           * Switches between "text" and "math" modes.
           */
          switchMode(newMode) {
            this.mode = newMode;
            this.gullet.switchMode(newMode);
          }
          /**
           * Main parsing function, which parses an entire input.
           */
          parse() {
            if (!this.settings.globalGroup) {
              this.gullet.beginGroup();
            }
            if (this.settings.colorIsTextColor) {
              this.gullet.macros.set("\\color", "\\textcolor");
            }
            try {
              const parse2 = this.parseExpression(false);
              this.expect("EOF");
              if (!this.settings.globalGroup) {
                this.gullet.endGroup();
              }
              return parse2;
            } finally {
              this.gullet.endGroups();
            }
          }
          /**
           * Fully parse a separate sequence of tokens as a separate job.
           * Tokens should be specified in reverse order, as in a MacroDefinition.
           */
          subparse(tokens) {
            const oldToken = this.nextToken;
            this.consume();
            this.gullet.pushToken(new Token2("}"));
            this.gullet.pushTokens(tokens);
            const parse2 = this.parseExpression(false);
            this.expect("}");
            this.nextToken = oldToken;
            return parse2;
          }
          /**
           * Parses an "expression", which is a list of atoms.
           *
           * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
           *                 happens when functions have higher precedence han infix
           *                 nodes in implicit parses.
           *
           * `breakOnTokenText`: The text of the token that the expression should end
           *                     with, or `null` if something else should end the
           *                     expression.
           */
          parseExpression(breakOnInfix, breakOnTokenText) {
            const body = [];
            while (true) {
              if (this.mode === "math") {
                this.consumeSpaces();
              }
              const lex = this.fetch();
              if (Parser3.endOfExpression.indexOf(lex.text) !== -1) {
                break;
              }
              if (breakOnTokenText && lex.text === breakOnTokenText) {
                break;
              }
              if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                break;
              }
              const atom = this.parseAtom(breakOnTokenText);
              if (!atom) {
                break;
              } else if (atom.type === "internal") {
                continue;
              }
              body.push(atom);
            }
            if (this.mode === "text") {
              this.formLigatures(body);
            }
            return this.handleInfixNodes(body);
          }
          /**
           * Rewrites infix operators such as \over with corresponding commands such
           * as \frac.
           *
           * There can only be one infix operator per group.  If there's more than one
           * then the expression is ambiguous.  This can be resolved by adding {}.
           */
          handleInfixNodes(body) {
            let overIndex = -1;
            let funcName;
            for (let i = 0; i < body.length; i++) {
              if (body[i].type === "infix") {
                if (overIndex !== -1) {
                  throw new src_ParseError("only one infix operator per group", body[i].token);
                }
                overIndex = i;
                funcName = body[i].replaceWith;
              }
            }
            if (overIndex !== -1 && funcName) {
              let numerNode;
              let denomNode;
              const numerBody = body.slice(0, overIndex);
              const denomBody = body.slice(overIndex + 1);
              if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                numerNode = numerBody[0];
              } else {
                numerNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: numerBody
                };
              }
              if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                denomNode = denomBody[0];
              } else {
                denomNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: denomBody
                };
              }
              let node2;
              if (funcName === "\\\\abovefrac") {
                node2 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
              } else {
                node2 = this.callFunction(funcName, [numerNode, denomNode], []);
              }
              return [node2];
            } else {
              return body;
            }
          }
          /**
           * Handle a subscript or superscript with nice errors.
           */
          handleSupSubscript(name2) {
            const symbolToken = this.fetch();
            const symbol2 = symbolToken.text;
            this.consume();
            this.consumeSpaces();
            const group = this.parseGroup(name2);
            if (!group) {
              throw new src_ParseError("Expected group after '" + symbol2 + "'", symbolToken);
            }
            return group;
          }
          /**
           * Converts the textual input of an unsupported command into a text node
           * contained within a color node whose color is determined by errorColor
           */
          formatUnsupportedCmd(text2) {
            const textordArray = [];
            for (let i = 0; i < text2.length; i++) {
              textordArray.push({
                type: "textord",
                mode: "text",
                text: text2[i]
              });
            }
            const textNode = {
              type: "text",
              mode: this.mode,
              body: textordArray
            };
            const colorNode = {
              type: "color",
              mode: this.mode,
              color: this.settings.errorColor,
              body: [textNode]
            };
            return colorNode;
          }
          /**
           * Parses a group with optional super/subscripts.
           */
          parseAtom(breakOnTokenText) {
            const base2 = this.parseGroup("atom", breakOnTokenText);
            if (this.mode === "text") {
              return base2;
            }
            let superscript2;
            let subscript2;
            while (true) {
              this.consumeSpaces();
              const lex = this.fetch();
              if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                if (base2 && base2.type === "op") {
                  const limits = lex.text === "\\limits";
                  base2.limits = limits;
                  base2.alwaysHandleSupSub = true;
                } else if (base2 && base2.type === "operatorname") {
                  if (base2.alwaysHandleSupSub) {
                    base2.limits = lex.text === "\\limits";
                  }
                } else {
                  throw new src_ParseError("Limit controls must follow a math operator", lex);
                }
                this.consume();
              } else if (lex.text === "^") {
                if (superscript2) {
                  throw new src_ParseError("Double superscript", lex);
                }
                superscript2 = this.handleSupSubscript("superscript");
              } else if (lex.text === "_") {
                if (subscript2) {
                  throw new src_ParseError("Double subscript", lex);
                }
                subscript2 = this.handleSupSubscript("subscript");
              } else if (lex.text === "'") {
                if (superscript2) {
                  throw new src_ParseError("Double superscript", lex);
                }
                const prime = {
                  type: "textord",
                  mode: this.mode,
                  text: "\\prime"
                };
                const primes = [prime];
                this.consume();
                while (this.fetch().text === "'") {
                  primes.push(prime);
                  this.consume();
                }
                if (this.fetch().text === "^") {
                  primes.push(this.handleSupSubscript("superscript"));
                }
                superscript2 = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: primes
                };
              } else if (uSubsAndSups[lex.text]) {
                const isSub = unicodeSubRegEx.test(lex.text);
                const subsupTokens = [];
                subsupTokens.push(new Token2(uSubsAndSups[lex.text]));
                this.consume();
                while (true) {
                  const token2 = this.fetch().text;
                  if (!uSubsAndSups[token2]) {
                    break;
                  }
                  if (unicodeSubRegEx.test(token2) !== isSub) {
                    break;
                  }
                  subsupTokens.unshift(new Token2(uSubsAndSups[token2]));
                  this.consume();
                }
                const body = this.subparse(subsupTokens);
                if (isSub) {
                  subscript2 = {
                    type: "ordgroup",
                    mode: "math",
                    body
                  };
                } else {
                  superscript2 = {
                    type: "ordgroup",
                    mode: "math",
                    body
                  };
                }
              } else {
                break;
              }
            }
            if (superscript2 || subscript2) {
              return {
                type: "supsub",
                mode: this.mode,
                base: base2,
                sup: superscript2,
                sub: subscript2
              };
            } else {
              return base2;
            }
          }
          /**
           * Parses an entire function, including its base and all of its arguments.
           */
          parseFunction(breakOnTokenText, name2) {
            const token2 = this.fetch();
            const func = token2.text;
            const funcData = src_functions[func];
            if (!funcData) {
              return null;
            }
            this.consume();
            if (name2 && name2 !== "atom" && !funcData.allowedInArgument) {
              throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token2);
            } else if (this.mode === "text" && !funcData.allowedInText) {
              throw new src_ParseError("Can't use function '" + func + "' in text mode", token2);
            } else if (this.mode === "math" && funcData.allowedInMath === false) {
              throw new src_ParseError("Can't use function '" + func + "' in math mode", token2);
            }
            const {
              args,
              optArgs
            } = this.parseArguments(func, funcData);
            return this.callFunction(func, args, optArgs, token2, breakOnTokenText);
          }
          /**
           * Call a function handler with a suitable context and arguments.
           */
          callFunction(name2, args, optArgs, token2, breakOnTokenText) {
            const context = {
              funcName: name2,
              parser: this,
              token: token2,
              breakOnTokenText
            };
            const func = src_functions[name2];
            if (func && func.handler) {
              return func.handler(context, args, optArgs);
            } else {
              throw new src_ParseError("No function handler for " + name2);
            }
          }
          /**
           * Parses the arguments of a function or environment
           */
          parseArguments(func, funcData) {
            const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
            if (totalArgs === 0) {
              return {
                args: [],
                optArgs: []
              };
            }
            const args = [];
            const optArgs = [];
            for (let i = 0; i < totalArgs; i++) {
              let argType = funcData.argTypes && funcData.argTypes[i];
              const isOptional = i < funcData.numOptionalArgs;
              if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
              funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
                argType = "primitive";
              }
              const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
              if (isOptional) {
                optArgs.push(arg);
              } else if (arg != null) {
                args.push(arg);
              } else {
                throw new src_ParseError("Null argument, please report this as a bug");
              }
            }
            return {
              args,
              optArgs
            };
          }
          /**
           * Parses a group when the mode is changing.
           */
          parseGroupOfType(name2, type, optional) {
            switch (type) {
              case "color":
                return this.parseColorGroup(optional);
              case "size":
                return this.parseSizeGroup(optional);
              case "url":
                return this.parseUrlGroup(optional);
              case "math":
              case "text":
                return this.parseArgumentGroup(optional, type);
              case "hbox": {
                const group = this.parseArgumentGroup(optional, "text");
                return group != null ? {
                  type: "styling",
                  mode: group.mode,
                  body: [group],
                  style: "text"
                  // simulate \textstyle
                } : null;
              }
              case "raw": {
                const token2 = this.parseStringGroup("raw", optional);
                return token2 != null ? {
                  type: "raw",
                  mode: "text",
                  string: token2.text
                } : null;
              }
              case "primitive": {
                if (optional) {
                  throw new src_ParseError("A primitive argument cannot be optional");
                }
                const group = this.parseGroup(name2);
                if (group == null) {
                  throw new src_ParseError("Expected group as " + name2, this.fetch());
                }
                return group;
              }
              case "original":
              case null:
              case void 0:
                return this.parseArgumentGroup(optional);
              default:
                throw new src_ParseError("Unknown group type as " + name2, this.fetch());
            }
          }
          /**
           * Discard any space tokens, fetching the next non-space token.
           */
          consumeSpaces() {
            while (this.fetch().text === " ") {
              this.consume();
            }
          }
          /**
           * Parses a group, essentially returning the string formed by the
           * brace-enclosed tokens plus some position information.
           */
          parseStringGroup(modeName, optional) {
            const argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            let str = "";
            let nextToken;
            while ((nextToken = this.fetch()).text !== "EOF") {
              str += nextToken.text;
              this.consume();
            }
            this.consume();
            argToken.text = str;
            return argToken;
          }
          /**
           * Parses a regex-delimited group: the largest sequence of tokens
           * whose concatenated strings match `regex`. Returns the string
           * formed by the tokens plus some position information.
           */
          parseRegexGroup(regex2, modeName) {
            const firstToken = this.fetch();
            let lastToken = firstToken;
            let str = "";
            let nextToken;
            while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str + nextToken.text)) {
              lastToken = nextToken;
              str += lastToken.text;
              this.consume();
            }
            if (str === "") {
              throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
            }
            return firstToken.range(lastToken, str);
          }
          /**
           * Parses a color description.
           */
          parseColorGroup(optional) {
            const res = this.parseStringGroup("color", optional);
            if (res == null) {
              return null;
            }
            const match3 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
            if (!match3) {
              throw new src_ParseError("Invalid color: '" + res.text + "'", res);
            }
            let color2 = match3[0];
            if (/^[0-9a-f]{6}$/i.test(color2)) {
              color2 = "#" + color2;
            }
            return {
              type: "color-token",
              mode: this.mode,
              color: color2
            };
          }
          /**
           * Parses a size specification, consisting of magnitude and unit.
           */
          parseSizeGroup(optional) {
            let res;
            let isBlank2 = false;
            this.gullet.consumeSpaces();
            if (!optional && this.gullet.future().text !== "{") {
              res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
            } else {
              res = this.parseStringGroup("size", optional);
            }
            if (!res) {
              return null;
            }
            if (!optional && res.text.length === 0) {
              res.text = "0pt";
              isBlank2 = true;
            }
            const match3 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
            if (!match3) {
              throw new src_ParseError("Invalid size: '" + res.text + "'", res);
            }
            const data2 = {
              number: +(match3[1] + match3[2]),
              // sign + magnitude, cast to number
              unit: match3[3]
            };
            if (!validUnit(data2)) {
              throw new src_ParseError("Invalid unit: '" + data2.unit + "'", res);
            }
            return {
              type: "size",
              mode: this.mode,
              value: data2,
              isBlank: isBlank2
            };
          }
          /**
           * Parses an URL, checking escaped letters and allowed protocols,
           * and setting the catcode of % as an active character (as in \hyperref).
           */
          parseUrlGroup(optional) {
            this.gullet.lexer.setCatcode("%", 13);
            this.gullet.lexer.setCatcode("~", 12);
            const res = this.parseStringGroup("url", optional);
            this.gullet.lexer.setCatcode("%", 14);
            this.gullet.lexer.setCatcode("~", 13);
            if (res == null) {
              return null;
            }
            const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
            return {
              type: "url",
              mode: this.mode,
              url
            };
          }
          /**
           * Parses an argument with the mode specified.
           */
          parseArgumentGroup(optional, mode) {
            const argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            const outerMode = this.mode;
            if (mode) {
              this.switchMode(mode);
            }
            this.gullet.beginGroup();
            const expression = this.parseExpression(false, "EOF");
            this.expect("EOF");
            this.gullet.endGroup();
            const result = {
              type: "ordgroup",
              mode: this.mode,
              loc: argToken.loc,
              body: expression
            };
            if (mode) {
              this.switchMode(outerMode);
            }
            return result;
          }
          /**
           * Parses an ordinary group, which is either a single nucleus (like "x")
           * or an expression in braces (like "{x+y}") or an implicit group, a group
           * that starts at the current position, and ends right before a higher explicit
           * group ends, or at EOF.
           */
          parseGroup(name2, breakOnTokenText) {
            const firstToken = this.fetch();
            const text2 = firstToken.text;
            let result;
            if (text2 === "{" || text2 === "\\begingroup") {
              this.consume();
              const groupEnd = text2 === "{" ? "}" : "\\endgroup";
              this.gullet.beginGroup();
              const expression = this.parseExpression(false, groupEnd);
              const lastToken = this.fetch();
              this.expect(groupEnd);
              this.gullet.endGroup();
              result = {
                type: "ordgroup",
                mode: this.mode,
                loc: SourceLocation.range(firstToken, lastToken),
                body: expression,
                // A group formed by \begingroup...\endgroup is a semi-simple group
                // which doesn't affect spacing in math mode, i.e., is transparent.
                // https://tex.stackexchange.com/questions/1930/when-should-one-
                // use-begingroup-instead-of-bgroup
                semisimple: text2 === "\\begingroup" || void 0
              };
            } else {
              result = this.parseFunction(breakOnTokenText, name2) || this.parseSymbol();
              if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
                if (this.settings.throwOnError) {
                  throw new src_ParseError("Undefined control sequence: " + text2, firstToken);
                }
                result = this.formatUnsupportedCmd(text2);
                this.consume();
              }
            }
            return result;
          }
          /**
           * Form ligature-like combinations of characters for text mode.
           * This includes inputs like "--", "---", "``" and "''".
           * The result will simply replace multiple textord nodes with a single
           * character in each value by a single textord node having multiple
           * characters in its value.  The representation is still ASCII source.
           * The group will be modified in place.
           */
          formLigatures(group) {
            let n = group.length - 1;
            for (let i = 0; i < n; ++i) {
              const a = group[i];
              const v2 = a.text;
              if (v2 === "-" && group[i + 1].text === "-") {
                if (i + 1 < n && group[i + 2].text === "-") {
                  group.splice(i, 3, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i + 2]),
                    text: "---"
                  });
                  n -= 2;
                } else {
                  group.splice(i, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i + 1]),
                    text: "--"
                  });
                  n -= 1;
                }
              }
              if ((v2 === "'" || v2 === "`") && group[i + 1].text === v2) {
                group.splice(i, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 1]),
                  text: v2 + v2
                });
                n -= 1;
              }
            }
          }
          /**
           * Parse a single symbol out of the string. Here, we handle single character
           * symbols and special functions like \verb.
           */
          parseSymbol() {
            const nucleus = this.fetch();
            let text2 = nucleus.text;
            if (/^\\verb[^a-zA-Z]/.test(text2)) {
              this.consume();
              let arg = text2.slice(5);
              const star = arg.charAt(0) === "*";
              if (star) {
                arg = arg.slice(1);
              }
              if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
              }
              arg = arg.slice(1, -1);
              return {
                type: "verb",
                mode: "text",
                body: arg,
                star
              };
            }
            if (unicodeSymbols.hasOwnProperty(text2[0]) && !src_symbols[this.mode][text2[0]]) {
              if (this.settings.strict && this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
              }
              text2 = unicodeSymbols[text2[0]] + text2.slice(1);
            }
            const match3 = combiningDiacriticalMarksEndRegex.exec(text2);
            if (match3) {
              text2 = text2.substring(0, match3.index);
              if (text2 === "i") {
                text2 = "ı";
              } else if (text2 === "j") {
                text2 = "ȷ";
              }
            }
            let symbol2;
            if (src_symbols[this.mode][text2]) {
              if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
              }
              const group = src_symbols[this.mode][text2].group;
              const loc = SourceLocation.range(nucleus);
              let s;
              if (ATOMS.hasOwnProperty(group)) {
                const family = group;
                s = {
                  type: "atom",
                  mode: this.mode,
                  family,
                  loc,
                  text: text2
                };
              } else {
                s = {
                  type: group,
                  mode: this.mode,
                  loc,
                  text: text2
                };
              }
              symbol2 = s;
            } else if (text2.charCodeAt(0) >= 128) {
              if (this.settings.strict) {
                if (!supportedCodepoint(text2.charCodeAt(0))) {
                  this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
                } else if (this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
                }
              }
              symbol2 = {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(nucleus),
                text: text2
              };
            } else {
              return null;
            }
            this.consume();
            if (match3) {
              for (let i = 0; i < match3[0].length; i++) {
                const accent2 = match3[0][i];
                if (!unicodeAccents[accent2]) {
                  throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
                }
                const command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
                if (!command) {
                  throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
                }
                symbol2 = {
                  type: "accent",
                  mode: this.mode,
                  loc: SourceLocation.range(nucleus),
                  label: command,
                  isStretchy: false,
                  isShifty: true,
                  // $FlowFixMe
                  base: symbol2
                };
              }
            }
            return symbol2;
          }
        }
        Parser3.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
        const parseTree = function(toParse, settings) {
          if (!(typeof toParse === "string" || toParse instanceof String)) {
            throw new TypeError("KaTeX can only parse string typed expression");
          }
          const parser = new Parser3(toParse, settings);
          delete parser.gullet.macros.current["\\df@tag"];
          let tree = parser.parse();
          delete parser.gullet.macros.current["\\current@color"];
          delete parser.gullet.macros.current["\\color"];
          if (parser.gullet.macros.get("\\df@tag")) {
            if (!settings.displayMode) {
              throw new src_ParseError("\\tag works only in display equations");
            }
            tree = [{
              type: "tag",
              mode: "text",
              body: tree,
              tag: parser.subparse([new Token2("\\df@tag")])
            }];
          }
          return tree;
        };
        var src_parseTree = parseTree;
        let render2 = function(expression, baseNode, options) {
          baseNode.textContent = "";
          const node2 = renderToDomTree(expression, options).toNode();
          baseNode.appendChild(node2);
        };
        if (typeof document !== "undefined") {
          if (document.compatMode !== "CSS1Compat") {
            typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
            render2 = function() {
              throw new src_ParseError("KaTeX doesn't work in quirks mode.");
            };
          }
        }
        const renderToString = function(expression, options) {
          const markup = renderToDomTree(expression, options).toMarkup();
          return markup;
        };
        const generateParseTree = function(expression, options) {
          const settings = new Settings(options);
          return src_parseTree(expression, settings);
        };
        const renderError = function(error2, expression, options) {
          if (options.throwOnError || !(error2 instanceof src_ParseError)) {
            throw error2;
          }
          const node2 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
          node2.setAttribute("title", error2.toString());
          node2.setAttribute("style", "color:" + options.errorColor);
          return node2;
        };
        const renderToDomTree = function(expression, options) {
          const settings = new Settings(options);
          try {
            const tree = src_parseTree(expression, settings);
            return buildTree2(tree, expression, settings);
          } catch (error2) {
            return renderError(error2, expression, settings);
          }
        };
        const renderToHTMLTree = function(expression, options) {
          const settings = new Settings(options);
          try {
            const tree = src_parseTree(expression, settings);
            return buildHTMLTree(tree, expression, settings);
          } catch (error2) {
            return renderError(error2, expression, settings);
          }
        };
        const version2 = "0.16.21";
        const __domTree = {
          Span,
          Anchor,
          SymbolNode,
          SvgNode,
          PathNode,
          LineNode
        };
        var katex2 = {
          /**
           * Current KaTeX version
           */
          version: version2,
          /**
           * Renders the given LaTeX into an HTML+MathML combination, and adds
           * it as a child to the specified DOM node.
           */
          render: render2,
          /**
           * Renders the given LaTeX into an HTML+MathML combination string,
           * for sending to the client.
           */
          renderToString,
          /**
           * KaTeX error, usually during parsing.
           */
          ParseError: src_ParseError,
          /**
           * The schema of Settings
           */
          SETTINGS_SCHEMA,
          /**
           * Parses the given LaTeX into KaTeX's internal parse tree structure,
           * without rendering to HTML or MathML.
           *
           * NOTE: This method is not currently recommended for public use.
           * The internal tree representation is unstable and is very likely
           * to change. Use at your own risk.
           */
          __parse: generateParseTree,
          /**
           * Renders the given LaTeX into an HTML+MathML internal DOM tree
           * representation, without flattening that representation to a string.
           *
           * NOTE: This method is not currently recommended for public use.
           * The internal tree representation is unstable and is very likely
           * to change. Use at your own risk.
           */
          __renderToDomTree: renderToDomTree,
          /**
           * Renders the given LaTeX into an HTML internal DOM tree representation,
           * without MathML and without flattening that representation to a string.
           *
           * NOTE: This method is not currently recommended for public use.
           * The internal tree representation is unstable and is very likely
           * to change. Use at your own risk.
           */
          __renderToHTMLTree: renderToHTMLTree,
          /**
           * extends internal font metrics object with a new object
           * each key in the new object represents a font name
          */
          __setFontMetrics: setFontMetrics,
          /**
           * adds a new symbol to builtin symbols table
           */
          __defineSymbol: defineSymbol,
          /**
           * adds a new function to builtin function list,
           * which directly produce parse tree elements
           * and have their own html/mathml builders
           */
          __defineFunction: defineFunction,
          /**
           * adds a new macro to builtin macro list
           */
          __defineMacro: defineMacro,
          /**
           * Expose the dom tree node types, which can be useful for type checking nodes.
           *
           * NOTE: These methods are not currently recommended for public use.
           * The internal tree representation is unstable and is very likely
           * to change. Use at your own risk.
           */
          __domTree
        };
        var katex_webpack = katex2;
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      }()
    );
  });
})(katex);
var katexExports = katex.exports;
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist, "__esModule", { value: true });
const katex_1 = __importDefault(katexExports);
function isValidInlineDelim(state, pos) {
  const prevChar = state.src[pos - 1];
  const char = state.src[pos];
  const nextChar = state.src[pos + 1];
  if (char !== "$") {
    return { can_open: false, can_close: false };
  }
  let canOpen = false;
  let canClose = false;
  if (prevChar !== "$" && prevChar !== "\\" && (prevChar === void 0 || isWhitespace(prevChar) || !isWordCharacterOrNumber(prevChar))) {
    canOpen = true;
  }
  if (nextChar !== "$" && (nextChar == void 0 || isWhitespace(nextChar) || !isWordCharacterOrNumber(nextChar))) {
    canClose = true;
  }
  return { can_open: canOpen, can_close: canClose };
}
function isWhitespace(char) {
  return /^\s$/u.test(char);
}
function isWordCharacterOrNumber(char) {
  return /^[\w\d]$/u.test(char);
}
function isValidBlockDelim(state, pos) {
  const prevChar = state.src[pos - 1];
  const char = state.src[pos];
  const nextChar = state.src[pos + 1];
  const nextCharPlus1 = state.src[pos + 2];
  if (char === "$" && prevChar !== "$" && prevChar !== "\\" && nextChar === "$" && nextCharPlus1 !== "$") {
    return { can_open: true, can_close: true };
  }
  return { can_open: false, can_close: false };
}
function inlineMath(state, silent) {
  if (state.src[state.pos] !== "$") {
    return false;
  }
  const lastToken = state.tokens.at(-1);
  if (lastToken?.type === "html_inline") {
    if (/^<\w+.+[^/]>$/.test(lastToken.content)) {
      return false;
    }
  }
  let res = isValidInlineDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos += 1;
    return true;
  }
  let start2 = state.pos + 1;
  let match3 = start2;
  let pos;
  while ((match3 = state.src.indexOf("$", match3)) !== -1) {
    pos = match3 - 1;
    while (state.src[pos] === "\\") {
      pos -= 1;
    }
    if ((match3 - pos) % 2 == 1) {
      break;
    }
    match3 += 1;
  }
  if (match3 === -1) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start2;
    return true;
  }
  if (match3 - start2 === 0) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos = start2 + 1;
    return true;
  }
  res = isValidInlineDelim(state, match3);
  if (!res.can_close) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start2;
    return true;
  }
  if (!silent) {
    const token2 = state.push("math_inline", "math", 0);
    token2.markup = "$";
    token2.content = state.src.slice(start2, match3);
  }
  state.pos = match3 + 1;
  return true;
}
function blockMath(state, start2, end2, silent) {
  var lastLine, next3, lastPos, found = false, token2, pos = state.bMarks[start2] + state.tShift[start2], max2 = state.eMarks[start2];
  if (pos + 2 > max2) {
    return false;
  }
  if (state.src.slice(pos, pos + 2) !== "$$") {
    return false;
  }
  pos += 2;
  let firstLine = state.src.slice(pos, max2);
  if (silent) {
    return true;
  }
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next3 = start2; !found; ) {
    next3++;
    if (next3 >= end2) {
      break;
    }
    pos = state.bMarks[next3] + state.tShift[next3];
    max2 = state.eMarks[next3];
    if (pos < max2 && state.tShift[next3] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max2).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max2).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    } else if (state.src.slice(pos, max2).trim().includes("$$")) {
      lastPos = state.src.slice(0, max2).trim().indexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next3 + 1;
  token2 = state.push("math_block", "math", 0);
  token2.block = true;
  token2.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start2 + 1, next3, state.tShift[start2], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token2.map = [start2, state.line];
  token2.markup = "$$";
  return true;
}
function blockBareMath(state, start2, end2, silent) {
  const startPos = state.bMarks[start2] + state.tShift[start2];
  const startMax = state.eMarks[start2];
  const firstLine = state.src.slice(startPos, startMax);
  const beginMatch = firstLine.match(/^\s*\\begin\s*\{([^{}]+)\}/);
  if (!beginMatch) {
    return false;
  }
  if (start2 > 0) {
    const previousStart = state.bMarks[start2 - 1] + state.tShift[start2 - 1];
    const previousEnd = state.eMarks[start2 - 1];
    const previousLine = state.src.slice(previousStart, previousEnd);
    if (!/^\s*$/.test(previousLine)) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  const beginEndStack = [];
  let next3 = start2;
  let lastLine;
  let found = false;
  outer:
    for (; !found; next3++) {
      if (next3 >= end2) {
        break;
      }
      const pos = state.bMarks[next3] + state.tShift[next3];
      const max2 = state.eMarks[next3];
      if (pos < max2 && state.tShift[next3] < state.blkIndent) {
        break;
      }
      const line = state.src.slice(pos, max2);
      for (const match3 of line.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g)) {
        if (match3[1] === "\\begin") {
          beginEndStack.push(match3[2].trim());
        } else if (match3[1] === "\\end") {
          beginEndStack.pop();
          if (!beginEndStack.length) {
            lastLine = state.src.slice(pos, max2);
            found = true;
            break outer;
          }
        }
      }
    }
  state.line = next3 + 1;
  const token2 = state.push("math_block", "math", 0);
  token2.block = true;
  token2.content = (state.getLines(start2, next3, state.tShift[start2], true) + (lastLine ?? "")).trim();
  token2.map = [start2, state.line];
  token2.markup = "$$";
  return true;
}
function inlineMathBlock(state, silent) {
  var start2, match3, token2, res, pos;
  if (state.src.slice(state.pos, state.pos + 2) !== "$$") {
    return false;
  }
  res = isValidBlockDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos += 2;
    return true;
  }
  start2 = state.pos + 2;
  match3 = start2;
  while ((match3 = state.src.indexOf("$$", match3)) !== -1) {
    pos = match3 - 1;
    while (state.src[pos] === "\\") {
      pos -= 1;
    }
    if ((match3 - pos) % 2 == 1) {
      break;
    }
    match3 += 2;
  }
  if (match3 === -1) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos = start2;
    return true;
  }
  if (match3 - start2 === 0) {
    if (!silent) {
      state.pending += "$$$$";
    }
    state.pos = start2 + 2;
    return true;
  }
  res = isValidBlockDelim(state, match3);
  if (!res.can_close) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos = start2;
    return true;
  }
  if (!silent) {
    token2 = state.push("math_block", "math", 0);
    token2.block = true;
    token2.markup = "$$";
    token2.content = state.src.slice(start2, match3);
  }
  state.pos = match3 + 2;
  return true;
}
function inlineBareBlock(state, silent) {
  const text2 = state.src.slice(state.pos);
  if (!/^\n\\begin/.test(text2)) {
    return false;
  }
  state.pos += 1;
  if (silent) {
    return true;
  }
  const lines = text2.split(/\n/g).slice(1);
  let foundLine;
  const beginEndStack = [];
  outer:
    for (var i = 0; i < lines.length; ++i) {
      const line = lines[i];
      for (const match3 of line.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g)) {
        if (match3[1] === "\\begin") {
          beginEndStack.push(match3[2].trim());
        } else if (match3[1] === "\\end") {
          beginEndStack.pop();
          if (!beginEndStack.length) {
            foundLine = i;
            break outer;
          }
        }
      }
    }
  if (typeof foundLine === "undefined") {
    return false;
  }
  const endIndex = lines.slice(0, foundLine + 1).reduce((p, c2) => p + c2.length, 0) + foundLine + 1;
  const token2 = state.push("math_inline_bare_block", "math", 0);
  token2.block = true;
  token2.markup = "$$";
  token2.content = text2.slice(1, endIndex);
  state.pos = state.pos + endIndex;
  return true;
}
function handleMathInHtml(state, mathType, mathMarkup, mathRegex) {
  const tokens = state.tokens;
  for (let index2 = tokens.length - 1; index2 >= 0; index2--) {
    const currentToken = tokens[index2];
    const newTokens = [];
    if (currentToken.type !== "html_block") {
      continue;
    }
    const content = currentToken.content;
    for (const match3 of content.matchAll(mathRegex)) {
      if (!match3.groups) {
        continue;
      }
      const html_before_math = match3.groups.html_before_math;
      const math = match3.groups.math;
      const html_after_math = match3.groups.html_after_math;
      if (html_before_math) {
        newTokens.push({ ...currentToken, type: "html_block", map: null, content: html_before_math });
      }
      if (math) {
        newTokens.push({
          ...currentToken,
          type: mathType,
          map: null,
          content: math,
          markup: mathMarkup,
          block: true,
          tag: "math"
        });
      }
      if (html_after_math) {
        newTokens.push({ ...currentToken, type: "html_block", map: null, content: html_after_math });
      }
    }
    if (newTokens.length > 0) {
      tokens.splice(index2, 1, ...newTokens);
    }
  }
  return true;
}
function escapeHtml(unsafe) {
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function default_1(md, options) {
  const katex2 = options?.katex ?? katex_1.default;
  const enableBareBlocks = options?.enableBareBlocks;
  const enableMathBlockInHtml = options?.enableMathBlockInHtml;
  const enableMathInlineInHtml = options?.enableMathInlineInHtml;
  const enableFencedBlocks = options?.enableFencedBlocks;
  md.inline.ruler.after("escape", "math_inline", inlineMath);
  md.inline.ruler.after("escape", "math_inline_block", inlineMathBlock);
  if (enableBareBlocks) {
    md.inline.ruler.before("text", "math_inline_bare_block", inlineBareBlock);
  }
  md.block.ruler.after("blockquote", "math_block", (state, start2, end2, silent) => {
    if (enableBareBlocks && blockBareMath(state, start2, end2, silent)) {
      return true;
    }
    return blockMath(state, start2, end2, silent);
  }, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  const math_block_within_html_regex = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm;
  const math_inline_within_html_regex = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
  if (enableMathBlockInHtml) {
    md.core.ruler.push("math_block_in_html_block", (state) => {
      return handleMathInHtml(state, "math_block", "$$", math_block_within_html_regex);
    });
  }
  if (enableMathInlineInHtml) {
    md.core.ruler.push("math_inline_in_html_block", (state) => {
      return handleMathInHtml(state, "math_inline", "$", math_inline_within_html_regex);
    });
  }
  const katexInline = (latex) => {
    const displayMode = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(latex);
    try {
      return katex2.renderToString(latex, { ...options, displayMode });
    } catch (error2) {
      if (options?.throwOnError) {
        console.log(error2);
      }
      return `<span class="katex-error" title="${escapeHtml(latex)}">${escapeHtml(error2 + "")}</span>`;
    }
  };
  const inlineRenderer = (tokens, idx) => {
    const content = tokens[idx].content;
    const hasBacktick = content.length > 2 && content[0] === "`" && content[content.length - 1] === "`";
    const sanitized = hasBacktick ? content.slice(1, -1) : content;
    return katexInline(sanitized);
  };
  const katexBlockRenderer = (latex) => {
    try {
      return `<p class="katex-block">${katex2.renderToString(latex, { ...options, displayMode: true })}</p>`;
    } catch (error2) {
      if (options?.throwOnError) {
        console.log(error2);
      }
      return `<p class="katex-block katex-error" title="${escapeHtml(latex)}">${escapeHtml(error2 + "")}</p>`;
    }
  };
  const blockRenderer = (tokens, idx) => {
    return katexBlockRenderer(tokens[idx].content) + "\n";
  };
  md.renderer.rules.math_inline = inlineRenderer;
  md.renderer.rules.math_inline_block = blockRenderer;
  md.renderer.rules.math_inline_bare_block = blockRenderer;
  md.renderer.rules.math_block = blockRenderer;
  if (enableFencedBlocks) {
    const mathLanguageId = "math";
    const originalFenceRenderer = md.renderer.rules.fence;
    md.renderer.rules.fence = function(tokens, idx, options2, env, self2) {
      const token2 = tokens[idx];
      if (token2.info.trim().toLowerCase() === mathLanguageId && enableFencedBlocks) {
        return katexBlockRenderer(token2.content) + "\n";
      } else {
        return originalFenceRenderer?.call(this, tokens, idx, options2, env, self2) || "";
      }
    };
  }
}
var _default = dist.default = default_1;
function initializeMarkdownIt() {
  const md = MarkdownIt({
    html: true,
    breaks: true
  });
  md.use(ins_plugin$1).use(ins_plugin).use(sub_plugin).use(sup_plugin);
  return md;
}
function createTransformHooks(transformer2) {
  return {
    transformer: transformer2,
    parser: new Hook(),
    beforeParse: new Hook(),
    afterParse: new Hook(),
    retransform: new Hook()
  };
}
function definePlugin(plugin2) {
  return plugin2;
}
const svgMarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>\n';
const svgUnmarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>\n';
const name$5 = "checkbox";
const images = {
  " ": svgUnmarked.trim(),
  x: svgMarked.trim()
};
const plugin$3 = definePlugin({
  name: name$5,
  transform(transformHooks) {
    transformHooks.parser.tap((md) => {
      md.core.ruler.before("inline", "checkbox", (state) => {
        for (let i = 2; i < state.tokens.length; i += 1) {
          const token2 = state.tokens[i];
          if (token2.type === "inline" && token2.content) {
            const prevType = state.tokens[i - 1].type;
            const prevPrevType = state.tokens[i - 2].type;
            if (prevType === "heading_open" || prevType === "paragraph_open" && prevPrevType === "list_item_open") {
              token2.content = token2.content.replace(
                /^\[(.)\] /,
                (m, g) => images[g] ? `${images[g]} ` : m
              );
            }
          }
        }
        return false;
      });
    });
    return {};
  }
});
const name$4 = "frontmatter";
const pluginFrontmatter = definePlugin({
  name: name$4,
  transform(transformHooks) {
    transformHooks.beforeParse.tap((_md, context) => {
      var _a2;
      const { content } = context;
      if (!/^---\r?\n/.test(content))
        return;
      const match3 = /\n---\r?\n/.exec(content);
      if (!match3)
        return;
      const raw = content.slice(4, match3.index).trimEnd();
      let frontmatter;
      try {
        frontmatter = parse(raw.replace(/\r?\n|\r/g, "\n"));
        if (frontmatter == null ? void 0 : frontmatter.markmap) {
          frontmatter.markmap = normalizeMarkmapJsonOptions(
            frontmatter.markmap
          );
        }
      } catch {
        return;
      }
      context.frontmatter = frontmatter;
      context.parserOptions = {
        ...context.parserOptions,
        ...(_a2 = frontmatter == null ? void 0 : frontmatter.markmap) == null ? void 0 : _a2.htmlParser
      };
      context.frontmatterInfo = {
        lines: content.slice(0, match3.index).split("\n").length + 1,
        offset: match3.index + match3[0].length
      };
    });
    return {};
  }
});
function normalizeMarkmapJsonOptions(options) {
  if (!options)
    return;
  ["color", "extraJs", "extraCss"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeStringArray(options[key]);
  });
  ["duration", "maxWidth", "initialExpandLevel"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeNumber(options[key]);
  });
  return options;
}
function normalizeStringArray(value) {
  let result;
  if (typeof value === "string")
    result = [value];
  else if (Array.isArray(value))
    result = value.filter((item) => item && typeof item === "string");
  return (result == null ? void 0 : result.length) ? result : void 0;
}
function normalizeNumber(value) {
  if (isNaN(+value))
    return;
  return +value;
}
function patchJSItem(urlBuilder, item) {
  if (item.type === "script" && item.data.src) {
    return {
      ...item,
      data: {
        ...item.data,
        src: urlBuilder.getFullUrl(item.data.src)
      }
    };
  }
  return item;
}
function patchCSSItem(urlBuilder, item) {
  if (item.type === "stylesheet" && item.data.href) {
    return {
      ...item,
      data: {
        ...item.data,
        href: urlBuilder.getFullUrl(item.data.href)
      }
    };
  }
  return item;
}
const name$3 = "hljs";
const preloadScripts$1 = [
  `@highlightjs/cdn-assets@${"11.11.1"}/highlight.min.js`
].map((path2) => buildJSItem(path2));
const styles$1 = [
  `@highlightjs/cdn-assets@${"11.11.1"}/styles/default.min.css`
].map((path2) => buildCSSItem(path2));
const config$1 = {
  versions: {
    hljs: "11.11.1"
  },
  preloadScripts: preloadScripts$1,
  styles: styles$1
};
const plugin$2 = definePlugin({
  name: name$3,
  config: config$1,
  transform(transformHooks) {
    var _a2, _b, _c;
    let loading;
    const preloadScripts2 = ((_b = (_a2 = plugin$2.config) == null ? void 0 : _a2.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    let enableFeature = noop$2;
    transformHooks.parser.tap((md) => {
      md.set({
        highlight: (str, language) => {
          enableFeature();
          const { hljs } = window;
          if (hljs) {
            return hljs.highlightAuto(str, language ? [language] : void 0).value;
          }
          autoload().then(() => {
            transformHooks.retransform.call();
          });
          return str;
        }
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$3] = true;
      };
    });
    return {
      styles: (_c = plugin$2.config) == null ? void 0 : _c.styles
    };
  }
});
function addDefaultVersions(paths, name2, version2) {
  return paths.map((path2) => {
    if (typeof path2 === "string" && !path2.includes("://")) {
      if (!path2.startsWith("npm:")) {
        path2 = `npm:${path2}`;
      }
      const prefixLength = 4 + name2.length;
      if (path2.startsWith(`npm:${name2}/`)) {
        path2 = `${path2.slice(0, prefixLength)}@${version2}${path2.slice(
          prefixLength
        )}`;
      }
    }
    return path2;
  });
}
var define_define_KATEX_RESOURCES_default = ["katex@0.16.18/dist/fonts/KaTeX_AMS-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Script-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size1-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size2-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size3-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size4-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Typewriter-Regular.woff2"];
const name$2 = "katex";
const preloadScripts = [
  `katex@${"0.16.18"}/dist/katex.min.js`
].map((path2) => buildJSItem(path2));
const webfontloader = buildJSItem(
  `webfontloader@${"1.6.28"}/webfontloader.js`
);
webfontloader.data.defer = true;
const styles$2 = [`katex@${"0.16.18"}/dist/katex.min.css`].map(
  (path2) => buildCSSItem(path2)
);
const config = {
  versions: {
    katex: "0.16.18",
    webfontloader: "1.6.28"
  },
  preloadScripts,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (getMarkmap) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              getMarkmap().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap }) {
          return [getMarkmap];
        }
      }
    },
    webfontloader
  ],
  styles: styles$2,
  resources: define_define_KATEX_RESOURCES_default
};
function interop(mod) {
  return mod.default || mod;
}
const katexPlugin = interop(_default);
const plugin$1 = definePlugin({
  name: name$2,
  config,
  transform(transformHooks) {
    var _a2, _b, _c, _d;
    let loading;
    const preloadScripts2 = ((_b = (_a2 = plugin$1.config) == null ? void 0 : _a2.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    const renderKatex = (source, displayMode) => {
      const { katex: katex2 } = window;
      if (katex2) {
        return katex2.renderToString(source, {
          displayMode,
          throwOnError: false
        });
      }
      autoload().then(() => {
        transformHooks.retransform.call();
      });
      return source;
    };
    let enableFeature = noop$2;
    transformHooks.parser.tap((md) => {
      md.use(katexPlugin);
      ["math_block", "math_inline"].forEach((key) => {
        const fn = (tokens, idx) => {
          enableFeature();
          const result = renderKatex(tokens[idx].content, !!tokens[idx].block);
          return result;
        };
        md.renderer.rules[key] = fn;
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$2] = true;
      };
    });
    transformHooks.afterParse.tap((_, context) => {
      var _a22;
      const markmap2 = (_a22 = context.frontmatter) == null ? void 0 : _a22.markmap;
      if (markmap2) {
        ["extraJs", "extraCss"].forEach((key) => {
          var _a3, _b2;
          const value = markmap2[key];
          if (value) {
            markmap2[key] = addDefaultVersions(
              value,
              name$2,
              ((_b2 = (_a3 = plugin$1.config) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.katex) || ""
            );
          }
        });
      }
    });
    return {
      styles: (_c = plugin$1.config) == null ? void 0 : _c.styles,
      scripts: (_d = plugin$1.config) == null ? void 0 : _d.scripts
    };
  }
});
const name$1 = "npmUrl";
const pluginNpmUrl = definePlugin({
  name: name$1,
  transform(transformHooks) {
    transformHooks.afterParse.tap((_, context) => {
      const { frontmatter } = context;
      const markmap2 = frontmatter == null ? void 0 : frontmatter.markmap;
      if (markmap2) {
        ["extraJs", "extraCss"].forEach((key) => {
          const value = markmap2[key];
          if (value) {
            markmap2[key] = value.map((path2) => {
              if (path2.startsWith("npm:")) {
                return transformHooks.transformer.urlBuilder.getFullUrl(
                  path2.slice(4)
                );
              }
              return path2;
            });
          }
        });
      }
    });
    return {};
  }
});
const name = "sourceLines";
const plugin = definePlugin({
  name,
  transform(transformHooks) {
    let frontmatterLines = 0;
    transformHooks.beforeParse.tap((_md, context) => {
      var _a2;
      frontmatterLines = ((_a2 = context.frontmatterInfo) == null ? void 0 : _a2.lines) || 0;
    });
    transformHooks.parser.tap((md) => {
      md.renderer.renderAttrs = wrapFunction(
        md.renderer.renderAttrs,
        (renderAttrs2, token2) => {
          if (token2.block && token2.map) {
            const lineRange = token2.map.map((line) => line + frontmatterLines);
            token2.attrSet("data-lines", lineRange.join(","));
          }
          return renderAttrs2(token2);
        }
      );
      if (md.renderer.rules.fence) {
        md.renderer.rules.fence = wrapFunction(
          md.renderer.rules.fence,
          (fence2, tokens, idx, ...rest) => {
            let result = fence2(tokens, idx, ...rest);
            const token2 = tokens[idx];
            if (result.startsWith("<pre>") && token2.map) {
              const lineRange = token2.map.map(
                (line) => line + frontmatterLines
              );
              result = result.slice(0, 4) + ` data-lines="${lineRange.join(",")}"` + result.slice(4);
            }
            return result;
          }
        );
      }
    });
    return {};
  }
});
const plugins = [
  pluginFrontmatter,
  plugin$1,
  plugin$2,
  pluginNpmUrl,
  plugin$3,
  plugin
];
const builtInPlugins = plugins;
function cleanNode(node2) {
  while (!node2.content && node2.children.length === 1) {
    node2 = node2.children[0];
  }
  while (node2.children.length === 1 && !node2.children[0].content) {
    node2 = {
      ...node2,
      children: node2.children[0].children
    };
  }
  return {
    ...node2,
    children: node2.children.map(cleanNode)
  };
}
class Transformer {
  constructor(plugins2 = builtInPlugins) {
    this.assetsMap = {};
    this.urlBuilder = new UrlBuilder();
    this.hooks = createTransformHooks(this);
    this.plugins = plugins2.map(
      (plugin2) => typeof plugin2 === "function" ? plugin2() : plugin2
    );
    const assetsMap = {};
    for (const { name: name2, transform: transform2 } of this.plugins) {
      assetsMap[name2] = transform2(this.hooks);
    }
    this.assetsMap = assetsMap;
    const md = initializeMarkdownIt();
    this.md = md;
    this.hooks.parser.call(md);
  }
  transform(content, fallbackParserOptions) {
    var _a2;
    const context = {
      content,
      features: {},
      parserOptions: fallbackParserOptions
    };
    this.hooks.beforeParse.call(this.md, context);
    let { content: rawContent } = context;
    if (context.frontmatterInfo)
      rawContent = rawContent.slice(context.frontmatterInfo.offset);
    const html2 = this.md.render(rawContent, {});
    this.hooks.afterParse.call(this.md, context);
    const root2 = cleanNode(buildTree(html2, context.parserOptions));
    root2.content || (root2.content = `${((_a2 = context.frontmatter) == null ? void 0 : _a2.title) || ""}`);
    return { ...context, root: root2 };
  }
  resolveJS(item) {
    return patchJSItem(this.urlBuilder, item);
  }
  resolveCSS(item) {
    return patchCSSItem(this.urlBuilder, item);
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(keys4) {
    const styles2 = [];
    const scripts2 = [];
    keys4 ?? (keys4 = this.plugins.map((plugin2) => plugin2.name));
    for (const assets of keys4.map((key) => this.assetsMap[key])) {
      if (assets) {
        if (assets.styles)
          styles2.push(...assets.styles);
        if (assets.scripts)
          scripts2.push(...assets.scripts);
      }
    }
    return {
      styles: styles2.map((item) => this.resolveCSS(item)),
      scripts: scripts2.map((item) => this.resolveJS(item))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(features) {
    const keys4 = this.plugins.map((plugin2) => plugin2.name).filter((name2) => features[name2]);
    return this.getAssets(keys4);
  }
}
const transformer = new Transformer();
const { scripts, styles } = transformer.getAssets();
loadCSS(styles);
loadJS(scripts, { getMarkmap: () => markmap });
var FileSaver_min = { exports: {} };
(function(module, exports) {
  (function(a, b) {
    b();
  })(commonjsGlobal$1, function() {
    function b(a2, b2) {
      return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
    }
    function c2(a2, b2, c3) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c3);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c3) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal$1 && commonjsGlobal$1.global === commonjsGlobal$1 ? commonjsGlobal$1 : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h2) {
      var i = f.URL || f.webkitURL, j2 = document.createElement("a");
      g2 = g2 || b2.name || "download", j2.download = g2, j2.rel = "noopener", "string" == typeof b2 ? (j2.href = b2, j2.origin === location.origin ? e(j2) : d(j2.href) ? c2(b2, g2, h2) : e(j2, j2.target = "_blank")) : (j2.href = i.createObjectURL(b2), setTimeout(function() {
        i.revokeObjectURL(j2.href);
      }, 4e4), setTimeout(function() {
        e(j2);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h2) {
      if (g2 = g2 || f2.name || "download", "string" != typeof f2)
        navigator.msSaveOrOpenBlob(b(f2, h2), g2);
      else if (d(f2))
        c2(f2, g2, h2);
      else {
        var i = document.createElement("a");
        i.href = f2, i.target = "_blank", setTimeout(function() {
          e(i);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
        return c2(b2, d2, e2);
      var h2 = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j2 || h2 && i || a) && "undefined" != typeof FileReader) {
        var k = new FileReader();
        k.onloadend = function() {
          var a2 = k.result;
          a2 = j2 ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k.readAsDataURL(b2);
      } else {
        var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
  });
})(FileSaver_min);
var FileSaver_minExports = FileSaver_min.exports;
const _hoisted_1$3 = { class: "flex flex-col bg-[#F9FAFB] rounded-xl overflow-hidden" };
const _hoisted_2$3 = { class: "flex-none h-[72px] bg-[#EBECEF] flex items-center px-6" };
const _hoisted_3$2 = { class: "flex-1" };
const _hoisted_4$2 = { class: "inline-flex h-12 px-1.5 items-center bg-[#E1E2E6] rounded-lg" };
const _hoisted_5$1 = { class: "flex items-center gap-5" };
const _hoisted_6$1 = { class: "el-dropdown-link" };
const _hoisted_7$1 = { class: "flex items-center gap-5" };
const _hoisted_8$1 = { class: "flex-1 relative overflow-hidden" };
const _hoisted_9$1 = {
  class: "absolute w-full h-full p-4",
  key: "code"
};
const _hoisted_10$1 = { class: "whitespace-pre-wrap h-full" };
const initValue = `
# LlamaIndex定位转变及AgentWorkflow诞生背景
- LlamaIndex从RAG框架转向多智能体框架
- AgentWorkflow因Workflow不足而诞生
# AgentWorkflow的构成及工作原理
- Agent模块包含FunctionAgent和ReActAgent
- AgentWorkflow模块负责整体流程编排
# 基于AgentWorkflow的客户服务项目实践
- 定义ConciergeAgent等不同功能智能体
- 使用Chainlit进行UI开发
# AgentWorkflow的问题及改进
- FunctionAgent存在响应不及时的问题
- 通过调整聊天记录解决响应问题
# AgentWorkflow的优势与未来展望
- 简化多智能体编排开发过程
- 特定场景有待进一步改进完善
- useful
- easy
- interactive
`;
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    const mode = ref("image");
    const svgRef = ref();
    const value = ref(initValue);
    let mm;
    const update2 = async () => {
      const { root: root2 } = transformer.transform(value.value);
      await mm.setData(root2);
      mm.fit();
    };
    onMounted(() => {
      mm = it$1.create(svgRef.value);
      update2();
    });
    const copyCode = () => {
      navigator.clipboard.writeText(value.value).then(() => {
        ElMessage.success("复制成功");
      }).catch(() => {
        ElMessage.error("复制失败");
      });
    };
    const zoomIn = () => {
      mm.rescale(1.25);
    };
    const zoomOut = () => {
      mm.rescale(0.8);
    };
    const downloadImage = async () => {
      const svg = svgRef.value;
      const clonedSvg = svg.cloneNode(true);
      clonedSvg.setAttribute("style", "background-color: white");
      const svgData = new XMLSerializer().serializeToString(clonedSvg);
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const img = new Image();
      const width = parseInt(svg.getAttribute("width")) || svg.clientWidth;
      const height = parseInt(svg.getAttribute("height")) || svg.clientHeight;
      canvas.width = width;
      canvas.height = height;
      img.onload = () => {
        ctx?.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
          if (blob) {
            FileSaver_minExports.saveAs(blob, "markmap.png");
          }
        }, "image/png");
      };
      img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgData)));
    };
    const copyPlainText = () => {
      const text2 = value.value.replace(/^[#*-]\s*/gm, "");
      navigator.clipboard.writeText(text2).then(() => {
        ElMessage.success("纯文本复制成功");
      }).catch(() => {
        ElMessage.error("复制失败");
      });
    };
    const copyMarkdown = () => {
      navigator.clipboard.writeText(value.value).then(() => {
        ElMessage.success("Markdown复制成功");
      }).catch(() => {
        ElMessage.error("复制失败");
      });
    };
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_dropdown_item = ElDropdownItem;
      const _component_el_dropdown_menu = ElDropdownMenu;
      const _component_el_dropdown = ElDropdown;
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", _hoisted_2$3, [
          createBaseVNode("div", _hoisted_3$2, [
            createBaseVNode("div", _hoisted_4$2, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "w-16 h-9 cursor-pointer flex-center rounded text-base",
                  mode.value === "image" ? "bg-white text-[#1D1E1F]" : "text-[#4F5052]"
                ]),
                onClick: _cache[0] || (_cache[0] = ($event) => mode.value = "image")
              }, " 图片 ", 2),
              createBaseVNode("div", {
                class: normalizeClass([
                  "w-16 h-9 cursor-pointer flex-center rounded text-base",
                  mode.value === "code" ? "bg-white text-[#1D1E1F]" : "text-[#4F5052]"
                ]),
                onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "code")
              }, " 代码 ", 2)
            ])
          ]),
          withDirectives(createBaseVNode("div", _hoisted_5$1, [
            createVNode(_component_el_dropdown, null, {
              dropdown: withCtx(() => [
                createVNode(_component_el_dropdown_menu, null, {
                  default: withCtx(() => [
                    createVNode(_component_el_dropdown_item, { onClick: downloadImage }, {
                      default: withCtx(() => _cache[2] || (_cache[2] = [
                        createTextVNode("下载图片")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_el_dropdown_item, { onClick: copyPlainText }, {
                      default: withCtx(() => _cache[3] || (_cache[3] = [
                        createTextVNode("复制文本")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_el_dropdown_item, { onClick: copyMarkdown }, {
                      default: withCtx(() => _cache[4] || (_cache[4] = [
                        createTextVNode("复制markdown")
                      ])),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_6$1, [
                  createVNode(_component_el_icon, {
                    color: "#333333",
                    size: "18"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(download_default))
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_icon, {
                    color: "#9A9A9A",
                    size: "12"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_down_default))
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }),
            createVNode(_component_el_icon, {
              class: "cursor-pointer",
              size: "16",
              color: "#1D1E1F",
              onClick: zoomOut
            }, {
              default: withCtx(() => [
                createVNode(unref(zoom_out_default))
              ]),
              _: 1
            }),
            createVNode(_component_el_icon, {
              class: "cursor-pointer",
              size: "16",
              color: "#1D1E1F",
              onClick: zoomIn
            }, {
              default: withCtx(() => [
                createVNode(unref(zoom_in_default))
              ]),
              _: 1
            })
          ], 512), [
            [vShow, mode.value === "image"]
          ]),
          withDirectives(createBaseVNode("div", _hoisted_7$1, [
            createVNode(_component_el_icon, {
              class: "cursor-pointer",
              onClick: copyCode
            }, {
              default: withCtx(() => [
                createVNode(unref(copy_document_default))
              ]),
              _: 1
            })
          ], 512), [
            [vShow, mode.value === "code"]
          ])
        ]),
        createBaseVNode("div", _hoisted_8$1, [
          createVNode(Transition$1, {
            name: "slide-fade",
            mode: "out-in"
          }, {
            default: withCtx(() => [
              withDirectives((openBlock(), createElementBlock("svg", {
                class: "absolute w-full h-full",
                ref_key: "svgRef",
                ref: svgRef,
                key: "image"
              }, null, 512)), [
                [vShow, mode.value === "image"]
              ])
            ]),
            _: 1
          }),
          createVNode(Transition$1, {
            name: "slide-fade",
            mode: "out-in"
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", _hoisted_9$1, [
                createBaseVNode("pre", _hoisted_10$1, toDisplayString(value.value), 1)
              ], 512), [
                [vShow, mode.value === "code"]
              ])
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});
const MarkMap = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-b27e249c"]]);
/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.1.9
 * @date    2023-11-03T01:42:27.418Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var check = function(it3) {
  return it3 && it3.Math === Math && it3;
};
var global$s = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || commonjsGlobal || Function("return this")()
);
var fails$z = function(exec2) {
  try {
    return !!exec2();
  } catch (error2) {
    return true;
  }
};
var fails$y = fails$z;
var functionBindNative = !fails$y(function() {
  var test3 = function() {
  }.bind();
  return typeof test3 != "function" || test3.hasOwnProperty("prototype");
});
var NATIVE_BIND$4 = functionBindNative;
var FunctionPrototype$4 = Function.prototype;
var apply$6 = FunctionPrototype$4.apply;
var call$l = FunctionPrototype$4.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$4 ? call$l.bind(apply$6) : function() {
  return call$l.apply(apply$6, arguments);
});
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var call$k = FunctionPrototype$3.call;
var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$3.bind.bind(call$k, call$k);
var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$k.apply(fn, arguments);
  };
};
var uncurryThis$y = functionUncurryThis;
var toString$d = uncurryThis$y({}.toString);
var stringSlice$1 = uncurryThis$y("".slice);
var classofRaw$2 = function(it3) {
  return stringSlice$1(toString$d(it3), 8, -1);
};
var classofRaw$1 = classofRaw$2;
var uncurryThis$x = functionUncurryThis;
var functionUncurryThisClause = function(fn) {
  if (classofRaw$1(fn) === "Function")
    return uncurryThis$x(fn);
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$m = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var objectGetOwnPropertyDescriptor = {};
var fails$x = fails$z;
var descriptors = !fails$x(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
});
var NATIVE_BIND$2 = functionBindNative;
var call$j = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$j.bind(call$j) : function() {
  return call$j.apply(call$j, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$a = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$a && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$a(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$1;
var createPropertyDescriptor$7 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var uncurryThis$w = functionUncurryThis;
var fails$w = fails$z;
var classof$g = classofRaw$2;
var $Object$5 = Object;
var split = uncurryThis$w("".split);
var indexedObject = fails$w(function() {
  return !$Object$5("z").propertyIsEnumerable(0);
}) ? function(it3) {
  return classof$g(it3) === "String" ? split(it3, "") : $Object$5(it3);
} : $Object$5;
var isNullOrUndefined$7 = function(it3) {
  return it3 === null || it3 === void 0;
};
var isNullOrUndefined$6 = isNullOrUndefined$7;
var $TypeError$h = TypeError;
var requireObjectCoercible$5 = function(it3) {
  if (isNullOrUndefined$6(it3))
    throw new $TypeError$h("Can't call method on " + it3);
  return it3;
};
var IndexedObject$3 = indexedObject;
var requireObjectCoercible$4 = requireObjectCoercible$5;
var toIndexedObject$a = function(it3) {
  return IndexedObject$3(requireObjectCoercible$4(it3));
};
var isCallable$l = isCallable$m;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$m = $documentAll.IS_HTMLDDA ? function(it3) {
  return typeof it3 == "object" ? it3 !== null : isCallable$l(it3) || it3 === documentAll;
} : function(it3) {
  return typeof it3 == "object" ? it3 !== null : isCallable$l(it3);
};
var path$y = {};
var path$x = path$y;
var global$r = global$s;
var isCallable$k = isCallable$m;
var aFunction = function(variable) {
  return isCallable$k(variable) ? variable : void 0;
};
var getBuiltIn$f = function(namespace2, method2) {
  return arguments.length < 2 ? aFunction(path$x[namespace2]) || aFunction(global$r[namespace2]) : path$x[namespace2] && path$x[namespace2][method2] || global$r[namespace2] && global$r[namespace2][method2];
};
var uncurryThis$v = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$v({}.isPrototypeOf);
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$q = global$s;
var userAgent$5 = engineUserAgent;
var process$3 = global$q.process;
var Deno$1 = global$q.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match2, version;
if (v8) {
  match2 = v8.split(".");
  version = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
}
if (!version && userAgent$5) {
  match2 = userAgent$5.match(/Edge\/(\d+)/);
  if (!match2 || match2[1] >= 74) {
    match2 = userAgent$5.match(/Chrome\/(\d+)/);
    if (match2)
      version = +match2[1];
  }
}
var engineV8Version = version;
var V8_VERSION$3 = engineV8Version;
var fails$v = fails$z;
var global$p = global$s;
var $String$5 = global$p.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$v(function() {
  var symbol2 = Symbol("symbol detection");
  return !$String$5(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
});
var NATIVE_SYMBOL$5 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$5 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$e = getBuiltIn$f;
var isCallable$j = isCallable$m;
var isPrototypeOf$o = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$4 = Object;
var isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function(it3) {
  return typeof it3 == "symbol";
} : function(it3) {
  var $Symbol2 = getBuiltIn$e("Symbol");
  return isCallable$j($Symbol2) && isPrototypeOf$o($Symbol2.prototype, $Object$4(it3));
};
var $String$4 = String;
var tryToString$6 = function(argument) {
  try {
    return $String$4(argument);
  } catch (error2) {
    return "Object";
  }
};
var isCallable$i = isCallable$m;
var tryToString$5 = tryToString$6;
var $TypeError$g = TypeError;
var aCallable$e = function(argument) {
  if (isCallable$i(argument))
    return argument;
  throw new $TypeError$g(tryToString$5(argument) + " is not a function");
};
var aCallable$d = aCallable$e;
var isNullOrUndefined$5 = isNullOrUndefined$7;
var getMethod$3 = function(V, P2) {
  var func = V[P2];
  return isNullOrUndefined$5(func) ? void 0 : aCallable$d(func);
};
var call$i = functionCall;
var isCallable$h = isCallable$m;
var isObject$l = isObject$m;
var $TypeError$f = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val2;
  if (pref === "string" && isCallable$h(fn = input.toString) && !isObject$l(val2 = call$i(fn, input)))
    return val2;
  if (isCallable$h(fn = input.valueOf) && !isObject$l(val2 = call$i(fn, input)))
    return val2;
  if (pref !== "string" && isCallable$h(fn = input.toString) && !isObject$l(val2 = call$i(fn, input)))
    return val2;
  throw new $TypeError$f("Can't convert object to primitive value");
};
var shared$7 = { exports: {} };
var isPure = true;
var global$o = global$s;
var defineProperty$f = Object.defineProperty;
var defineGlobalProperty$1 = function(key, value) {
  try {
    defineProperty$f(global$o, key, { value, configurable: true, writable: true });
  } catch (error2) {
    global$o[key] = value;
  }
  return value;
};
var global$n = global$s;
var defineGlobalProperty = defineGlobalProperty$1;
var SHARED = "__core-js_shared__";
var store$3 = global$n[SHARED] || defineGlobalProperty(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$7.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.33.0",
  mode: "pure",
  copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var sharedExports = shared$7.exports;
var requireObjectCoercible$3 = requireObjectCoercible$5;
var $Object$3 = Object;
var toObject$f = function(argument) {
  return $Object$3(requireObjectCoercible$3(argument));
};
var uncurryThis$u = functionUncurryThis;
var toObject$e = toObject$f;
var hasOwnProperty = uncurryThis$u({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it3, key) {
  return hasOwnProperty(toObject$e(it3), key);
};
var uncurryThis$t = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$c = uncurryThis$t(1 .toString);
var uid$4 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$c(++id$2 + postfix, 36);
};
var global$m = global$s;
var shared$6 = sharedExports;
var hasOwn$l = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$4 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$5 = global$m.Symbol;
var WellKnownSymbolsStore$2 = shared$6("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$5["for"] || Symbol$5 : Symbol$5 && Symbol$5.withoutSetter || uid$3;
var wellKnownSymbol$p = function(name2) {
  if (!hasOwn$l(WellKnownSymbolsStore$2, name2)) {
    WellKnownSymbolsStore$2[name2] = NATIVE_SYMBOL$4 && hasOwn$l(Symbol$5, name2) ? Symbol$5[name2] : createWellKnownSymbol("Symbol." + name2);
  }
  return WellKnownSymbolsStore$2[name2];
};
var call$h = functionCall;
var isObject$k = isObject$m;
var isSymbol$4 = isSymbol$5;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$o = wellKnownSymbol$p;
var $TypeError$e = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$o("toPrimitive");
var toPrimitive$6 = function(input, pref) {
  if (!isObject$k(input) || isSymbol$4(input))
    return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$h(exoticToPrim, input, pref);
    if (!isObject$k(result) || isSymbol$4(result))
      return result;
    throw new $TypeError$e("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive$5 = toPrimitive$6;
var isSymbol$3 = isSymbol$5;
var toPropertyKey$4 = function(argument) {
  var key = toPrimitive$5(argument, "string");
  return isSymbol$3(key) ? key : key + "";
};
var global$l = global$s;
var isObject$j = isObject$m;
var document$3 = global$l.document;
var EXISTS$1 = isObject$j(document$3) && isObject$j(document$3.createElement);
var documentCreateElement$1 = function(it3) {
  return EXISTS$1 ? document$3.createElement(it3) : {};
};
var DESCRIPTORS$h = descriptors;
var fails$u = fails$z;
var createElement$1 = documentCreateElement$1;
var ie8DomDefine = !DESCRIPTORS$h && !fails$u(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var DESCRIPTORS$g = descriptors;
var call$g = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$6 = createPropertyDescriptor$7;
var toIndexedObject$9 = toIndexedObject$a;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$k = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P2) {
  O = toIndexedObject$9(O);
  P2 = toPropertyKey$3(P2);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$2(O, P2);
    } catch (error2) {
    }
  if (hasOwn$k(O, P2))
    return createPropertyDescriptor$6(!call$g(propertyIsEnumerableModule$2.f, O, P2), O[P2]);
};
var fails$t = fails$z;
var isCallable$g = isCallable$m;
var replacement = /#|\.prototype\./;
var isForced$2 = function(feature, detection) {
  var value = data[normalize2(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable$g(detection) ? fails$t(detection) : !!detection;
};
var normalize2 = isForced$2.normalize = function(string2) {
  return String(string2).replace(replacement, ".").toLowerCase();
};
var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = "N";
var POLYFILL = isForced$2.POLYFILL = "P";
var isForced_1 = isForced$2;
var uncurryThis$s = functionUncurryThisClause;
var aCallable$c = aCallable$e;
var NATIVE_BIND$1 = functionBindNative;
var bind$i = uncurryThis$s(uncurryThis$s.bind);
var functionBindContext = function(fn, that) {
  aCallable$c(fn);
  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$i(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var objectDefineProperty = {};
var DESCRIPTORS$f = descriptors;
var fails$s = fails$z;
var v8PrototypeDefineBug = DESCRIPTORS$f && fails$s(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var isObject$i = isObject$m;
var $String$3 = String;
var $TypeError$d = TypeError;
var anObject$f = function(argument) {
  if (isObject$i(argument))
    return argument;
  throw new $TypeError$d($String$3(argument) + " is not an object");
};
var DESCRIPTORS$e = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$e = anObject$f;
var toPropertyKey$2 = toPropertyKey$4;
var $TypeError$c = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P2, Attributes2) {
  anObject$e(O);
  P2 = toPropertyKey$2(P2);
  anObject$e(Attributes2);
  if (typeof O === "function" && P2 === "prototype" && "value" in Attributes2 && WRITABLE in Attributes2 && !Attributes2[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P2);
    if (current && current[WRITABLE]) {
      O[P2] = Attributes2.value;
      Attributes2 = {
        configurable: CONFIGURABLE$1 in Attributes2 ? Attributes2[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes2 ? Attributes2[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty$1(O, P2, Attributes2);
} : $defineProperty$1 : function defineProperty2(O, P2, Attributes2) {
  anObject$e(O);
  P2 = toPropertyKey$2(P2);
  anObject$e(Attributes2);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty$1(O, P2, Attributes2);
    } catch (error2) {
    }
  if ("get" in Attributes2 || "set" in Attributes2)
    throw new $TypeError$c("Accessors not supported");
  if ("value" in Attributes2)
    O[P2] = Attributes2.value;
  return O;
};
var DESCRIPTORS$d = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$5 = createPropertyDescriptor$7;
var createNonEnumerableProperty$9 = DESCRIPTORS$d ? function(object2, key, value) {
  return definePropertyModule$4.f(object2, key, createPropertyDescriptor$5(1, value));
} : function(object2, key, value) {
  object2[key] = value;
  return object2;
};
var global$k = global$s;
var apply$5 = functionApply;
var uncurryThis$r = functionUncurryThisClause;
var isCallable$f = isCallable$m;
var getOwnPropertyDescriptor$9 = objectGetOwnPropertyDescriptor.f;
var isForced$1 = isForced_1;
var path$w = path$y;
var bind$h = functionBindContext;
var createNonEnumerableProperty$8 = createNonEnumerableProperty$9;
var hasOwn$j = hasOwnProperty_1;
var wrapConstructor = function(NativeConstructor) {
  var Wrapper = function(a, b, c2) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();
        case 1:
          return new NativeConstructor(a);
        case 2:
          return new NativeConstructor(a, b);
      }
      return new NativeConstructor(a, b, c2);
    }
    return apply$5(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$k : STATIC ? global$k[TARGET] : (global$k[TARGET] || {}).prototype;
  var target = GLOBAL ? path$w : path$w[TARGET] || createNonEnumerableProperty$8(path$w, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED2, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
  for (key in source) {
    FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    USE_NATIVE = !FORCED2 && nativeSource && hasOwn$j(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE)
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$9(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else
        nativeProperty = nativeSource[key];
    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)
      continue;
    if (options.bind && USE_NATIVE)
      resultProperty = bind$h(sourceProperty, global$k);
    else if (options.wrap && USE_NATIVE)
      resultProperty = wrapConstructor(sourceProperty);
    else if (PROTO && isCallable$f(sourceProperty))
      resultProperty = uncurryThis$r(sourceProperty);
    else
      resultProperty = sourceProperty;
    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$8(resultProperty, "sham", true);
    }
    createNonEnumerableProperty$8(target, key, resultProperty);
    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + "Prototype";
      if (!hasOwn$j(path$w, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty$8(path$w, VIRTUAL_PROTOTYPE, {});
      }
      createNonEnumerableProperty$8(path$w[VIRTUAL_PROTOTYPE], key, sourceProperty);
      if (options.real && targetPrototype && (FORCED2 || !targetPrototype[key])) {
        createNonEnumerableProperty$8(targetPrototype, key, sourceProperty);
      }
    }
  }
};
var ceil = Math.ceil;
var floor$1 = Math.floor;
var mathTrunc = Math.trunc || function trunc(x2) {
  var n = +x2;
  return (n > 0 ? floor$1 : ceil)(n);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$4 = function(argument) {
  var number2 = +argument;
  return number2 !== number2 || number2 === 0 ? 0 : trunc2(number2);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$2 = Math.min;
var toAbsoluteIndex$5 = function(index2, length2) {
  var integer = toIntegerOrInfinity$3(index2);
  return integer < 0 ? max$3(integer + length2, 0) : min$2(integer, length2);
};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$1 = Math.min;
var toLength$1 = function(argument) {
  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$e = function(obj) {
  return toLength(obj.length);
};
var toIndexedObject$8 = toIndexedObject$a;
var toAbsoluteIndex$4 = toAbsoluteIndex$5;
var lengthOfArrayLike$d = lengthOfArrayLike$e;
var createMethod$4 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$8($this);
    var length2 = lengthOfArrayLike$d(O);
    var index2 = toAbsoluteIndex$4(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el !== el)
      while (length2 > index2) {
        value = O[index2++];
        if (value !== value)
          return true;
      }
    else
      for (; length2 > index2; index2++) {
        if ((IS_INCLUDES || index2 in O) && O[index2] === el)
          return IS_INCLUDES || index2 || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$4(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$4(false)
};
var hiddenKeys$6 = {};
var uncurryThis$q = functionUncurryThis;
var hasOwn$i = hasOwnProperty_1;
var toIndexedObject$7 = toIndexedObject$a;
var indexOf$4 = arrayIncludes.indexOf;
var hiddenKeys$5 = hiddenKeys$6;
var push$c = uncurryThis$q([].push);
var objectKeysInternal = function(object2, names) {
  var O = toIndexedObject$7(object2);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$i(hiddenKeys$5, key) && hasOwn$i(O, key) && push$c(result, key);
  while (names.length > i)
    if (hasOwn$i(O, key = names[i++])) {
      ~indexOf$4(result, key) || push$c(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var objectKeys$3 = Object.keys || function keys(O) {
  return internalObjectKeys$1(O, enumBugKeys$2);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var DESCRIPTORS$c = descriptors;
var uncurryThis$p = functionUncurryThis;
var call$f = functionCall;
var fails$r = fails$z;
var objectKeys$2 = objectKeys$3;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var toObject$d = toObject$f;
var IndexedObject$2 = indexedObject;
var $assign = Object.assign;
var defineProperty$e = Object.defineProperty;
var concat$6 = uncurryThis$p([].concat);
var objectAssign = !$assign || fails$r(function() {
  if (DESCRIPTORS$c && $assign({ b: 1 }, $assign(defineProperty$e({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$e(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A2 = {};
  var B = {};
  var symbol2 = Symbol("assign detection");
  var alphabet = "abcdefghijklmnopqrst";
  A2[symbol2] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A2)[symbol2] !== 7 || objectKeys$2($assign({}, B)).join("") !== alphabet;
}) ? function assign(target, source) {
  var T2 = toObject$d(target);
  var argumentsLength = arguments.length;
  var index2 = 1;
  var getOwnPropertySymbols3 = getOwnPropertySymbolsModule$3.f;
  var propertyIsEnumerable3 = propertyIsEnumerableModule$1.f;
  while (argumentsLength > index2) {
    var S = IndexedObject$2(arguments[index2++]);
    var keys4 = getOwnPropertySymbols3 ? concat$6(objectKeys$2(S), getOwnPropertySymbols3(S)) : objectKeys$2(S);
    var length2 = keys4.length;
    var j2 = 0;
    var key;
    while (length2 > j2) {
      key = keys4[j2++];
      if (!DESCRIPTORS$c || call$f(propertyIsEnumerable3, S, key))
        T2[key] = S[key];
    }
  }
  return T2;
} : $assign;
var $$10 = _export;
var assign$5 = objectAssign;
$$10({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign$5 }, {
  assign: assign$5
});
var path$v = path$y;
var assign$4 = path$v.Object.assign;
var parent$1p = assign$4;
var assign$3 = parent$1p;
var assign$2 = assign$3;
var _Object$assign = /* @__PURE__ */ getDefaultExportFromCjs(assign$2);
var uncurryThis$o = functionUncurryThis;
var arraySlice$6 = uncurryThis$o([].slice);
var uncurryThis$n = functionUncurryThis;
var aCallable$b = aCallable$e;
var isObject$h = isObject$m;
var hasOwn$h = hasOwnProperty_1;
var arraySlice$5 = arraySlice$6;
var NATIVE_BIND = functionBindNative;
var $Function = Function;
var concat$5 = uncurryThis$n([].concat);
var join = uncurryThis$n([].join);
var factories = {};
var construct$4 = function(C, argsLength, args) {
  if (!hasOwn$h(factories, argsLength)) {
    var list2 = [];
    var i = 0;
    for (; i < argsLength; i++)
      list2[i] = "a[" + i + "]";
    factories[argsLength] = $Function("C,a", "return new C(" + join(list2, ",") + ")");
  }
  return factories[argsLength](C, args);
};
var functionBind = NATIVE_BIND ? $Function.bind : function bind(that) {
  var F = aCallable$b(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice$5(arguments, 1);
  var boundFunction = function bound() {
    var args = concat$5(partArgs, arraySlice$5(arguments));
    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);
  };
  if (isObject$h(Prototype))
    boundFunction.prototype = Prototype;
  return boundFunction;
};
var $$$ = _export;
var bind$g = functionBind;
$$$({ target: "Function", proto: true, forced: Function.bind !== bind$g }, {
  bind: bind$g
});
var path$u = path$y;
var entryVirtual$l = function(CONSTRUCTOR) {
  return path$u[CONSTRUCTOR + "Prototype"];
};
var entryVirtual$k = entryVirtual$l;
var bind$f = entryVirtual$k("Function").bind;
var isPrototypeOf$n = objectIsPrototypeOf;
var method$i = bind$f;
var FunctionPrototype$2 = Function.prototype;
var bind$e = function(it3) {
  var own = it3.bind;
  return it3 === FunctionPrototype$2 || isPrototypeOf$n(FunctionPrototype$2, it3) && own === FunctionPrototype$2.bind ? method$i : own;
};
var parent$1o = bind$e;
var bind$d = parent$1o;
var bind$c = bind$d;
var _bindInstanceProperty$1 = /* @__PURE__ */ getDefaultExportFromCjs(bind$c);
function drawCircle(ctx, x2, y2, r) {
  ctx.beginPath();
  ctx.arc(x2, y2, r, 0, 2 * Math.PI, false);
  ctx.closePath();
}
function drawSquare(ctx, x2, y2, r) {
  ctx.beginPath();
  ctx.rect(x2 - r, y2 - r, r * 2, r * 2);
  ctx.closePath();
}
function drawTriangle(ctx, x2, y2, r) {
  ctx.beginPath();
  r *= 1.15;
  y2 += 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s;
  var h2 = Math.sqrt(s * s - s2 * s2);
  ctx.moveTo(x2, y2 - (h2 - ir));
  ctx.lineTo(x2 + s2, y2 + ir);
  ctx.lineTo(x2 - s2, y2 + ir);
  ctx.lineTo(x2, y2 - (h2 - ir));
  ctx.closePath();
}
function drawTriangleDown(ctx, x2, y2, r) {
  ctx.beginPath();
  r *= 1.15;
  y2 -= 0.275 * r;
  var s = r * 2;
  var s2 = s / 2;
  var ir = Math.sqrt(3) / 6 * s;
  var h2 = Math.sqrt(s * s - s2 * s2);
  ctx.moveTo(x2, y2 + (h2 - ir));
  ctx.lineTo(x2 + s2, y2 - ir);
  ctx.lineTo(x2 - s2, y2 - ir);
  ctx.lineTo(x2, y2 + (h2 - ir));
  ctx.closePath();
}
function drawStar(ctx, x2, y2, r) {
  ctx.beginPath();
  r *= 0.82;
  y2 += 0.1 * r;
  for (var n = 0; n < 10; n++) {
    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
    ctx.lineTo(x2 + radius * Math.sin(n * 2 * Math.PI / 10), y2 - radius * Math.cos(n * 2 * Math.PI / 10));
  }
  ctx.closePath();
}
function drawDiamond(ctx, x2, y2, r) {
  ctx.beginPath();
  ctx.lineTo(x2, y2 + r);
  ctx.lineTo(x2 + r, y2);
  ctx.lineTo(x2, y2 - r);
  ctx.lineTo(x2 - r, y2);
  ctx.closePath();
}
function drawRoundRect(ctx, x2, y2, w, h2, r) {
  var r2d = Math.PI / 180;
  if (w - 2 * r < 0) {
    r = w / 2;
  }
  if (h2 - 2 * r < 0) {
    r = h2 / 2;
  }
  ctx.beginPath();
  ctx.moveTo(x2 + r, y2);
  ctx.lineTo(x2 + w - r, y2);
  ctx.arc(x2 + w - r, y2 + r, r, r2d * 270, r2d * 360, false);
  ctx.lineTo(x2 + w, y2 + h2 - r);
  ctx.arc(x2 + w - r, y2 + h2 - r, r, 0, r2d * 90, false);
  ctx.lineTo(x2 + r, y2 + h2);
  ctx.arc(x2 + r, y2 + h2 - r, r, r2d * 90, r2d * 180, false);
  ctx.lineTo(x2, y2 + r);
  ctx.arc(x2 + r, y2 + r, r, r2d * 180, r2d * 270, false);
  ctx.closePath();
}
function drawEllipse(ctx, x2, y2, w, h2) {
  var kappa = 0.5522848, ox = w / 2 * kappa, oy = h2 / 2 * kappa, xe = x2 + w, ye = y2 + h2, xm = x2 + w / 2, ym = y2 + h2 / 2;
  ctx.beginPath();
  ctx.moveTo(x2, ym);
  ctx.bezierCurveTo(x2, ym - oy, xm - ox, y2, xm, y2);
  ctx.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x2, ym + oy, x2, ym);
  ctx.closePath();
}
function drawDatabase(ctx, x2, y2, w, h2) {
  var f = 1 / 3;
  var wEllipse = w;
  var hEllipse = h2 * f;
  var kappa = 0.5522848, ox = wEllipse / 2 * kappa, oy = hEllipse / 2 * kappa, xe = x2 + wEllipse, ye = y2 + hEllipse, xm = x2 + wEllipse / 2, ym = y2 + hEllipse / 2, ymb = y2 + (h2 - hEllipse / 2), yeb = y2 + h2;
  ctx.beginPath();
  ctx.moveTo(xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x2, ym + oy, x2, ym);
  ctx.bezierCurveTo(x2, ym - oy, xm - ox, y2, xm, y2);
  ctx.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
  ctx.lineTo(xe, ymb);
  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
  ctx.bezierCurveTo(xm - ox, yeb, x2, ymb + oy, x2, ymb);
  ctx.lineTo(x2, ym);
}
function drawDashedLine(ctx, x2, y2, x22, y22, pattern) {
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  var patternLength = pattern.length;
  var dx = x22 - x2;
  var dy = y22 - y2;
  var slope = dy / dx;
  var distRemaining = Math.sqrt(dx * dx + dy * dy);
  var patternIndex = 0;
  var draw = true;
  var xStep = 0;
  var dashLength = +pattern[0];
  while (distRemaining >= 0.1) {
    dashLength = +pattern[patternIndex++ % patternLength];
    if (dashLength > distRemaining) {
      dashLength = distRemaining;
    }
    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
    xStep = dx < 0 ? -xStep : xStep;
    x2 += xStep;
    y2 += slope * xStep;
    if (draw === true) {
      ctx.lineTo(x2, y2);
    } else {
      ctx.moveTo(x2, y2);
    }
    distRemaining -= dashLength;
    draw = !draw;
  }
}
function drawHexagon(ctx, x2, y2, r) {
  ctx.beginPath();
  var sides = 6;
  var a = Math.PI * 2 / sides;
  ctx.moveTo(x2 + r, y2);
  for (var i = 1; i < sides; i++) {
    ctx.lineTo(x2 + r * Math.cos(a * i), y2 + r * Math.sin(a * i));
  }
  ctx.closePath();
}
var shapeMap = {
  circle: drawCircle,
  dashedLine: drawDashedLine,
  database: drawDatabase,
  diamond: drawDiamond,
  ellipse: drawEllipse,
  ellipse_vis: drawEllipse,
  hexagon: drawHexagon,
  roundRect: drawRoundRect,
  square: drawSquare,
  star: drawStar,
  triangle: drawTriangle,
  triangleDown: drawTriangleDown
};
function getShape(name2) {
  if (Object.prototype.hasOwnProperty.call(shapeMap, name2)) {
    return shapeMap[name2];
  } else {
    return function(ctx) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      CanvasRenderingContext2D.prototype[name2].call(ctx, args);
    };
  }
}
function styleInject(css2, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css_248z$6 = ".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";
styleInject(css_248z$6);
var css_248z$5 = '/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*="span"] {\n  min-height: 0;\n  width: auto;\n}\n';
styleInject(css_248z$5);
var css_248z$4 = `div.vis-color-picker {
  position: absolute;
  top: 0px;
  left: 30px;
  margin-top: -140px;
  margin-left: 30px;
  width: 310px;
  height: 444px;
  z-index: 1;
  padding: 10px;
  border-radius: 15px;
  background-color: #ffffff;
  display: none;
  box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px;
}

div.vis-color-picker div.vis-arrow {
  position: absolute;
  top: 147px;
  left: 5px;
}

div.vis-color-picker div.vis-arrow::after,
div.vis-color-picker div.vis-arrow::before {
  right: 100%;
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
}

div.vis-color-picker div.vis-arrow:after {
  border-color: rgba(255, 255, 255, 0);
  border-right-color: #ffffff;
  border-width: 30px;
  margin-top: -30px;
}

div.vis-color-picker div.vis-color {
  position: absolute;
  width: 289px;
  height: 289px;
  cursor: pointer;
}

div.vis-color-picker div.vis-brightness {
  position: absolute;
  top: 313px;
}

div.vis-color-picker div.vis-opacity {
  position: absolute;
  top: 350px;
}

div.vis-color-picker div.vis-selector {
  position: absolute;
  top: 137px;
  left: 137px;
  width: 15px;
  height: 15px;
  border-radius: 15px;
  border: 1px solid #ffffff;
  background: #4c4c4c; /* Old browsers */
  background: -moz-linear-gradient(
    top,
    #4c4c4c 0%,
    #595959 12%,
    #666666 25%,
    #474747 39%,
    #2c2c2c 50%,
    #000000 51%,
    #111111 60%,
    #2b2b2b 76%,
    #1c1c1c 91%,
    #131313 100%
  ); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #4c4c4c),
    color-stop(12%, #595959),
    color-stop(25%, #666666),
    color-stop(39%, #474747),
    color-stop(50%, #2c2c2c),
    color-stop(51%, #000000),
    color-stop(60%, #111111),
    color-stop(76%, #2b2b2b),
    color-stop(91%, #1c1c1c),
    color-stop(100%, #131313)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #4c4c4c 0%,
    #595959 12%,
    #666666 25%,
    #474747 39%,
    #2c2c2c 50%,
    #000000 51%,
    #111111 60%,
    #2b2b2b 76%,
    #1c1c1c 91%,
    #131313 100%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #4c4c4c 0%,
    #595959 12%,
    #666666 25%,
    #474747 39%,
    #2c2c2c 50%,
    #000000 51%,
    #111111 60%,
    #2b2b2b 76%,
    #1c1c1c 91%,
    #131313 100%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(
    top,
    #4c4c4c 0%,
    #595959 12%,
    #666666 25%,
    #474747 39%,
    #2c2c2c 50%,
    #000000 51%,
    #111111 60%,
    #2b2b2b 76%,
    #1c1c1c 91%,
    #131313 100%
  ); /* IE10+ */
  background: linear-gradient(
    to bottom,
    #4c4c4c 0%,
    #595959 12%,
    #666666 25%,
    #474747 39%,
    #2c2c2c 50%,
    #000000 51%,
    #111111 60%,
    #2b2b2b 76%,
    #1c1c1c 91%,
    #131313 100%
  ); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */
}

div.vis-color-picker div.vis-new-color {
  position: absolute;
  width: 140px;
  height: 20px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  top: 380px;
  left: 159px;
  text-align: right;
  padding-right: 2px;
  font-size: 10px;
  color: rgba(0, 0, 0, 0.4);
  vertical-align: middle;
  line-height: 20px;
}

div.vis-color-picker div.vis-initial-color {
  position: absolute;
  width: 140px;
  height: 20px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: 5px;
  top: 380px;
  left: 10px;
  text-align: left;
  padding-left: 2px;
  font-size: 10px;
  color: rgba(0, 0, 0, 0.4);
  vertical-align: middle;
  line-height: 20px;
}

div.vis-color-picker div.vis-label {
  position: absolute;
  width: 300px;
  left: 10px;
}

div.vis-color-picker div.vis-label.vis-brightness {
  top: 300px;
}

div.vis-color-picker div.vis-label.vis-opacity {
  top: 338px;
}

div.vis-color-picker div.vis-button {
  position: absolute;
  width: 68px;
  height: 25px;
  border-radius: 10px;
  vertical-align: middle;
  text-align: center;
  line-height: 25px;
  top: 410px;
  border: 2px solid #d9d9d9;
  background-color: #f7f7f7;
  cursor: pointer;
}

div.vis-color-picker div.vis-button.vis-cancel {
  /*border:2px solid #ff4e33;*/
  /*background-color: #ff7761;*/
  left: 5px;
}
div.vis-color-picker div.vis-button.vis-load {
  /*border:2px solid #a153e6;*/
  /*background-color: #cb8dff;*/
  left: 82px;
}
div.vis-color-picker div.vis-button.vis-apply {
  /*border:2px solid #4588e6;*/
  /*background-color: #82b6ff;*/
  left: 159px;
}
div.vis-color-picker div.vis-button.vis-save {
  /*border:2px solid #45e655;*/
  /*background-color: #6dff7c;*/
  left: 236px;
}

div.vis-color-picker input.vis-range {
  width: 290px;
  height: 20px;
}

/* TODO: is this redundant?
div.vis-color-picker input.vis-range-brightness {
  width: 289px !important;
}


div.vis-color-picker input.vis-saturation-range {
  width: 289px !important;
}*/
`;
styleInject(css_248z$4);
var css_248z$3 = `div.vis-configuration {
  position: relative;
  display: block;
  float: left;
  font-size: 12px;
}

div.vis-configuration-wrapper {
  display: block;
  width: 700px;
}

div.vis-configuration-wrapper::after {
  clear: both;
  content: "";
  display: block;
}

div.vis-configuration.vis-config-option-container {
  display: block;
  width: 495px;
  background-color: #ffffff;
  border: 2px solid #f7f8fa;
  border-radius: 4px;
  margin-top: 20px;
  left: 10px;
  padding-left: 5px;
}

div.vis-configuration.vis-config-button {
  display: block;
  width: 495px;
  height: 25px;
  vertical-align: middle;
  line-height: 25px;
  background-color: #f7f8fa;
  border: 2px solid #ceced0;
  border-radius: 4px;
  margin-top: 20px;
  left: 10px;
  padding-left: 5px;
  cursor: pointer;
  margin-bottom: 30px;
}

div.vis-configuration.vis-config-button.hover {
  background-color: #4588e6;
  border: 2px solid #214373;
  color: #ffffff;
}

div.vis-configuration.vis-config-item {
  display: block;
  float: left;
  width: 495px;
  height: 25px;
  vertical-align: middle;
  line-height: 25px;
}

div.vis-configuration.vis-config-item.vis-config-s2 {
  left: 10px;
  background-color: #f7f8fa;
  padding-left: 5px;
  border-radius: 3px;
}
div.vis-configuration.vis-config-item.vis-config-s3 {
  left: 20px;
  background-color: #e4e9f0;
  padding-left: 5px;
  border-radius: 3px;
}
div.vis-configuration.vis-config-item.vis-config-s4 {
  left: 30px;
  background-color: #cfd8e6;
  padding-left: 5px;
  border-radius: 3px;
}

div.vis-configuration.vis-config-header {
  font-size: 18px;
  font-weight: bold;
}

div.vis-configuration.vis-config-label {
  width: 120px;
  height: 25px;
  line-height: 25px;
}

div.vis-configuration.vis-config-label.vis-config-s3 {
  width: 110px;
}
div.vis-configuration.vis-config-label.vis-config-s4 {
  width: 100px;
}

div.vis-configuration.vis-config-colorBlock {
  top: 1px;
  width: 30px;
  height: 19px;
  border: 1px solid #444444;
  border-radius: 2px;
  padding: 0px;
  margin: 0px;
  cursor: pointer;
}

input.vis-configuration.vis-config-checkbox {
  left: -5px;
}

input.vis-configuration.vis-config-rangeinput {
  position: relative;
  top: -5px;
  width: 60px;
  /*height:13px;*/
  padding: 1px;
  margin: 0;
  pointer-events: none;
}

input.vis-configuration.vis-config-range {
  /*removes default webkit styles*/
  -webkit-appearance: none;

  /*fix for FF unable to apply focus style bug */
  border: 0px solid white;
  background-color: rgba(0, 0, 0, 0);

  /*required for proper track sizing in FF*/
  width: 300px;
  height: 20px;
}
input.vis-configuration.vis-config-range::-webkit-slider-runnable-track {
  width: 300px;
  height: 5px;
  background: #dedede; /* Old browsers */
  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #dedede),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

  border: 1px solid #999999;
  box-shadow: #aaaaaa 0px 0px 3px 0px;
  border-radius: 3px;
}
input.vis-configuration.vis-config-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  border: 1px solid #14334b;
  height: 17px;
  width: 17px;
  border-radius: 50%;
  background: #3876c2; /* Old browsers */
  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #3876c2),
    color-stop(100%, #385380)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #3876c2 0%,
    #385380 100%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #3876c2 0%,
    #385380 100%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */
  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */
  box-shadow: #111927 0px 0px 1px 0px;
  margin-top: -7px;
}
input.vis-configuration.vis-config-range:focus {
  outline: none;
}
input.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {
  background: #9d9d9d; /* Old browsers */
  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #9d9d9d),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #9d9d9d 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #9d9d9d 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */
}

input.vis-configuration.vis-config-range::-moz-range-track {
  width: 300px;
  height: 10px;
  background: #dedede; /* Old browsers */
  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */
  background: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, #dedede),
    color-stop(99%, #c8c8c8)
  ); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(
    top,
    #dedede 0%,
    #c8c8c8 99%
  ); /* Opera 11.10+ */
  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */
  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */

  border: 1px solid #999999;
  box-shadow: #aaaaaa 0px 0px 3px 0px;
  border-radius: 3px;
}
input.vis-configuration.vis-config-range::-moz-range-thumb {
  border: none;
  height: 16px;
  width: 16px;

  border-radius: 50%;
  background: #385380;
}

/*hide the outline behind the border*/
input.vis-configuration.vis-config-range:-moz-focusring {
  outline: 1px solid white;
  outline-offset: -1px;
}

input.vis-configuration.vis-config-range::-ms-track {
  width: 300px;
  height: 5px;

  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */
  background: transparent;

  /*leave room for the larger thumb to overflow with a transparent border */
  border-color: transparent;
  border-width: 6px 0;

  /*remove default tick marks*/
  color: transparent;
}
input.vis-configuration.vis-config-range::-ms-fill-lower {
  background: #777;
  border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-fill-upper {
  background: #ddd;
  border-radius: 10px;
}
input.vis-configuration.vis-config-range::-ms-thumb {
  border: none;
  height: 16px;
  width: 16px;
  border-radius: 50%;
  background: #385380;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-lower {
  background: #888;
}
input.vis-configuration.vis-config-range:focus::-ms-fill-upper {
  background: #ccc;
}

.vis-configuration-popup {
  position: absolute;
  background: rgba(57, 76, 89, 0.85);
  border: 2px solid #f2faff;
  line-height: 30px;
  height: 30px;
  width: 150px;
  text-align: center;
  color: #ffffff;
  font-size: 14px;
  border-radius: 4px;
  -webkit-transition: opacity 0.3s ease-in-out;
  -moz-transition: opacity 0.3s ease-in-out;
  transition: opacity 0.3s ease-in-out;
}
.vis-configuration-popup:after,
.vis-configuration-popup:before {
  left: 100%;
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none;
}

.vis-configuration-popup:after {
  border-color: rgba(136, 183, 213, 0);
  border-left-color: rgba(57, 76, 89, 0.85);
  border-width: 8px;
  margin-top: -8px;
}
.vis-configuration-popup:before {
  border-color: rgba(194, 225, 245, 0);
  border-left-color: #f2faff;
  border-width: 12px;
  margin-top: -12px;
}
`;
styleInject(css_248z$3);
var css_248z$2 = "div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";
styleInject(css_248z$2);
var componentEmitter = { exports: {} };
(function(module) {
  {
    module.exports = Emitter2;
  }
  function Emitter2(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter2.prototype) {
      obj[key] = Emitter2.prototype[key];
    }
    return obj;
  }
  Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter2.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter2.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter2.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter2.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);
var componentEmitterExports = componentEmitter.exports;
var Emitter = /* @__PURE__ */ getDefaultExportFromCjs(componentEmitterExports);
var wellKnownSymbol$n = wellKnownSymbol$p;
var TO_STRING_TAG$4 = wellKnownSymbol$n("toStringTag");
var test$2 = {};
test$2[TO_STRING_TAG$4] = "z";
var toStringTagSupport = String(test$2) === "[object z]";
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$e = isCallable$m;
var classofRaw = classofRaw$2;
var wellKnownSymbol$m = wellKnownSymbol$p;
var TO_STRING_TAG$3 = wellKnownSymbol$m("toStringTag");
var $Object$2 = Object;
var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var tryGet = function(it3, key) {
  try {
    return it3[key];
  } catch (error2) {
  }
};
var classof$f = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it3) {
  var O, tag, result;
  return it3 === void 0 ? "Undefined" : it3 === null ? "Null" : typeof (tag = tryGet(O = $Object$2(it3), TO_STRING_TAG$3)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable$e(O.callee) ? "Arguments" : result;
};
var classof$e = classof$f;
var $String$2 = String;
var toString$b = function(argument) {
  if (classof$e(argument) === "Symbol")
    throw new TypeError("Cannot convert a Symbol value to a string");
  return $String$2(argument);
};
var uncurryThis$m = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$a = toString$b;
var requireObjectCoercible$2 = requireObjectCoercible$5;
var charAt$3 = uncurryThis$m("".charAt);
var charCodeAt$1 = uncurryThis$m("".charCodeAt);
var stringSlice = uncurryThis$m("".slice);
var createMethod$3 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString$a(requireObjectCoercible$2($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first2, second;
    if (position < 0 || position >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first2 = charCodeAt$1(S, position);
    return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = charCodeAt$1(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$3(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};
var global$j = global$s;
var isCallable$d = isCallable$m;
var WeakMap$1 = global$j.WeakMap;
var weakMapBasicDetection = isCallable$d(WeakMap$1) && /native code/.test(String(WeakMap$1));
var shared$5 = sharedExports;
var uid$2 = uid$4;
var keys$7 = shared$5("keys");
var sharedKey$4 = function(key) {
  return keys$7[key] || (keys$7[key] = uid$2(key));
};
var NATIVE_WEAK_MAP$1 = weakMapBasicDetection;
var global$i = global$s;
var isObject$g = isObject$m;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$9;
var hasOwn$g = hasOwnProperty_1;
var shared$4 = sharedStore;
var sharedKey$3 = sharedKey$4;
var hiddenKeys$4 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$3 = global$i.TypeError;
var WeakMap = global$i.WeakMap;
var set$4, get$6, has;
var enforce = function(it3) {
  return has(it3) ? get$6(it3) : set$4(it3, {});
};
var getterFor = function(TYPE) {
  return function(it3) {
    var state;
    if (!isObject$g(it3) || (state = get$6(it3)).type !== TYPE) {
      throw new TypeError$3("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$4.state) {
  var store$1 = shared$4.state || (shared$4.state = new WeakMap());
  store$1.get = store$1.get;
  store$1.has = store$1.has;
  store$1.set = store$1.set;
  set$4 = function(it3, metadata) {
    if (store$1.has(it3))
      throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it3;
    store$1.set(it3, metadata);
    return metadata;
  };
  get$6 = function(it3) {
    return store$1.get(it3) || {};
  };
  has = function(it3) {
    return store$1.has(it3);
  };
} else {
  var STATE = sharedKey$3("state");
  hiddenKeys$4[STATE] = true;
  set$4 = function(it3, metadata) {
    if (hasOwn$g(it3, STATE))
      throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it3;
    createNonEnumerableProperty$7(it3, STATE, metadata);
    return metadata;
  };
  get$6 = function(it3) {
    return hasOwn$g(it3, STATE) ? it3[STATE] : {};
  };
  has = function(it3) {
    return hasOwn$g(it3, STATE);
  };
}
var internalState = {
  set: set$4,
  get: get$6,
  has,
  enforce,
  getterFor
};
var DESCRIPTORS$b = descriptors;
var hasOwn$f = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$f(FunctionPrototype$1, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var objectDefineProperties = {};
var DESCRIPTORS$a = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$d = anObject$f;
var toIndexedObject$6 = toIndexedObject$a;
var objectKeys$1 = objectKeys$3;
objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$d(O);
  var props = toIndexedObject$6(Properties);
  var keys4 = objectKeys$1(Properties);
  var length2 = keys4.length;
  var index2 = 0;
  var key;
  while (length2 > index2)
    definePropertyModule$3.f(O, key = keys4[index2++], props[key]);
  return O;
};
var getBuiltIn$d = getBuiltIn$f;
var html$2 = getBuiltIn$d("document", "documentElement");
var anObject$c = anObject$f;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$3 = hiddenKeys$6;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$2 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$1 = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$2("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$1.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error2) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length2 = enumBugKeys$1.length;
  while (length2--)
    delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length2]];
  return NullProtoObject();
};
hiddenKeys$3[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$c(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null;
    result[IE_PROTO$1] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
};
var fails$q = fails$z;
var correctPrototypeGetter = !fails$q(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$e = hasOwnProperty_1;
var isCallable$c = isCallable$m;
var toObject$c = toObject$f;
var sharedKey$1 = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO = sharedKey$1("IE_PROTO");
var $Object$1 = Object;
var ObjectPrototype$2 = $Object$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? $Object$1.getPrototypeOf : function(O) {
  var object2 = toObject$c(O);
  if (hasOwn$e(object2, IE_PROTO))
    return object2[IE_PROTO];
  var constructor = object2.constructor;
  if (isCallable$c(constructor) && object2 instanceof constructor) {
    return constructor.prototype;
  }
  return object2 instanceof $Object$1 ? ObjectPrototype$2 : null;
};
var createNonEnumerableProperty$6 = createNonEnumerableProperty$9;
var defineBuiltIn$6 = function(target, key, value, options) {
  if (options && options.enumerable)
    target[key] = value;
  else
    createNonEnumerableProperty$6(target, key, value);
  return target;
};
var fails$p = fails$z;
var isCallable$b = isCallable$m;
var isObject$f = isObject$m;
var create$b = objectCreate;
var getPrototypeOf$9 = objectGetPrototypeOf;
var defineBuiltIn$5 = defineBuiltIn$6;
var wellKnownSymbol$l = wellKnownSymbol$p;
var ITERATOR$6 = wellKnownSymbol$l("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$9(getPrototypeOf$9(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$f(IteratorPrototype$1) || fails$p(function() {
  var test3 = {};
  return IteratorPrototype$1[ITERATOR$6].call(test3) !== test3;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$1 = {};
else
  IteratorPrototype$1 = create$b(IteratorPrototype$1);
if (!isCallable$b(IteratorPrototype$1[ITERATOR$6])) {
  defineBuiltIn$5(IteratorPrototype$1, ITERATOR$6, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$d = classof$f;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return "[object " + classof$d(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$d = objectDefineProperty.f;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$9;
var hasOwn$d = hasOwnProperty_1;
var toString$9 = objectToString;
var wellKnownSymbol$k = wellKnownSymbol$p;
var TO_STRING_TAG$2 = wellKnownSymbol$k("toStringTag");
var setToStringTag$7 = function(it3, TAG, STATIC, SET_METHOD) {
  if (it3) {
    var target = STATIC ? it3 : it3.prototype;
    if (!hasOwn$d(target, TO_STRING_TAG$2)) {
      defineProperty$d(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty$5(target, "toString", toString$9);
    }
  }
};
var iterators = {};
var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$a = objectCreate;
var createPropertyDescriptor$4 = createPropertyDescriptor$7;
var setToStringTag$6 = setToStringTag$7;
var Iterators$5 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME, next3, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create$a(IteratorPrototype, { next: createPropertyDescriptor$4(+!ENUMERABLE_NEXT, next3) });
  setToStringTag$6(IteratorConstructor, TO_STRING_TAG2, false, true);
  Iterators$5[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var uncurryThis$l = functionUncurryThis;
var aCallable$a = aCallable$e;
var functionUncurryThisAccessor = function(object2, key, method2) {
  try {
    return uncurryThis$l(aCallable$a(Object.getOwnPropertyDescriptor(object2, key)[method2]));
  } catch (error2) {
  }
};
var isCallable$a = isCallable$m;
var $String$1 = String;
var $TypeError$b = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$a(argument))
    return argument;
  throw new $TypeError$b("Can't set " + $String$1(argument) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject$b = anObject$f;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test3 = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
    setter(test3, []);
    CORRECT_SETTER = test3 instanceof Array;
  } catch (error2) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject$b(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var $$_ = _export;
var call$e = functionCall;
var FunctionName = functionName;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf$8 = objectGetPrototypeOf;
var setToStringTag$5 = setToStringTag$7;
var defineBuiltIn$4 = defineBuiltIn$6;
var wellKnownSymbol$j = wellKnownSymbol$p;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$j("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME, next3);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys4() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries2() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$5] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$8(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      setToStringTag$5(CurrentIteratorPrototype, TO_STRING_TAG2, true, true);
      Iterators$4[TO_STRING_TAG2] = returnThis;
    }
  }
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$e(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn$4(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$_({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (FORCED2 && IterablePrototype[ITERATOR$5] !== defaultIterator) {
    defineBuiltIn$4(IterablePrototype, ITERATOR$5, defaultIterator, { name: DEFAULT });
  }
  Iterators$4[NAME] = defaultIterator;
  return methods;
};
var createIterResultObject$3 = function(value, done) {
  return { value, done };
};
var charAt$2 = stringMultibyte.charAt;
var toString$8 = toString$b;
var InternalStateModule$6 = internalState;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$2 = createIterResultObject$3;
var STRING_ITERATOR = "String Iterator";
var setInternalState$6 = InternalStateModule$6.set;
var getInternalState$2 = InternalStateModule$6.getterFor(STRING_ITERATOR);
defineIterator$2(String, "String", function(iterated) {
  setInternalState$6(this, {
    type: STRING_ITERATOR,
    string: toString$8(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState$2(this);
  var string2 = state.string;
  var index2 = state.index;
  var point;
  if (index2 >= string2.length)
    return createIterResultObject$2(void 0, true);
  point = charAt$2(string2, index2);
  state.index += point.length;
  return createIterResultObject$2(point, false);
});
var call$d = functionCall;
var anObject$a = anObject$f;
var getMethod$1 = getMethod$3;
var iteratorClose$2 = function(iterator2, kind, value) {
  var innerResult, innerError;
  anObject$a(iterator2);
  try {
    innerResult = getMethod$1(iterator2, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = call$d(innerResult, iterator2);
  } catch (error2) {
    innerError = true;
    innerResult = error2;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject$a(innerResult);
  return value;
};
var anObject$9 = anObject$f;
var iteratorClose$1 = iteratorClose$2;
var callWithSafeIterationClosing$1 = function(iterator2, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject$9(value)[0], value[1]) : fn(value);
  } catch (error2) {
    iteratorClose$1(iterator2, "throw", error2);
  }
};
var wellKnownSymbol$i = wellKnownSymbol$p;
var Iterators$3 = iterators;
var ITERATOR$4 = wellKnownSymbol$i("iterator");
var ArrayPrototype$j = Array.prototype;
var isArrayIteratorMethod$2 = function(it3) {
  return it3 !== void 0 && (Iterators$3.Array === it3 || ArrayPrototype$j[ITERATOR$4] === it3);
};
var uncurryThis$k = functionUncurryThis;
var isCallable$9 = isCallable$m;
var store = sharedStore;
var functionToString = uncurryThis$k(Function.toString);
if (!isCallable$9(store.inspectSource)) {
  store.inspectSource = function(it3) {
    return functionToString(it3);
  };
}
var inspectSource$2 = store.inspectSource;
var uncurryThis$j = functionUncurryThis;
var fails$o = fails$z;
var isCallable$8 = isCallable$m;
var classof$c = classof$f;
var getBuiltIn$c = getBuiltIn$f;
var inspectSource$1 = inspectSource$2;
var noop = function() {
};
var empty = [];
var construct$3 = getBuiltIn$c("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$j(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$8(argument))
    return false;
  try {
    construct$3(noop, empty, argument);
    return true;
  } catch (error2) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$8(argument))
    return false;
  switch (classof$c(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
  } catch (error2) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$4 = !construct$3 || fails$o(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$7;
var createProperty$6 = function(object2, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object2)
    definePropertyModule$2.f(object2, propertyKey, createPropertyDescriptor$3(0, value));
  else
    object2[propertyKey] = value;
};
var classof$b = classof$f;
var getMethod = getMethod$3;
var isNullOrUndefined$4 = isNullOrUndefined$7;
var Iterators$2 = iterators;
var wellKnownSymbol$h = wellKnownSymbol$p;
var ITERATOR$3 = wellKnownSymbol$h("iterator");
var getIteratorMethod$9 = function(it3) {
  if (!isNullOrUndefined$4(it3))
    return getMethod(it3, ITERATOR$3) || getMethod(it3, "@@iterator") || Iterators$2[classof$b(it3)];
};
var call$c = functionCall;
var aCallable$9 = aCallable$e;
var anObject$8 = anObject$f;
var tryToString$4 = tryToString$6;
var getIteratorMethod$8 = getIteratorMethod$9;
var $TypeError$a = TypeError;
var getIterator$8 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$8(argument) : usingIterator;
  if (aCallable$9(iteratorMethod))
    return anObject$8(call$c(iteratorMethod, argument));
  throw new $TypeError$a(tryToString$4(argument) + " is not iterable");
};
var bind$b = functionBindContext;
var call$b = functionCall;
var toObject$b = toObject$f;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$3 = isConstructor$4;
var lengthOfArrayLike$c = lengthOfArrayLike$e;
var createProperty$5 = createProperty$6;
var getIterator$7 = getIterator$8;
var getIteratorMethod$7 = getIteratorMethod$9;
var $Array$3 = Array;
var arrayFrom = function from(arrayLike) {
  var O = toObject$b(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$3(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping)
    mapfn = bind$b(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod$7(O);
  var index2 = 0;
  var length2, result, step, iterator2, next3, value;
  if (iteratorMethod && !(this === $Array$3 && isArrayIteratorMethod$1(iteratorMethod))) {
    iterator2 = getIterator$7(O, iteratorMethod);
    next3 = iterator2.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$b(next3, iterator2)).done; index2++) {
      value = mapping ? callWithSafeIterationClosing(iterator2, mapfn, [step.value, index2], true) : step.value;
      createProperty$5(result, index2, value);
    }
  } else {
    length2 = lengthOfArrayLike$c(O);
    result = IS_CONSTRUCTOR ? new this(length2) : $Array$3(length2);
    for (; length2 > index2; index2++) {
      value = mapping ? mapfn(O[index2], index2) : O[index2];
      createProperty$5(result, index2, value);
    }
  }
  result.length = index2;
  return result;
};
var wellKnownSymbol$g = wellKnownSymbol$p;
var ITERATOR$2 = wellKnownSymbol$g("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$2] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error2) {
}
var checkCorrectnessOfIteration$2 = function(exec2, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING)
      return false;
  } catch (error2) {
    return false;
  }
  var ITERATION_SUPPORT = false;
  try {
    var object2 = {};
    object2[ITERATOR$2] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object2);
  } catch (error2) {
  }
  return ITERATION_SUPPORT;
};
var $$Z = _export;
var from$6 = arrayFrom;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration$1(function(iterable) {
  Array.from(iterable);
});
$$Z({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
  from: from$6
});
var path$t = path$y;
var from$5 = path$t.Array.from;
var parent$1n = from$5;
var from$4 = parent$1n;
var from$3 = from$4;
var _Array$from$1 = /* @__PURE__ */ getDefaultExportFromCjs(from$3);
var toIndexedObject$5 = toIndexedObject$a;
var Iterators$1 = iterators;
var InternalStateModule$5 = internalState;
objectDefineProperty.f;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$1 = createIterResultObject$3;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$1 = InternalStateModule$5.getterFor(ARRAY_ITERATOR);
defineIterator$1(Array, "Array", function(iterated, kind) {
  setInternalState$5(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$5(iterated),
    // target
    index: 0,
    // next index
    kind
    // kind
  });
}, function() {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index2 = state.index++;
  if (!target || index2 >= target.length) {
    state.target = void 0;
    return createIterResultObject$1(void 0, true);
  }
  switch (kind) {
    case "keys":
      return createIterResultObject$1(index2, false);
    case "values":
      return createIterResultObject$1(target[index2], false);
  }
  return createIterResultObject$1([index2, target[index2]], false);
}, "values");
Iterators$1.Arguments = Iterators$1.Array;
var getIteratorMethod$6 = getIteratorMethod$9;
var getIteratorMethod_1 = getIteratorMethod$6;
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var DOMIterables$4 = domIterables;
var global$h = global$s;
var classof$a = classof$f;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$9;
var Iterators = iterators;
var wellKnownSymbol$f = wellKnownSymbol$p;
var TO_STRING_TAG$1 = wellKnownSymbol$f("toStringTag");
for (var COLLECTION_NAME in DOMIterables$4) {
  var Collection2 = global$h[COLLECTION_NAME];
  var CollectionPrototype = Collection2 && Collection2.prototype;
  if (CollectionPrototype && classof$a(CollectionPrototype) !== TO_STRING_TAG$1) {
    createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);
  }
  Iterators[COLLECTION_NAME] = Iterators.Array;
}
var parent$1m = getIteratorMethod_1;
var getIteratorMethod$5 = parent$1m;
var parent$1l = getIteratorMethod$5;
var getIteratorMethod$4 = parent$1l;
var parent$1k = getIteratorMethod$4;
var getIteratorMethod$3 = parent$1k;
var getIteratorMethod$2 = getIteratorMethod$3;
var _getIteratorMethod$1 = /* @__PURE__ */ getDefaultExportFromCjs(getIteratorMethod$2);
var getIteratorMethod$1 = getIteratorMethod$2;
var _getIteratorMethod = /* @__PURE__ */ getDefaultExportFromCjs(getIteratorMethod$1);
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var defineProperty$c = { exports: {} };
var $$Y = _export;
var DESCRIPTORS$9 = descriptors;
var defineProperty$b = objectDefineProperty.f;
$$Y({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty$b, sham: !DESCRIPTORS$9 }, {
  defineProperty: defineProperty$b
});
var path$s = path$y;
var Object$5 = path$s.Object;
var defineProperty$a = defineProperty$c.exports = function defineProperty3(it3, key, desc) {
  return Object$5.defineProperty(it3, key, desc);
};
if (Object$5.defineProperty.sham)
  defineProperty$a.sham = true;
var definePropertyExports = defineProperty$c.exports;
var parent$1j = definePropertyExports;
var defineProperty$9 = parent$1j;
var parent$1i = defineProperty$9;
var defineProperty$8 = parent$1i;
var parent$1h = defineProperty$8;
var defineProperty$7 = parent$1h;
var defineProperty$6 = defineProperty$7;
var _Object$defineProperty$1 = /* @__PURE__ */ getDefaultExportFromCjs(defineProperty$6);
var classof$9 = classofRaw$2;
var isArray$f = Array.isArray || function isArray(argument) {
  return classof$9(argument) === "Array";
};
var $TypeError$9 = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger$4 = function(it3) {
  if (it3 > MAX_SAFE_INTEGER)
    throw $TypeError$9("Maximum allowed index exceeded");
  return it3;
};
var isArray$e = isArray$f;
var isConstructor$2 = isConstructor$4;
var isObject$e = isObject$m;
var wellKnownSymbol$e = wellKnownSymbol$p;
var SPECIES$5 = wellKnownSymbol$e("species");
var $Array$2 = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray$e(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor$2(C) && (C === $Array$2 || isArray$e(C.prototype)))
      C = void 0;
    else if (isObject$e(C)) {
      C = C[SPECIES$5];
      if (C === null)
        C = void 0;
    }
  }
  return C === void 0 ? $Array$2 : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$4 = function(originalArray, length2) {
  return new (arraySpeciesConstructor(originalArray))(length2 === 0 ? 0 : length2);
};
var fails$n = fails$z;
var wellKnownSymbol$d = wellKnownSymbol$p;
var V8_VERSION$2 = engineV8Version;
var SPECIES$4 = wellKnownSymbol$d("species");
var arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {
  return V8_VERSION$2 >= 51 || !fails$n(function() {
    var array2 = [];
    var constructor = array2.constructor = {};
    constructor[SPECIES$4] = function() {
      return { foo: 1 };
    };
    return array2[METHOD_NAME](Boolean).foo !== 1;
  });
};
var $$X = _export;
var fails$m = fails$z;
var isArray$d = isArray$f;
var isObject$d = isObject$m;
var toObject$a = toObject$f;
var lengthOfArrayLike$b = lengthOfArrayLike$e;
var doesNotExceedSafeInteger$3 = doesNotExceedSafeInteger$4;
var createProperty$4 = createProperty$6;
var arraySpeciesCreate$3 = arraySpeciesCreate$4;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$c = wellKnownSymbol$p;
var V8_VERSION$1 = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$c("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$m(function() {
  var array2 = [];
  array2[IS_CONCAT_SPREADABLE] = false;
  return array2.concat()[0] !== array2;
});
var isConcatSpreadable = function(O) {
  if (!isObject$d(O))
    return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$d(O);
};
var FORCED$a = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$4("concat");
$$X({ target: "Array", proto: true, arity: 1, forced: FORCED$a }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$a(this);
    var A2 = arraySpeciesCreate$3(O, 0);
    var n = 0;
    var i, k, length2, len, E;
    for (i = -1, length2 = arguments.length; i < length2; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$b(E);
        doesNotExceedSafeInteger$3(n + len);
        for (k = 0; k < len; k++, n++)
          if (k in E)
            createProperty$4(A2, n, E[k]);
      } else {
        doesNotExceedSafeInteger$3(n + 1);
        createProperty$4(A2, n++, E);
      }
    }
    A2.length = n;
    return A2;
  }
});
var objectGetOwnPropertyNames = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys$2);
};
var objectGetOwnPropertyNamesExternal = {};
var toAbsoluteIndex$3 = toAbsoluteIndex$5;
var lengthOfArrayLike$a = lengthOfArrayLike$e;
var createProperty$3 = createProperty$6;
var $Array$1 = Array;
var max$2 = Math.max;
var arraySliceSimple = function(O, start2, end2) {
  var length2 = lengthOfArrayLike$a(O);
  var k = toAbsoluteIndex$3(start2, length2);
  var fin = toAbsoluteIndex$3(end2 === void 0 ? length2 : end2, length2);
  var result = $Array$1(max$2(fin - k, 0));
  var n = 0;
  for (; k < fin; k++, n++)
    createProperty$3(result, n, O[k]);
  result.length = n;
  return result;
};
var classof$8 = classofRaw$2;
var toIndexedObject$4 = toIndexedObject$a;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$4 = arraySliceSimple;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it3) {
  try {
    return $getOwnPropertyNames$1(it3);
  } catch (error2) {
    return arraySlice$4(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it3) {
  return windowNames && classof$8(it3) === "Window" ? getWindowNames(it3) : $getOwnPropertyNames$1(toIndexedObject$4(it3));
};
var defineProperty$5 = objectDefineProperty;
var defineBuiltInAccessor$3 = function(target, name2, descriptor) {
  return defineProperty$5.f(target, name2, descriptor);
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$b = wellKnownSymbol$p;
wellKnownSymbolWrapped.f = wellKnownSymbol$b;
var path$r = path$y;
var hasOwn$c = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$4 = objectDefineProperty.f;
var wellKnownSymbolDefine = function(NAME) {
  var Symbol2 = path$r.Symbol || (path$r.Symbol = {});
  if (!hasOwn$c(Symbol2, NAME))
    defineProperty$4(Symbol2, NAME, {
      value: wrappedWellKnownSymbolModule$1.f(NAME)
    });
};
var call$a = functionCall;
var getBuiltIn$b = getBuiltIn$f;
var wellKnownSymbol$a = wellKnownSymbol$p;
var defineBuiltIn$3 = defineBuiltIn$6;
var symbolDefineToPrimitive = function() {
  var Symbol2 = getBuiltIn$b("Symbol");
  var SymbolPrototype2 = Symbol2 && Symbol2.prototype;
  var valueOf = SymbolPrototype2 && SymbolPrototype2.valueOf;
  var TO_PRIMITIVE2 = wellKnownSymbol$a("toPrimitive");
  if (SymbolPrototype2 && !SymbolPrototype2[TO_PRIMITIVE2]) {
    defineBuiltIn$3(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {
      return call$a(valueOf, this);
    }, { arity: 1 });
  }
};
var bind$a = functionBindContext;
var uncurryThis$i = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$9 = toObject$f;
var lengthOfArrayLike$9 = lengthOfArrayLike$e;
var arraySpeciesCreate$2 = arraySpeciesCreate$4;
var push$b = uncurryThis$i([].push);
var createMethod$2 = function(TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject$9($this);
    var self2 = IndexedObject$1(O);
    var boundFunction = bind$a(callbackfn, that);
    var length2 = lengthOfArrayLike$9(self2);
    var index2 = 0;
    var create5 = specificCreate || arraySpeciesCreate$2;
    var target = IS_MAP ? create5($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create5($this, 0) : void 0;
    var value, result;
    for (; length2 > index2; index2++)
      if (NO_HOLES || index2 in self2) {
        value = self2[index2];
        result = boundFunction(value, index2, O);
        if (TYPE) {
          if (IS_MAP)
            target[index2] = result;
          else if (result)
            switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index2;
              case 2:
                push$b(target, value);
            }
          else
            switch (TYPE) {
              case 4:
                return false;
              case 7:
                push$b(target, value);
            }
        }
      }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$2(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$2(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$2(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$2(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$2(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$2(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$2(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$2(7)
};
var $$W = _export;
var global$g = global$s;
var call$9 = functionCall;
var uncurryThis$h = functionUncurryThis;
var DESCRIPTORS$8 = descriptors;
var NATIVE_SYMBOL$3 = symbolConstructorDetection;
var fails$l = fails$z;
var hasOwn$b = hasOwnProperty_1;
var isPrototypeOf$m = objectIsPrototypeOf;
var anObject$7 = anObject$f;
var toIndexedObject$3 = toIndexedObject$a;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$b;
var createPropertyDescriptor$2 = createPropertyDescriptor$7;
var nativeObjectCreate = objectCreate;
var objectKeys = objectKeys$3;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var defineBuiltIn$2 = defineBuiltIn$6;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$3;
var shared$3 = sharedExports;
var sharedKey = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$9 = wellKnownSymbol$p;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$l = wellKnownSymbolDefine;
var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
var setToStringTag$4 = setToStringTag$7;
var InternalStateModule$4 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE = "prototype";
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState = InternalStateModule$4.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = global$g.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError$1 = global$g.RangeError;
var TypeError$2 = global$g.TypeError;
var QObject = global$g.QObject;
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$3.f;
var nativeDefineProperty = definePropertyModule$1.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push$a = uncurryThis$h([].push);
var AllSymbols = shared$3("symbols");
var ObjectPrototypeSymbols = shared$3("op-symbols");
var WellKnownSymbolsStore$1 = shared$3("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var fallbackDefineProperty = function(O, P2, Attributes2) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P2);
  if (ObjectPrototypeDescriptor)
    delete ObjectPrototype$1[P2];
  nativeDefineProperty(O, P2, Attributes2);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
    nativeDefineProperty(ObjectPrototype$1, P2, ObjectPrototypeDescriptor);
  }
};
var setSymbolDescriptor = DESCRIPTORS$8 && fails$l(function() {
  return nativeObjectCreate(nativeDefineProperty({}, "a", {
    get: function() {
      return nativeDefineProperty(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty;
var wrap = function(tag, description) {
  var symbol2 = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState$4(symbol2, {
    type: SYMBOL,
    tag,
    description
  });
  if (!DESCRIPTORS$8)
    symbol2.description = description;
  return symbol2;
};
var $defineProperty = function defineProperty4(O, P2, Attributes2) {
  if (O === ObjectPrototype$1)
    $defineProperty(ObjectPrototypeSymbols, P2, Attributes2);
  anObject$7(O);
  var key = toPropertyKey(P2);
  anObject$7(Attributes2);
  if (hasOwn$b(AllSymbols, key)) {
    if (!Attributes2.enumerable) {
      if (!hasOwn$b(O, HIDDEN))
        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor$2(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$b(O, HIDDEN) && O[HIDDEN][key])
        O[HIDDEN][key] = false;
      Attributes2 = nativeObjectCreate(Attributes2, { enumerable: createPropertyDescriptor$2(0, false) });
    }
    return setSymbolDescriptor(O, key, Attributes2);
  }
  return nativeDefineProperty(O, key, Attributes2);
};
var $defineProperties = function defineProperties2(O, Properties) {
  anObject$7(O);
  var properties = toIndexedObject$3(Properties);
  var keys4 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys4, function(key) {
    if (!DESCRIPTORS$8 || call$9($propertyIsEnumerable, properties, key))
      $defineProperty(O, key, properties[key]);
  });
  return O;
};
var $create = function create2(O, Properties) {
  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable = function propertyIsEnumerable2(V) {
  var P2 = toPropertyKey(V);
  var enumerable = call$9(nativePropertyIsEnumerable, this, P2);
  if (this === ObjectPrototype$1 && hasOwn$b(AllSymbols, P2) && !hasOwn$b(ObjectPrototypeSymbols, P2))
    return false;
  return enumerable || !hasOwn$b(this, P2) || !hasOwn$b(AllSymbols, P2) || hasOwn$b(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P2) {
  var it3 = toIndexedObject$3(O);
  var key = toPropertyKey(P2);
  if (it3 === ObjectPrototype$1 && hasOwn$b(AllSymbols, key) && !hasOwn$b(ObjectPrototypeSymbols, key))
    return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it3, key);
  if (descriptor && hasOwn$b(AllSymbols, key) && !(hasOwn$b(it3, HIDDEN) && it3[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$3(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (!hasOwn$b(AllSymbols, key) && !hasOwn$b(hiddenKeys$1, key))
      push$a(result, key);
  });
  return result;
};
var $getOwnPropertySymbols = function(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$3(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (hasOwn$b(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$b(ObjectPrototype$1, key))) {
      push$a(result, AllSymbols[key]);
    }
  });
  return result;
};
if (!NATIVE_SYMBOL$3) {
  $Symbol = function Symbol2() {
    if (isPrototypeOf$m(SymbolPrototype, this))
      throw new TypeError$2("Symbol is not a constructor");
    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
    var tag = uid$1(description);
    var setter = function(value) {
      if (this === ObjectPrototype$1)
        call$9(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$b(this, HIDDEN) && hasOwn$b(this[HIDDEN], tag))
        this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor$2(1, value);
      try {
        setSymbolDescriptor(this, tag, descriptor);
      } catch (error2) {
        if (!(error2 instanceof RangeError$1))
          throw error2;
        fallbackDefineProperty(this, tag, descriptor);
      }
    };
    if (DESCRIPTORS$8 && USE_SETTER)
      setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };
  SymbolPrototype = $Symbol[PROTOTYPE];
  defineBuiltIn$2(SymbolPrototype, "toString", function toString3() {
    return getInternalState(this).tag;
  });
  defineBuiltIn$2($Symbol, "withoutSetter", function(description) {
    return wrap(uid$1(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule$1.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$3.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function(name2) {
    return wrap(wellKnownSymbol$9(name2), name2);
  };
  if (DESCRIPTORS$8) {
    defineBuiltInAccessor$2(SymbolPrototype, "description", {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
  }
}
$$W({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$3, sham: !NATIVE_SYMBOL$3 }, {
  Symbol: $Symbol
});
$forEach$1(objectKeys(WellKnownSymbolsStore$1), function(name2) {
  defineWellKnownSymbol$l(name2);
});
$$W({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$3 }, {
  useSetter: function() {
    USE_SETTER = true;
  },
  useSimple: function() {
    USE_SETTER = false;
  }
});
$$W({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$3, sham: !DESCRIPTORS$8 }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$W({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$3 }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});
defineSymbolToPrimitive$1();
setToStringTag$4($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var symbolRegistryDetection = NATIVE_SYMBOL$2 && !!Symbol["for"] && !!Symbol.keyFor;
var $$V = _export;
var getBuiltIn$a = getBuiltIn$f;
var hasOwn$a = hasOwnProperty_1;
var toString$7 = toString$b;
var shared$2 = sharedExports;
var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
var StringToSymbolRegistry = shared$2("string-to-symbol-registry");
var SymbolToStringRegistry$1 = shared$2("symbol-to-string-registry");
$$V({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {
  "for": function(key) {
    var string2 = toString$7(key);
    if (hasOwn$a(StringToSymbolRegistry, string2))
      return StringToSymbolRegistry[string2];
    var symbol2 = getBuiltIn$a("Symbol")(string2);
    StringToSymbolRegistry[string2] = symbol2;
    SymbolToStringRegistry$1[symbol2] = string2;
    return symbol2;
  }
});
var $$U = _export;
var hasOwn$9 = hasOwnProperty_1;
var isSymbol$2 = isSymbol$5;
var tryToString$3 = tryToString$6;
var shared$1 = sharedExports;
var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
var SymbolToStringRegistry = shared$1("symbol-to-string-registry");
$$U({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol$2(sym))
      throw new TypeError(tryToString$3(sym) + " is not a symbol");
    if (hasOwn$9(SymbolToStringRegistry, sym))
      return SymbolToStringRegistry[sym];
  }
});
var uncurryThis$g = functionUncurryThis;
var isArray$c = isArray$f;
var isCallable$7 = isCallable$m;
var classof$7 = classofRaw$2;
var toString$6 = toString$b;
var push$9 = uncurryThis$g([].push);
var getJsonReplacerFunction = function(replacer) {
  if (isCallable$7(replacer))
    return replacer;
  if (!isArray$c(replacer))
    return;
  var rawLength = replacer.length;
  var keys4 = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == "string")
      push$9(keys4, element);
    else if (typeof element == "number" || classof$7(element) === "Number" || classof$7(element) === "String")
      push$9(keys4, toString$6(element));
  }
  var keysLength = keys4.length;
  var root2 = true;
  return function(key, value) {
    if (root2) {
      root2 = false;
      return value;
    }
    if (isArray$c(this))
      return value;
    for (var j2 = 0; j2 < keysLength; j2++)
      if (keys4[j2] === key)
        return value;
  };
};
var $$T = _export;
var getBuiltIn$9 = getBuiltIn$f;
var apply$4 = functionApply;
var call$8 = functionCall;
var uncurryThis$f = functionUncurryThis;
var fails$k = fails$z;
var isCallable$6 = isCallable$m;
var isSymbol$1 = isSymbol$5;
var arraySlice$3 = arraySlice$6;
var getReplacerFunction = getJsonReplacerFunction;
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var $String = String;
var $stringify = getBuiltIn$9("JSON", "stringify");
var exec$1 = uncurryThis$f(/./.exec);
var charAt$1 = uncurryThis$f("".charAt);
var charCodeAt = uncurryThis$f("".charCodeAt);
var replace$2 = uncurryThis$f("".replace);
var numberToString = uncurryThis$f(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$1 || fails$k(function() {
  var symbol2 = getBuiltIn$9("Symbol")("stringify detection");
  return $stringify([symbol2]) !== "[null]" || $stringify({ a: symbol2 }) !== "{}" || $stringify(Object(symbol2)) !== "{}";
});
var ILL_FORMED_UNICODE = fails$k(function() {
  return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
});
var stringifyWithSymbolsFix = function(it3, replacer) {
  var args = arraySlice$3(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable$6($replacer) && (it3 === void 0 || isSymbol$1(it3)))
    return;
  args[1] = function(key, value) {
    if (isCallable$6($replacer))
      value = call$8($replacer, this, $String(key), value);
    if (!isSymbol$1(value))
      return value;
  };
  return apply$4($stringify, null, args);
};
var fixIllFormed = function(match3, offset, string2) {
  var prev2 = charAt$1(string2, offset - 1);
  var next3 = charAt$1(string2, offset + 1);
  if (exec$1(low, match3) && !exec$1(hi, next3) || exec$1(hi, match3) && !exec$1(low, prev2)) {
    return "\\u" + numberToString(charCodeAt(match3, 0), 16);
  }
  return match3;
};
if ($stringify) {
  $$T({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify3(it3, replacer, space) {
      var args = arraySlice$3(arguments);
      var result = apply$4(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == "string" ? replace$2(result, tester, fixIllFormed) : result;
    }
  });
}
var $$S = _export;
var NATIVE_SYMBOL = symbolConstructorDetection;
var fails$j = fails$z;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var toObject$8 = toObject$f;
var FORCED$9 = !NATIVE_SYMBOL || fails$j(function() {
  getOwnPropertySymbolsModule$1.f(1);
});
$$S({ target: "Object", stat: true, forced: FORCED$9 }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it3) {
    var $getOwnPropertySymbols2 = getOwnPropertySymbolsModule$1.f;
    return $getOwnPropertySymbols2 ? $getOwnPropertySymbols2(toObject$8(it3)) : [];
  }
});
var defineWellKnownSymbol$k = wellKnownSymbolDefine;
defineWellKnownSymbol$k("asyncIterator");
var defineWellKnownSymbol$j = wellKnownSymbolDefine;
defineWellKnownSymbol$j("hasInstance");
var defineWellKnownSymbol$i = wellKnownSymbolDefine;
defineWellKnownSymbol$i("isConcatSpreadable");
var defineWellKnownSymbol$h = wellKnownSymbolDefine;
defineWellKnownSymbol$h("iterator");
var defineWellKnownSymbol$g = wellKnownSymbolDefine;
defineWellKnownSymbol$g("match");
var defineWellKnownSymbol$f = wellKnownSymbolDefine;
defineWellKnownSymbol$f("matchAll");
var defineWellKnownSymbol$e = wellKnownSymbolDefine;
defineWellKnownSymbol$e("replace");
var defineWellKnownSymbol$d = wellKnownSymbolDefine;
defineWellKnownSymbol$d("search");
var defineWellKnownSymbol$c = wellKnownSymbolDefine;
defineWellKnownSymbol$c("species");
var defineWellKnownSymbol$b = wellKnownSymbolDefine;
defineWellKnownSymbol$b("split");
var defineWellKnownSymbol$a = wellKnownSymbolDefine;
var defineSymbolToPrimitive = symbolDefineToPrimitive;
defineWellKnownSymbol$a("toPrimitive");
defineSymbolToPrimitive();
var getBuiltIn$8 = getBuiltIn$f;
var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
var setToStringTag$3 = setToStringTag$7;
defineWellKnownSymbol$9("toStringTag");
setToStringTag$3(getBuiltIn$8("Symbol"), "Symbol");
var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
defineWellKnownSymbol$8("unscopables");
var global$f = global$s;
var setToStringTag$2 = setToStringTag$7;
setToStringTag$2(global$f.JSON, "JSON", true);
var path$q = path$y;
var symbol$5 = path$q.Symbol;
var parent$1g = symbol$5;
var symbol$4 = parent$1g;
var wellKnownSymbol$8 = wellKnownSymbol$p;
var defineProperty$3 = objectDefineProperty.f;
var METADATA$1 = wellKnownSymbol$8("metadata");
var FunctionPrototype = Function.prototype;
if (FunctionPrototype[METADATA$1] === void 0) {
  defineProperty$3(FunctionPrototype, METADATA$1, {
    value: null
  });
}
var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
defineWellKnownSymbol$7("asyncDispose");
var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
defineWellKnownSymbol$6("dispose");
var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
defineWellKnownSymbol$5("metadata");
var parent$1f = symbol$4;
var symbol$3 = parent$1f;
var getBuiltIn$7 = getBuiltIn$f;
var uncurryThis$e = functionUncurryThis;
var Symbol$4 = getBuiltIn$7("Symbol");
var keyFor2 = Symbol$4.keyFor;
var thisSymbolValue$1 = uncurryThis$e(Symbol$4.prototype.valueOf);
var symbolIsRegistered = Symbol$4.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor2(thisSymbolValue$1(value)) !== void 0;
  } catch (error2) {
    return false;
  }
};
var $$R = _export;
var isRegisteredSymbol$1 = symbolIsRegistered;
$$R({ target: "Symbol", stat: true }, {
  isRegisteredSymbol: isRegisteredSymbol$1
});
var shared = sharedExports;
var getBuiltIn$6 = getBuiltIn$f;
var uncurryThis$d = functionUncurryThis;
var isSymbol = isSymbol$5;
var wellKnownSymbol$7 = wellKnownSymbol$p;
var Symbol$3 = getBuiltIn$6("Symbol");
var $isWellKnownSymbol = Symbol$3.isWellKnownSymbol;
var getOwnPropertyNames$4 = getBuiltIn$6("Object", "getOwnPropertyNames");
var thisSymbolValue = uncurryThis$d(Symbol$3.prototype.valueOf);
var WellKnownSymbolsStore = shared("wks");
for (var i = 0, symbolKeys = getOwnPropertyNames$4(Symbol$3), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol$3[symbolKey]))
      wellKnownSymbol$7(symbolKey);
  } catch (error2) {
  }
}
var symbolIsWellKnown = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value))
    return true;
  try {
    var symbol2 = thisSymbolValue(value);
    for (var j2 = 0, keys4 = getOwnPropertyNames$4(WellKnownSymbolsStore), keysLength = keys4.length; j2 < keysLength; j2++) {
      if (WellKnownSymbolsStore[keys4[j2]] == symbol2)
        return true;
    }
  } catch (error2) {
  }
  return false;
};
var $$Q = _export;
var isWellKnownSymbol$1 = symbolIsWellKnown;
$$Q({ target: "Symbol", stat: true, forced: true }, {
  isWellKnownSymbol: isWellKnownSymbol$1
});
var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
defineWellKnownSymbol$4("matcher");
var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
defineWellKnownSymbol$3("observable");
var $$P = _export;
var isRegisteredSymbol2 = symbolIsRegistered;
$$P({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, {
  isRegistered: isRegisteredSymbol2
});
var $$O = _export;
var isWellKnownSymbol2 = symbolIsWellKnown;
$$O({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, {
  isWellKnown: isWellKnownSymbol2
});
var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
defineWellKnownSymbol$2("metadataKey");
var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
defineWellKnownSymbol$1("patternMatch");
var defineWellKnownSymbol = wellKnownSymbolDefine;
defineWellKnownSymbol("replaceAll");
var parent$1e = symbol$3;
var symbol$2 = parent$1e;
var symbol$1 = symbol$2;
var _Symbol$1 = /* @__PURE__ */ getDefaultExportFromCjs(symbol$1);
var WrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var iterator$5 = WrappedWellKnownSymbolModule$1.f("iterator");
var parent$1d = iterator$5;
var iterator$4 = parent$1d;
var parent$1c = iterator$4;
var iterator$3 = parent$1c;
var parent$1b = iterator$3;
var iterator$2 = parent$1b;
var iterator$1 = iterator$2;
var _Symbol$iterator$1 = /* @__PURE__ */ getDefaultExportFromCjs(iterator$1);
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof _Symbol$1 && "symbol" == typeof _Symbol$iterator$1 ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof _Symbol$1 && o2.constructor === _Symbol$1 && o2 !== _Symbol$1.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var toPrimitive$4 = WrappedWellKnownSymbolModule.f("toPrimitive");
var parent$1a = toPrimitive$4;
var toPrimitive$3 = parent$1a;
var parent$19 = toPrimitive$3;
var toPrimitive$2 = parent$19;
var parent$18 = toPrimitive$2;
var toPrimitive$1 = parent$18;
var toPrimitive = toPrimitive$1;
var _Symbol$toPrimitive = /* @__PURE__ */ getDefaultExportFromCjs(toPrimitive);
function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null)
    return input;
  var prim = input[_Symbol$toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    _Object$defineProperty$1(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  _Object$defineProperty$1(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var $$N = _export;
var isArray$b = isArray$f;
$$N({ target: "Array", stat: true }, {
  isArray: isArray$b
});
var path$p = path$y;
var isArray$a = path$p.Array.isArray;
var parent$17 = isArray$a;
var isArray$9 = parent$17;
var parent$16 = isArray$9;
var isArray$8 = parent$16;
var parent$15 = isArray$8;
var isArray$7 = parent$15;
var isArray$6 = isArray$7;
var _Array$isArray$1 = /* @__PURE__ */ getDefaultExportFromCjs(isArray$6);
function _arrayWithHoles(arr) {
  if (_Array$isArray$1(arr))
    return arr;
}
var DESCRIPTORS$7 = descriptors;
var isArray$5 = isArray$f;
var $TypeError$8 = TypeError;
var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor;
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$7 && !function() {
  if (this !== void 0)
    return true;
  try {
    Object.defineProperty([], "length", { writable: false }).length = 1;
  } catch (error2) {
    return error2 instanceof TypeError;
  }
}();
var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length2) {
  if (isArray$5(O) && !getOwnPropertyDescriptor$8(O, "length").writable) {
    throw new $TypeError$8("Cannot set read only .length");
  }
  return O.length = length2;
} : function(O, length2) {
  return O.length = length2;
};
var $$M = _export;
var toObject$7 = toObject$f;
var lengthOfArrayLike$8 = lengthOfArrayLike$e;
var setArrayLength$1 = arraySetLength;
var doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$4;
var fails$i = fails$z;
var INCORRECT_TO_LENGTH = fails$i(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
});
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).push();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED$8 = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
$$M({ target: "Array", proto: true, arity: 1, forced: FORCED$8 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject$7(this);
    var len = lengthOfArrayLike$8(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger$2(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength$1(O, len);
    return len;
  }
});
var entryVirtual$j = entryVirtual$l;
var push$8 = entryVirtual$j("Array").push;
var isPrototypeOf$l = objectIsPrototypeOf;
var method$h = push$8;
var ArrayPrototype$i = Array.prototype;
var push$7 = function(it3) {
  var own = it3.push;
  return it3 === ArrayPrototype$i || isPrototypeOf$l(ArrayPrototype$i, it3) && own === ArrayPrototype$i.push ? method$h : own;
};
var parent$14 = push$7;
var push$6 = parent$14;
var parent$13 = push$6;
var push$5 = parent$13;
var parent$12 = push$5;
var push$4 = parent$12;
var push$3 = push$4;
var _pushInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(push$3);
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof _Symbol$1 && _getIteratorMethod$1(r) || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t)).done) && (_pushInstanceProperty(a).call(a, e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}
var $$L = _export;
var isArray$4 = isArray$f;
var isConstructor$1 = isConstructor$4;
var isObject$c = isObject$m;
var toAbsoluteIndex$2 = toAbsoluteIndex$5;
var lengthOfArrayLike$7 = lengthOfArrayLike$e;
var toIndexedObject$2 = toIndexedObject$a;
var createProperty$2 = createProperty$6;
var wellKnownSymbol$6 = wellKnownSymbol$p;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var nativeSlice = arraySlice$6;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3("slice");
var SPECIES$3 = wellKnownSymbol$6("species");
var $Array = Array;
var max$1 = Math.max;
$$L({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
  slice: function slice(start2, end2) {
    var O = toIndexedObject$2(this);
    var length2 = lengthOfArrayLike$7(O);
    var k = toAbsoluteIndex$2(start2, length2);
    var fin = toAbsoluteIndex$2(end2 === void 0 ? length2 : end2, length2);
    var Constructor, result, n;
    if (isArray$4(O)) {
      Constructor = O.constructor;
      if (isConstructor$1(Constructor) && (Constructor === $Array || isArray$4(Constructor.prototype))) {
        Constructor = void 0;
      } else if (isObject$c(Constructor)) {
        Constructor = Constructor[SPECIES$3];
        if (Constructor === null)
          Constructor = void 0;
      }
      if (Constructor === $Array || Constructor === void 0) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === void 0 ? $Array : Constructor)(max$1(fin - k, 0));
    for (n = 0; k < fin; k++, n++)
      if (k in O)
        createProperty$2(result, n, O[k]);
    result.length = n;
    return result;
  }
});
var entryVirtual$i = entryVirtual$l;
var slice$6 = entryVirtual$i("Array").slice;
var isPrototypeOf$k = objectIsPrototypeOf;
var method$g = slice$6;
var ArrayPrototype$h = Array.prototype;
var slice$5 = function(it3) {
  var own = it3.slice;
  return it3 === ArrayPrototype$h || isPrototypeOf$k(ArrayPrototype$h, it3) && own === ArrayPrototype$h.slice ? method$g : own;
};
var parent$11 = slice$5;
var slice$4 = parent$11;
var parent$10 = slice$4;
var slice$3 = parent$10;
var parent$$ = slice$3;
var slice$2 = parent$$;
var slice$1 = slice$2;
var _sliceInstanceProperty$1 = /* @__PURE__ */ getDefaultExportFromCjs(slice$1);
var parent$_ = from$4;
var from$2 = parent$_;
var parent$Z = from$2;
var from$1 = parent$Z;
var from2 = from$1;
var _Array$from = /* @__PURE__ */ getDefaultExportFromCjs(from2);
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray$8(o, minLen) {
  var _context;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$8(o, minLen);
  var n = _sliceInstanceProperty$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$8(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest();
}
function _arrayWithoutHoles(arr) {
  if (_Array$isArray$1(arr))
    return _arrayLikeToArray$8(arr);
}
function _iterableToArray(iter) {
  if (typeof _Symbol$1 !== "undefined" && _getIteratorMethod$1(iter) != null || iter["@@iterator"] != null)
    return _Array$from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread();
}
var symbol = symbol$4;
var _Symbol = /* @__PURE__ */ getDefaultExportFromCjs(symbol);
var entryVirtual$h = entryVirtual$l;
var concat$4 = entryVirtual$h("Array").concat;
var isPrototypeOf$j = objectIsPrototypeOf;
var method$f = concat$4;
var ArrayPrototype$g = Array.prototype;
var concat$3 = function(it3) {
  var own = it3.concat;
  return it3 === ArrayPrototype$g || isPrototypeOf$j(ArrayPrototype$g, it3) && own === ArrayPrototype$g.concat ? method$f : own;
};
var parent$Y = concat$3;
var concat$2 = parent$Y;
var concat$1 = concat$2;
var _concatInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(concat$1);
var slice2 = slice$4;
var _sliceInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(slice2);
var getBuiltIn$5 = getBuiltIn$f;
var uncurryThis$c = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$6 = anObject$f;
var concat2 = uncurryThis$c([].concat);
var ownKeys$b = getBuiltIn$5("Reflect", "ownKeys") || function ownKeys(it3) {
  var keys4 = getOwnPropertyNamesModule$1.f(anObject$6(it3));
  var getOwnPropertySymbols3 = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols3 ? concat2(keys4, getOwnPropertySymbols3(it3)) : keys4;
};
var $$K = _export;
var ownKeys$a = ownKeys$b;
$$K({ target: "Reflect", stat: true }, {
  ownKeys: ownKeys$a
});
var path$o = path$y;
var ownKeys$9 = path$o.Reflect.ownKeys;
var parent$X = ownKeys$9;
var ownKeys$8 = parent$X;
var ownKeys$7 = ownKeys$8;
var _Reflect$ownKeys = /* @__PURE__ */ getDefaultExportFromCjs(ownKeys$7);
var isArray$3 = isArray$9;
var _Array$isArray = /* @__PURE__ */ getDefaultExportFromCjs(isArray$3);
var $$J = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2("map");
$$J({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
  map: function map(callbackfn) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$g = entryVirtual$l;
var map$6 = entryVirtual$g("Array").map;
var isPrototypeOf$i = objectIsPrototypeOf;
var method$e = map$6;
var ArrayPrototype$f = Array.prototype;
var map$5 = function(it3) {
  var own = it3.map;
  return it3 === ArrayPrototype$f || isPrototypeOf$i(ArrayPrototype$f, it3) && own === ArrayPrototype$f.map ? method$e : own;
};
var parent$W = map$5;
var map$4 = parent$W;
var map$3 = map$4;
var _mapInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(map$3);
var $$I = _export;
var toObject$6 = toObject$f;
var nativeKeys = objectKeys$3;
var fails$h = fails$z;
var FAILS_ON_PRIMITIVES$3 = fails$h(function() {
  nativeKeys(1);
});
$$I({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$3 }, {
  keys: function keys2(it3) {
    return nativeKeys(toObject$6(it3));
  }
});
var path$n = path$y;
var keys$6 = path$n.Object.keys;
var parent$V = keys$6;
var keys$5 = parent$V;
var keys$4 = keys$5;
var _Object$keys = /* @__PURE__ */ getDefaultExportFromCjs(keys$4);
var $$H = _export;
var uncurryThis$b = functionUncurryThis;
var $Date = Date;
var thisTimeValue = uncurryThis$b($Date.prototype.getTime);
$$H({ target: "Date", stat: true }, {
  now: function now() {
    return thisTimeValue(new $Date());
  }
});
var path$m = path$y;
var now$3 = path$m.Date.now;
var parent$U = now$3;
var now$2 = parent$U;
var now$1 = now$2;
var _Date$now = /* @__PURE__ */ getDefaultExportFromCjs(now$1);
var fails$g = fails$z;
var arrayMethodIsStrict$6 = function(METHOD_NAME, argument) {
  var method2 = [][METHOD_NAME];
  return !!method2 && fails$g(function() {
    method2.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$5 = arrayMethodIsStrict$6;
var STRICT_METHOD$3 = arrayMethodIsStrict$5("forEach");
var arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var $$G = _export;
var forEach$9 = arrayForEach;
$$G({ target: "Array", proto: true, forced: [].forEach !== forEach$9 }, {
  forEach: forEach$9
});
var entryVirtual$f = entryVirtual$l;
var forEach$8 = entryVirtual$f("Array").forEach;
var parent$T = forEach$8;
var forEach$7 = parent$T;
var classof$6 = classof$f;
var hasOwn$8 = hasOwnProperty_1;
var isPrototypeOf$h = objectIsPrototypeOf;
var method$d = forEach$7;
var ArrayPrototype$e = Array.prototype;
var DOMIterables$3 = {
  DOMTokenList: true,
  NodeList: true
};
var forEach$6 = function(it3) {
  var own = it3.forEach;
  return it3 === ArrayPrototype$e || isPrototypeOf$h(ArrayPrototype$e, it3) && own === ArrayPrototype$e.forEach || hasOwn$8(DOMIterables$3, classof$6(it3)) ? method$d : own;
};
var forEach$5 = forEach$6;
var _forEachInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(forEach$5);
var $$F = _export;
var uncurryThis$a = functionUncurryThis;
var isArray$2 = isArray$f;
var nativeReverse = uncurryThis$a([].reverse);
var test$1 = [1, 2];
$$F({ target: "Array", proto: true, forced: String(test$1) === String(test$1.reverse()) }, {
  reverse: function reverse() {
    if (isArray$2(this))
      this.length = this.length;
    return nativeReverse(this);
  }
});
var entryVirtual$e = entryVirtual$l;
var reverse$6 = entryVirtual$e("Array").reverse;
var isPrototypeOf$g = objectIsPrototypeOf;
var method$c = reverse$6;
var ArrayPrototype$d = Array.prototype;
var reverse$5 = function(it3) {
  var own = it3.reverse;
  return it3 === ArrayPrototype$d || isPrototypeOf$g(ArrayPrototype$d, it3) && own === ArrayPrototype$d.reverse ? method$c : own;
};
var parent$S = reverse$5;
var reverse$4 = parent$S;
var reverse$3 = reverse$4;
var _reverseInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(reverse$3);
var tryToString$2 = tryToString$6;
var $TypeError$7 = TypeError;
var deletePropertyOrThrow$2 = function(O, P2) {
  if (!delete O[P2])
    throw new $TypeError$7("Cannot delete property " + tryToString$2(P2) + " of " + tryToString$2(O));
};
var $$E = _export;
var toObject$5 = toObject$f;
var toAbsoluteIndex$1 = toAbsoluteIndex$5;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$e;
var setArrayLength = arraySetLength;
var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$4;
var arraySpeciesCreate$1 = arraySpeciesCreate$4;
var createProperty$1 = createProperty$6;
var deletePropertyOrThrow$1 = deletePropertyOrThrow$2;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1("splice");
var max = Math.max;
var min = Math.min;
$$E({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
  splice: function splice(start2, deleteCount) {
    var O = toObject$5(this);
    var len = lengthOfArrayLike$6(O);
    var actualStart = toAbsoluteIndex$1(start2, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A2, k, from3, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger$1(len + insertCount - actualDeleteCount);
    A2 = arraySpeciesCreate$1(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from3 = actualStart + k;
      if (from3 in O)
        createProperty$1(A2, k, O[from3]);
    }
    A2.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from3 = k + actualDeleteCount;
        to = k + insertCount;
        if (from3 in O)
          O[to] = O[from3];
        else
          deletePropertyOrThrow$1(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--)
        deletePropertyOrThrow$1(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from3 = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from3 in O)
          O[to] = O[from3];
        else
          deletePropertyOrThrow$1(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    setArrayLength(O, len - actualDeleteCount + insertCount);
    return A2;
  }
});
var entryVirtual$d = entryVirtual$l;
var splice$4 = entryVirtual$d("Array").splice;
var isPrototypeOf$f = objectIsPrototypeOf;
var method$b = splice$4;
var ArrayPrototype$c = Array.prototype;
var splice$3 = function(it3) {
  var own = it3.splice;
  return it3 === ArrayPrototype$c || isPrototypeOf$f(ArrayPrototype$c, it3) && own === ArrayPrototype$c.splice ? method$b : own;
};
var parent$R = splice$3;
var splice$2 = parent$R;
var splice$1 = splice$2;
var _spliceInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(splice$1);
var $$D = _export;
var $includes = arrayIncludes.includes;
var fails$f = fails$z;
var BROKEN_ON_SPARSE = fails$f(function() {
  return !Array(1).includes();
});
$$D({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$c = entryVirtual$l;
var includes$4 = entryVirtual$c("Array").includes;
var isObject$b = isObject$m;
var classof$5 = classofRaw$2;
var wellKnownSymbol$5 = wellKnownSymbol$p;
var MATCH$1 = wellKnownSymbol$5("match");
var isRegexp = function(it3) {
  var isRegExp2;
  return isObject$b(it3) && ((isRegExp2 = it3[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$5(it3) === "RegExp");
};
var isRegExp = isRegexp;
var $TypeError$6 = TypeError;
var notARegexp = function(it3) {
  if (isRegExp(it3)) {
    throw new $TypeError$6("The method doesn't accept regular expressions");
  }
  return it3;
};
var wellKnownSymbol$4 = wellKnownSymbol$p;
var MATCH = wellKnownSymbol$4("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$C = _export;
var uncurryThis$9 = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$5;
var toString$5 = toString$b;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$9("".indexOf);
$$C({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf(
      toString$5(requireObjectCoercible$1(this)),
      toString$5(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var entryVirtual$b = entryVirtual$l;
var includes$3 = entryVirtual$b("String").includes;
var isPrototypeOf$e = objectIsPrototypeOf;
var arrayMethod = includes$4;
var stringMethod = includes$3;
var ArrayPrototype$b = Array.prototype;
var StringPrototype = String.prototype;
var includes$2 = function(it3) {
  var own = it3.includes;
  if (it3 === ArrayPrototype$b || isPrototypeOf$e(ArrayPrototype$b, it3) && own === ArrayPrototype$b.includes)
    return arrayMethod;
  if (typeof it3 == "string" || it3 === StringPrototype || isPrototypeOf$e(StringPrototype, it3) && own === StringPrototype.includes) {
    return stringMethod;
  }
  return own;
};
var parent$Q = includes$2;
var includes$1 = parent$Q;
var includes3 = includes$1;
var _includesInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(includes3);
var $$B = _export;
var fails$e = fails$z;
var toObject$4 = toObject$f;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$2 = fails$e(function() {
  nativeGetPrototypeOf(1);
});
$$B({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$2, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it3) {
    return nativeGetPrototypeOf(toObject$4(it3));
  }
});
var path$l = path$y;
var getPrototypeOf$7 = path$l.Object.getPrototypeOf;
var parent$P = getPrototypeOf$7;
var getPrototypeOf$6 = parent$P;
var getPrototypeOf$5 = getPrototypeOf$6;
var _Object$getPrototypeOf$1 = /* @__PURE__ */ getDefaultExportFromCjs(getPrototypeOf$5);
var $$A = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
$$A({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$a = entryVirtual$l;
var filter$3 = entryVirtual$a("Array").filter;
var isPrototypeOf$d = objectIsPrototypeOf;
var method$a = filter$3;
var ArrayPrototype$a = Array.prototype;
var filter$2 = function(it3) {
  var own = it3.filter;
  return it3 === ArrayPrototype$a || isPrototypeOf$d(ArrayPrototype$a, it3) && own === ArrayPrototype$a.filter ? method$a : own;
};
var parent$O = filter$2;
var filter$1 = parent$O;
var filter2 = filter$1;
var _filterInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(filter2);
var whitespaces$3 = "	\n\v\f\r                　\u2028\u2029\uFEFF";
var uncurryThis$8 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$5;
var toString$4 = toString$b;
var whitespaces$2 = whitespaces$3;
var replace$1 = uncurryThis$8("".replace);
var ltrim = RegExp("^[" + whitespaces$2 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$2 + "])[" + whitespaces$2 + "]+$");
var createMethod$1 = function(TYPE) {
  return function($this) {
    var string2 = toString$4(requireObjectCoercible($this));
    if (TYPE & 1)
      string2 = replace$1(string2, ltrim, "");
    if (TYPE & 2)
      string2 = replace$1(string2, rtrim, "$1");
    return string2;
  };
};
var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};
var global$e = global$s;
var fails$d = fails$z;
var uncurryThis$7 = functionUncurryThis;
var toString$3 = toString$b;
var trim$1 = stringTrim.trim;
var whitespaces$1 = whitespaces$3;
var $parseInt$1 = global$e.parseInt;
var Symbol$2 = global$e.Symbol;
var ITERATOR$1 = Symbol$2 && Symbol$2.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis$7(hex.exec);
var FORCED$7 = $parseInt$1(whitespaces$1 + "08") !== 8 || $parseInt$1(whitespaces$1 + "0x16") !== 22 || ITERATOR$1 && !fails$d(function() {
  $parseInt$1(Object(ITERATOR$1));
});
var numberParseInt = FORCED$7 ? function parseInt2(string2, radix) {
  var S = trim$1(toString$3(string2));
  return $parseInt$1(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
} : $parseInt$1;
var $$z = _export;
var $parseInt = numberParseInt;
$$z({ global: true, forced: parseInt !== $parseInt }, {
  parseInt: $parseInt
});
var path$k = path$y;
var _parseInt$3 = path$k.parseInt;
var parent$N = _parseInt$3;
var _parseInt$2 = parent$N;
var _parseInt = _parseInt$2;
var _parseInt$1 = /* @__PURE__ */ getDefaultExportFromCjs(_parseInt);
var $$y = _export;
var uncurryThis$6 = functionUncurryThisClause;
var $indexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$6;
var nativeIndexOf = uncurryThis$6([].indexOf);
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED$6 = NEGATIVE_ZERO || !arrayMethodIsStrict$4("indexOf");
$$y({ target: "Array", proto: true, forced: FORCED$6 }, {
  indexOf: function indexOf(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
  }
});
var entryVirtual$9 = entryVirtual$l;
var indexOf$3 = entryVirtual$9("Array").indexOf;
var isPrototypeOf$c = objectIsPrototypeOf;
var method$9 = indexOf$3;
var ArrayPrototype$9 = Array.prototype;
var indexOf$2 = function(it3) {
  var own = it3.indexOf;
  return it3 === ArrayPrototype$9 || isPrototypeOf$c(ArrayPrototype$9, it3) && own === ArrayPrototype$9.indexOf ? method$9 : own;
};
var parent$M = indexOf$2;
var indexOf$1 = parent$M;
var indexOf2 = indexOf$1;
var _indexOfInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(indexOf2);
var $$x = _export;
var DESCRIPTORS$6 = descriptors;
var create$9 = objectCreate;
$$x({ target: "Object", stat: true, sham: !DESCRIPTORS$6 }, {
  create: create$9
});
var path$j = path$y;
var Object$4 = path$j.Object;
var create$8 = function create3(P2, D) {
  return Object$4.create(P2, D);
};
var parent$L = create$8;
var create$7 = parent$L;
var create$6 = create$7;
var _Object$create$1 = /* @__PURE__ */ getDefaultExportFromCjs(create$6);
var path$i = path$y;
var apply$3 = functionApply;
if (!path$i.JSON)
  path$i.JSON = { stringify: JSON.stringify };
var stringify$2 = function stringify(it3, replacer, space) {
  return apply$3(path$i.JSON.stringify, null, arguments);
};
var parent$K = stringify$2;
var stringify$1 = parent$K;
var stringify2 = stringify$1;
var _JSON$stringify = /* @__PURE__ */ getDefaultExportFromCjs(stringify2);
var engineIsBun = typeof Bun == "function" && Bun && typeof Bun.version == "string";
var $TypeError$5 = TypeError;
var validateArgumentsLength$2 = function(passed, required) {
  if (passed < required)
    throw new $TypeError$5("Not enough arguments");
  return passed;
};
var global$d = global$s;
var apply$2 = functionApply;
var isCallable$5 = isCallable$m;
var ENGINE_IS_BUN = engineIsBun;
var USER_AGENT = engineUserAgent;
var arraySlice$2 = arraySlice$6;
var validateArgumentsLength$1 = validateArgumentsLength$2;
var Function$2 = global$d.Function;
var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && function() {
  var version2 = global$d.Bun.version.split(".");
  return version2.length < 3 || version2[0] === "0" && (version2[1] < 3 || version2[1] === "3" && version2[2] === "0");
}();
var schedulersFix$2 = function(scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function(handler, timeout2) {
    var boundArgs = validateArgumentsLength$1(arguments.length, 1) > firstParamIndex;
    var fn = isCallable$5(handler) ? handler : Function$2(handler);
    var params = boundArgs ? arraySlice$2(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function() {
      apply$2(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout2) : scheduler(callback);
  } : scheduler;
};
var $$w = _export;
var global$c = global$s;
var schedulersFix$1 = schedulersFix$2;
var setInterval$2 = schedulersFix$1(global$c.setInterval, true);
$$w({ global: true, bind: true, forced: global$c.setInterval !== setInterval$2 }, {
  setInterval: setInterval$2
});
var $$v = _export;
var global$b = global$s;
var schedulersFix = schedulersFix$2;
var setTimeout$3 = schedulersFix(global$b.setTimeout, true);
$$v({ global: true, bind: true, forced: global$b.setTimeout !== setTimeout$3 }, {
  setTimeout: setTimeout$3
});
var path$h = path$y;
var setTimeout$2 = path$h.setTimeout;
var setTimeout$1 = setTimeout$2;
var _setTimeout = /* @__PURE__ */ getDefaultExportFromCjs(setTimeout$1);
var toObject$3 = toObject$f;
var toAbsoluteIndex = toAbsoluteIndex$5;
var lengthOfArrayLike$5 = lengthOfArrayLike$e;
var arrayFill = function fill(value) {
  var O = toObject$3(this);
  var length2 = lengthOfArrayLike$5(O);
  var argumentsLength = arguments.length;
  var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length2);
  var end2 = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end2 === void 0 ? length2 : toAbsoluteIndex(end2, length2);
  while (endPos > index2)
    O[index2++] = value;
  return O;
};
var $$u = _export;
var fill$4 = arrayFill;
$$u({ target: "Array", proto: true }, {
  fill: fill$4
});
var entryVirtual$8 = entryVirtual$l;
var fill$3 = entryVirtual$8("Array").fill;
var isPrototypeOf$b = objectIsPrototypeOf;
var method$8 = fill$3;
var ArrayPrototype$8 = Array.prototype;
var fill$2 = function(it3) {
  var own = it3.fill;
  return it3 === ArrayPrototype$8 || isPrototypeOf$b(ArrayPrototype$8, it3) && own === ArrayPrototype$8.fill ? method$8 : own;
};
var parent$J = fill$2;
var fill$1 = parent$J;
var fill2 = fill$1;
var _fillInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(fill2);
/*! Hammer.JS - v2.0.17-rc - 2019-12-16
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var assign2;
if (typeof Object.assign !== "function") {
  assign2 = function assign3(target) {
    if (target === void 0 || target === null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    var output = Object(target);
    for (var index2 = 1; index2 < arguments.length; index2++) {
      var source = arguments[index2];
      if (source !== void 0 && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }
    return output;
  };
} else {
  assign2 = Object.assign;
}
var assign$1 = assign2;
var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
var TEST_ELEMENT = typeof document === "undefined" ? {
  style: {}
} : document.createElement("div");
var TYPE_FUNCTION = "function";
var round = Math.round, abs$1 = Math.abs;
var now2 = Date.now;
function prefixed(obj, property) {
  var prefix;
  var prop2;
  var camelProp = property[0].toUpperCase() + property.slice(1);
  var i = 0;
  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop2 = prefix ? prefix + camelProp : property;
    if (prop2 in obj) {
      return prop2;
    }
    i++;
  }
  return void 0;
}
var win;
if (typeof window === "undefined") {
  win = {};
} else {
  win = window;
}
var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== void 0;
function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }
  var touchMap = {};
  var cssSupports = win.CSS && win.CSS.supports;
  ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val2) {
    return touchMap[val2] = cssSupports ? win.CSS.supports("touch-action", val2) : true;
  });
  return touchMap;
}
var TOUCH_ACTION_COMPUTE = "compute";
var TOUCH_ACTION_AUTO = "auto";
var TOUCH_ACTION_MANIPULATION = "manipulation";
var TOUCH_ACTION_NONE = "none";
var TOUCH_ACTION_PAN_X = "pan-x";
var TOUCH_ACTION_PAN_Y = "pan-y";
var TOUCH_ACTION_MAP = getTouchActionProps();
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = "ontouchstart" in win;
var SUPPORT_POINTER_EVENTS = prefixed(win, "PointerEvent") !== void 0;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = "touch";
var INPUT_TYPE_PEN = "pen";
var INPUT_TYPE_MOUSE = "mouse";
var INPUT_TYPE_KINECT = "kinect";
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ["x", "y"];
var PROPS_CLIENT_XY = ["clientX", "clientY"];
function each(obj, iterator2, context) {
  var i;
  if (!obj) {
    return;
  }
  if (obj.forEach) {
    obj.forEach(iterator2, context);
  } else if (obj.length !== void 0) {
    i = 0;
    while (i < obj.length) {
      iterator2.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator2.call(context, obj[i], i, obj);
    }
  }
}
function boolOrFn(val2, args) {
  if (typeof val2 === TYPE_FUNCTION) {
    return val2.apply(args ? args[0] || void 0 : void 0, args);
  }
  return val2;
}
function inStr(str, find2) {
  return str.indexOf(find2) > -1;
}
function cleanTouchActions(actions) {
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }
  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }
  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }
  return TOUCH_ACTION_AUTO;
}
var TouchAction = /* @__PURE__ */ function() {
  function TouchAction2(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  var _proto = TouchAction2.prototype;
  _proto.set = function set3(value) {
    if (value === TOUCH_ACTION_COMPUTE) {
      value = this.compute();
    }
    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
    }
    this.actions = value.toLowerCase().trim();
  };
  _proto.update = function update2() {
    this.set(this.manager.options.touchAction);
  };
  _proto.compute = function compute() {
    var actions = [];
    each(this.manager.recognizers, function(recognizer) {
      if (boolOrFn(recognizer.options.enable, [recognizer])) {
        actions = actions.concat(recognizer.getTouchAction());
      }
    });
    return cleanTouchActions(actions.join(" "));
  };
  _proto.preventDefaults = function preventDefaults(input) {
    var srcEvent = input.srcEvent;
    var direction = input.offsetDirection;
    if (this.manager.session.prevented) {
      srcEvent.preventDefault();
      return;
    }
    var actions = this.actions;
    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
    if (hasNone) {
      var isTapPointer = input.pointers.length === 1;
      var isTapMovement = input.distance < 2;
      var isTapTouchTime = input.deltaTime < 250;
      if (isTapPointer && isTapMovement && isTapTouchTime) {
        return;
      }
    }
    if (hasPanX && hasPanY) {
      return;
    }
    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
      return this.preventSrc(srcEvent);
    }
  };
  _proto.preventSrc = function preventSrc(srcEvent) {
    this.manager.session.prevented = true;
    srcEvent.preventDefault();
  };
  return TouchAction2;
}();
function hasParent(node2, parent2) {
  while (node2) {
    if (node2 === parent2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
function getCenter(pointers) {
  var pointersLength = pointers.length;
  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }
  var x2 = 0;
  var y2 = 0;
  var i = 0;
  while (i < pointersLength) {
    x2 += pointers[i].clientX;
    y2 += pointers[i].clientY;
    i++;
  }
  return {
    x: round(x2 / pointersLength),
    y: round(y2 / pointersLength)
  };
}
function simpleCloneInputData(input) {
  var pointers = [];
  var i = 0;
  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }
  return {
    timeStamp: now2(),
    pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}
function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x2 = p2[props[0]] - p1[props[0]];
  var y2 = p2[props[1]] - p1[props[1]];
  return Math.sqrt(x2 * x2 + y2 * y2);
}
function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x2 = p2[props[0]] - p1[props[0]];
  var y2 = p2[props[1]] - p1[props[1]];
  return Math.atan2(y2, x2) * 180 / Math.PI;
}
function getDirection(x2, y2) {
  if (x2 === y2) {
    return DIRECTION_NONE;
  }
  if (abs$1(x2) >= abs$1(y2)) {
    return x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }
  return y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}
function computeDeltaXY(session, input) {
  var center = input.center;
  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};
  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };
    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }
  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}
function getVelocity(deltaTime, x2, y2) {
  return {
    x: x2 / deltaTime || 0,
    y: y2 / deltaTime || 0
  };
}
function getScale(start2, end2) {
  return getDistance(end2[0], end2[1], PROPS_CLIENT_XY) / getDistance(start2[0], start2[1], PROPS_CLIENT_XY);
}
function getRotation(start2, end2) {
  return getAngle(end2[1], end2[0], PROPS_CLIENT_XY) + getAngle(start2[1], start2[0], PROPS_CLIENT_XY);
}
function computeIntervalInputData(session, input) {
  var last2 = session.lastInterval || input;
  var deltaTime = input.timeStamp - last2.timeStamp;
  var velocity;
  var velocityX;
  var velocityY;
  var direction;
  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last2.velocity === void 0)) {
    var deltaX = input.deltaX - last2.deltaX;
    var deltaY = input.deltaY - last2.deltaY;
    var v2 = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v2.x;
    velocityY = v2.y;
    velocity = abs$1(v2.x) > abs$1(v2.y) ? v2.x : v2.y;
    direction = getDirection(deltaX, deltaY);
    session.lastInterval = input;
  } else {
    velocity = last2.velocity;
    velocityX = last2.velocityX;
    velocityY = last2.velocityY;
    direction = last2.direction;
  }
  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}
function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length;
  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }
  var firstInput = session.firstInput, firstMultiple = session.firstMultiple;
  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
  var center = input.center = getCenter(pointers);
  input.timeStamp = now2();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;
  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);
  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);
  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
  computeIntervalInputData(session, input);
  var target = manager.element;
  var srcEvent = input.srcEvent;
  var srcEventTarget;
  if (srcEvent.composedPath) {
    srcEventTarget = srcEvent.composedPath()[0];
  } else if (srcEvent.path) {
    srcEventTarget = srcEvent.path[0];
  } else {
    srcEventTarget = srcEvent.target;
  }
  if (hasParent(srcEventTarget, target)) {
    target = srcEventTarget;
  }
  input.target = target;
}
function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;
  if (isFirst) {
    manager.session = {};
  }
  input.eventType = eventType;
  computeInputData(manager, input);
  manager.emit("hammer.input", input);
  manager.recognize(input);
  manager.session.prevInput = input;
}
function splitStr(str) {
  return str.trim().split(/\s+/g);
}
function addEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.addEventListener(type, handler, false);
  });
}
function removeEventListeners(target, types, handler) {
  each(splitStr(types), function(type) {
    target.removeEventListener(type, handler, false);
  });
}
function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}
var Input = /* @__PURE__ */ function() {
  function Input2(manager, callback) {
    var self2 = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;
    this.domHandler = function(ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self2.handler(ev);
      }
    };
    this.init();
  }
  var _proto = Input2.prototype;
  _proto.handler = function handler() {
  };
  _proto.init = function init2() {
    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  _proto.destroy = function destroy() {
    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
  };
  return Input2;
}();
function inArray(src, find2, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find2);
  } else {
    var i = 0;
    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {
        return i;
      }
      i++;
    }
    return -1;
  }
}
var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
};
var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT
  // see https://twitter.com/jacobrossi/status/480596438489890816
};
var POINTER_ELEMENT_EVENTS = "pointerdown";
var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
if (win.MSPointerEvent && !win.PointerEvent) {
  POINTER_ELEMENT_EVENTS = "MSPointerDown";
  POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
}
var PointerEventInput = /* @__PURE__ */ function(_Input) {
  _inheritsLoose(PointerEventInput2, _Input);
  function PointerEventInput2() {
    var _this;
    var proto = PointerEventInput2.prototype;
    proto.evEl = POINTER_ELEMENT_EVENTS;
    proto.evWin = POINTER_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }
  var _proto = PointerEventInput2.prototype;
  _proto.handler = function handler(ev) {
    var store2 = this.store;
    var removePointer = false;
    var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
    var isTouch = pointerType === INPUT_TYPE_TOUCH;
    var storeIndex = inArray(store2, ev.pointerId, "pointerId");
    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
      if (storeIndex < 0) {
        store2.push(ev);
        storeIndex = store2.length - 1;
      }
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      removePointer = true;
    }
    if (storeIndex < 0) {
      return;
    }
    store2[storeIndex] = ev;
    this.callback(this.manager, eventType, {
      pointers: store2,
      changedPointers: [ev],
      pointerType,
      srcEvent: ev
    });
    if (removePointer) {
      store2.splice(storeIndex, 1);
    }
  };
  return PointerEventInput2;
}(Input);
function toArray(obj) {
  return Array.prototype.slice.call(obj, 0);
}
function uniqueArray(src, key, sort3) {
  var results = [];
  var values2 = [];
  var i = 0;
  while (i < src.length) {
    var val2 = key ? src[i][key] : src[i];
    if (inArray(values2, val2) < 0) {
      results.push(src[i]);
    }
    values2[i] = val2;
    i++;
  }
  if (sort3) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function(a, b) {
        return a[key] > b[key];
      });
    }
  }
  return results;
}
var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
var TouchInput = /* @__PURE__ */ function(_Input) {
  _inheritsLoose(TouchInput2, _Input);
  function TouchInput2() {
    var _this;
    TouchInput2.prototype.evTarget = TOUCH_TARGET_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.targetIds = {};
    return _this;
  }
  var _proto = TouchInput2.prototype;
  _proto.handler = function handler(ev) {
    var type = TOUCH_INPUT_MAP[ev.type];
    var touches = getTouches.call(this, ev, type);
    if (!touches) {
      return;
    }
    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };
  return TouchInput2;
}(Input);
function getTouches(ev, type) {
  var allTouches = toArray(ev.touches);
  var targetIds = this.targetIds;
  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }
  var i;
  var targetTouches;
  var changedTouches = toArray(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target;
  targetTouches = allTouches.filter(function(touch) {
    return hasParent(touch.target, target);
  });
  if (type === INPUT_START) {
    i = 0;
    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  }
  i = 0;
  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    }
    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }
    i++;
  }
  if (!changedTargetTouches.length) {
    return;
  }
  return [
    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
    changedTargetTouches
  ];
}
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = "mousedown";
var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
var MouseInput = /* @__PURE__ */ function(_Input) {
  _inheritsLoose(MouseInput2, _Input);
  function MouseInput2() {
    var _this;
    var proto = MouseInput2.prototype;
    proto.evEl = MOUSE_ELEMENT_EVENTS;
    proto.evWin = MOUSE_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.pressed = false;
    return _this;
  }
  var _proto = MouseInput2.prototype;
  _proto.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button === 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which !== 1) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: INPUT_TYPE_MOUSE,
      srcEvent: ev
    });
  };
  return MouseInput2;
}(Input);
var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;
function setLastTouch(eventData) {
  var _eventData$changedPoi = eventData.changedPointers, touch = _eventData$changedPoi[0];
  if (touch.identifier === this.primaryTouch) {
    var lastTouch = {
      x: touch.clientX,
      y: touch.clientY
    };
    var lts = this.lastTouches;
    this.lastTouches.push(lastTouch);
    var removeLastTouch = function removeLastTouch2() {
      var i = lts.indexOf(lastTouch);
      if (i > -1) {
        lts.splice(i, 1);
      }
    };
    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
  }
}
function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}
function isSyntheticEvent(eventData) {
  var x2 = eventData.srcEvent.clientX;
  var y2 = eventData.srcEvent.clientY;
  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x2 - t.x);
    var dy = Math.abs(y2 - t.y);
    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }
  return false;
}
var TouchMouseInput = /* @__PURE__ */ function() {
  var TouchMouseInput2 = /* @__PURE__ */ function(_Input) {
    _inheritsLoose(TouchMouseInput3, _Input);
    function TouchMouseInput3(_manager, callback) {
      var _this;
      _this = _Input.call(this, _manager, callback) || this;
      _this.handler = function(manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;
        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        }
        if (isTouch) {
          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {
          return;
        }
        _this.callback(manager, inputEvent, inputData);
      };
      _this.touch = new TouchInput(_this.manager, _this.handler);
      _this.mouse = new MouseInput(_this.manager, _this.handler);
      _this.primaryTouch = null;
      _this.lastTouches = [];
      return _this;
    }
    var _proto = TouchMouseInput3.prototype;
    _proto.destroy = function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    };
    return TouchMouseInput3;
  }(Input);
  return TouchMouseInput2;
}();
function createInputInstance(manager) {
  var Type;
  var inputClass = manager.options.inputClass;
  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }
  return new Type(manager, inputHandler);
}
function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }
  return false;
}
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
var _uniqueId = 1;
function uniqueId() {
  return _uniqueId++;
}
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;
  if (manager) {
    return manager.get(otherRecognizer);
  }
  return otherRecognizer;
}
function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return "cancel";
  } else if (state & STATE_ENDED) {
    return "end";
  } else if (state & STATE_CHANGED) {
    return "move";
  } else if (state & STATE_BEGAN) {
    return "start";
  }
  return "";
}
var Recognizer = /* @__PURE__ */ function() {
  function Recognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = _extends({
      enable: true
    }, options);
    this.id = uniqueId();
    this.manager = null;
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  var _proto = Recognizer2.prototype;
  _proto.set = function set3(options) {
    assign$1(this.options, options);
    this.manager && this.manager.touchAction.update();
    return this;
  };
  _proto.recognizeWith = function recognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
      return this;
    }
    var simultaneous = this.simultaneous;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    if (!simultaneous[otherRecognizer.id]) {
      simultaneous[otherRecognizer.id] = otherRecognizer;
      otherRecognizer.recognizeWith(this);
    }
    return this;
  };
  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
      return this;
    }
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    delete this.simultaneous[otherRecognizer.id];
    return this;
  };
  _proto.requireFailure = function requireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
      return this;
    }
    var requireFail = this.requireFail;
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    if (inArray(requireFail, otherRecognizer) === -1) {
      requireFail.push(otherRecognizer);
      otherRecognizer.requireFailure(this);
    }
    return this;
  };
  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
    if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
      return this;
    }
    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
    var index2 = inArray(this.requireFail, otherRecognizer);
    if (index2 > -1) {
      this.requireFail.splice(index2, 1);
    }
    return this;
  };
  _proto.hasRequireFailures = function hasRequireFailures() {
    return this.requireFail.length > 0;
  };
  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
    return !!this.simultaneous[otherRecognizer.id];
  };
  _proto.emit = function emit(input) {
    var self2 = this;
    var state = this.state;
    function emit2(event) {
      self2.manager.emit(event, input);
    }
    if (state < STATE_ENDED) {
      emit2(self2.options.event + stateStr(state));
    }
    emit2(self2.options.event);
    if (input.additionalEvent) {
      emit2(input.additionalEvent);
    }
    if (state >= STATE_ENDED) {
      emit2(self2.options.event + stateStr(state));
    }
  };
  _proto.tryEmit = function tryEmit(input) {
    if (this.canEmit()) {
      return this.emit(input);
    }
    this.state = STATE_FAILED;
  };
  _proto.canEmit = function canEmit() {
    var i = 0;
    while (i < this.requireFail.length) {
      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
        return false;
      }
      i++;
    }
    return true;
  };
  _proto.recognize = function recognize(inputData) {
    var inputDataClone = assign$1({}, inputData);
    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
      this.reset();
      this.state = STATE_FAILED;
      return;
    }
    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
      this.state = STATE_POSSIBLE;
    }
    this.state = this.process(inputDataClone);
    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
      this.tryEmit(inputDataClone);
    }
  };
  _proto.process = function process2(inputData) {
  };
  _proto.getTouchAction = function getTouchAction() {
  };
  _proto.reset = function reset() {
  };
  return Recognizer2;
}();
var TapRecognizer = /* @__PURE__ */ function(_Recognizer) {
  _inheritsLoose(TapRecognizer2, _Recognizer);
  function TapRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Recognizer.call(this, _extends({
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10
    }, options)) || this;
    _this.pTime = false;
    _this.pCenter = false;
    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }
  var _proto = TapRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_MANIPULATION];
  };
  _proto.process = function process2(input) {
    var _this2 = this;
    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTouchTime = input.deltaTime < options.time;
    this.reset();
    if (input.eventType & INPUT_START && this.count === 0) {
      return this.failTimeout();
    }
    if (validMovement && validTouchTime && validPointers) {
      if (input.eventType !== INPUT_END) {
        return this.failTimeout();
      }
      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
      this.pTime = input.timeStamp;
      this.pCenter = input.center;
      if (!validMultiTap || !validInterval) {
        this.count = 1;
      } else {
        this.count += 1;
      }
      this._input = input;
      var tapCount = this.count % options.taps;
      if (tapCount === 0) {
        if (!this.hasRequireFailures()) {
          return STATE_RECOGNIZED;
        } else {
          this._timer = setTimeout(function() {
            _this2.state = STATE_RECOGNIZED;
            _this2.tryEmit();
          }, options.interval);
          return STATE_BEGAN;
        }
      }
    }
    return STATE_FAILED;
  };
  _proto.failTimeout = function failTimeout() {
    var _this3 = this;
    this._timer = setTimeout(function() {
      _this3.state = STATE_FAILED;
    }, this.options.interval);
    return STATE_FAILED;
  };
  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };
  _proto.emit = function emit() {
    if (this.state === STATE_RECOGNIZED) {
      this._input.tapCount = this.count;
      this.manager.emit(this.options.event, this._input);
    }
  };
  return TapRecognizer2;
}(Recognizer);
var AttrRecognizer = /* @__PURE__ */ function(_Recognizer) {
  _inheritsLoose(AttrRecognizer2, _Recognizer);
  function AttrRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _Recognizer.call(this, _extends({
      pointers: 1
    }, options)) || this;
  }
  var _proto = AttrRecognizer2.prototype;
  _proto.attrTest = function attrTest(input) {
    var optionPointers = this.options.pointers;
    return optionPointers === 0 || input.pointers.length === optionPointers;
  };
  _proto.process = function process2(input) {
    var state = this.state;
    var eventType = input.eventType;
    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
    var isValid = this.attrTest(input);
    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
      return state | STATE_CANCELLED;
    } else if (isRecognized || isValid) {
      if (eventType & INPUT_END) {
        return state | STATE_ENDED;
      } else if (!(state & STATE_BEGAN)) {
        return STATE_BEGAN;
      }
      return state | STATE_CHANGED;
    }
    return STATE_FAILED;
  };
  return AttrRecognizer2;
}(Recognizer);
function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return "down";
  } else if (direction === DIRECTION_UP) {
    return "up";
  } else if (direction === DIRECTION_LEFT) {
    return "left";
  } else if (direction === DIRECTION_RIGHT) {
    return "right";
  }
  return "";
}
var PanRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {
  _inheritsLoose(PanRecognizer2, _AttrRecognizer);
  function PanRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _AttrRecognizer.call(this, _extends({
      event: "pan",
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    }, options)) || this;
    _this.pX = null;
    _this.pY = null;
    return _this;
  }
  var _proto = PanRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    var direction = this.options.direction;
    var actions = [];
    if (direction & DIRECTION_HORIZONTAL) {
      actions.push(TOUCH_ACTION_PAN_Y);
    }
    if (direction & DIRECTION_VERTICAL) {
      actions.push(TOUCH_ACTION_PAN_X);
    }
    return actions;
  };
  _proto.directionTest = function directionTest(input) {
    var options = this.options;
    var hasMoved = true;
    var distance = input.distance;
    var direction = input.direction;
    var x2 = input.deltaX;
    var y2 = input.deltaY;
    if (!(direction & options.direction)) {
      if (options.direction & DIRECTION_HORIZONTAL) {
        direction = x2 === 0 ? DIRECTION_NONE : x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        hasMoved = x2 !== this.pX;
        distance = Math.abs(input.deltaX);
      } else {
        direction = y2 === 0 ? DIRECTION_NONE : y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        hasMoved = y2 !== this.pY;
        distance = Math.abs(input.deltaY);
      }
    }
    input.direction = direction;
    return hasMoved && distance > options.threshold && direction & options.direction;
  };
  _proto.attrTest = function attrTest(input) {
    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call
    (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
  };
  _proto.emit = function emit(input) {
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    var direction = directionStr(input.direction);
    if (direction) {
      input.additionalEvent = this.options.event + direction;
    }
    _AttrRecognizer.prototype.emit.call(this, input);
  };
  return PanRecognizer2;
}(AttrRecognizer);
var SwipeRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {
  _inheritsLoose(SwipeRecognizer2, _AttrRecognizer);
  function SwipeRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "swipe",
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    }, options)) || this;
  }
  var _proto = SwipeRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return PanRecognizer.prototype.getTouchAction.call(this);
  };
  _proto.attrTest = function attrTest(input) {
    var direction = this.options.direction;
    var velocity;
    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
      velocity = input.overallVelocity;
    } else if (direction & DIRECTION_HORIZONTAL) {
      velocity = input.overallVelocityX;
    } else if (direction & DIRECTION_VERTICAL) {
      velocity = input.overallVelocityY;
    }
    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;
  };
  _proto.emit = function emit(input) {
    var direction = directionStr(input.offsetDirection);
    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }
    this.manager.emit(this.options.event, input);
  };
  return SwipeRecognizer2;
}(AttrRecognizer);
var PinchRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {
  _inheritsLoose(PinchRecognizer2, _AttrRecognizer);
  function PinchRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "pinch",
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }
  var _proto = PinchRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };
  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
  };
  _proto.emit = function emit(input) {
    if (input.scale !== 1) {
      var inOut = input.scale < 1 ? "in" : "out";
      input.additionalEvent = this.options.event + inOut;
    }
    _AttrRecognizer.prototype.emit.call(this, input);
  };
  return PinchRecognizer2;
}(AttrRecognizer);
var RotateRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {
  _inheritsLoose(RotateRecognizer2, _AttrRecognizer);
  function RotateRecognizer2(options) {
    if (options === void 0) {
      options = {};
    }
    return _AttrRecognizer.call(this, _extends({
      event: "rotate",
      threshold: 0,
      pointers: 2
    }, options)) || this;
  }
  var _proto = RotateRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_NONE];
  };
  _proto.attrTest = function attrTest(input) {
    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
  };
  return RotateRecognizer2;
}(AttrRecognizer);
var PressRecognizer = /* @__PURE__ */ function(_Recognizer) {
  _inheritsLoose(PressRecognizer2, _Recognizer);
  function PressRecognizer2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Recognizer.call(this, _extends({
      event: "press",
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9
    }, options)) || this;
    _this._timer = null;
    _this._input = null;
    return _this;
  }
  var _proto = PressRecognizer2.prototype;
  _proto.getTouchAction = function getTouchAction() {
    return [TOUCH_ACTION_AUTO];
  };
  _proto.process = function process2(input) {
    var _this2 = this;
    var options = this.options;
    var validPointers = input.pointers.length === options.pointers;
    var validMovement = input.distance < options.threshold;
    var validTime = input.deltaTime > options.time;
    this._input = input;
    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
      this.reset();
    } else if (input.eventType & INPUT_START) {
      this.reset();
      this._timer = setTimeout(function() {
        _this2.state = STATE_RECOGNIZED;
        _this2.tryEmit();
      }, options.time);
    } else if (input.eventType & INPUT_END) {
      return STATE_RECOGNIZED;
    }
    return STATE_FAILED;
  };
  _proto.reset = function reset() {
    clearTimeout(this._timer);
  };
  _proto.emit = function emit(input) {
    if (this.state !== STATE_RECOGNIZED) {
      return;
    }
    if (input && input.eventType & INPUT_END) {
      this.manager.emit(this.options.event + "up", input);
    } else {
      this._input.timeStamp = now2();
      this.manager.emit(this.options.event, this._input);
    }
  };
  return PressRecognizer2;
}(Recognizer);
var defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,
  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,
  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,
  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,
  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,
  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: "none",
    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: "none",
    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: "none",
    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: "none",
    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: "none",
    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
var preset = [[RotateRecognizer, {
  enable: false
}], [PinchRecognizer, {
  enable: false
}, ["rotate"]], [SwipeRecognizer, {
  direction: DIRECTION_HORIZONTAL
}], [PanRecognizer, {
  direction: DIRECTION_HORIZONTAL
}, ["swipe"]], [TapRecognizer], [TapRecognizer, {
  event: "doubletap",
  taps: 2
}, ["tap"]], [PressRecognizer]];
var STOP = 1;
var FORCED_STOP = 2;
function toggleCssProps(manager, add3) {
  var element = manager.element;
  if (!element.style) {
    return;
  }
  var prop2;
  each(manager.options.cssProps, function(value, name2) {
    prop2 = prefixed(element.style, name2);
    if (add3) {
      manager.oldCssProps[prop2] = element.style[prop2];
      element.style[prop2] = value;
    } else {
      element.style[prop2] = manager.oldCssProps[prop2] || "";
    }
  });
  if (!add3) {
    manager.oldCssProps = {};
  }
}
function triggerDomEvent(event, data2) {
  var gestureEvent = document.createEvent("Event");
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data2;
  data2.target.dispatchEvent(gestureEvent);
}
var Manager = /* @__PURE__ */ function() {
  function Manager2(element, options) {
    var _this = this;
    this.options = assign$1({}, defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function(item) {
      var recognizer = _this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  var _proto = Manager2.prototype;
  _proto.set = function set3(options) {
    assign$1(this.options, options);
    if (options.touchAction) {
      this.touchAction.update();
    }
    if (options.inputTarget) {
      this.input.destroy();
      this.input.target = options.inputTarget;
      this.input.init();
    }
    return this;
  };
  _proto.stop = function stop(force) {
    this.session.stopped = force ? FORCED_STOP : STOP;
  };
  _proto.recognize = function recognize(inputData) {
    var session = this.session;
    if (session.stopped) {
      return;
    }
    this.touchAction.preventDefaults(inputData);
    var recognizer;
    var recognizers = this.recognizers;
    var curRecognizer = session.curRecognizer;
    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
      session.curRecognizer = null;
      curRecognizer = null;
    }
    var i = 0;
    while (i < recognizers.length) {
      recognizer = recognizers[i];
      if (session.stopped !== FORCED_STOP && // 1
      (!curRecognizer || recognizer === curRecognizer || // 2
      recognizer.canRecognizeWith(curRecognizer))) {
        recognizer.recognize(inputData);
      } else {
        recognizer.reset();
      }
      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
        session.curRecognizer = recognizer;
        curRecognizer = recognizer;
      }
      i++;
    }
  };
  _proto.get = function get2(recognizer) {
    if (recognizer instanceof Recognizer) {
      return recognizer;
    }
    var recognizers = this.recognizers;
    for (var i = 0; i < recognizers.length; i++) {
      if (recognizers[i].options.event === recognizer) {
        return recognizers[i];
      }
    }
    return null;
  };
  _proto.add = function add3(recognizer) {
    if (invokeArrayArg(recognizer, "add", this)) {
      return this;
    }
    var existing = this.get(recognizer.options.event);
    if (existing) {
      this.remove(existing);
    }
    this.recognizers.push(recognizer);
    recognizer.manager = this;
    this.touchAction.update();
    return recognizer;
  };
  _proto.remove = function remove2(recognizer) {
    if (invokeArrayArg(recognizer, "remove", this)) {
      return this;
    }
    var targetRecognizer = this.get(recognizer);
    if (recognizer) {
      var recognizers = this.recognizers;
      var index2 = inArray(recognizers, targetRecognizer);
      if (index2 !== -1) {
        recognizers.splice(index2, 1);
        this.touchAction.update();
      }
    }
    return this;
  };
  _proto.on = function on(events, handler) {
    if (events === void 0 || handler === void 0) {
      return this;
    }
    var handlers = this.handlers;
    each(splitStr(events), function(event) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    });
    return this;
  };
  _proto.off = function off(events, handler) {
    if (events === void 0) {
      return this;
    }
    var handlers = this.handlers;
    each(splitStr(events), function(event) {
      if (!handler) {
        delete handlers[event];
      } else {
        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
      }
    });
    return this;
  };
  _proto.emit = function emit(event, data2) {
    if (this.options.domEvents) {
      triggerDomEvent(event, data2);
    }
    var handlers = this.handlers[event] && this.handlers[event].slice();
    if (!handlers || !handlers.length) {
      return;
    }
    data2.type = event;
    data2.preventDefault = function() {
      data2.srcEvent.preventDefault();
    };
    var i = 0;
    while (i < handlers.length) {
      handlers[i](data2);
      i++;
    }
  };
  _proto.destroy = function destroy() {
    this.element && toggleCssProps(this, false);
    this.handlers = {};
    this.session = {};
    this.input.destroy();
    this.element = null;
  };
  return Manager2;
}();
var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
var SingleTouchInput = /* @__PURE__ */ function(_Input) {
  _inheritsLoose(SingleTouchInput2, _Input);
  function SingleTouchInput2() {
    var _this;
    var proto = SingleTouchInput2.prototype;
    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this = _Input.apply(this, arguments) || this;
    _this.started = false;
    return _this;
  }
  var _proto = SingleTouchInput2.prototype;
  _proto.handler = function handler(ev) {
    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
    if (type === INPUT_START) {
      this.started = true;
    }
    if (!this.started) {
      return;
    }
    var touches = normalizeSingleTouches.call(this, ev, type);
    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
      this.started = false;
    }
    this.callback(this.manager, type, {
      pointers: touches[0],
      changedPointers: touches[1],
      pointerType: INPUT_TYPE_TOUCH,
      srcEvent: ev
    });
  };
  return SingleTouchInput2;
}(Input);
function normalizeSingleTouches(ev, type) {
  var all2 = toArray(ev.touches);
  var changed = toArray(ev.changedTouches);
  if (type & (INPUT_END | INPUT_CANCEL)) {
    all2 = uniqueArray(all2.concat(changed), "identifier", true);
  }
  return [all2, changed];
}
function deprecate(method2, name2, message) {
  var deprecationMessage = "DEPRECATED METHOD: " + name2 + "\n" + message + " AT \n";
  return function() {
    var e = new Error("get-stack-trace");
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
    var log = window.console && (window.console.warn || window.console.log);
    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }
    return method2.apply(this, arguments);
  };
}
var extend = deprecate(function(dest, src, merge2) {
  var keys4 = Object.keys(src);
  var i = 0;
  while (i < keys4.length) {
    if (!merge2 || merge2 && dest[keys4[i]] === void 0) {
      dest[keys4[i]] = src[keys4[i]];
    }
    i++;
  }
  return dest;
}, "extend", "Use `assign`.");
var merge$2 = deprecate(function(dest, src) {
  return extend(dest, src, true);
}, "merge", "Use `assign`.");
function inherit(child, base2, properties) {
  var baseP = base2.prototype;
  var childP;
  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;
  if (properties) {
    assign$1(childP, properties);
  }
}
function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}
var Hammer$2 = /* @__PURE__ */ function() {
  var Hammer2 = (
    /**
      * @private
      * @const {string}
      */
    function Hammer3(element, options) {
      if (options === void 0) {
        options = {};
      }
      return new Manager(element, _extends({
        recognizers: preset.concat()
      }, options));
    }
  );
  Hammer2.VERSION = "2.0.17-rc";
  Hammer2.DIRECTION_ALL = DIRECTION_ALL;
  Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer2.DIRECTION_LEFT = DIRECTION_LEFT;
  Hammer2.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Hammer2.DIRECTION_UP = DIRECTION_UP;
  Hammer2.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Hammer2.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Hammer2.DIRECTION_NONE = DIRECTION_NONE;
  Hammer2.DIRECTION_DOWN = DIRECTION_DOWN;
  Hammer2.INPUT_START = INPUT_START;
  Hammer2.INPUT_MOVE = INPUT_MOVE;
  Hammer2.INPUT_END = INPUT_END;
  Hammer2.INPUT_CANCEL = INPUT_CANCEL;
  Hammer2.STATE_POSSIBLE = STATE_POSSIBLE;
  Hammer2.STATE_BEGAN = STATE_BEGAN;
  Hammer2.STATE_CHANGED = STATE_CHANGED;
  Hammer2.STATE_ENDED = STATE_ENDED;
  Hammer2.STATE_RECOGNIZED = STATE_RECOGNIZED;
  Hammer2.STATE_CANCELLED = STATE_CANCELLED;
  Hammer2.STATE_FAILED = STATE_FAILED;
  Hammer2.Manager = Manager;
  Hammer2.Input = Input;
  Hammer2.TouchAction = TouchAction;
  Hammer2.TouchInput = TouchInput;
  Hammer2.MouseInput = MouseInput;
  Hammer2.PointerEventInput = PointerEventInput;
  Hammer2.TouchMouseInput = TouchMouseInput;
  Hammer2.SingleTouchInput = SingleTouchInput;
  Hammer2.Recognizer = Recognizer;
  Hammer2.AttrRecognizer = AttrRecognizer;
  Hammer2.Tap = TapRecognizer;
  Hammer2.Pan = PanRecognizer;
  Hammer2.Swipe = SwipeRecognizer;
  Hammer2.Pinch = PinchRecognizer;
  Hammer2.Rotate = RotateRecognizer;
  Hammer2.Press = PressRecognizer;
  Hammer2.on = addEventListeners;
  Hammer2.off = removeEventListeners;
  Hammer2.each = each;
  Hammer2.merge = merge$2;
  Hammer2.extend = extend;
  Hammer2.bindFn = bindFn;
  Hammer2.assign = assign$1;
  Hammer2.inherit = inherit;
  Hammer2.bindFn = bindFn;
  Hammer2.prefixed = prefixed;
  Hammer2.toArray = toArray;
  Hammer2.inArray = inArray;
  Hammer2.uniqueArray = uniqueArray;
  Hammer2.splitStr = splitStr;
  Hammer2.boolOrFn = boolOrFn;
  Hammer2.hasParent = hasParent;
  Hammer2.addEventListeners = addEventListeners;
  Hammer2.removeEventListeners = removeEventListeners;
  Hammer2.defaults = assign$1({}, defaults, {
    preset
  });
  return Hammer2;
}();
Hammer$2.defaults;
var RealHammer = Hammer$2;
function _createForOfIteratorHelper$7(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$7(o, minLen) {
  var _context17;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$7(o, minLen);
  var n = _sliceInstanceProperty(_context17 = Object.prototype.toString.call(o)).call(_context17, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var DELETE = _Symbol("DELETE");
function pureDeepObjectAssign(base2) {
  var _context;
  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    updates[_key - 1] = arguments[_key];
  }
  return deepObjectAssign.apply(void 0, _concatInstanceProperty(_context = [{}, base2]).call(_context, updates));
}
function deepObjectAssign() {
  var merged = deepObjectAssignNonentry.apply(void 0, arguments);
  stripDelete(merged);
  return merged;
}
function deepObjectAssignNonentry() {
  for (var _len2 = arguments.length, values2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    values2[_key2] = arguments[_key2];
  }
  if (values2.length < 2) {
    return values2[0];
  } else if (values2.length > 2) {
    var _context2;
    return deepObjectAssignNonentry.apply(void 0, _concatInstanceProperty(_context2 = [deepObjectAssign(values2[0], values2[1])]).call(_context2, _toConsumableArray(_sliceInstanceProperty(values2).call(values2, 2))));
  }
  var a = values2[0];
  var b = values2[1];
  if (a instanceof Date && b instanceof Date) {
    a.setTime(b.getTime());
    return a;
  }
  var _iterator = _createForOfIteratorHelper$7(_Reflect$ownKeys(b)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var prop2 = _step.value;
      if (!Object.prototype.propertyIsEnumerable.call(b, prop2))
        ;
      else if (b[prop2] === DELETE) {
        delete a[prop2];
      } else if (a[prop2] !== null && b[prop2] !== null && _typeof$1(a[prop2]) === "object" && _typeof$1(b[prop2]) === "object" && !_Array$isArray(a[prop2]) && !_Array$isArray(b[prop2])) {
        a[prop2] = deepObjectAssignNonentry(a[prop2], b[prop2]);
      } else {
        a[prop2] = clone(b[prop2]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return a;
}
function clone(a) {
  if (_Array$isArray(a)) {
    return _mapInstanceProperty(a).call(a, function(value) {
      return clone(value);
    });
  } else if (_typeof$1(a) === "object" && a !== null) {
    if (a instanceof Date) {
      return new Date(a.getTime());
    }
    return deepObjectAssignNonentry({}, a);
  } else {
    return a;
  }
}
function stripDelete(a) {
  for (var _i = 0, _Object$keys$1 = _Object$keys(a); _i < _Object$keys$1.length; _i++) {
    var prop2 = _Object$keys$1[_i];
    if (a[prop2] === DELETE) {
      delete a[prop2];
    } else if (_typeof$1(a[prop2]) === "object" && a[prop2] !== null) {
      stripDelete(a[prop2]);
    }
  }
}
function Alea() {
  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    seed[_key3] = arguments[_key3];
  }
  return AleaImplementation(seed.length ? seed : [_Date$now()]);
}
function AleaImplementation(seed) {
  var _mashSeed = mashSeed(seed), _mashSeed2 = _slicedToArray(_mashSeed, 3), s0 = _mashSeed2[0], s1 = _mashSeed2[1], s2 = _mashSeed2[2];
  var c2 = 1;
  var random = function random2() {
    var t = 2091639 * s0 + c2 * 23283064365386963e-26;
    s0 = s1;
    s1 = s2;
    return s2 = t - (c2 = t | 0);
  };
  random.uint32 = function() {
    return random() * 4294967296;
  };
  random.fract53 = function() {
    return random() + (random() * 2097152 | 0) * 11102230246251565e-32;
  };
  random.algorithm = "Alea";
  random.seed = seed;
  random.version = "0.9";
  return random;
}
function mashSeed() {
  var mash = Mash();
  var s0 = mash(" ");
  var s1 = mash(" ");
  var s2 = mash(" ");
  for (var i = 0; i < arguments.length; i++) {
    s0 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s0 < 0) {
      s0 += 1;
    }
    s1 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s1 < 0) {
      s1 += 1;
    }
    s2 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    if (s2 < 0) {
      s2 += 1;
    }
  }
  return [s0, s1, s2];
}
function Mash() {
  var n = 4022871197;
  return function(data2) {
    var string2 = data2.toString();
    for (var i = 0; i < string2.length; i++) {
      n += string2.charCodeAt(i);
      var h2 = 0.02519603282416938 * n;
      n = h2 >>> 0;
      h2 -= n;
      h2 *= n;
      n = h2 >>> 0;
      h2 -= n;
      n += h2 * 4294967296;
    }
    return (n >>> 0) * 23283064365386963e-26;
  };
}
function hammerMock() {
  var noop2 = function noop3() {
  };
  return {
    on: noop2,
    off: noop2,
    destroy: noop2,
    emit: noop2,
    get: function get2() {
      return {
        set: noop2
      };
    }
  };
}
var Hammer$1 = typeof window !== "undefined" ? window.Hammer || RealHammer : function() {
  return hammerMock();
};
function Activator$1(container) {
  var _this = this, _context3;
  this._cleanupQueue = [];
  this.active = false;
  this._dom = {
    container,
    overlay: document.createElement("div")
  };
  this._dom.overlay.classList.add("vis-overlay");
  this._dom.container.appendChild(this._dom.overlay);
  this._cleanupQueue.push(function() {
    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);
  });
  var hammer = Hammer$1(this._dom.overlay);
  hammer.on("tap", _bindInstanceProperty$1(_context3 = this._onTapOverlay).call(_context3, this));
  this._cleanupQueue.push(function() {
    hammer.destroy();
  });
  var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
  _forEachInstanceProperty(events).call(events, function(event) {
    hammer.on(event, function(event2) {
      event2.srcEvent.stopPropagation();
    });
  });
  if (document && document.body) {
    this._onClick = function(event) {
      if (!_hasParent(event.target, container)) {
        _this.deactivate();
      }
    };
    document.body.addEventListener("click", this._onClick);
    this._cleanupQueue.push(function() {
      document.body.removeEventListener("click", _this._onClick);
    });
  }
  this._escListener = function(event) {
    if ("key" in event ? event.key === "Escape" : event.keyCode === 27) {
      _this.deactivate();
    }
  };
}
Emitter(Activator$1.prototype);
Activator$1.current = null;
Activator$1.prototype.destroy = function() {
  var _context4, _context5;
  this.deactivate();
  var _iterator2 = _createForOfIteratorHelper$7(_reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var callback = _step2.value;
      callback();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};
Activator$1.prototype.activate = function() {
  if (Activator$1.current) {
    Activator$1.current.deactivate();
  }
  Activator$1.current = this;
  this.active = true;
  this._dom.overlay.style.display = "none";
  this._dom.container.classList.add("vis-active");
  this.emit("change");
  this.emit("activate");
  document.body.addEventListener("keydown", this._escListener);
};
Activator$1.prototype.deactivate = function() {
  this.active = false;
  this._dom.overlay.style.display = "block";
  this._dom.container.classList.remove("vis-active");
  document.body.removeEventListener("keydown", this._escListener);
  this.emit("change");
  this.emit("deactivate");
};
Activator$1.prototype._onTapOverlay = function(event) {
  this.activate();
  event.srcEvent.stopPropagation();
};
function _hasParent(element, parent2) {
  while (element) {
    if (element === parent2) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}
var fullHexRE = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var shortHexRE = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var rgbRE = /^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;
var rgbaRE = /^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;
function recursiveDOMDelete(DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      var child = DOMobject.firstChild;
      if (child) {
        recursiveDOMDelete(child);
        DOMobject.removeChild(child);
      }
    }
  }
}
function isString(value) {
  return value instanceof String || typeof value === "string";
}
function isObject$a(value) {
  return _typeof$1(value) === "object" && value !== null;
}
function copyOrDelete(a, b, prop2, allowDeletion) {
  var doDeletion = false;
  if (allowDeletion === true) {
    doDeletion = b[prop2] === null && a[prop2] !== void 0;
  }
  if (doDeletion) {
    delete a[prop2];
  } else {
    a[prop2] = b[prop2];
  }
}
function fillIfDefined(a, b) {
  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  for (var prop2 in a) {
    if (b[prop2] !== void 0) {
      if (b[prop2] === null || _typeof$1(b[prop2]) !== "object") {
        copyOrDelete(a, b, prop2, allowDeletion);
      } else {
        var aProp = a[prop2];
        var bProp = b[prop2];
        if (isObject$a(aProp) && isObject$a(bProp)) {
          fillIfDefined(aProp, bProp, allowDeletion);
        }
      }
    }
  }
}
function selectiveDeepExtend(props, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (_Array$isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (var p = 0; p < props.length; p++) {
    var prop2 = props[p];
    if (Object.prototype.hasOwnProperty.call(b, prop2)) {
      if (b[prop2] && b[prop2].constructor === Object) {
        if (a[prop2] === void 0) {
          a[prop2] = {};
        }
        if (a[prop2].constructor === Object) {
          deepExtend(a[prop2], b[prop2], false, allowDeletion);
        } else {
          copyOrDelete(a, b, prop2, allowDeletion);
        }
      } else if (_Array$isArray(b[prop2])) {
        throw new TypeError("Arrays are not supported by deepExtend");
      } else {
        copyOrDelete(a, b, prop2, allowDeletion);
      }
    }
  }
  return a;
}
function selectiveNotDeepExtend(propsToExclude, a, b) {
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (_Array$isArray(b)) {
    throw new TypeError("Arrays are not supported by deepExtend");
  }
  for (var prop2 in b) {
    if (!Object.prototype.hasOwnProperty.call(b, prop2)) {
      continue;
    }
    if (_includesInstanceProperty(propsToExclude).call(propsToExclude, prop2)) {
      continue;
    }
    if (b[prop2] && b[prop2].constructor === Object) {
      if (a[prop2] === void 0) {
        a[prop2] = {};
      }
      if (a[prop2].constructor === Object) {
        deepExtend(a[prop2], b[prop2]);
      } else {
        copyOrDelete(a, b, prop2, allowDeletion);
      }
    } else if (_Array$isArray(b[prop2])) {
      a[prop2] = [];
      for (var i = 0; i < b[prop2].length; i++) {
        a[prop2].push(b[prop2][i]);
      }
    } else {
      copyOrDelete(a, b, prop2, allowDeletion);
    }
  }
  return a;
}
function deepExtend(a, b) {
  var protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  for (var prop2 in b) {
    if (Object.prototype.hasOwnProperty.call(b, prop2) || protoExtend === true) {
      if (_typeof$1(b[prop2]) === "object" && b[prop2] !== null && _Object$getPrototypeOf$1(b[prop2]) === Object.prototype) {
        if (a[prop2] === void 0) {
          a[prop2] = deepExtend({}, b[prop2], protoExtend);
        } else if (_typeof$1(a[prop2]) === "object" && a[prop2] !== null && _Object$getPrototypeOf$1(a[prop2]) === Object.prototype) {
          deepExtend(a[prop2], b[prop2], protoExtend);
        } else {
          copyOrDelete(a, b, prop2, allowDeletion);
        }
      } else if (_Array$isArray(b[prop2])) {
        var _context6;
        a[prop2] = _sliceInstanceProperty(_context6 = b[prop2]).call(_context6);
      } else {
        copyOrDelete(a, b, prop2, allowDeletion);
      }
    }
  }
  return a;
}
function copyAndExtendArray(arr, newValue) {
  var _context7;
  return _concatInstanceProperty(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);
}
function copyArray(arr) {
  return _sliceInstanceProperty(arr).call(arr);
}
function getAbsoluteLeft(elem) {
  return elem.getBoundingClientRect().left;
}
function getAbsoluteTop(elem) {
  return elem.getBoundingClientRect().top;
}
function forEach$4(object2, callback) {
  if (_Array$isArray(object2)) {
    var len = object2.length;
    for (var i = 0; i < len; i++) {
      callback(object2[i], i, object2);
    }
  } else {
    for (var key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        callback(object2[key], key, object2);
      }
    }
  }
}
function hexToRGB(hex2) {
  var result;
  switch (hex2.length) {
    case 3:
    case 4:
      result = shortHexRE.exec(hex2);
      return result ? {
        r: _parseInt$1(result[1] + result[1], 16),
        g: _parseInt$1(result[2] + result[2], 16),
        b: _parseInt$1(result[3] + result[3], 16)
      } : null;
    case 6:
    case 7:
      result = fullHexRE.exec(hex2);
      return result ? {
        r: _parseInt$1(result[1], 16),
        g: _parseInt$1(result[2], 16),
        b: _parseInt$1(result[3], 16)
      } : null;
    default:
      return null;
  }
}
function overrideOpacity(color2, opacity) {
  if (_includesInstanceProperty(color2).call(color2, "rgba")) {
    return color2;
  } else if (_includesInstanceProperty(color2).call(color2, "rgb")) {
    var rgb2 = color2.substr(_indexOfInstanceProperty(color2).call(color2, "(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb2[0] + "," + rgb2[1] + "," + rgb2[2] + "," + opacity + ")";
  } else {
    var _rgb = hexToRGB(color2);
    if (_rgb == null) {
      return color2;
    } else {
      return "rgba(" + _rgb.r + "," + _rgb.g + "," + _rgb.b + "," + opacity + ")";
    }
  }
}
function RGBToHex(red, green, blue) {
  var _context10;
  return "#" + _sliceInstanceProperty(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);
}
function parseColor(inputColor, defaultColor) {
  if (isString(inputColor)) {
    var colorStr = inputColor;
    if (isValidRGB(colorStr)) {
      var _context11;
      var rgb2 = _mapInstanceProperty(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(",")).call(_context11, function(value) {
        return _parseInt$1(value);
      });
      colorStr = RGBToHex(rgb2[0], rgb2[1], rgb2[2]);
    }
    if (isValidHex(colorStr) === true) {
      var hsv = hexToHSV(colorStr);
      var lighterColorHSV = {
        h: hsv.h,
        s: hsv.s * 0.8,
        v: Math.min(1, hsv.v * 1.02)
      };
      var darkerColorHSV = {
        h: hsv.h,
        s: Math.min(1, hsv.s * 1.25),
        v: hsv.v * 0.8
      };
      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      return {
        background: colorStr,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      return {
        background: colorStr,
        border: colorStr,
        highlight: {
          background: colorStr,
          border: colorStr
        },
        hover: {
          background: colorStr,
          border: colorStr
        }
      };
    }
  } else {
    if (defaultColor) {
      var color2 = {
        background: inputColor.background || defaultColor.background,
        border: inputColor.border || defaultColor.border,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,
          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,
          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background
        }
      };
      return color2;
    } else {
      var _color = {
        background: inputColor.background || void 0,
        border: inputColor.border || void 0,
        highlight: isString(inputColor.highlight) ? {
          border: inputColor.highlight,
          background: inputColor.highlight
        } : {
          background: inputColor.highlight && inputColor.highlight.background || void 0,
          border: inputColor.highlight && inputColor.highlight.border || void 0
        },
        hover: isString(inputColor.hover) ? {
          border: inputColor.hover,
          background: inputColor.hover
        } : {
          border: inputColor.hover && inputColor.hover.border || void 0,
          background: inputColor.hover && inputColor.hover.background || void 0
        }
      };
      return _color;
    }
  }
}
function RGBToHSV(red, green, blue) {
  red = red / 255;
  green = green / 255;
  blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));
  if (minRGB === maxRGB) {
    return {
      h: 0,
      s: 0,
      v: minRGB
    };
  }
  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;
  var h2 = red === minRGB ? 3 : blue === minRGB ? 1 : 5;
  var hue = 60 * (h2 - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return {
    h: hue,
    s: saturation,
    v: value
  };
}
function HSVToRGB(h2, s, v2) {
  var r;
  var g;
  var b;
  var i = Math.floor(h2 * 6);
  var f = h2 * 6 - i;
  var p = v2 * (1 - s);
  var q2 = v2 * (1 - f * s);
  var t = v2 * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v2, g = t, b = p;
      break;
    case 1:
      r = q2, g = v2, b = p;
      break;
    case 2:
      r = p, g = v2, b = t;
      break;
    case 3:
      r = p, g = q2, b = v2;
      break;
    case 4:
      r = t, g = p, b = v2;
      break;
    case 5:
      r = v2, g = p, b = q2;
      break;
  }
  return {
    r: Math.floor(r * 255),
    g: Math.floor(g * 255),
    b: Math.floor(b * 255)
  };
}
function HSVToHex(h2, s, v2) {
  var rgb2 = HSVToRGB(h2, s, v2);
  return RGBToHex(rgb2.r, rgb2.g, rgb2.b);
}
function hexToHSV(hex2) {
  var rgb2 = hexToRGB(hex2);
  if (!rgb2) {
    throw new TypeError("'".concat(hex2, "' is not a valid color."));
  }
  return RGBToHSV(rgb2.r, rgb2.g, rgb2.b);
}
function isValidHex(hex2) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex2);
  return isOk;
}
function isValidRGB(rgb2) {
  return rgbRE.test(rgb2);
}
function isValidRGBA(rgba2) {
  return rgbaRE.test(rgba2);
}
function bridgeObject(referenceObject) {
  if (referenceObject === null || _typeof$1(referenceObject) !== "object") {
    return null;
  }
  if (referenceObject instanceof Element) {
    return referenceObject;
  }
  var objectTo = _Object$create$1(referenceObject);
  for (var i in referenceObject) {
    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {
      if (_typeof$1(referenceObject[i]) == "object") {
        objectTo[i] = bridgeObject(referenceObject[i]);
      }
    }
  }
  return objectTo;
}
function mergeOptions(mergeTarget, options, option) {
  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var isPresent = function isPresent2(obj) {
    return obj !== null && obj !== void 0;
  };
  var isObject2 = function isObject3(obj) {
    return obj !== null && _typeof$1(obj) === "object";
  };
  var isEmpty3 = function isEmpty4(obj) {
    for (var x2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, x2)) {
        return false;
      }
    }
    return true;
  };
  if (!isObject2(mergeTarget)) {
    throw new Error("Parameter mergeTarget must be an object");
  }
  if (!isObject2(options)) {
    throw new Error("Parameter options must be an object");
  }
  if (!isPresent(option)) {
    throw new Error("Parameter option must have a value");
  }
  if (!isObject2(globalOptions)) {
    throw new Error("Parameter globalOptions must be an object");
  }
  var doMerge = function doMerge2(target, options2, option2) {
    if (!isObject2(target[option2])) {
      target[option2] = {};
    }
    var src = options2[option2];
    var dst = target[option2];
    for (var prop2 in src) {
      if (Object.prototype.hasOwnProperty.call(src, prop2)) {
        dst[prop2] = src[prop2];
      }
    }
  };
  var srcOption = options[option];
  var globalPassed = isObject2(globalOptions) && !isEmpty3(globalOptions);
  var globalOption = globalPassed ? globalOptions[option] : void 0;
  var globalEnabled = globalOption ? globalOption.enabled : void 0;
  if (srcOption === void 0) {
    return;
  }
  if (typeof srcOption === "boolean") {
    if (!isObject2(mergeTarget[option])) {
      mergeTarget[option] = {};
    }
    mergeTarget[option].enabled = srcOption;
    return;
  }
  if (srcOption === null && !isObject2(mergeTarget[option])) {
    if (isPresent(globalOption)) {
      mergeTarget[option] = _Object$create$1(globalOption);
    } else {
      return;
    }
  }
  if (!isObject2(srcOption)) {
    return;
  }
  var enabled = true;
  if (srcOption.enabled !== void 0) {
    enabled = srcOption.enabled;
  } else {
    if (globalEnabled !== void 0) {
      enabled = globalOption.enabled;
    }
  }
  doMerge(mergeTarget, options, option);
  mergeTarget[option].enabled = enabled;
}
var easingFunctions = {
  /**
   * Provides no easing and no acceleration.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  linear: function linear2(t) {
    return t;
  },
  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuad: function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutCubic: function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuart: function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  /**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  /**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  /**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   * @returns Value at time t.
   */
  easeInOutQuint: function easeInOutQuint(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
function topMost(pile, accessors) {
  var candidate;
  if (!_Array$isArray(accessors)) {
    accessors = [accessors];
  }
  var _iterator3 = _createForOfIteratorHelper$7(pile), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var member = _step3.value;
      if (member) {
        candidate = member[accessors[0]];
        for (var i = 1; i < accessors.length; i++) {
          if (candidate) {
            candidate = candidate[accessors[i]];
          }
        }
        if (typeof candidate !== "undefined") {
          break;
        }
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return candidate;
}
var htmlColors = {
  black: "#000000",
  navy: "#000080",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  blue: "#0000FF",
  darkgreen: "#006400",
  green: "#008000",
  teal: "#008080",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  lime: "#00FF00",
  springgreen: "#00FF7F",
  aqua: "#00FFFF",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  lightslategray: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  maroon: "#800000",
  purple: "#800080",
  olive: "#808000",
  gray: "#808080",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370D8",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  silver: "#C0C0C0",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgrey: "#D3D3D3",
  palevioletred: "#D87093",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  red: "#FF0000",
  fuchsia: "#FF00FF",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  yellow: "#FFFF00",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0",
  white: "#FFFFFF"
};
var ColorPicker$1 = /* @__PURE__ */ function() {
  function ColorPicker() {
    var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    _classCallCheck(this, ColorPicker);
    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = {
      x: 289 / 2,
      y: 289 / 2
    };
    this.r = 289 * 0.49;
    this.color = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.hueCircle = void 0;
    this.initialColor = {
      r: 255,
      g: 255,
      b: 255,
      a: 1
    };
    this.previousColor = void 0;
    this.applied = false;
    this.updateCallback = function() {
    };
    this.closeCallback = function() {
    };
    this._create();
  }
  _createClass(ColorPicker, [{
    key: "insertTo",
    value: function insertTo(container) {
      if (this.hammer !== void 0) {
        this.hammer.destroy();
        this.hammer = void 0;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();
      this._setSize();
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */
  }, {
    key: "setUpdateCallback",
    value: function setUpdateCallback(callback) {
      if (typeof callback === "function") {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker update callback is not a function.");
      }
    }
    /**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */
  }, {
    key: "setCloseCallback",
    value: function setCloseCallback(callback) {
      if (typeof callback === "function") {
        this.closeCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
      }
    }
    /**
     *
     * @param {string} color
     * @returns {string}
     * @private
     */
  }, {
    key: "_isColorString",
    value: function _isColorString(color2) {
      if (typeof color2 === "string") {
        return htmlColors[color2];
      }
    }
    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     *
     * @param {string | object} color
     * @param {boolean} [setInitial=true]
     */
  }, {
    key: "setColor",
    value: function setColor(color2) {
      var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (color2 === "none") {
        return;
      }
      var rgba2;
      var htmlColor = this._isColorString(color2);
      if (htmlColor !== void 0) {
        color2 = htmlColor;
      }
      if (isString(color2) === true) {
        if (isValidRGB(color2) === true) {
          var rgbaArray = color2.substr(4).substr(0, color2.length - 5).split(",");
          rgba2 = {
            r: rgbaArray[0],
            g: rgbaArray[1],
            b: rgbaArray[2],
            a: 1
          };
        } else if (isValidRGBA(color2) === true) {
          var _rgbaArray = color2.substr(5).substr(0, color2.length - 6).split(",");
          rgba2 = {
            r: _rgbaArray[0],
            g: _rgbaArray[1],
            b: _rgbaArray[2],
            a: _rgbaArray[3]
          };
        } else if (isValidHex(color2) === true) {
          var rgbObj = hexToRGB(color2);
          rgba2 = {
            r: rgbObj.r,
            g: rgbObj.g,
            b: rgbObj.b,
            a: 1
          };
        }
      } else {
        if (color2 instanceof Object) {
          if (color2.r !== void 0 && color2.g !== void 0 && color2.b !== void 0) {
            var alpha = color2.a !== void 0 ? color2.a : "1.0";
            rgba2 = {
              r: color2.r,
              g: color2.g,
              b: color2.b,
              a: alpha
            };
          }
        }
      }
      if (rgba2 === void 0) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + _JSON$stringify(color2));
      } else {
        this._setColor(rgba2, setInitial);
      }
    }
    /**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */
  }, {
    key: "show",
    value: function show() {
      if (this.closeCallback !== void 0) {
        this.closeCallback();
        this.closeCallback = void 0;
      }
      this.applied = false;
      this.frame.style.display = "block";
      this._generateHueCircle();
    }
    // ------------------------------------------ PRIVATE ----------------------------- //
    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     *
     * @param {boolean} [storePrevious=true]
     * @private
     */
  }, {
    key: "_hide",
    value: function _hide() {
      var _this2 = this;
      var storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (storePrevious === true) {
        this.previousColor = _Object$assign({}, this.color);
      }
      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }
      this.frame.style.display = "none";
      _setTimeout(function() {
        if (_this2.closeCallback !== void 0) {
          _this2.closeCallback();
          _this2.closeCallback = void 0;
        }
      }, 0);
    }
    /**
     * bound to the save button. Saves and hides.
     *
     * @private
     */
  }, {
    key: "_save",
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }
    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     *
     * @private
     */
  }, {
    key: "_apply",
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }
    /**
     * load the color from the previous session.
     *
     * @private
     */
  }, {
    key: "_loadLast",
    value: function _loadLast() {
      if (this.previousColor !== void 0) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }
    /**
     * set the color, place the picker
     *
     * @param {object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */
  }, {
    key: "_setColor",
    value: function _setColor(rgba2) {
      var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (setInitial === true) {
        this.initialColor = _Object$assign({}, rgba2);
      }
      this.color = rgba2;
      var hsv = RGBToHSV(rgba2.r, rgba2.g, rgba2.b);
      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x2 = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y2 = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
      this.colorPickerSelector.style.left = x2 - 0.5 * this.colorPickerSelector.clientWidth + "px";
      this.colorPickerSelector.style.top = y2 - 0.5 * this.colorPickerSelector.clientHeight + "px";
      this._updatePicker(rgba2);
    }
    /**
     * bound to opacity control
     *
     * @param {number} value
     * @private
     */
  }, {
    key: "_setOpacity",
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }
    /**
     * bound to brightness control
     *
     * @param {number} value
     * @private
     */
  }, {
    key: "_setBrightness",
    value: function _setBrightness(value) {
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba2 = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba2["a"] = this.color.a;
      this.color = rgba2;
      this._updatePicker();
    }
    /**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     *
     * @param {object} rgba
     * @private
     */
  }, {
    key: "_updatePicker",
    value: function _updatePicker() {
      var rgba2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
      var hsv = RGBToHSV(rgba2.r, rgba2.g, rgba2.b);
      var ctx = this.colorPickerCanvas.getContext("2d");
      if (this.pixelRation === void 0) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      var w = this.colorPickerCanvas.clientWidth;
      var h2 = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h2);
      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      _fillInstanceProperty(ctx).call(ctx);
      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba2.a;
      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
    /**
     * used by create to set the size of the canvas.
     *
     * @private
     */
  }, {
    key: "_setSize",
    value: function _setSize() {
      this.colorPickerCanvas.style.width = "100%";
      this.colorPickerCanvas.style.height = "100%";
      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }
    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     *
     * @private
     */
  }, {
    key: "_create",
    value: function _create() {
      var _context12, _context13, _context14, _context15;
      this.frame = document.createElement("div");
      this.frame.className = "vis-color-picker";
      this.colorPickerDiv = document.createElement("div");
      this.colorPickerSelector = document.createElement("div");
      this.colorPickerSelector.className = "vis-selector";
      this.colorPickerDiv.appendChild(this.colorPickerSelector);
      this.colorPickerCanvas = document.createElement("canvas");
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);
      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }
      this.colorPickerDiv.className = "vis-color";
      this.opacityDiv = document.createElement("div");
      this.opacityDiv.className = "vis-opacity";
      this.brightnessDiv = document.createElement("div");
      this.brightnessDiv.className = "vis-brightness";
      this.arrowDiv = document.createElement("div");
      this.arrowDiv.className = "vis-arrow";
      this.opacityRange = document.createElement("input");
      try {
        this.opacityRange.type = "range";
        this.opacityRange.min = "0";
        this.opacityRange.max = "100";
      } catch (err) {
      }
      this.opacityRange.value = "100";
      this.opacityRange.className = "vis-range";
      this.brightnessRange = document.createElement("input");
      try {
        this.brightnessRange.type = "range";
        this.brightnessRange.min = "0";
        this.brightnessRange.max = "100";
      } catch (err) {
      }
      this.brightnessRange.value = "100";
      this.brightnessRange.className = "vis-range";
      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);
      var me = this;
      this.opacityRange.onchange = function() {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function() {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function() {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function() {
        me._setBrightness(this.value);
      };
      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerText = "brightness:";
      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerText = "opacity:";
      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerText = "new";
      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerText = "initial";
      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerText = "cancel";
      this.cancelButton.onclick = _bindInstanceProperty$1(_context12 = this._hide).call(_context12, this, false);
      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerText = "apply";
      this.applyButton.onclick = _bindInstanceProperty$1(_context13 = this._apply).call(_context13, this);
      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerText = "save";
      this.saveButton.onclick = _bindInstanceProperty$1(_context14 = this._save).call(_context14, this);
      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerText = "load last";
      this.loadButton.onclick = _bindInstanceProperty$1(_context15 = this._loadLast).call(_context15, this);
      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);
      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }
    /**
     * bind hammer to the color picker
     *
     * @private
     */
  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;
      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer$1(this.colorPickerCanvas);
      this.hammer.get("pinch").set({
        enable: true
      });
      this.hammer.on("hammer.input", function(event) {
        if (event.isFirst) {
          _this3._moveSelector(event);
        }
      });
      this.hammer.on("tap", function(event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panstart", function(event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panmove", function(event) {
        _this3._moveSelector(event);
      });
      this.hammer.on("panend", function(event) {
        _this3._moveSelector(event);
      });
    }
    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     *
     * @private
     */
  }, {
    key: "_generateHueCircle",
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext("2d");
        if (this.pixelRation === void 0) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        var w = this.colorPickerCanvas.clientWidth;
        var h2 = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h2);
        var x2, y2, hue, sat;
        this.centerCoordinates = {
          x: w * 0.5,
          y: h2 * 0.5
        };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb2;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x2 = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y2 = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb2 = HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = "rgb(" + rgb2.r + "," + rgb2.g + "," + rgb2.b + ")";
            ctx.fillRect(x2 - 0.5, y2 - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();
        this.hueCircle = ctx.getImageData(0, 0, w, h2);
      }
      this.generated = true;
    }
    /**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "_moveSelector",
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;
      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;
      var x2 = left - centerX;
      var y2 = top - centerY;
      var angle = Math.atan2(x2, y2);
      var radius = 0.98 * Math.min(Math.sqrt(x2 * x2 + y2 * y2), centerX);
      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;
      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
      var h2 = angle / (2 * Math.PI);
      h2 = h2 < 0 ? h2 + 1 : h2;
      var s = radius / this.r;
      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h2;
      hsv.s = s;
      var rgba2 = HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba2["a"] = this.color.a;
      this.color = rgba2;
      this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
      this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
    }
  }]);
  return ColorPicker;
}();
function wrapInTag() {
  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    rest[_key5] = arguments[_key5];
  }
  if (rest.length < 1) {
    throw new TypeError("Invalid arguments.");
  } else if (rest.length === 1) {
    return document.createTextNode(rest[0]);
  } else {
    var element = document.createElement(rest[0]);
    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(_sliceInstanceProperty(rest).call(rest, 1))));
    return element;
  }
}
var Configurator$1 = /* @__PURE__ */ function() {
  function Configurator2(parentModule, defaultContainer, configureOptions2) {
    var pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    var hideOption = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
      return false;
    };
    _classCallCheck(this, Configurator2);
    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;
    this.hideOption = hideOption;
    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: void 0,
      showButton: true
    };
    _Object$assign(this.options, this.defaultOptions);
    this.configureOptions = configureOptions2;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new ColorPicker$1(pixelRatio);
    this.wrapper = void 0;
  }
  _createClass(Configurator2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        this.popupHistory = {};
        this._removePopup();
        var enabled = true;
        if (typeof options === "string") {
          this.options.filter = options;
        } else if (_Array$isArray(options)) {
          this.options.filter = options.join();
        } else if (_typeof$1(options) === "object") {
          if (options == null) {
            throw new TypeError("options cannot be null");
          }
          if (options.container !== void 0) {
            this.options.container = options.container;
          }
          if (_filterInstanceProperty(options) !== void 0) {
            this.options.filter = _filterInstanceProperty(options);
          }
          if (options.showButton !== void 0) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== void 0) {
            enabled = options.enabled;
          }
        } else if (typeof options === "boolean") {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === "function") {
          this.options.filter = options;
          enabled = true;
        }
        if (_filterInstanceProperty(this.options) === false) {
          enabled = false;
        }
        this.options.enabled = enabled;
      }
      this._clean();
    }
    /**
     *
     * @param {object} moduleOptions
     */
  }, {
    key: "setModuleOptions",
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== void 0) {
          this.container = this.options.container;
        }
        this._create();
      }
    }
    /**
     * Create all DOM elements
     *
     * @private
     */
  }, {
    key: "_create",
    value: function _create() {
      this._clean();
      this.changedOptions = [];
      var filter3 = _filterInstanceProperty(this.options);
      var counter2 = 0;
      var show = false;
      for (var _option in this.configureOptions) {
        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter3 === "function") {
            show = filter3(_option, []);
            show = show || this._handleObject(this.configureOptions[_option], [_option], true);
          } else if (filter3 === true || _indexOfInstanceProperty(filter3).call(filter3, _option) !== -1) {
            show = true;
          }
          if (show !== false) {
            this.allowCreation = true;
            if (counter2 > 0) {
              this._makeItem([]);
            }
            this._makeHeader(_option);
            this._handleObject(this.configureOptions[_option], [_option]);
          }
          counter2++;
        }
      }
      this._makeButton();
      this._push();
    }
    /**
     * draw all DOM elements on the screen
     *
     * @private
     */
  }, {
    key: "_push",
    value: function _push() {
      this.wrapper = document.createElement("div");
      this.wrapper.className = "vis-configuration-wrapper";
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }
      this._showPopupIfNeeded();
    }
    /**
     * delete all DOM elements
     *
     * @private
     */
  }, {
    key: "_clean",
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }
      if (this.wrapper !== void 0) {
        this.container.removeChild(this.wrapper);
        this.wrapper = void 0;
      }
      this.domElements = [];
      this._removePopup();
    }
    /**
     * get the value from the actualOptions if it exists
     *
     * @param {Array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */
  }, {
    key: "_getValue",
    value: function _getValue(path2) {
      var base2 = this.moduleOptions;
      for (var i = 0; i < path2.length; i++) {
        if (base2[path2[i]] !== void 0) {
          base2 = base2[path2[i]];
        } else {
          base2 = void 0;
          break;
        }
      }
      return base2;
    }
    /**
     * all option elements are wrapped in an item
     *
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */
  }, {
    key: "_makeItem",
    value: function _makeItem(path2) {
      if (this.allowCreation === true) {
        var item = document.createElement("div");
        item.className = "vis-configuration vis-config-item vis-config-s" + path2.length;
        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          domElements[_key6 - 1] = arguments[_key6];
        }
        _forEachInstanceProperty(domElements).call(domElements, function(element) {
          item.appendChild(element);
        });
        this.domElements.push(item);
        return this.domElements.length;
      }
      return 0;
    }
    /**
     * header for major subjects
     *
     * @param {string} name
     * @private
     */
  }, {
    key: "_makeHeader",
    value: function _makeHeader(name2) {
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-header";
      div.innerText = name2;
      this._makeItem([], div);
    }
    /**
     * make a label, if it is an object label, it gets different styling.
     *
     * @param {string} name
     * @param {Array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: "_makeLabel",
    value: function _makeLabel(name2, path2) {
      var objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var div = document.createElement("div");
      div.className = "vis-configuration vis-config-label vis-config-s" + path2.length;
      if (objectLabel === true) {
        while (div.firstChild) {
          div.removeChild(div.firstChild);
        }
        div.appendChild(wrapInTag("i", "b", name2));
      } else {
        div.innerText = name2 + ":";
      }
      return div;
    }
    /**
     * make a dropdown list for multiple possible string optoins
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_makeDropdown",
    value: function _makeDropdown(arr, value, path2) {
      var select2 = document.createElement("select");
      select2.className = "vis-configuration vis-config-select";
      var selectedValue = 0;
      if (value !== void 0) {
        if (_indexOfInstanceProperty(arr).call(arr, value) !== -1) {
          selectedValue = _indexOfInstanceProperty(arr).call(arr, value);
        }
      }
      for (var i = 0; i < arr.length; i++) {
        var _option2 = document.createElement("option");
        _option2.value = arr[i];
        if (i === selectedValue) {
          _option2.selected = "selected";
        }
        _option2.innerText = arr[i];
        select2.appendChild(_option2);
      }
      var me = this;
      select2.onchange = function() {
        me._update(this.value, path2);
      };
      var label = this._makeLabel(path2[path2.length - 1], path2);
      this._makeItem(path2, label, select2);
    }
    /**
     * make a range object for numeric options
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_makeRange",
    value: function _makeRange(arr, value, path2) {
      var defaultValue = arr[0];
      var min2 = arr[1];
      var max2 = arr[2];
      var step = arr[3];
      var range = document.createElement("input");
      range.className = "vis-configuration vis-config-range";
      try {
        range.type = "range";
        range.min = min2;
        range.max = max2;
      } catch (err) {
      }
      range.step = step;
      var popupString = "";
      var popupValue = 0;
      if (value !== void 0) {
        var factor = 1.2;
        if (value < 0 && value * factor < min2) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = "range increased";
        } else if (value / factor < min2) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = "range increased";
        }
        if (value * factor > max2 && max2 !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = "range increased";
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }
      var input = document.createElement("input");
      input.className = "vis-configuration vis-config-rangeinput";
      input.value = range.value;
      var me = this;
      range.onchange = function() {
        input.value = this.value;
        me._update(Number(this.value), path2);
      };
      range.oninput = function() {
        input.value = this.value;
      };
      var label = this._makeLabel(path2[path2.length - 1], path2);
      var itemIndex = this._makeItem(path2, label, range, input);
      if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }
    /**
     * make a button object
     *
     * @private
     */
  }, {
    key: "_makeButton",
    value: function _makeButton() {
      var _this4 = this;
      if (this.options.showButton === true) {
        var generateButton = document.createElement("div");
        generateButton.className = "vis-configuration vis-config-button";
        generateButton.innerText = "generate options";
        generateButton.onclick = function() {
          _this4._printOptions();
        };
        generateButton.onmouseover = function() {
          generateButton.className = "vis-configuration vis-config-button hover";
        };
        generateButton.onmouseout = function() {
          generateButton.className = "vis-configuration vis-config-button";
        };
        this.optionsContainer = document.createElement("div");
        this.optionsContainer.className = "vis-configuration vis-config-option-container";
        this.domElements.push(this.optionsContainer);
        this.domElements.push(generateButton);
      }
    }
    /**
     * prepare the popup
     *
     * @param {string} string
     * @param {number} index
     * @private
     */
  }, {
    key: "_setupPopup",
    value: function _setupPopup(string2, index2) {
      var _this5 = this;
      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerText = string2;
        div.onclick = function() {
          _this5._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = {
          html: div,
          index: index2
        };
      }
    }
    /**
     * remove the popup from the dom
     *
     * @private
     */
  }, {
    key: "_removePopup",
    value: function _removePopup() {
      if (this.popupDiv.html !== void 0) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }
    /**
     * Show the popup if it is needed.
     *
     * @private
     */
  }, {
    key: "_showPopupIfNeeded",
    value: function _showPopupIfNeeded() {
      var _this6 = this;
      if (this.popupDiv.html !== void 0) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px";
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = _setTimeout(function() {
          _this6.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = _setTimeout(function() {
          _this6._removePopup();
        }, 1800);
      }
    }
    /**
     * make a checkbox for boolean options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_makeCheckbox",
    value: function _makeCheckbox(defaultValue, value, path2) {
      var checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "vis-configuration vis-config-checkbox";
      checkbox.checked = defaultValue;
      if (value !== void 0) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if (_typeof$1(defaultValue) === "object") {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({
                path: path2,
                value
              });
            }
          } else {
            this.changedOptions.push({
              path: path2,
              value
            });
          }
        }
      }
      var me = this;
      checkbox.onchange = function() {
        me._update(this.checked, path2);
      };
      var label = this._makeLabel(path2[path2.length - 1], path2);
      this._makeItem(path2, label, checkbox);
    }
    /**
     * make a text input field for string options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_makeTextInput",
    value: function _makeTextInput(defaultValue, value, path2) {
      var checkbox = document.createElement("input");
      checkbox.type = "text";
      checkbox.className = "vis-configuration vis-config-text";
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({
          path: path2,
          value
        });
      }
      var me = this;
      checkbox.onchange = function() {
        me._update(this.value, path2);
      };
      var label = this._makeLabel(path2[path2.length - 1], path2);
      this._makeItem(path2, label, checkbox);
    }
    /**
     * make a color field with a color picker for color fields
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_makeColorField",
    value: function _makeColorField(arr, value, path2) {
      var _this7 = this;
      var defaultColor = arr[1];
      var div = document.createElement("div");
      value = value === void 0 ? defaultColor : value;
      if (value !== "none") {
        div.className = "vis-configuration vis-config-colorBlock";
        div.style.backgroundColor = value;
      } else {
        div.className = "vis-configuration vis-config-colorBlock none";
      }
      value = value === void 0 ? defaultColor : value;
      div.onclick = function() {
        _this7._showColorPicker(value, div, path2);
      };
      var label = this._makeLabel(path2[path2.length - 1], path2);
      this._makeItem(path2, label, div);
    }
    /**
     * used by the color buttons to call the color picker.
     *
     * @param {number} value
     * @param {HTMLElement} div
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_showColorPicker",
    value: function _showColorPicker(value, div, path2) {
      var _this8 = this;
      div.onclick = function() {
      };
      this.colorPicker.insertTo(div);
      this.colorPicker.show();
      this.colorPicker.setColor(value);
      this.colorPicker.setUpdateCallback(function(color2) {
        var colorString = "rgba(" + color2.r + "," + color2.g + "," + color2.b + "," + color2.a + ")";
        div.style.backgroundColor = colorString;
        _this8._update(colorString, path2);
      });
      this.colorPicker.setCloseCallback(function() {
        div.onclick = function() {
          _this8._showColorPicker(value, div, path2);
        };
      });
    }
    /**
     * parse an object and draw the correct items
     *
     * @param {object} obj
     * @param {Array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */
  }, {
    key: "_handleObject",
    value: function _handleObject(obj) {
      var path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var show = false;
      var filter3 = _filterInstanceProperty(this.options);
      var visibleInSet = false;
      for (var subObj in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = copyAndExtendArray(path2, subObj);
          if (typeof filter3 === "function") {
            show = filter3(subObj, path2);
            if (show === false) {
              if (!_Array$isArray(item) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }
          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);
            if (_Array$isArray(item)) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === "string") {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === "boolean") {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              if (!this.hideOption(path2, subObj, this.moduleOptions)) {
                if (item.enabled !== void 0) {
                  var enabledPath = copyAndExtendArray(newPath, "enabled");
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var _label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, _label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error("dont know how to handle", item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }
    /**
     * handle the array type of option
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_handleArray",
    value: function _handleArray(arr, value, path2) {
      if (typeof arr[0] === "string" && arr[0] === "color") {
        this._makeColorField(arr, value, path2);
        if (arr[1] !== value) {
          this.changedOptions.push({
            path: path2,
            value
          });
        }
      } else if (typeof arr[0] === "string") {
        this._makeDropdown(arr, value, path2);
        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path2,
            value
          });
        }
      } else if (typeof arr[0] === "number") {
        this._makeRange(arr, value, path2);
        if (arr[0] !== value) {
          this.changedOptions.push({
            path: path2,
            value: Number(value)
          });
        }
      }
    }
    /**
     * called to update the network with the new settings.
     *
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */
  }, {
    key: "_update",
    value: function _update(value, path2) {
      var options = this._constructOptions(value, path2);
      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }
    /**
     *
     * @param {string | boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */
  }, {
    key: "_constructOptions",
    value: function _constructOptions(value, path2) {
      var optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var pointer2 = optionsObj;
      value = value === "true" ? true : value;
      value = value === "false" ? false : value;
      for (var i = 0; i < path2.length; i++) {
        if (path2[i] !== "global") {
          if (pointer2[path2[i]] === void 0) {
            pointer2[path2[i]] = {};
          }
          if (i !== path2.length - 1) {
            pointer2 = pointer2[path2[i]];
          } else {
            pointer2[path2[i]] = value;
          }
        }
      }
      return optionsObj;
    }
    /**
     * @private
     */
  }, {
    key: "_printOptions",
    value: function _printOptions() {
      var options = this.getOptions();
      while (this.optionsContainer.firstChild) {
        this.optionsContainer.removeChild(this.optionsContainer.firstChild);
      }
      this.optionsContainer.appendChild(wrapInTag("pre", "const options = " + _JSON$stringify(options, null, 2)));
    }
    /**
     *
     * @returns {{}} options
     */
  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);
  return Configurator2;
}();
var Popup$1 = /* @__PURE__ */ function() {
  function Popup2(container, overflowMethod) {
    _classCallCheck(this, Popup2);
    this.container = container;
    this.overflowMethod = overflowMethod || "cap";
    this.x = 0;
    this.y = 0;
    this.padding = 5;
    this.hidden = false;
    this.frame = document.createElement("div");
    this.frame.className = "vis-tooltip";
    this.container.appendChild(this.frame);
  }
  _createClass(Popup2, [{
    key: "setPosition",
    value: function setPosition(x2, y2) {
      this.x = _parseInt$1(x2);
      this.y = _parseInt$1(y2);
    }
    /**
     * Set the content for the popup window. This can be HTML code or text.
     *
     * @param {string | Element} content
     */
  }, {
    key: "setText",
    value: function setText(content) {
      if (content instanceof Element) {
        while (this.frame.firstChild) {
          this.frame.removeChild(this.frame.firstChild);
        }
        this.frame.appendChild(content);
      } else {
        this.frame.innerText = content;
      }
    }
    /**
     * Show the popup window
     *
     * @param {boolean} [doShow]    Show or hide the window
     */
  }, {
    key: "show",
    value: function show(doShow) {
      if (doShow === void 0) {
        doShow = true;
      }
      if (doShow === true) {
        var height = this.frame.clientHeight;
        var width = this.frame.clientWidth;
        var maxHeight = this.frame.parentNode.clientHeight;
        var maxWidth = this.frame.parentNode.clientWidth;
        var left = 0, top = 0;
        if (this.overflowMethod == "flip") {
          var isLeft = false, isTop = true;
          if (this.y - height < this.padding) {
            isTop = false;
          }
          if (this.x + width > maxWidth - this.padding) {
            isLeft = true;
          }
          if (isLeft) {
            left = this.x - width;
          } else {
            left = this.x;
          }
          if (isTop) {
            top = this.y - height;
          } else {
            top = this.y;
          }
        } else {
          top = this.y - height;
          if (top + height + this.padding > maxHeight) {
            top = maxHeight - height - this.padding;
          }
          if (top < this.padding) {
            top = this.padding;
          }
          left = this.x;
          if (left + width + this.padding > maxWidth) {
            left = maxWidth - width - this.padding;
          }
          if (left < this.padding) {
            left = this.padding;
          }
        }
        this.frame.style.left = left + "px";
        this.frame.style.top = top + "px";
        this.frame.style.visibility = "visible";
        this.hidden = false;
      } else {
        this.hide();
      }
    }
    /**
     * Hide the popup window
     */
  }, {
    key: "hide",
    value: function hide() {
      this.hidden = true;
      this.frame.style.left = "0";
      this.frame.style.top = "0";
      this.frame.style.visibility = "hidden";
    }
    /**
     * Remove the popup window
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.frame.parentNode.removeChild(this.frame);
    }
  }]);
  return Popup2;
}();
var errorFound = false;
var allOptions$1;
var VALIDATOR_PRINT_STYLE$1 = "background: #FFeeee; color: #dd0000";
var Validator$1 = /* @__PURE__ */ function() {
  function Validator2() {
    _classCallCheck(this, Validator2);
  }
  _createClass(Validator2, null, [{
    key: "validate",
    value: (
      /**
       * Main function to be called
       *
       * @param {object} options
       * @param {object} referenceOptions
       * @param {object} subObject
       * @returns {boolean}
       * @static
       */
      function validate(options, referenceOptions, subObject) {
        errorFound = false;
        allOptions$1 = referenceOptions;
        var usedOptions = referenceOptions;
        if (subObject !== void 0) {
          usedOptions = referenceOptions[subObject];
        }
        Validator2.parse(options, usedOptions, []);
        return errorFound;
      }
    )
    /**
     * Will traverse an object recursively and check every value
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */
  }, {
    key: "parse",
    value: function parse2(options, referenceOptions, path2) {
      for (var _option3 in options) {
        if (Object.prototype.hasOwnProperty.call(options, _option3)) {
          Validator2.check(_option3, options, referenceOptions, path2);
        }
      }
    }
    /**
     * Check every value. If the value is an object, call the parse function on that object.
     *
     * @param {string} option
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */
  }, {
    key: "check",
    value: function check2(option, options, referenceOptions, path2) {
      if (referenceOptions[option] === void 0 && referenceOptions.__any__ === void 0) {
        Validator2.getSuggestion(option, referenceOptions, path2);
        return;
      }
      var referenceOption = option;
      var is_object = true;
      if (referenceOptions[option] === void 0 && referenceOptions.__any__ !== void 0) {
        referenceOption = "__any__";
        is_object = Validator2.getType(options[option]) === "object";
      }
      var refOptionObj = referenceOptions[referenceOption];
      if (is_object && refOptionObj.__type__ !== void 0) {
        refOptionObj = refOptionObj.__type__;
      }
      Validator2.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path2);
    }
    /**
     *
     * @param {string}  option           | the option property
     * @param {object}  options          | The supplied options object
     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */
  }, {
    key: "checkFields",
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path2) {
      var log = function log2(message) {
        console.error("%c" + message + Validator2.printLocation(path2, option), VALIDATOR_PRINT_STYLE$1);
      };
      var optionType = Validator2.getType(options[option]);
      var refOptionType = refOptionObj[optionType];
      if (refOptionType !== void 0) {
        if (Validator2.getType(refOptionType) === "array" && _indexOfInstanceProperty(refOptionType).call(refOptionType, options[option]) === -1) {
          log('Invalid option detected in "' + option + '". Allowed values are:' + Validator2.print(refOptionType) + ' not "' + options[option] + '". ');
          errorFound = true;
        } else if (optionType === "object" && referenceOption !== "__any__") {
          path2 = copyAndExtendArray(path2, option);
          Validator2.parse(options[option], referenceOptions[referenceOption], path2);
        }
      } else if (refOptionObj["any"] === void 0) {
        log('Invalid type received for "' + option + '". Expected: ' + Validator2.print(_Object$keys(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
        errorFound = true;
      }
    }
    /**
     *
     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
     * @returns {string}
     * @static
     */
  }, {
    key: "getType",
    value: function getType(object2) {
      var type = _typeof$1(object2);
      if (type === "object") {
        if (object2 === null) {
          return "null";
        }
        if (object2 instanceof Boolean) {
          return "boolean";
        }
        if (object2 instanceof Number) {
          return "number";
        }
        if (object2 instanceof String) {
          return "string";
        }
        if (_Array$isArray(object2)) {
          return "array";
        }
        if (object2 instanceof Date) {
          return "date";
        }
        if (object2.nodeType !== void 0) {
          return "dom";
        }
        if (object2._isAMomentObject === true) {
          return "moment";
        }
        return "object";
      } else if (type === "number") {
        return "number";
      } else if (type === "boolean") {
        return "boolean";
      } else if (type === "string") {
        return "string";
      } else if (type === void 0) {
        return "undefined";
      }
      return type;
    }
    /**
     * @param {string} option
     * @param {object} options
     * @param {Array.<string>} path
     * @static
     */
  }, {
    key: "getSuggestion",
    value: function getSuggestion(option, options, path2) {
      var localSearch = Validator2.findInOptions(option, options, path2, false);
      var globalSearch = Validator2.findInOptions(option, allOptions$1, [], true);
      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;
      var msg;
      if (localSearch.indexMatch !== void 0) {
        msg = " in " + Validator2.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        msg = " in " + Validator2.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator2.printLocation(globalSearch.path, globalSearch.closestMatch, "");
      } else if (localSearch.distance <= localSearchThreshold) {
        msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator2.printLocation(localSearch.path, option);
      } else {
        msg = ". Did you mean one of these: " + Validator2.print(_Object$keys(options)) + Validator2.printLocation(path2, option);
      }
      console.error('%cUnknown option detected: "' + option + '"' + msg, VALIDATOR_PRINT_STYLE$1);
      errorFound = true;
    }
    /**
     * traverse the options in search for a match.
     *
     * @param {string} option
     * @param {object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */
  }, {
    key: "findInOptions",
    value: function findInOptions(option, options, path2) {
      var recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var min2 = 1e9;
      var closestMatch = "";
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = void 0;
      for (var op in options) {
        var distance = void 0;
        if (options[op].__type__ !== void 0 && recursive === true) {
          var result = Validator2.findInOptions(option, options[op], copyAndExtendArray(path2, op));
          if (min2 > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min2 = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          var _context16;
          if (_indexOfInstanceProperty(_context16 = op.toLowerCase()).call(_context16, lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator2.levenshteinDistance(option, op);
          if (min2 > distance) {
            closestMatch = op;
            closestMatchPath = copyArray(path2);
            min2 = distance;
          }
        }
      }
      return {
        closestMatch,
        path: closestMatchPath,
        distance: min2,
        indexMatch
      };
    }
    /**
     * @param {Array.<string>} path
     * @param {object} option
     * @param {string} prefix
     * @returns {string}
     * @static
     */
  }, {
    key: "printLocation",
    value: function printLocation(path2, option) {
      var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
      var str = "\n\n" + prefix + "options = {\n";
      for (var i = 0; i < path2.length; i++) {
        for (var j2 = 0; j2 < i + 1; j2++) {
          str += "  ";
        }
        str += path2[i] + ": {\n";
      }
      for (var _j = 0; _j < path2.length + 1; _j++) {
        str += "  ";
      }
      str += option + "\n";
      for (var _i5 = 0; _i5 < path2.length + 1; _i5++) {
        for (var _j2 = 0; _j2 < path2.length - _i5; _j2++) {
          str += "  ";
        }
        str += "}\n";
      }
      return str + "\n\n";
    }
    /**
     * @param {object} options
     * @returns {string}
     * @static
     */
  }, {
    key: "print",
    value: function print(options) {
      return _JSON$stringify(options).replace(/(")|(\[)|(\])|(,"__type__")/g, "").replace(/(,)/g, ", ");
    }
    /**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */
  }, {
    key: "levenshteinDistance",
    value: function levenshteinDistance(a, b) {
      if (a.length === 0)
        return b.length;
      if (b.length === 0)
        return a.length;
      var matrix = [];
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      var j2;
      for (j2 = 0; j2 <= a.length; j2++) {
        matrix[0][j2] = j2;
      }
      for (i = 1; i <= b.length; i++) {
        for (j2 = 1; j2 <= a.length; j2++) {
          if (b.charAt(i - 1) == a.charAt(j2 - 1)) {
            matrix[i][j2] = matrix[i - 1][j2 - 1];
          } else {
            matrix[i][j2] = Math.min(
              matrix[i - 1][j2 - 1] + 1,
              // substitution
              Math.min(
                matrix[i][j2 - 1] + 1,
                // insertion
                matrix[i - 1][j2] + 1
              )
            );
          }
        }
      }
      return matrix[b.length][a.length];
    }
  }]);
  return Validator2;
}();
var Activator = Activator$1;
var Configurator = Configurator$1;
var Hammer = Hammer$1;
var Popup = Popup$1;
var VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;
var Validator = Validator$1;
function parseDOT(data2) {
  dot = data2;
  return parseGraph();
}
var NODE_ATTR_MAPPING = {
  fontsize: "font.size",
  fontcolor: "font.color",
  labelfontcolor: "font.color",
  fontname: "font.face",
  color: ["color.border", "color.background"],
  fillcolor: "color.background",
  tooltip: "title",
  labeltooltip: "title"
};
var EDGE_ATTR_MAPPING = _Object$create$1(NODE_ATTR_MAPPING);
EDGE_ATTR_MAPPING.color = "color.color";
EDGE_ATTR_MAPPING.style = "dashes";
var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  IDENTIFIER: 2,
  UNKNOWN: 3
};
var DELIMITERS = {
  "{": true,
  "}": true,
  "[": true,
  "]": true,
  ";": true,
  "=": true,
  ",": true,
  "->": true,
  "--": true
};
var dot = "";
var index$1 = 0;
var c = "";
var token = "";
var tokenType = TOKENTYPE.NULL;
function first() {
  index$1 = 0;
  c = dot.charAt(0);
}
function next2() {
  index$1++;
  c = dot.charAt(index$1);
}
function nextPreview() {
  return dot.charAt(index$1 + 1);
}
function isAlphaNumeric(c2) {
  var charCode = c2.charCodeAt(0);
  if (charCode < 47) {
    return charCode === 35 || charCode === 46;
  }
  if (charCode < 59) {
    return charCode > 47;
  }
  if (charCode < 91) {
    return charCode > 64;
  }
  if (charCode < 96) {
    return charCode === 95;
  }
  if (charCode < 123) {
    return charCode > 96;
  }
  return false;
}
function merge$1(a, b) {
  if (!a) {
    a = {};
  }
  if (b) {
    for (var name2 in b) {
      if (b.hasOwnProperty(name2)) {
        a[name2] = b[name2];
      }
    }
  }
  return a;
}
function setValue(obj, path2, value) {
  var keys4 = path2.split(".");
  var o = obj;
  while (keys4.length) {
    var key = keys4.shift();
    if (keys4.length) {
      if (!o[key]) {
        o[key] = {};
      }
      o = o[key];
    } else {
      o[key] = value;
    }
  }
}
function addNode(graph, node2) {
  var i, len;
  var current = null;
  var graphs = [graph];
  var root2 = graph;
  while (root2.parent) {
    graphs.push(root2.parent);
    root2 = root2.parent;
  }
  if (root2.nodes) {
    for (i = 0, len = root2.nodes.length; i < len; i++) {
      if (node2.id === root2.nodes[i].id) {
        current = root2.nodes[i];
        break;
      }
    }
  }
  if (!current) {
    current = {
      id: node2.id
    };
    if (graph.node) {
      current.attr = merge$1(current.attr, graph.node);
    }
  }
  for (i = graphs.length - 1; i >= 0; i--) {
    var _context;
    var g = graphs[i];
    if (!g.nodes) {
      g.nodes = [];
    }
    if (_indexOfInstanceProperty(_context = g.nodes).call(_context, current) === -1) {
      g.nodes.push(current);
    }
  }
  if (node2.attr) {
    current.attr = merge$1(current.attr, node2.attr);
  }
}
function addEdge(graph, edge) {
  if (!graph.edges) {
    graph.edges = [];
  }
  graph.edges.push(edge);
  if (graph.edge) {
    var attr2 = merge$1({}, graph.edge);
    edge.attr = merge$1(attr2, edge.attr);
  }
}
function createEdge(graph, from3, to, type, attr2) {
  var edge = {
    from: from3,
    to,
    type
  };
  if (graph.edge) {
    edge.attr = merge$1({}, graph.edge);
  }
  edge.attr = merge$1(edge.attr || {}, attr2);
  if (attr2 != null) {
    if (attr2.hasOwnProperty("arrows") && attr2["arrows"] != null) {
      edge["arrows"] = {
        to: {
          enabled: true,
          type: attr2.arrows.type
        }
      };
      attr2["arrows"] = null;
    }
  }
  return edge;
}
function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = "";
  while (c === " " || c === "	" || c === "\n" || c === "\r") {
    next2();
  }
  do {
    var isComment2 = false;
    if (c === "#") {
      var i = index$1 - 1;
      while (dot.charAt(i) === " " || dot.charAt(i) === "	") {
        i--;
      }
      if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
        while (c != "" && c != "\n") {
          next2();
        }
        isComment2 = true;
      }
    }
    if (c === "/" && nextPreview() === "/") {
      while (c != "" && c != "\n") {
        next2();
      }
      isComment2 = true;
    }
    if (c === "/" && nextPreview() === "*") {
      while (c != "") {
        if (c === "*" && nextPreview() === "/") {
          next2();
          next2();
          break;
        } else {
          next2();
        }
      }
      isComment2 = true;
    }
    while (c === " " || c === "	" || c === "\n" || c === "\r") {
      next2();
    }
  } while (isComment2);
  if (c === "") {
    tokenType = TOKENTYPE.DELIMITER;
    return;
  }
  var c2 = c + nextPreview();
  if (DELIMITERS[c2]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c2;
    next2();
    next2();
    return;
  }
  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next2();
    return;
  }
  if (isAlphaNumeric(c) || c === "-") {
    token += c;
    next2();
    while (isAlphaNumeric(c)) {
      token += c;
      next2();
    }
    if (token === "false") {
      token = false;
    } else if (token === "true") {
      token = true;
    } else if (!isNaN(Number(token))) {
      token = Number(token);
    }
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }
  if (c === '"') {
    next2();
    while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
      if (c === '"') {
        token += c;
        next2();
      } else if (c === "\\" && nextPreview() === "n") {
        token += "\n";
        next2();
      } else {
        token += c;
      }
      next2();
    }
    if (c != '"') {
      throw newSyntaxError('End of string " expected');
    }
    next2();
    tokenType = TOKENTYPE.IDENTIFIER;
    return;
  }
  tokenType = TOKENTYPE.UNKNOWN;
  while (c != "") {
    token += c;
    next2();
  }
  throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
}
function parseGraph() {
  var graph = {};
  first();
  getToken();
  if (token === "strict") {
    graph.strict = true;
    getToken();
  }
  if (token === "graph" || token === "digraph") {
    graph.type = token;
    getToken();
  }
  if (tokenType === TOKENTYPE.IDENTIFIER) {
    graph.id = token;
    getToken();
  }
  if (token != "{") {
    throw newSyntaxError("Angle bracket { expected");
  }
  getToken();
  parseStatements(graph);
  if (token != "}") {
    throw newSyntaxError("Angle bracket } expected");
  }
  getToken();
  if (token !== "") {
    throw newSyntaxError("End of file expected");
  }
  getToken();
  delete graph.node;
  delete graph.edge;
  delete graph.graph;
  return graph;
}
function parseStatements(graph) {
  while (token !== "" && token != "}") {
    parseStatement(graph);
    if (token === ";") {
      getToken();
    }
  }
}
function parseStatement(graph) {
  var subgraph = parseSubgraph(graph);
  if (subgraph) {
    parseEdge(graph, subgraph);
    return;
  }
  var attr2 = parseAttributeStatement(graph);
  if (attr2) {
    return;
  }
  if (tokenType != TOKENTYPE.IDENTIFIER) {
    throw newSyntaxError("Identifier expected");
  }
  var id2 = token;
  getToken();
  if (token === "=") {
    getToken();
    if (tokenType != TOKENTYPE.IDENTIFIER) {
      throw newSyntaxError("Identifier expected");
    }
    graph[id2] = token;
    getToken();
  } else {
    parseNodeStatement(graph, id2);
  }
}
function parseSubgraph(graph) {
  var subgraph = null;
  if (token === "subgraph") {
    subgraph = {};
    subgraph.type = "subgraph";
    getToken();
    if (tokenType === TOKENTYPE.IDENTIFIER) {
      subgraph.id = token;
      getToken();
    }
  }
  if (token === "{") {
    getToken();
    if (!subgraph) {
      subgraph = {};
    }
    subgraph.parent = graph;
    subgraph.node = graph.node;
    subgraph.edge = graph.edge;
    subgraph.graph = graph.graph;
    parseStatements(subgraph);
    if (token != "}") {
      throw newSyntaxError("Angle bracket } expected");
    }
    getToken();
    delete subgraph.node;
    delete subgraph.edge;
    delete subgraph.graph;
    delete subgraph.parent;
    if (!graph.subgraphs) {
      graph.subgraphs = [];
    }
    graph.subgraphs.push(subgraph);
  }
  return subgraph;
}
function parseAttributeStatement(graph) {
  if (token === "node") {
    getToken();
    graph.node = parseAttributeList();
    return "node";
  } else if (token === "edge") {
    getToken();
    graph.edge = parseAttributeList();
    return "edge";
  } else if (token === "graph") {
    getToken();
    graph.graph = parseAttributeList();
    return "graph";
  }
  return null;
}
function parseNodeStatement(graph, id2) {
  var node2 = {
    id: id2
  };
  var attr2 = parseAttributeList();
  if (attr2) {
    node2.attr = attr2;
  }
  addNode(graph, node2);
  parseEdge(graph, id2);
}
function parseEdge(graph, from3) {
  while (token === "->" || token === "--") {
    var to;
    var type = token;
    getToken();
    var subgraph = parseSubgraph(graph);
    if (subgraph) {
      to = subgraph;
    } else {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Identifier or subgraph expected");
      }
      to = token;
      addNode(graph, {
        id: to
      });
      getToken();
    }
    var attr2 = parseAttributeList();
    var edge = createEdge(graph, from3, to, type, attr2);
    addEdge(graph, edge);
    from3 = to;
  }
}
function parseAttributeList() {
  var i;
  var attr2 = null;
  var edgeStyles = {
    dashed: true,
    solid: false,
    dotted: [1, 5]
  };
  var arrowTypes = {
    dot: "circle",
    box: "box",
    crow: "crow",
    curve: "curve",
    icurve: "inv_curve",
    normal: "triangle",
    inv: "inv_triangle",
    diamond: "diamond",
    tee: "bar",
    vee: "vee"
  };
  var attr_list = new Array();
  var attr_names = new Array();
  while (token === "[") {
    getToken();
    attr2 = {};
    while (token !== "" && token != "]") {
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute name expected");
      }
      var name2 = token;
      getToken();
      if (token != "=") {
        throw newSyntaxError("Equal sign = expected");
      }
      getToken();
      if (tokenType != TOKENTYPE.IDENTIFIER) {
        throw newSyntaxError("Attribute value expected");
      }
      var value = token;
      if (name2 === "style") {
        value = edgeStyles[value];
      }
      var arrowType;
      if (name2 === "arrowhead") {
        arrowType = arrowTypes[value];
        name2 = "arrows";
        value = {
          to: {
            enabled: true,
            type: arrowType
          }
        };
      }
      if (name2 === "arrowtail") {
        arrowType = arrowTypes[value];
        name2 = "arrows";
        value = {
          from: {
            enabled: true,
            type: arrowType
          }
        };
      }
      attr_list.push({
        attr: attr2,
        name: name2,
        value
      });
      attr_names.push(name2);
      getToken();
      if (token == ",") {
        getToken();
      }
    }
    if (token != "]") {
      throw newSyntaxError("Bracket ] expected");
    }
    getToken();
  }
  if (_includesInstanceProperty(attr_names).call(attr_names, "dir")) {
    var idx = {};
    idx.arrows = {};
    for (i = 0; i < attr_list.length; i++) {
      if (attr_list[i].name === "arrows") {
        if (attr_list[i].value.to != null) {
          idx.arrows.to = i;
        } else if (attr_list[i].value.from != null) {
          idx.arrows.from = i;
        } else {
          throw newSyntaxError("Invalid value of arrows");
        }
      } else if (attr_list[i].name === "dir") {
        idx.dir = i;
      }
    }
    var dir_type = attr_list[idx.dir].value;
    if (!_includesInstanceProperty(attr_names).call(attr_names, "arrows")) {
      if (dir_type === "both") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "forward") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            to: {
              enabled: true
            }
          }
        });
        idx.arrows.to = attr_list.length - 1;
      } else if (dir_type === "back") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: {
            from: {
              enabled: true
            }
          }
        });
        idx.arrows.from = attr_list.length - 1;
      } else if (dir_type === "none") {
        attr_list.push({
          attr: attr_list[idx.dir].attr,
          name: "arrows",
          value: ""
        });
        idx.arrows.to = attr_list.length - 1;
      } else {
        throw newSyntaxError('Invalid dir type "' + dir_type + '"');
      }
    }
    var from_type;
    var to_type;
    if (dir_type === "both") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
        _spliceInstanceProperty(attr_list).call(attr_list, idx.arrows.from, 1);
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "arrow";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
    } else if (dir_type === "back") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.to) {
        to_type = "";
        from_type = "arrow";
        idx.arrows.from = idx.arrows.to;
        attr_list[idx.arrows.from] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "";
        from_type = attr_list[idx.arrows.from].value.from.type;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.from].attr,
          name: attr_list[idx.arrows.from].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
      attr_list[idx.arrows.from] = {
        attr: attr_list[idx.arrows.from].attr,
        name: attr_list[idx.arrows.from].name,
        value: {
          from: {
            enabled: true,
            type: attr_list[idx.arrows.from].value.from.type
          }
        }
      };
    } else if (dir_type === "none") {
      var idx_arrow;
      if (idx.arrows.to) {
        idx_arrow = idx.arrows.to;
      } else {
        idx_arrow = idx.arrows.from;
      }
      attr_list[idx_arrow] = {
        attr: attr_list[idx_arrow].attr,
        name: attr_list[idx_arrow].name,
        value: ""
      };
    } else if (dir_type === "forward") {
      if (idx.arrows.to && idx.arrows.from) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.to) {
        to_type = attr_list[idx.arrows.to].value.to.type;
        from_type = "";
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      } else if (idx.arrows.from) {
        to_type = "arrow";
        from_type = "";
        idx.arrows.to = idx.arrows.from;
        attr_list[idx.arrows.to] = {
          attr: attr_list[idx.arrows.to].attr,
          name: attr_list[idx.arrows.to].name,
          value: {
            to: {
              enabled: true,
              type: to_type
            },
            from: {
              enabled: true,
              type: from_type
            }
          }
        };
      }
      attr_list[idx.arrows.to] = {
        attr: attr_list[idx.arrows.to].attr,
        name: attr_list[idx.arrows.to].name,
        value: {
          to: {
            enabled: true,
            type: attr_list[idx.arrows.to].value.to.type
          }
        }
      };
    } else {
      throw newSyntaxError('Invalid dir type "' + dir_type + '"');
    }
    _spliceInstanceProperty(attr_list).call(attr_list, idx.dir, 1);
  }
  var nof_attr_list;
  if (_includesInstanceProperty(attr_names).call(attr_names, "penwidth")) {
    var tmp_attr_list = [];
    nof_attr_list = attr_list.length;
    for (i = 0; i < nof_attr_list; i++) {
      if (attr_list[i].name !== "width") {
        if (attr_list[i].name === "penwidth") {
          attr_list[i].name = "width";
        }
        tmp_attr_list.push(attr_list[i]);
      }
    }
    attr_list = tmp_attr_list;
  }
  nof_attr_list = attr_list.length;
  for (i = 0; i < nof_attr_list; i++) {
    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);
  }
  return attr2;
}
function newSyntaxError(message) {
  return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index$1 + ")");
}
function chop(text2, maxLength) {
  return text2.length <= maxLength ? text2 : text2.substr(0, 27) + "...";
}
function forEach2(array1, array2, fn) {
  if (_Array$isArray(array1)) {
    _forEachInstanceProperty(array1).call(array1, function(elem1) {
      if (_Array$isArray(array2)) {
        _forEachInstanceProperty(array2).call(array2, function(elem2) {
          fn(elem1, elem2);
        });
      } else {
        fn(elem1, array2);
      }
    });
  } else {
    if (_Array$isArray(array2)) {
      _forEachInstanceProperty(array2).call(array2, function(elem2) {
        fn(array1, elem2);
      });
    } else {
      fn(array1, array2);
    }
  }
}
function setProp(object2, path2, value) {
  var names = path2.split(".");
  var prop2 = names.pop();
  var obj = object2;
  for (var i = 0; i < names.length; i++) {
    var name2 = names[i];
    if (!(name2 in obj)) {
      obj[name2] = {};
    }
    obj = obj[name2];
  }
  obj[prop2] = value;
  return object2;
}
function convertAttr(attr2, mapping) {
  var converted = {};
  for (var prop2 in attr2) {
    if (attr2.hasOwnProperty(prop2)) {
      var visProp = mapping[prop2];
      if (_Array$isArray(visProp)) {
        _forEachInstanceProperty(visProp).call(visProp, function(visPropI) {
          setProp(converted, visPropI, attr2[prop2]);
        });
      } else if (typeof visProp === "string") {
        setProp(converted, visProp, attr2[prop2]);
      } else {
        setProp(converted, prop2, attr2[prop2]);
      }
    }
  }
  return converted;
}
function DOTToGraph(data2) {
  var dotData = parseDOT(data2);
  var graphData = {
    nodes: [],
    edges: [],
    options: {}
  };
  if (dotData.nodes) {
    var _context2;
    _forEachInstanceProperty(_context2 = dotData.nodes).call(_context2, function(dotNode) {
      var graphNode = {
        id: dotNode.id,
        label: String(dotNode.label || dotNode.id)
      };
      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
      if (graphNode.image) {
        graphNode.shape = "image";
      }
      graphData.nodes.push(graphNode);
    });
  }
  if (dotData.edges) {
    var _context3;
    var convertEdge = function convertEdge2(dotEdge) {
      var graphEdge = {
        from: dotEdge.from,
        to: dotEdge.to
      };
      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
      if (graphEdge.arrows == null && dotEdge.type === "->") {
        graphEdge.arrows = "to";
      }
      return graphEdge;
    };
    _forEachInstanceProperty(_context3 = dotData.edges).call(_context3, function(dotEdge) {
      var from3, to;
      if (dotEdge.from instanceof Object) {
        from3 = dotEdge.from.nodes;
      } else {
        from3 = {
          id: dotEdge.from
        };
      }
      if (dotEdge.to instanceof Object) {
        to = dotEdge.to.nodes;
      } else {
        to = {
          id: dotEdge.to
        };
      }
      if (dotEdge.from instanceof Object && dotEdge.from.edges) {
        var _context4;
        _forEachInstanceProperty(_context4 = dotEdge.from.edges).call(_context4, function(subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
      forEach2(from3, to, function(from4, to2) {
        var subEdge = createEdge(graphData, from4.id, to2.id, dotEdge.type, dotEdge.attr);
        var graphEdge = convertEdge(subEdge);
        graphData.edges.push(graphEdge);
      });
      if (dotEdge.to instanceof Object && dotEdge.to.edges) {
        var _context5;
        _forEachInstanceProperty(_context5 = dotEdge.to.edges).call(_context5, function(subEdge) {
          var graphEdge = convertEdge(subEdge);
          graphData.edges.push(graphEdge);
        });
      }
    });
  }
  if (dotData.attr) {
    graphData.options = dotData.attr;
  }
  return graphData;
}
function parseGephi(gephiJSON, optionsObj) {
  var _context;
  var options = {
    edges: {
      inheritColor: false
    },
    nodes: {
      fixed: false,
      parseColor: false
    }
  };
  if (optionsObj != null) {
    if (optionsObj.fixed != null) {
      options.nodes.fixed = optionsObj.fixed;
    }
    if (optionsObj.parseColor != null) {
      options.nodes.parseColor = optionsObj.parseColor;
    }
    if (optionsObj.inheritColor != null) {
      options.edges.inheritColor = optionsObj.inheritColor;
    }
  }
  var gEdges = gephiJSON.edges;
  var vEdges = _mapInstanceProperty(gEdges).call(gEdges, function(gEdge) {
    var vEdge = {
      from: gEdge.source,
      id: gEdge.id,
      to: gEdge.target
    };
    if (gEdge.attributes != null) {
      vEdge.attributes = gEdge.attributes;
    }
    if (gEdge.label != null) {
      vEdge.label = gEdge.label;
    }
    if (gEdge.attributes != null && gEdge.attributes.title != null) {
      vEdge.title = gEdge.attributes.title;
    }
    if (gEdge.type === "Directed") {
      vEdge.arrows = "to";
    }
    if (gEdge.color && options.edges.inheritColor === false) {
      vEdge.color = gEdge.color;
    }
    return vEdge;
  });
  var vNodes = _mapInstanceProperty(_context = gephiJSON.nodes).call(_context, function(gNode) {
    var vNode = {
      id: gNode.id,
      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null
    };
    if (gNode.attributes != null) {
      vNode.attributes = gNode.attributes;
    }
    if (gNode.label != null) {
      vNode.label = gNode.label;
    }
    if (gNode.size != null) {
      vNode.size = gNode.size;
    }
    if (gNode.attributes != null && gNode.attributes.title != null) {
      vNode.title = gNode.attributes.title;
    }
    if (gNode.title != null) {
      vNode.title = gNode.title;
    }
    if (gNode.x != null) {
      vNode.x = gNode.x;
    }
    if (gNode.y != null) {
      vNode.y = gNode.y;
    }
    if (gNode.color != null) {
      if (options.nodes.parseColor === true) {
        vNode.color = gNode.color;
      } else {
        vNode.color = {
          background: gNode.color,
          border: gNode.color,
          highlight: {
            background: gNode.color,
            border: gNode.color
          },
          hover: {
            background: gNode.color,
            border: gNode.color
          }
        };
      }
    }
    return vNode;
  });
  return {
    nodes: vNodes,
    edges: vEdges
  };
}
var en = {
  addDescription: "Click in an empty space to place a new node.",
  addEdge: "Add Edge",
  addNode: "Add Node",
  back: "Back",
  close: "Close",
  createEdgeError: "Cannot link edges to a cluster.",
  del: "Delete selected",
  deleteClusterError: "Clusters cannot be deleted.",
  edgeDescription: "Click on a node and drag the edge to another node to connect them.",
  edit: "Edit",
  editClusterError: "Clusters cannot be edited.",
  editEdge: "Edit Edge",
  editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
  editNode: "Edit Node"
};
var de = {
  addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
  addEdge: "Kante hinzufügen",
  addNode: "Knoten hinzufügen",
  back: "Zurück",
  close: "Schließen",
  createEdgeError: "Es ist nicht möglich, Kanten mit Clustern zu verbinden.",
  del: "Lösche Auswahl",
  deleteClusterError: "Cluster können nicht gelöscht werden.",
  edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
  edit: "Editieren",
  editClusterError: "Cluster können nicht editiert werden.",
  editEdge: "Kante editieren",
  editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
  editNode: "Knoten editieren"
};
var es = {
  addDescription: "Haga clic en un lugar vacío para colocar un nuevo nodo.",
  addEdge: "Añadir arista",
  addNode: "Añadir nodo",
  back: "Atrás",
  close: "Cerrar",
  createEdgeError: "No se puede conectar una arista a un grupo.",
  del: "Eliminar selección",
  deleteClusterError: "No es posible eliminar grupos.",
  edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
  edit: "Editar",
  editClusterError: "No es posible editar grupos.",
  editEdge: "Editar arista",
  editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
  editNode: "Editar nodo"
};
var it2 = {
  addDescription: "Clicca per aggiungere un nuovo nodo",
  addEdge: "Aggiungi un vertice",
  addNode: "Aggiungi un nodo",
  back: "Indietro",
  close: "Chiudere",
  createEdgeError: "Non si possono collegare vertici ad un cluster",
  del: "Cancella la selezione",
  deleteClusterError: "I cluster non possono essere cancellati",
  edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
  edit: "Modifica",
  editClusterError: "I clusters non possono essere modificati.",
  editEdge: "Modifica il vertice",
  editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
  editNode: "Modifica il nodo"
};
var nl = {
  addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
  addEdge: "Link toevoegen",
  addNode: "Node toevoegen",
  back: "Terug",
  close: "Sluiten",
  createEdgeError: "Kan geen link maken naar een cluster.",
  del: "Selectie verwijderen",
  deleteClusterError: "Clusters kunnen niet worden verwijderd.",
  edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
  edit: "Wijzigen",
  editClusterError: "Clusters kunnen niet worden aangepast.",
  editEdge: "Link wijzigen",
  editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
  editNode: "Node wijzigen"
};
var pt = {
  addDescription: "Clique em um espaço em branco para adicionar um novo nó",
  addEdge: "Adicionar aresta",
  addNode: "Adicionar nó",
  back: "Voltar",
  close: "Fechar",
  createEdgeError: "Não foi possível linkar arestas a um cluster.",
  del: "Remover selecionado",
  deleteClusterError: "Clusters não puderam ser removidos.",
  edgeDescription: "Clique em um nó e arraste a aresta até outro nó para conectá-los",
  edit: "Editar",
  editClusterError: "Clusters não puderam ser editados.",
  editEdge: "Editar aresta",
  editEdgeDescription: "Clique nos pontos de controle e os arraste para um nó para conectá-los",
  editNode: "Editar nó"
};
var ru = {
  addDescription: "Кликните в свободное место, чтобы добавить новый узел.",
  addEdge: "Добавить ребро",
  addNode: "Добавить узел",
  back: "Назад",
  close: "Закрывать",
  createEdgeError: "Невозможно соединить ребра в кластер.",
  del: "Удалить выбранное",
  deleteClusterError: "Кластеры не могут быть удалены",
  edgeDescription: "Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",
  edit: "Редактировать",
  editClusterError: "Кластеры недоступны для редактирования.",
  editEdge: "Редактировать ребро",
  editEdgeDescription: "Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",
  editNode: "Редактировать узел"
};
var cn = {
  addDescription: "单击空白处放置新节点。",
  addEdge: "添加连接线",
  addNode: "添加节点",
  back: "返回",
  close: "關閉",
  createEdgeError: "无法将连接线连接到群集。",
  del: "删除选定",
  deleteClusterError: "无法删除群集。",
  edgeDescription: "单击某个节点并将该连接线拖动到另一个节点以连接它们。",
  edit: "编辑",
  editClusterError: "无法编辑群集。",
  editEdge: "编辑连接线",
  editEdgeDescription: "单击控制节点并将它们拖到节点上连接。",
  editNode: "编辑节点"
};
var uk = {
  addDescription: "Kлікніть на вільне місце, щоб додати новий вузол.",
  addEdge: "Додати край",
  addNode: "Додати вузол",
  back: "Назад",
  close: "Закрити",
  createEdgeError: "Не можливо об'єднати краї в групу.",
  del: "Видалити обране",
  deleteClusterError: "Групи не можуть бути видалені.",
  edgeDescription: "Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",
  edit: "Редагувати",
  editClusterError: "Групи недоступні для редагування.",
  editEdge: "Редагувати край",
  editEdgeDescription: "Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",
  editNode: "Редагувати вузол"
};
var fr = {
  addDescription: "Cliquez dans un endroit vide pour placer un nœud.",
  addEdge: "Ajouter un lien",
  addNode: "Ajouter un nœud",
  back: "Retour",
  close: "Fermer",
  createEdgeError: "Impossible de créer un lien vers un cluster.",
  del: "Effacer la sélection",
  deleteClusterError: "Les clusters ne peuvent pas être effacés.",
  edgeDescription: "Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",
  edit: "Éditer",
  editClusterError: "Les clusters ne peuvent pas être édités.",
  editEdge: "Éditer le lien",
  editEdgeDescription: "Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",
  editNode: "Éditer le nœud"
};
var cs = {
  addDescription: "Kluknutím do prázdného prostoru můžete přidat nový vrchol.",
  addEdge: "Přidat hranu",
  addNode: "Přidat vrchol",
  back: "Zpět",
  close: "Zavřít",
  createEdgeError: "Nelze připojit hranu ke shluku.",
  del: "Smazat výběr",
  deleteClusterError: "Nelze mazat shluky.",
  edgeDescription: "Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",
  edit: "Upravit",
  editClusterError: "Nelze upravovat shluky.",
  editEdge: "Upravit hranu",
  editEdgeDescription: "Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",
  editNode: "Upravit vrchol"
};
var locales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  cn,
  cs,
  de,
  en,
  es,
  fr,
  it: it2,
  nl,
  pt,
  ru,
  uk
});
function normalizeLanguageCode(locales2, rawCode) {
  try {
    var _rawCode$split = rawCode.split(/[-_ /]/, 2), _rawCode$split2 = _slicedToArray(_rawCode$split, 2), rawLanguage = _rawCode$split2[0], rawCountry = _rawCode$split2[1];
    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;
    var country = rawCountry != null ? rawCountry.toUpperCase() : null;
    if (language && country) {
      var code2 = language + "-" + country;
      if (Object.prototype.hasOwnProperty.call(locales2, code2)) {
        return code2;
      } else {
        var _context;
        console.warn(_concatInstanceProperty(_context = "Unknown variant ".concat(country, " of language ")).call(_context, language, "."));
      }
    }
    if (language) {
      var _code = language;
      if (Object.prototype.hasOwnProperty.call(locales2, _code)) {
        return _code;
      } else {
        console.warn("Unknown language ".concat(language));
      }
    }
    console.warn("Unknown locale ".concat(rawCode, ", falling back to English."));
    return "en";
  } catch (error2) {
    console.error(error2);
    console.warn("Unexpected error while normalizing locale ".concat(rawCode, ", falling back to English."));
    return "en";
  }
}
var CachedImage = /* @__PURE__ */ function() {
  function CachedImage2() {
    _classCallCheck(this, CachedImage2);
    this.NUM_ITERATIONS = 4;
    this.image = new Image();
    this.canvas = document.createElement("canvas");
  }
  _createClass(CachedImage2, [{
    key: "init",
    value: function init2() {
      if (this.initialized())
        return;
      this.src = this.image.src;
      var w = this.image.width;
      var h2 = this.image.height;
      this.width = w;
      this.height = h2;
      var h22 = Math.floor(h2 / 2);
      var h4 = Math.floor(h2 / 4);
      var h8 = Math.floor(h2 / 8);
      var h16 = Math.floor(h2 / 16);
      var w2 = Math.floor(w / 2);
      var w4 = Math.floor(w / 4);
      var w8 = Math.floor(w / 8);
      var w16 = Math.floor(w / 16);
      this.canvas.width = 3 * w4;
      this.canvas.height = h22;
      this.coordinates = [[0, 0, w2, h22], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];
      this._fillMipMap();
    }
    /**
     * @returns {boolean} true if init() has been called, false otherwise.
     */
  }, {
    key: "initialized",
    value: function initialized() {
      return this.coordinates !== void 0;
    }
    /**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */
  }, {
    key: "_fillMipMap",
    value: function _fillMipMap() {
      var ctx = this.canvas.getContext("2d");
      var to = this.coordinates[0];
      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);
      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
        var from3 = this.coordinates[iterations - 1];
        var _to = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from3[0], from3[1], from3[2], from3[3], _to[0], _to[1], _to[2], _to[3]);
      }
    }
    /**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */
  }, {
    key: "drawImageAtPosition",
    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
      if (!this.initialized())
        return;
      if (factor > 2) {
        factor *= 0.5;
        var iterations = 0;
        while (factor > 2 && iterations < this.NUM_ITERATIONS) {
          factor *= 0.5;
          iterations += 1;
        }
        if (iterations >= this.NUM_ITERATIONS) {
          iterations = this.NUM_ITERATIONS - 1;
        }
        var from3 = this.coordinates[iterations];
        ctx.drawImage(this.canvas, from3[0], from3[1], from3[2], from3[3], left, top, width, height);
      } else {
        ctx.drawImage(this.image, left, top, width, height);
      }
    }
  }]);
  return CachedImage2;
}();
var Images = /* @__PURE__ */ function() {
  function Images2(callback) {
    _classCallCheck(this, Images2);
    this.images = {};
    this.imageBroken = {};
    this.callback = callback;
  }
  _createClass(Images2, [{
    key: "_tryloadBrokenUrl",
    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
      if (url === void 0 || imageToLoadBrokenUrlOn === void 0)
        return;
      if (brokenUrl === void 0) {
        console.warn("No broken url image defined");
        return;
      }
      imageToLoadBrokenUrlOn.image.onerror = function() {
        console.error("Could not load brokenImage:", brokenUrl);
      };
      imageToLoadBrokenUrlOn.image.src = brokenUrl;
    }
    /**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */
  }, {
    key: "_redrawWithImage",
    value: function _redrawWithImage(imageToRedrawWith) {
      if (this.callback) {
        this.callback(imageToRedrawWith);
      }
    }
    /**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @returns {Image} img          The image object
     */
  }, {
    key: "load",
    value: function load2(url, brokenUrl) {
      var _this = this;
      var cachedImage = this.images[url];
      if (cachedImage)
        return cachedImage;
      var img = new CachedImage();
      this.images[url] = img;
      img.image.onload = function() {
        _this._fixImageCoordinates(img.image);
        img.init();
        _this._redrawWithImage(img);
      };
      img.image.onerror = function() {
        console.error("Could not load image:", url);
        _this._tryloadBrokenUrl(url, brokenUrl, img);
      };
      img.image.src = url;
      return img;
    }
    /**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     *
     * @param {vis.Image} imageToCache
     * @private
     */
  }, {
    key: "_fixImageCoordinates",
    value: function _fixImageCoordinates(imageToCache) {
      if (imageToCache.width === 0) {
        document.body.appendChild(imageToCache);
        imageToCache.width = imageToCache.offsetWidth;
        imageToCache.height = imageToCache.offsetHeight;
        document.body.removeChild(imageToCache);
      }
    }
  }]);
  return Images2;
}();
var internalMetadata = { exports: {} };
var fails$c = fails$z;
var arrayBufferNonExtensible = fails$c(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer = new ArrayBuffer(8);
    if (Object.isExtensible(buffer))
      Object.defineProperty(buffer, "a", { value: 8 });
  }
});
var fails$b = fails$z;
var isObject$9 = isObject$m;
var classof$4 = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$1 = fails$b(function() {
  $isExtensible(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it3) {
  if (!isObject$9(it3))
    return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$4(it3) === "ArrayBuffer")
    return false;
  return $isExtensible ? $isExtensible(it3) : true;
} : $isExtensible;
var fails$a = fails$z;
var freezing = !fails$a(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$t = _export;
var uncurryThis$5 = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$8 = isObject$m;
var hasOwn$7 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING$1 = freezing;
var REQUIRED = false;
var METADATA = uid("meta");
var id$1 = 0;
var setMetadata = function(it3) {
  defineProperty$2(it3, METADATA, { value: {
    objectID: "O" + id$1++,
    // object ID
    weakData: {}
    // weak collections IDs
  } });
};
var fastKey$1 = function(it3, create5) {
  if (!isObject$8(it3))
    return typeof it3 == "symbol" ? it3 : (typeof it3 == "string" ? "S" : "P") + it3;
  if (!hasOwn$7(it3, METADATA)) {
    if (!isExtensible$1(it3))
      return "F";
    if (!create5)
      return "E";
    setMetadata(it3);
  }
  return it3[METADATA].objectID;
};
var getWeakData$1 = function(it3, create5) {
  if (!hasOwn$7(it3, METADATA)) {
    if (!isExtensible$1(it3))
      return true;
    if (!create5)
      return false;
    setMetadata(it3);
  }
  return it3[METADATA].weakData;
};
var onFreeze = function(it3) {
  if (FREEZING$1 && REQUIRED && isExtensible$1(it3) && !hasOwn$7(it3, METADATA))
    setMetadata(it3);
  return it3;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames6 = getOwnPropertyNamesModule.f;
  var splice3 = uncurryThis$5([].splice);
  var test3 = {};
  test3[METADATA] = 1;
  if (getOwnPropertyNames6(test3).length) {
    getOwnPropertyNamesModule.f = function(it3) {
      var result = getOwnPropertyNames6(it3);
      for (var i = 0, length2 = result.length; i < length2; i++) {
        if (result[i] === METADATA) {
          splice3(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$t({ target: "Object", stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze
};
hiddenKeys[METADATA] = true;
var internalMetadataExports = internalMetadata.exports;
var bind$9 = functionBindContext;
var call$7 = functionCall;
var anObject$5 = anObject$f;
var tryToString$1 = tryToString$6;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$e;
var isPrototypeOf$a = objectIsPrototypeOf;
var getIterator$6 = getIterator$8;
var getIteratorMethod = getIteratorMethod$9;
var iteratorClose = iteratorClose$2;
var $TypeError$4 = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$8 = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$9(unboundFunction, that);
  var iterator2, iterFn, index2, length2, result, next3, step;
  var stop = function(condition) {
    if (iterator2)
      iteratorClose(iterator2, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$5(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator2 = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator2 = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw new $TypeError$4(tryToString$1(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (index2 = 0, length2 = lengthOfArrayLike$4(iterable); length2 > index2; index2++) {
        result = callFn(iterable[index2]);
        if (result && isPrototypeOf$a(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator2 = getIterator$6(iterable, iterFn);
  }
  next3 = IS_RECORD ? iterable.next : iterator2.next;
  while (!(step = call$7(next3, iterator2)).done) {
    try {
      result = callFn(step.value);
    } catch (error2) {
      iteratorClose(iterator2, "throw", error2);
    }
    if (typeof result == "object" && result && isPrototypeOf$a(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var isPrototypeOf$9 = objectIsPrototypeOf;
var $TypeError$3 = TypeError;
var anInstance$4 = function(it3, Prototype) {
  if (isPrototypeOf$9(Prototype, it3))
    return it3;
  throw new $TypeError$3("Incorrect invocation");
};
var $$s = _export;
var global$a = global$s;
var InternalMetadataModule$1 = internalMetadataExports;
var fails$9 = fails$z;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$9;
var iterate$7 = iterate$8;
var anInstance$3 = anInstance$4;
var isCallable$4 = isCallable$m;
var isObject$7 = isObject$m;
var isNullOrUndefined$3 = isNullOrUndefined$7;
var setToStringTag$1 = setToStringTag$7;
var defineProperty$1 = objectDefineProperty.f;
var forEach$3 = arrayIteration.forEach;
var DESCRIPTORS$5 = descriptors;
var InternalStateModule$3 = internalState;
var setInternalState$3 = InternalStateModule$3.set;
var internalStateGetterFor$2 = InternalStateModule$3.getterFor;
var collection$3 = function(CONSTRUCTOR_NAME, wrapper2, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = global$a[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;
  if (!DESCRIPTORS$5 || !isCallable$4(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$9(function() {
    new NativeConstructor().entries().next();
  }))) {
    Constructor = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else {
    Constructor = wrapper2(function(target, iterable) {
      setInternalState$3(anInstance$3(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (!isNullOrUndefined$3(iterable))
        iterate$7(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$2(CONSTRUCTOR_NAME);
    forEach$3(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function(KEY) {
      var IS_ADDER = KEY === "add" || KEY === "set";
      if (KEY in NativePrototype && !(IS_WEAK && KEY === "clear")) {
        createNonEnumerableProperty$3(Prototype, KEY, function(a, b) {
          var collection2 = getInternalState2(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject$7(a))
            return KEY === "get" ? void 0 : false;
          var result = collection2[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });
    IS_WEAK || defineProperty$1(Prototype, "size", {
      configurable: true,
      get: function() {
        return getInternalState2(this).collection.size;
      }
    });
  }
  setToStringTag$1(Constructor, CONSTRUCTOR_NAME, false, true);
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$s({ global: true, forced: true }, exported);
  if (!IS_WEAK)
    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};
var defineBuiltIn$1 = defineBuiltIn$6;
var defineBuiltIns$3 = function(target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key])
      target[key] = src[key];
    else
      defineBuiltIn$1(target, key, src[key], options);
  }
  return target;
};
var getBuiltIn$4 = getBuiltIn$f;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$3;
var wellKnownSymbol$3 = wellKnownSymbol$p;
var DESCRIPTORS$4 = descriptors;
var SPECIES$2 = wellKnownSymbol$3("species");
var setSpecies$2 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
  if (DESCRIPTORS$4 && Constructor && !Constructor[SPECIES$2]) {
    defineBuiltInAccessor$1(Constructor, SPECIES$2, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var create$5 = objectCreate;
var defineBuiltInAccessor = defineBuiltInAccessor$3;
var defineBuiltIns$2 = defineBuiltIns$3;
var bind$8 = functionBindContext;
var anInstance$2 = anInstance$4;
var isNullOrUndefined$2 = isNullOrUndefined$7;
var iterate$6 = iterate$8;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$3;
var setSpecies$1 = setSpecies$2;
var DESCRIPTORS$3 = descriptors;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule$2 = internalState;
var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor$1 = InternalStateModule$2.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance$2(that, Prototype);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        index: create$5(null),
        first: void 0,
        last: void 0,
        size: 0
      });
      if (!DESCRIPTORS$3)
        that.size = 0;
      if (!isNullOrUndefined$2(iterable))
        iterate$6(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define2 = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index2;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index2 = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: void 0,
          removed: false
        };
        if (!state.first)
          state.first = entry;
        if (previous)
          previous.next = entry;
        if (DESCRIPTORS$3)
          state.size++;
        else
          that.size++;
        if (index2 !== "F")
          state.index[index2] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index2 = fastKey(key);
      var entry;
      if (index2 !== "F")
        return state.index[index2];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key)
          return entry;
      }
    };
    defineBuiltIns$2(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var data2 = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous)
            entry.previous = entry.previous.next = void 0;
          delete data2[entry.index];
          entry = entry.next;
        }
        state.first = state.last = void 0;
        if (DESCRIPTORS$3)
          state.size = 0;
        else
          that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next3 = entry.next;
          var prev2 = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev2)
            prev2.next = next3;
          if (next3)
            next3.previous = prev2;
          if (state.first === entry)
            state.first = next3;
          if (state.last === entry)
            state.last = prev2;
          if (DESCRIPTORS$3)
            state.size--;
          else
            that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach4(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$8(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed)
            entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has2(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns$2(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get2(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set3(key, value) {
        return define2(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add3(value) {
        return define2(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$3)
      defineBuiltInAccessor(Prototype, "size", {
        configurable: true,
        get: function() {
          return getInternalState2(this).size;
        }
      });
    return Constructor;
  },
  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState$2(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: void 0
      });
    }, function() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed)
        entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind === "keys")
        return createIterResultObject(entry.key, false);
      if (kind === "values")
        return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies$1(CONSTRUCTOR_NAME);
  }
};
var collection$2 = collection$3;
var collectionStrong$1 = collectionStrong$2;
collection$2("Map", function(init2) {
  return function Map2() {
    return init2(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var path$g = path$y;
var map$2 = path$g.Map;
var parent$I = map$2;
var map$1 = parent$I;
var map2 = map$1;
var _Map = /* @__PURE__ */ getDefaultExportFromCjs(map2);
var Groups = /* @__PURE__ */ function() {
  function Groups2() {
    _classCallCheck(this, Groups2);
    this.clear();
    this._defaultIndex = 0;
    this._groupIndex = 0;
    this._defaultGroups = [
      {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      // 0: blue
      {
        border: "#FFA500",
        background: "#FFFF00",
        highlight: {
          border: "#FFA500",
          background: "#FFFFA3"
        },
        hover: {
          border: "#FFA500",
          background: "#FFFFA3"
        }
      },
      // 1: yellow
      {
        border: "#FA0A10",
        background: "#FB7E81",
        highlight: {
          border: "#FA0A10",
          background: "#FFAFB1"
        },
        hover: {
          border: "#FA0A10",
          background: "#FFAFB1"
        }
      },
      // 2: red
      {
        border: "#41A906",
        background: "#7BE141",
        highlight: {
          border: "#41A906",
          background: "#A1EC76"
        },
        hover: {
          border: "#41A906",
          background: "#A1EC76"
        }
      },
      // 3: green
      {
        border: "#E129F0",
        background: "#EB7DF4",
        highlight: {
          border: "#E129F0",
          background: "#F0B3F5"
        },
        hover: {
          border: "#E129F0",
          background: "#F0B3F5"
        }
      },
      // 4: magenta
      {
        border: "#7C29F0",
        background: "#AD85E4",
        highlight: {
          border: "#7C29F0",
          background: "#D3BDF0"
        },
        hover: {
          border: "#7C29F0",
          background: "#D3BDF0"
        }
      },
      // 5: purple
      {
        border: "#C37F00",
        background: "#FFA807",
        highlight: {
          border: "#C37F00",
          background: "#FFCA66"
        },
        hover: {
          border: "#C37F00",
          background: "#FFCA66"
        }
      },
      // 6: orange
      {
        border: "#4220FB",
        background: "#6E6EFD",
        highlight: {
          border: "#4220FB",
          background: "#9B9BFD"
        },
        hover: {
          border: "#4220FB",
          background: "#9B9BFD"
        }
      },
      // 7: darkblue
      {
        border: "#FD5A77",
        background: "#FFC0CB",
        highlight: {
          border: "#FD5A77",
          background: "#FFD1D9"
        },
        hover: {
          border: "#FD5A77",
          background: "#FFD1D9"
        }
      },
      // 8: pink
      {
        border: "#4AD63A",
        background: "#C2FABC",
        highlight: {
          border: "#4AD63A",
          background: "#E6FFE3"
        },
        hover: {
          border: "#4AD63A",
          background: "#E6FFE3"
        }
      },
      // 9: mint
      {
        border: "#990000",
        background: "#EE0000",
        highlight: {
          border: "#BB0000",
          background: "#FF3333"
        },
        hover: {
          border: "#BB0000",
          background: "#FF3333"
        }
      },
      // 10:bright red
      {
        border: "#FF6000",
        background: "#FF6000",
        highlight: {
          border: "#FF6000",
          background: "#FF6000"
        },
        hover: {
          border: "#FF6000",
          background: "#FF6000"
        }
      },
      // 12: real orange
      {
        border: "#97C2FC",
        background: "#2B7CE9",
        highlight: {
          border: "#D2E5FF",
          background: "#2B7CE9"
        },
        hover: {
          border: "#D2E5FF",
          background: "#2B7CE9"
        }
      },
      // 13: blue
      {
        border: "#399605",
        background: "#255C03",
        highlight: {
          border: "#399605",
          background: "#255C03"
        },
        hover: {
          border: "#399605",
          background: "#255C03"
        }
      },
      // 14: green
      {
        border: "#B70054",
        background: "#FF007E",
        highlight: {
          border: "#B70054",
          background: "#FF007E"
        },
        hover: {
          border: "#B70054",
          background: "#FF007E"
        }
      },
      // 15: magenta
      {
        border: "#AD85E4",
        background: "#7C29F0",
        highlight: {
          border: "#D3BDF0",
          background: "#7C29F0"
        },
        hover: {
          border: "#D3BDF0",
          background: "#7C29F0"
        }
      },
      // 16: purple
      {
        border: "#4557FA",
        background: "#000EA1",
        highlight: {
          border: "#6E6EFD",
          background: "#000EA1"
        },
        hover: {
          border: "#6E6EFD",
          background: "#000EA1"
        }
      },
      // 17: darkblue
      {
        border: "#FFC0CB",
        background: "#FD5A77",
        highlight: {
          border: "#FFD1D9",
          background: "#FD5A77"
        },
        hover: {
          border: "#FFD1D9",
          background: "#FD5A77"
        }
      },
      // 18: pink
      {
        border: "#C2FABC",
        background: "#74D66A",
        highlight: {
          border: "#E6FFE3",
          background: "#74D66A"
        },
        hover: {
          border: "#E6FFE3",
          background: "#74D66A"
        }
      },
      // 19: mint
      {
        border: "#EE0000",
        background: "#990000",
        highlight: {
          border: "#FF3333",
          background: "#BB0000"
        },
        hover: {
          border: "#FF3333",
          background: "#BB0000"
        }
      }
      // 20:bright red
    ];
    this.options = {};
    this.defaultOptions = {
      useDefaultGroups: true
    };
    _Object$assign(this.options, this.defaultOptions);
  }
  _createClass(Groups2, [{
    key: "setOptions",
    value: function setOptions(options) {
      var optionFields = ["useDefaultGroups"];
      if (options !== void 0) {
        for (var groupName in options) {
          if (Object.prototype.hasOwnProperty.call(options, groupName)) {
            if (_indexOfInstanceProperty(optionFields).call(optionFields, groupName) === -1) {
              var group = options[groupName];
              this.add(groupName, group);
            }
          }
        }
      }
    }
    /**
     * Clear all groups
     */
  }, {
    key: "clear",
    value: function clear2() {
      this._groups = new _Map();
      this._groupNames = [];
    }
    /**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @returns {object} The found or created group
     */
  }, {
    key: "get",
    value: function get2(groupname) {
      var shouldCreate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var group = this._groups.get(groupname);
      if (group === void 0 && shouldCreate) {
        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {
          var index2 = this._groupIndex % this._groupNames.length;
          ++this._groupIndex;
          group = {};
          group.color = this._groups.get(this._groupNames[index2]);
          this._groups.set(groupname, group);
        } else {
          var _index = this._defaultIndex % this._defaultGroups.length;
          this._defaultIndex++;
          group = {};
          group.color = this._defaultGroups[_index];
          this._groups.set(groupname, group);
        }
      }
      return group;
    }
    /**
     * Add custom group style.
     *
     * @param {string} groupName - The name of the group, a new group will be
     * created if a group with the same name doesn't exist, otherwise the old
     * groups style will be overwritten.
     * @param {object} style - An object containing borderColor, backgroundColor,
     * etc.
     * @returns {object} The created group object.
     */
  }, {
    key: "add",
    value: function add3(groupName, style) {
      if (!this._groups.has(groupName)) {
        this._groupNames.push(groupName);
      }
      this._groups.set(groupName, style);
      return style;
    }
  }]);
  return Groups2;
}();
var $$r = _export;
$$r({ target: "Number", stat: true }, {
  isNaN: function isNaN2(number2) {
    return number2 !== number2;
  }
});
var path$f = path$y;
var isNan$2 = path$f.Number.isNaN;
var parent$H = isNan$2;
var isNan$1 = parent$H;
var isNan = isNan$1;
var _Number$isNaN = /* @__PURE__ */ getDefaultExportFromCjs(isNan);
var global$9 = global$s;
var globalIsFinite = global$9.isFinite;
var numberIsFinite$1 = Number.isFinite || function isFinite2(it3) {
  return typeof it3 == "number" && globalIsFinite(it3);
};
var $$q = _export;
var numberIsFinite = numberIsFinite$1;
$$q({ target: "Number", stat: true }, { isFinite: numberIsFinite });
var path$e = path$y;
var _isFinite$2 = path$e.Number.isFinite;
var parent$G = _isFinite$2;
var _isFinite$1 = parent$G;
var _isFinite = _isFinite$1;
var _Number$isFinite = /* @__PURE__ */ getDefaultExportFromCjs(_isFinite);
var $$p = _export;
var $some = arrayIteration.some;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$6;
var STRICT_METHOD$2 = arrayMethodIsStrict$3("some");
$$p({ target: "Array", proto: true, forced: !STRICT_METHOD$2 }, {
  some: function some(callbackfn) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$7 = entryVirtual$l;
var some$3 = entryVirtual$7("Array").some;
var isPrototypeOf$8 = objectIsPrototypeOf;
var method$7 = some$3;
var ArrayPrototype$7 = Array.prototype;
var some$2 = function(it3) {
  var own = it3.some;
  return it3 === ArrayPrototype$7 || isPrototypeOf$8(ArrayPrototype$7, it3) && own === ArrayPrototype$7.some ? method$7 : own;
};
var parent$F = some$2;
var some$1 = parent$F;
var some2 = some$1;
var _someInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(some2);
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var parent$E = create$7;
var create$4 = parent$E;
var parent$D = create$4;
var create$3 = parent$D;
var create$2 = create$3;
var _Object$create = /* @__PURE__ */ getDefaultExportFromCjs(create$2);
var $$o = _export;
var setPrototypeOf$6 = objectSetPrototypeOf;
$$o({ target: "Object", stat: true }, {
  setPrototypeOf: setPrototypeOf$6
});
var path$d = path$y;
var setPrototypeOf$5 = path$d.Object.setPrototypeOf;
var parent$C = setPrototypeOf$5;
var setPrototypeOf$4 = parent$C;
var parent$B = setPrototypeOf$4;
var setPrototypeOf$3 = parent$B;
var parent$A = setPrototypeOf$3;
var setPrototypeOf$2 = parent$A;
var setPrototypeOf$1 = setPrototypeOf$2;
var _Object$setPrototypeOf = /* @__PURE__ */ getDefaultExportFromCjs(setPrototypeOf$1);
var parent$z = bind$d;
var bind$7 = parent$z;
var parent$y = bind$7;
var bind$6 = parent$y;
var bind$5 = bind$6;
var _bindInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(bind$5);
function _setPrototypeOf(o, p) {
  var _context;
  _setPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$setPrototypeOf).call(_context) : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  _Object$defineProperty$1(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var parent$x = getPrototypeOf$6;
var getPrototypeOf$4 = parent$x;
var parent$w = getPrototypeOf$4;
var getPrototypeOf$3 = parent$w;
var getPrototypeOf$2 = getPrototypeOf$3;
var _Object$getPrototypeOf = /* @__PURE__ */ getDefaultExportFromCjs(getPrototypeOf$2);
function _getPrototypeOf(o) {
  var _context;
  _getPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$getPrototypeOf).call(_context) : function _getPrototypeOf2(o2) {
    return o2.__proto__ || _Object$getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    _Object$defineProperty$1(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var regeneratorRuntime$1 = { exports: {} };
var _typeof = { exports: {} };
(function(module) {
  var _Symbol2 = symbol$1;
  var _Symbol$iterator3 = iterator$1;
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof _Symbol2 && "symbol" == typeof _Symbol$iterator3 ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof _Symbol2 && o2.constructor === _Symbol2 && o2 !== _Symbol2.prototype ? "symbol" : typeof o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof);
var _typeofExports = _typeof.exports;
var parent$v = forEach$6;
var forEach$2 = parent$v;
var parent$u = forEach$2;
var forEach$1 = parent$u;
var forEach3 = forEach$1;
var hasOwn$6 = hasOwnProperty_1;
var ownKeys$6 = ownKeys$b;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys4 = ownKeys$6(source);
  var defineProperty6 = definePropertyModule.f;
  var getOwnPropertyDescriptor6 = getOwnPropertyDescriptorModule$2.f;
  for (var i = 0; i < keys4.length; i++) {
    var key = keys4[i];
    if (!hasOwn$6(target, key) && !(exceptions && hasOwn$6(exceptions, key))) {
      defineProperty6(target, key, getOwnPropertyDescriptor6(source, key));
    }
  }
};
var isObject$6 = isObject$m;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$9;
var installErrorCause$1 = function(O, options) {
  if (isObject$6(options) && "cause" in options) {
    createNonEnumerableProperty$2(O, "cause", options.cause);
  }
};
var uncurryThis$4 = functionUncurryThis;
var $Error$1 = Error;
var replace = uncurryThis$4("".replace);
var TEST = function(arg) {
  return String(new $Error$1(arg).stack);
}("zxcasd");
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var errorStackClear = function(stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error$1.prepareStackTrace) {
    while (dropEntries--)
      stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
  }
  return stack;
};
var fails$8 = fails$z;
var createPropertyDescriptor$1 = createPropertyDescriptor$7;
var errorStackInstallable = !fails$8(function() {
  var error2 = new Error("a");
  if (!("stack" in error2))
    return true;
  Object.defineProperty(error2, "stack", createPropertyDescriptor$1(1, 7));
  return error2.stack !== 7;
});
var createNonEnumerableProperty$1 = createNonEnumerableProperty$9;
var clearErrorStack = errorStackClear;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var captureStackTrace = Error.captureStackTrace;
var errorStackInstall = function(error2, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace)
      captureStackTrace(error2, C);
    else
      createNonEnumerableProperty$1(error2, "stack", clearErrorStack(stack, dropEntries));
  }
};
var toString$2 = toString$b;
var normalizeStringArgument$1 = function(argument, $default) {
  return argument === void 0 ? arguments.length < 2 ? "" : $default : toString$2(argument);
};
var $$n = _export;
var isPrototypeOf$7 = objectIsPrototypeOf;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var copyConstructorProperties = copyConstructorProperties$1;
var create$1 = objectCreate;
var createNonEnumerableProperty = createNonEnumerableProperty$9;
var createPropertyDescriptor = createPropertyDescriptor$7;
var installErrorCause = installErrorCause$1;
var installErrorStack = errorStackInstall;
var iterate$5 = iterate$8;
var normalizeStringArgument = normalizeStringArgument$1;
var wellKnownSymbol$2 = wellKnownSymbol$p;
var TO_STRING_TAG = wellKnownSymbol$2("toStringTag");
var $Error = Error;
var push$2 = [].push;
var $AggregateError = function AggregateError(errors2, message) {
  var isInstance = isPrototypeOf$7(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf) {
    that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf$1(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create$1(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
  }
  if (message !== void 0)
    createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
  installErrorStack(that, $AggregateError, that.stack, 1);
  if (arguments.length > 2)
    installErrorCause(that, arguments[2]);
  var errorsArray = [];
  iterate$5(errors2, push$2, { that: errorsArray });
  createNonEnumerableProperty(that, "errors", errorsArray);
  return that;
};
if (setPrototypeOf)
  setPrototypeOf($AggregateError, $Error);
else
  copyConstructorProperties($AggregateError, $Error, { name: true });
var AggregateErrorPrototype = $AggregateError.prototype = create$1($Error.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ""),
  name: createPropertyDescriptor(1, "AggregateError")
});
$$n({ global: true, constructor: true, arity: 2 }, {
  AggregateError: $AggregateError
});
var global$8 = global$s;
var classof$3 = classofRaw$2;
var engineIsNode = classof$3(global$8.process) === "process";
var isConstructor3 = isConstructor$4;
var tryToString = tryToString$6;
var $TypeError$2 = TypeError;
var aConstructor$2 = function(argument) {
  if (isConstructor3(argument))
    return argument;
  throw new $TypeError$2(tryToString(argument) + " is not a constructor");
};
var anObject$4 = anObject$f;
var aConstructor$1 = aConstructor$2;
var isNullOrUndefined$1 = isNullOrUndefined$7;
var wellKnownSymbol$1 = wellKnownSymbol$p;
var SPECIES$1 = wellKnownSymbol$1("species");
var speciesConstructor$2 = function(O, defaultConstructor) {
  var C = anObject$4(O).constructor;
  var S;
  return C === void 0 || isNullOrUndefined$1(S = anObject$4(C)[SPECIES$1]) ? defaultConstructor : aConstructor$1(S);
};
var userAgent$4 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);
var global$7 = global$s;
var apply$1 = functionApply;
var bind$4 = functionBindContext;
var isCallable$3 = isCallable$m;
var hasOwn$5 = hasOwnProperty_1;
var fails$7 = fails$z;
var html = html$2;
var arraySlice$1 = arraySlice$6;
var createElement = documentCreateElement$1;
var validateArgumentsLength = validateArgumentsLength$2;
var IS_IOS$1 = engineIsIos;
var IS_NODE$4 = engineIsNode;
var set$3 = global$7.setImmediate;
var clear = global$7.clearImmediate;
var process$2 = global$7.process;
var Dispatch = global$7.Dispatch;
var Function$1 = global$7.Function;
var MessageChannel = global$7.MessageChannel;
var String$1 = global$7.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location, defer, channel, port;
fails$7(function() {
  $location = global$7.location;
});
var run = function(id2) {
  if (hasOwn$5(queue$2, id2)) {
    var fn = queue$2[id2];
    delete queue$2[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var eventListener = function(event) {
  run(event.data);
};
var globalPostMessageDefer = function(id2) {
  global$7.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
};
if (!set$3 || !clear) {
  set$3 = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$3(handler) ? handler : Function$1(handler);
    var args = arraySlice$1(arguments, 1);
    queue$2[++counter] = function() {
      apply$1(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id2) {
    delete queue$2[id2];
  };
  if (IS_NODE$4) {
    defer = function(id2) {
      process$2.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$4(port.postMessage, port);
  } else if (global$7.addEventListener && isCallable$3(global$7.postMessage) && !global$7.importScripts && $location && $location.protocol !== "file:" && !fails$7(globalPostMessageDefer)) {
    defer = globalPostMessageDefer;
    global$7.addEventListener("message", eventListener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id2) {
      html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set: set$3,
  clear
};
var Queue$3 = function() {
  this.head = null;
  this.tail = null;
};
Queue$3.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    var tail = this.tail;
    if (tail)
      tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      var next3 = this.head = entry.next;
      if (next3 === null)
        this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$3;
var userAgent$3 = engineUserAgent;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && typeof Pebble != "undefined";
var userAgent$2 = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);
var global$6 = global$s;
var bind$3 = functionBindContext;
var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var Queue$2 = queue$1;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$3 = engineIsNode;
var MutationObserver = global$6.MutationObserver || global$6.WebKitMutationObserver;
var document$2 = global$6.document;
var process$1 = global$6.process;
var Promise$1 = global$6.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$7(global$6, "queueMicrotask");
var microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify$1, toggle, node, promise$5, then;
if (!microtask$1) {
  var queue = new Queue$2();
  var flush = function() {
    var parent2, fn;
    if (IS_NODE$3 && (parent2 = process$1.domain))
      parent2.exit();
    while (fn = queue.get())
      try {
        fn();
      } catch (error2) {
        if (queue.head)
          notify$1();
        throw error2;
      }
    if (parent2)
      parent2.enter();
  };
  if (!IS_IOS && !IS_NODE$3 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver(flush).observe(node, { characterData: true });
    notify$1 = function() {
      node.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    promise$5 = Promise$1.resolve(void 0);
    promise$5.constructor = Promise$1;
    then = bind$3(promise$5.then, promise$5);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$3) {
    notify$1 = function() {
      process$1.nextTick(flush);
    };
  } else {
    macrotask = bind$3(macrotask, global$6);
    notify$1 = function() {
      macrotask(flush);
    };
  }
  microtask$1 = function(fn) {
    if (!queue.head)
      notify$1();
    queue.add(fn);
  };
}
var microtask_1 = microtask$1;
var hostReportErrors$1 = function(a, b) {
  try {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error2) {
  }
};
var perform$6 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error2) {
    return { error: true, value: error2 };
  }
};
var global$5 = global$s;
var promiseNativeConstructor = global$5.Promise;
var engineIsDeno = typeof Deno == "object" && Deno && typeof Deno.version == "object";
var IS_DENO$1 = engineIsDeno;
var IS_NODE$2 = engineIsNode;
var engineIsBrowser = !IS_DENO$1 && !IS_NODE$2 && typeof window == "object" && typeof document == "object";
var global$4 = global$s;
var NativePromiseConstructor$5 = promiseNativeConstructor;
var isCallable$2 = isCallable$m;
var isForced = isForced_1;
var inspectSource = inspectSource$2;
var wellKnownSymbol = wellKnownSymbol$p;
var IS_BROWSER = engineIsBrowser;
var IS_DENO = engineIsDeno;
var V8_VERSION = engineV8Version;
var NativePromisePrototype$2 = NativePromiseConstructor$5 && NativePromiseConstructor$5.prototype;
var SPECIES = wellKnownSymbol("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(global$4.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced("Promise", function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$5);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$5);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
    return true;
  if (!(NativePromisePrototype$2["catch"] && NativePromisePrototype$2["finally"]))
    return true;
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    var promise2 = new NativePromiseConstructor$5(function(resolve2) {
      resolve2(1);
    });
    var FakePromise = function(exec2) {
      exec2(function() {
      }, function() {
      });
    };
    var constructor = promise2.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise2.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING)
      return true;
  }
  return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING
};
var newPromiseCapability$2 = {};
var aCallable$8 = aCallable$e;
var $TypeError$1 = TypeError;
var PromiseCapability = function(C) {
  var resolve2, reject2;
  this.promise = new C(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw new $TypeError$1("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$8(resolve2);
  this.reject = aCallable$8(reject2);
};
newPromiseCapability$2.f = function(C) {
  return new PromiseCapability(C);
};
var $$m = _export;
var IS_NODE$1 = engineIsNode;
var global$3 = global$s;
var call$6 = functionCall;
var defineBuiltIn = defineBuiltIn$6;
var setToStringTag = setToStringTag$7;
var setSpecies = setSpecies$2;
var aCallable$7 = aCallable$e;
var isCallable$1 = isCallable$m;
var isObject$5 = isObject$m;
var anInstance$1 = anInstance$4;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask_1;
var hostReportErrors = hostReportErrors$1;
var perform$5 = perform$6;
var Queue$1 = queue$1;
var InternalStateModule$1 = internalState;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$7 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var NativePromisePrototype$1 = NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var PromiseConstructor = NativePromiseConstructor$4;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = global$3.TypeError;
var document$1 = global$3.document;
var process = global$3.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$7.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper;
var isThenable = function(it3) {
  var then2;
  return isObject$5(it3) && isCallable$1(then2 = it3.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED)
          onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true)
        result = value;
      else {
        if (domain)
          domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(new TypeError$1("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$6(then2, result, resolve2, reject2);
      } else
        resolve2(result);
    } else
      reject2(value);
  } catch (error2) {
    if (domain && !exited)
      domain.exit();
    reject2(error2);
  }
};
var notify = function(state, isReject) {
  if (state.notified)
    return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection)
      onUnhandled(state);
  });
};
var dispatchEvent = function(name2, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name2, false, true);
    global$3.dispatchEvent(event);
  } else
    event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$3["on" + name2]))
    handler(event);
  else if (name2 === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$6(task, global$3, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$5(function() {
        if (IS_NODE$1) {
          process.emit("unhandledRejection", value, promise2);
        } else
          dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error)
        throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$6(task, global$3, function() {
    var promise2 = state.facade;
    if (IS_NODE$1) {
      process.emit("rejectionHandled", promise2);
    } else
      dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$2 = function(fn, state, unwrap2) {
  return function(value) {
    fn(state, value, unwrap2);
  };
};
var internalReject = function(state, value, unwrap2) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap2)
    state = unwrap2;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap2) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap2)
    state = unwrap2;
  try {
    if (state.facade === value)
      throw new TypeError$1("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper2 = { done: false };
        try {
          call$6(
            then2,
            value,
            bind$2(internalResolve, wrapper2, state),
            bind$2(internalReject, wrapper2, state)
          );
        } catch (error2) {
          internalReject(wrapper2, error2, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error2) {
    internalReject({ done: false }, error2, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance$1(this, PromisePrototype);
    aCallable$7(executor);
    call$6(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$2(internalResolve, state), bind$2(internalReject, state));
    } catch (error2) {
      internalReject(state, error2);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue$1(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$1(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$1(onRejected) && onRejected;
    reaction.domain = IS_NODE$1 ? process.domain : void 0;
    if (state.state === PENDING)
      state.reactions.add(reaction);
    else
      microtask(function() {
        callReaction(reaction, state);
      });
    return reaction.promise;
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalPromiseState(promise2);
    this.promise = promise2;
    this.resolve = bind$2(internalResolve, state);
    this.reject = bind$2(internalReject, state);
  };
  newPromiseCapabilityModule$7.f = newPromiseCapability$1 = function(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}
$$m({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
var NativePromiseConstructor$3 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {
  NativePromiseConstructor$3.all(iterable).then(void 0, function() {
  });
});
var $$l = _export;
var call$5 = functionCall;
var aCallable$6 = aCallable$e;
var newPromiseCapabilityModule$6 = newPromiseCapability$2;
var perform$4 = perform$6;
var iterate$4 = iterate$8;
var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration;
$$l({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$3 }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$6.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$4(function() {
      var $promiseResolve = aCallable$6(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$4(iterable, function(promise2) {
        var index2 = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$5($promiseResolve, C, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index2] = value;
          --remaining || resolve2(values2);
        }, reject2);
      });
      --remaining || resolve2(values2);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$k = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor$2 = promiseNativeConstructor;
NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
$$k({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  "catch": function(onRejected) {
    return this.then(void 0, onRejected);
  }
});
var $$j = _export;
var call$4 = functionCall;
var aCallable$5 = aCallable$e;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var perform$3 = perform$6;
var iterate$3 = iterate$8;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration;
$$j({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2 }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$5.f(C);
    var reject2 = capability.reject;
    var result = perform$3(function() {
      var $promiseResolve = aCallable$5(C.resolve);
      iterate$3(iterable, function(promise2) {
        call$4($promiseResolve, C, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$i = _export;
var call$3 = functionCall;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$i({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule$4.f(this);
    call$3(capability.reject, void 0, r);
    return capability.promise;
  }
});
var anObject$3 = anObject$f;
var isObject$4 = isObject$m;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function(C, x2) {
  anObject$3(C);
  if (isObject$4(x2) && x2.constructor === C)
    return x2;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x2);
  return promiseCapability.promise;
};
var $$h = _export;
var getBuiltIn$3 = getBuiltIn$f;
var IS_PURE = isPure;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
var PromiseConstructorWrapper = getBuiltIn$3("Promise");
var CHECK_WRAPPER = !FORCED_PROMISE_CONSTRUCTOR;
$$h({ target: "Promise", stat: true, forced: IS_PURE }, {
  resolve: function resolve(x2) {
    return promiseResolve$1(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor$1 : this, x2);
  }
});
var $$g = _export;
var call$2 = functionCall;
var aCallable$4 = aCallable$e;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$2 = perform$6;
var iterate$2 = iterate$8;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$g({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$3.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$2(function() {
      var promiseResolve2 = aCallable$4(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$2(iterable, function(promise2) {
        var index2 = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$2(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index2] = { status: "fulfilled", value };
          --remaining || resolve2(values2);
        }, function(error2) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index2] = { status: "rejected", reason: error2 };
          --remaining || resolve2(values2);
        });
      });
      --remaining || resolve2(values2);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$f = _export;
var call$1 = functionCall;
var aCallable$3 = aCallable$e;
var getBuiltIn$2 = getBuiltIn$f;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$6;
var iterate$1 = iterate$8;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
var PROMISE_ANY_ERROR = "No one promise resolved";
$$f({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  any: function any(iterable) {
    var C = this;
    var AggregateError2 = getBuiltIn$2("AggregateError");
    var capability = newPromiseCapabilityModule$2.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$1(function() {
      var promiseResolve2 = aCallable$3(C.resolve);
      var errors2 = [];
      var counter2 = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate$1(iterable, function(promise2) {
        var index2 = counter2++;
        var alreadyRejected = false;
        remaining++;
        call$1(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyRejected || alreadyResolved)
            return;
          alreadyResolved = true;
          resolve2(value);
        }, function(error2) {
          if (alreadyRejected || alreadyResolved)
            return;
          alreadyRejected = true;
          errors2[index2] = error2;
          --remaining || reject2(new AggregateError2(errors2, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject2(new AggregateError2(errors2, PROMISE_ANY_ERROR));
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$e = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails$6 = fails$z;
var getBuiltIn$1 = getBuiltIn$f;
var isCallable = isCallable$m;
var speciesConstructor = speciesConstructor$2;
var promiseResolve = promiseResolve$2;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var NON_GENERIC = !!NativePromiseConstructor && fails$6(function() {
  NativePromisePrototype["finally"].call({ then: function() {
  } }, function() {
  });
});
$$e({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
  "finally": function(onFinally) {
    var C = speciesConstructor(this, getBuiltIn$1("Promise"));
    var isFunction2 = isCallable(onFinally);
    return this.then(
      isFunction2 ? function(x2) {
        return promiseResolve(C, onFinally()).then(function() {
          return x2;
        });
      } : onFinally,
      isFunction2 ? function(e) {
        return promiseResolve(C, onFinally()).then(function() {
          throw e;
        });
      } : onFinally
    );
  }
});
var path$c = path$y;
var promise$4 = path$c.Promise;
var parent$t = promise$4;
var promise$3 = parent$t;
var $$d = _export;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
$$d({ target: "Promise", stat: true }, {
  withResolvers: function withResolvers() {
    var promiseCapability = newPromiseCapabilityModule$1.f(this);
    return {
      promise: promiseCapability.promise,
      resolve: promiseCapability.resolve,
      reject: promiseCapability.reject
    };
  }
});
var parent$s = promise$3;
var promise$2 = parent$s;
var $$c = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$6;
$$c({ target: "Promise", stat: true, forced: true }, {
  "try": function(callbackfn) {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    var result = perform(callbackfn);
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});
var parent$r = promise$2;
var promise$1 = parent$r;
var promise = promise$1;
var parent$q = reverse$4;
var reverse$2 = parent$q;
var parent$p = reverse$2;
var reverse$1 = parent$p;
var reverse2 = reverse$1;
(function(module) {
  var _typeof2 = _typeofExports["default"];
  var _Object$defineProperty2 = defineProperty$6;
  var _Symbol2 = symbol$1;
  var _Object$create2 = create$2;
  var _Object$getPrototypeOf2 = getPrototypeOf$2;
  var _forEachInstanceProperty2 = forEach3;
  var _pushInstanceProperty2 = push$3;
  var _Object$setPrototypeOf2 = setPrototypeOf$1;
  var _Promise = promise;
  var _reverseInstanceProperty2 = reverse2;
  var _sliceInstanceProperty2 = slice$1;
  function _regeneratorRuntime2() {
    module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = _Object$defineProperty2 || function(t2, e2, r2) {
      t2[e2] = r2.value;
    }, i = "function" == typeof _Symbol2 ? _Symbol2 : {}, a = i.iterator || "@@iterator", c2 = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define2(t2, e2, r2) {
      return _Object$defineProperty2(t2, e2, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t2[e2];
    }
    try {
      define2({}, "");
    } catch (t2) {
      define2 = function define3(t3, e2, r2) {
        return t3[e2] = r2;
      };
    }
    function wrap2(t2, e2, r2, n2) {
      var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = _Object$create2(i2.prototype), c3 = new Context(n2 || []);
      return o(a2, "_invoke", {
        value: makeInvokeMethod(t2, r2, c3)
      }), a2;
    }
    function tryCatch(t2, e2, r2) {
      try {
        return {
          type: "normal",
          arg: t2.call(e2, r2)
        };
      } catch (t3) {
        return {
          type: "throw",
          arg: t3
        };
      }
    }
    e.wrap = wrap2;
    var h2 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y2 = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p = {};
    define2(p, a, function() {
      return this;
    });
    var d = _Object$getPrototypeOf2, v2 = d && d(d(values2([])));
    v2 && v2 !== r && n.call(v2, a) && (p = v2);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = _Object$create2(p);
    function defineIteratorMethods(t2) {
      var _context;
      _forEachInstanceProperty2(_context = ["next", "throw", "return"]).call(_context, function(e2) {
        define2(t2, e2, function(t3) {
          return this._invoke(e2, t3);
        });
      });
    }
    function AsyncIterator(t2, e2) {
      function invoke(r3, o2, i2, a2) {
        var c3 = tryCatch(t2[r3], t2, o2);
        if ("throw" !== c3.type) {
          var u2 = c3.arg, h3 = u2.value;
          return h3 && "object" == _typeof2(h3) && n.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
            invoke("next", t3, i2, a2);
          }, function(t3) {
            invoke("throw", t3, i2, a2);
          }) : e2.resolve(h3).then(function(t3) {
            u2.value = t3, i2(u2);
          }, function(t3) {
            return invoke("throw", t3, i2, a2);
          });
        }
        a2(c3.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e2, r2, n2) {
      var o2 = h2;
      return function(i2, a2) {
        if (o2 === f)
          throw new Error("Generator is already running");
        if (o2 === s) {
          if ("throw" === i2)
            throw a2;
          return {
            value: t,
            done: true
          };
        }
        for (n2.method = i2, n2.arg = a2; ; ) {
          var c3 = n2.delegate;
          if (c3) {
            var u2 = maybeInvokeDelegate(c3, n2);
            if (u2) {
              if (u2 === y2)
                continue;
              return u2;
            }
          }
          if ("next" === n2.method)
            n2.sent = n2._sent = n2.arg;
          else if ("throw" === n2.method) {
            if (o2 === h2)
              throw o2 = s, n2.arg;
            n2.dispatchException(n2.arg);
          } else
            "return" === n2.method && n2.abrupt("return", n2.arg);
          o2 = f;
          var p2 = tryCatch(e2, r2, n2);
          if ("normal" === p2.type) {
            if (o2 = n2.done ? s : l, p2.arg === y2)
              continue;
            return {
              value: p2.arg,
              done: n2.done
            };
          }
          "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
        }
      };
    }
    function maybeInvokeDelegate(e2, r2) {
      var n2 = r2.method, o2 = e2.iterator[n2];
      if (o2 === t)
        return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y2;
      var i2 = tryCatch(o2, e2.iterator, r2.arg);
      if ("throw" === i2.type)
        return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y2;
      var a2 = i2.arg;
      return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y2) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y2);
    }
    function pushTryEntry(t2) {
      var _context2;
      var e2 = {
        tryLoc: t2[0]
      };
      1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), _pushInstanceProperty2(_context2 = this.tryEntries).call(_context2, e2);
    }
    function resetTryEntry(t2) {
      var e2 = t2.completion || {};
      e2.type = "normal", delete e2.arg, t2.completion = e2;
    }
    function Context(t2) {
      this.tryEntries = [{
        tryLoc: "root"
      }], _forEachInstanceProperty2(t2).call(t2, pushTryEntry, this), this.reset(true);
    }
    function values2(e2) {
      if (e2 || "" === e2) {
        var r2 = e2[a];
        if (r2)
          return r2.call(e2);
        if ("function" == typeof e2.next)
          return e2;
        if (!isNaN(e2.length)) {
          var o2 = -1, i2 = function next3() {
            for (; ++o2 < e2.length; )
              if (n.call(e2, o2))
                return next3.value = e2[o2], next3.done = false, next3;
            return next3.value = t, next3.done = true, next3;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof2(e2) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
      var e2 = "function" == typeof t2 && t2.constructor;
      return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
    }, e.mark = function(t2) {
      return _Object$setPrototypeOf2 ? _Object$setPrototypeOf2(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = _Object$create2(g), t2;
    }, e.awrap = function(t2) {
      return {
        __await: t2
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c2, function() {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
      void 0 === i2 && (i2 = _Promise);
      var a2 = new AsyncIterator(wrap2(t2, r2, n2, o2), i2);
      return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
        return t3.done ? t3.value : a2.next();
      });
    }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
      return this;
    }), define2(g, "toString", function() {
      return "[object Generator]";
    }), e.keys = function(t2) {
      var e2 = Object(t2), r2 = [];
      for (var n2 in e2)
        _pushInstanceProperty2(r2).call(r2, n2);
      return _reverseInstanceProperty2(r2).call(r2), function next3() {
        for (; r2.length; ) {
          var t3 = r2.pop();
          if (t3 in e2)
            return next3.value = t3, next3.done = false, next3;
        }
        return next3.done = true, next3;
      };
    }, e.values = values2, Context.prototype = {
      constructor: Context,
      reset: function reset(e2) {
        var _context3;
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, _forEachInstanceProperty2(_context3 = this.tryEntries).call(_context3, resetTryEntry), !e2)
          for (var r2 in this)
            "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+_sliceInstanceProperty2(r2).call(r2, 1)) && (this[r2] = t);
      },
      stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type)
          throw t2.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e2) {
        if (this.done)
          throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc)
            return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c3 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c3 && u2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            } else if (c3) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
            } else {
              if (!u2)
                throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y2) : this.complete(a2);
      },
      complete: function complete(t2, e2) {
        if ("throw" === t2.type)
          throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y2;
      },
      finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2)
            return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y2;
        }
      },
      "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = {
          iterator: values2(e2),
          resultName: r2,
          nextLoc: n2
        }, "next" === this.method && (this.arg = t), y2;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;
var runtime = regeneratorRuntimeExports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
var _regeneratorRuntime = /* @__PURE__ */ getDefaultExportFromCjs(regenerator);
var aCallable$2 = aCallable$e;
var toObject$2 = toObject$f;
var IndexedObject = indexedObject;
var lengthOfArrayLike$3 = lengthOfArrayLike$e;
var $TypeError = TypeError;
var createMethod = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable$2(callbackfn);
    var O = toObject$2(that);
    var self2 = IndexedObject(O);
    var length2 = lengthOfArrayLike$3(O);
    var index2 = IS_RIGHT ? length2 - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i;
          break;
        }
        index2 += i;
        if (IS_RIGHT ? index2 < 0 : length2 <= index2) {
          throw new $TypeError("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index2 >= 0 : length2 > index2; index2 += i)
      if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O);
      }
    return memo;
  };
};
var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};
var $$b = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$6;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED$5 = CHROME_BUG || !arrayMethodIsStrict$2("reduce");
$$b({ target: "Array", proto: true, forced: FORCED$5 }, {
  reduce: function reduce(callbackfn) {
    var length2 = arguments.length;
    return $reduce(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$6 = entryVirtual$l;
var reduce$3 = entryVirtual$6("Array").reduce;
var isPrototypeOf$6 = objectIsPrototypeOf;
var method$6 = reduce$3;
var ArrayPrototype$6 = Array.prototype;
var reduce$2 = function(it3) {
  var own = it3.reduce;
  return it3 === ArrayPrototype$6 || isPrototypeOf$6(ArrayPrototype$6, it3) && own === ArrayPrototype$6.reduce ? method$6 : own;
};
var parent$o = reduce$2;
var reduce$1 = parent$o;
var reduce2 = reduce$1;
var _reduceInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(reduce2);
var isArray$1 = isArray$f;
var lengthOfArrayLike$2 = lengthOfArrayLike$e;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$4;
var bind$1 = functionBindContext;
var flattenIntoArray$1 = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
  var targetIndex = start2;
  var sourceIndex = 0;
  var mapFn = mapper ? bind$1(mapper, thisArg) : false;
  var element, elementLen;
  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      if (depth > 0 && isArray$1(element)) {
        elementLen = lengthOfArrayLike$2(element);
        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger(targetIndex + 1);
        target[targetIndex] = element;
      }
      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};
var flattenIntoArray_1 = flattenIntoArray$1;
var $$a = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$1 = aCallable$e;
var toObject$1 = toObject$f;
var lengthOfArrayLike$1 = lengthOfArrayLike$e;
var arraySpeciesCreate = arraySpeciesCreate$4;
$$a({ target: "Array", proto: true }, {
  flatMap: function flatMap(callbackfn) {
    var O = toObject$1(this);
    var sourceLen = lengthOfArrayLike$1(O);
    var A2;
    aCallable$1(callbackfn);
    A2 = arraySpeciesCreate(O, 0);
    A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return A2;
  }
});
var entryVirtual$5 = entryVirtual$l;
entryVirtual$5("Array").flatMap;
var collection$1 = collection$3;
var collectionStrong = collectionStrong$2;
collection$1("Set", function(init2) {
  return function Set2() {
    return init2(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
var path$b = path$y;
var set$2 = path$b.Set;
var parent$m = set$2;
var set$1 = parent$m;
var set2 = set$1;
var _Set = /* @__PURE__ */ getDefaultExportFromCjs(set2);
var iterator = iterator$4;
var _Symbol$iterator2 = /* @__PURE__ */ getDefaultExportFromCjs(iterator);
var getIterator$5 = getIterator$8;
var getIterator_1 = getIterator$5;
var parent$l = getIterator_1;
var getIterator$4 = parent$l;
var parent$k = getIterator$4;
var getIterator$3 = parent$k;
var parent$j = getIterator$3;
var getIterator$2 = parent$j;
var getIterator$1 = getIterator$2;
var getIterator = getIterator$1;
var _getIterator = /* @__PURE__ */ getDefaultExportFromCjs(getIterator);
var arraySlice = arraySliceSimple;
var floor = Math.floor;
var mergeSort = function(array2, comparefn) {
  var length2 = array2.length;
  var middle = floor(length2 / 2);
  return length2 < 8 ? insertionSort(array2, comparefn) : merge(
    array2,
    mergeSort(arraySlice(array2, 0, middle), comparefn),
    mergeSort(arraySlice(array2, middle), comparefn),
    comparefn
  );
};
var insertionSort = function(array2, comparefn) {
  var length2 = array2.length;
  var i = 1;
  var element, j2;
  while (i < length2) {
    j2 = i;
    element = array2[i];
    while (j2 && comparefn(array2[j2 - 1], element) > 0) {
      array2[j2] = array2[--j2];
    }
    if (j2 !== i++)
      array2[j2] = element;
  }
  return array2;
};
var merge = function(array2, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }
  return array2;
};
var arraySort = mergeSort;
var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$9 = _export;
var uncurryThis$3 = functionUncurryThis;
var aCallable = aCallable$e;
var toObject = toObject$f;
var lengthOfArrayLike = lengthOfArrayLike$e;
var deletePropertyOrThrow = deletePropertyOrThrow$2;
var toString$1 = toString$b;
var fails$5 = fails$z;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$6;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test2 = [];
var nativeSort = uncurryThis$3(test2.sort);
var push$1 = uncurryThis$3(test2.push);
var FAILS_ON_UNDEFINED = fails$5(function() {
  test2.sort(void 0);
});
var FAILS_ON_NULL = fails$5(function() {
  test2.sort(null);
});
var STRICT_METHOD$1 = arrayMethodIsStrict$1("sort");
var STABLE_SORT = !fails$5(function() {
  if (V8)
    return V8 < 70;
  if (FF && FF > 3)
    return;
  if (IE_OR_EDGE)
    return true;
  if (WEBKIT)
    return WEBKIT < 603;
  var result = "";
  var code2, chr, value, index2;
  for (code2 = 65; code2 < 76; code2++) {
    chr = String.fromCharCode(code2);
    switch (code2) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index2 = 0; index2 < 47; index2++) {
      test2.push({ k: chr + index2, v: value });
    }
  }
  test2.sort(function(a, b) {
    return b.v - a.v;
  });
  for (index2 = 0; index2 < test2.length; index2++) {
    chr = test2[index2].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr)
      result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;
var getSortCompare = function(comparefn) {
  return function(x2, y2) {
    if (y2 === void 0)
      return -1;
    if (x2 === void 0)
      return 1;
    if (comparefn !== void 0)
      return +comparefn(x2, y2) || 0;
    return toString$1(x2) > toString$1(y2) ? 1 : -1;
  };
};
$$9({ target: "Array", proto: true, forced: FORCED$4 }, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0)
      aCallable(comparefn);
    var array2 = toObject(this);
    if (STABLE_SORT)
      return comparefn === void 0 ? nativeSort(array2) : nativeSort(array2, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike(array2);
    var itemsLength, index2;
    for (index2 = 0; index2 < arrayLength; index2++) {
      if (index2 in array2)
        push$1(items, array2[index2]);
    }
    internalSort(items, getSortCompare(comparefn));
    itemsLength = lengthOfArrayLike(items);
    index2 = 0;
    while (index2 < itemsLength)
      array2[index2] = items[index2++];
    while (index2 < arrayLength)
      deletePropertyOrThrow(array2, index2++);
    return array2;
  }
});
var entryVirtual$4 = entryVirtual$l;
var sort$3 = entryVirtual$4("Array").sort;
var isPrototypeOf$4 = objectIsPrototypeOf;
var method$4 = sort$3;
var ArrayPrototype$4 = Array.prototype;
var sort$2 = function(it3) {
  var own = it3.sort;
  return it3 === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it3) && own === ArrayPrototype$4.sort ? method$4 : own;
};
var parent$i = sort$2;
var sort$1 = parent$i;
var sort2 = sort$1;
var _sortInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(sort2);
var entryVirtual$3 = entryVirtual$l;
var keys$3 = entryVirtual$3("Array").keys;
var parent$h = keys$3;
var keys$2 = parent$h;
var classof$2 = classof$f;
var hasOwn$4 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var method$3 = keys$2;
var ArrayPrototype$3 = Array.prototype;
var DOMIterables$2 = {
  DOMTokenList: true,
  NodeList: true
};
var keys$1 = function(it3) {
  var own = it3.keys;
  return it3 === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it3) && own === ArrayPrototype$3.keys || hasOwn$4(DOMIterables$2, classof$2(it3)) ? method$3 : own;
};
var keys3 = keys$1;
var _keysInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(keys3);
var entryVirtual$2 = entryVirtual$l;
var values$3 = entryVirtual$2("Array").values;
var parent$g = values$3;
var values$2 = parent$g;
var classof$1 = classof$f;
var hasOwn$3 = hasOwnProperty_1;
var isPrototypeOf$2 = objectIsPrototypeOf;
var method$2 = values$2;
var ArrayPrototype$2 = Array.prototype;
var DOMIterables$1 = {
  DOMTokenList: true,
  NodeList: true
};
var values$1 = function(it3) {
  var own = it3.values;
  return it3 === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it3) && own === ArrayPrototype$2.values || hasOwn$3(DOMIterables$1, classof$1(it3)) ? method$2 : own;
};
var values = values$1;
var _valuesInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(values);
var entryVirtual$1 = entryVirtual$l;
var entries$3 = entryVirtual$1("Array").entries;
var parent$f = entries$3;
var entries$2 = parent$f;
var classof = classof$f;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var method$1 = entries$2;
var ArrayPrototype$1 = Array.prototype;
var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};
var entries$1 = function(it3) {
  var own = it3.entries;
  return it3 === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it3) && own === ArrayPrototype$1.entries || hasOwn$2(DOMIterables, classof(it3)) ? method$1 : own;
};
var entries = entries$1;
var _entriesInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(entries);
var defineProperty5 = defineProperty$9;
var _Object$defineProperty = /* @__PURE__ */ getDefaultExportFromCjs(defineProperty5);
var $$8 = _export;
var getBuiltIn = getBuiltIn$f;
var apply = functionApply;
var bind2 = functionBind;
var aConstructor = aConstructor$2;
var anObject$2 = anObject$f;
var isObject$3 = isObject$m;
var create4 = objectCreate;
var fails$4 = fails$z;
var nativeConstruct = getBuiltIn("Reflect", "construct");
var ObjectPrototype = Object.prototype;
var push2 = [].push;
var NEW_TARGET_BUG = fails$4(function() {
  function F() {
  }
  return !(nativeConstruct(function() {
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$4(function() {
  nativeConstruct(function() {
  });
});
var FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;
$$8({ target: "Reflect", stat: true, forced: FORCED$3, sham: FORCED$3 }, {
  construct: function construct(Target, args) {
    aConstructor(Target);
    anObject$2(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG)
      return nativeConstruct(Target, args, newTarget);
    if (Target === newTarget) {
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      var $args = [null];
      apply(push2, $args, args);
      return new (apply(bind2, Target, $args))();
    }
    var proto = newTarget.prototype;
    var instance = create4(isObject$3(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject$3(result) ? result : instance;
  }
});
var path$a = path$y;
var construct$2 = path$a.Reflect.construct;
var parent$e = construct$2;
var construct$1 = parent$e;
var construct2 = construct$1;
var _Reflect$construct = /* @__PURE__ */ getDefaultExportFromCjs(construct2);
var path$9 = path$y;
var getOwnPropertySymbols$2 = path$9.Object.getOwnPropertySymbols;
var parent$d = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$d;
var getOwnPropertySymbols2 = getOwnPropertySymbols$1;
var _Object$getOwnPropertySymbols = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertySymbols2);
var getOwnPropertyDescriptor$6 = { exports: {} };
var $$7 = _export;
var fails$3 = fails$z;
var toIndexedObject$1 = toIndexedObject$a;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$2 = descriptors;
var FORCED$2 = !DESCRIPTORS$2 || fails$3(function() {
  nativeGetOwnPropertyDescriptor(1);
});
$$7({ target: "Object", stat: true, forced: FORCED$2, sham: !DESCRIPTORS$2 }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it3, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject$1(it3), key);
  }
});
var path$8 = path$y;
var Object$3 = path$8.Object;
var getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor4(it3, key) {
  return Object$3.getOwnPropertyDescriptor(it3, key);
};
if (Object$3.getOwnPropertyDescriptor.sham)
  getOwnPropertyDescriptor$5.sham = true;
var getOwnPropertyDescriptorExports = getOwnPropertyDescriptor$6.exports;
var parent$c = getOwnPropertyDescriptorExports;
var getOwnPropertyDescriptor$4 = parent$c;
var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;
var _Object$getOwnPropertyDescriptor$1 = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertyDescriptor$3);
var $$6 = _export;
var DESCRIPTORS$1 = descriptors;
var ownKeys$5 = ownKeys$b;
var toIndexedObject = toIndexedObject$a;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var createProperty = createProperty$6;
$$6({ target: "Object", stat: true, sham: !DESCRIPTORS$1 }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object2) {
    var O = toIndexedObject(object2);
    var getOwnPropertyDescriptor6 = getOwnPropertyDescriptorModule$1.f;
    var keys4 = ownKeys$5(O);
    var result = {};
    var index2 = 0;
    var key, descriptor;
    while (keys4.length > index2) {
      descriptor = getOwnPropertyDescriptor6(O, key = keys4[index2++]);
      if (descriptor !== void 0)
        createProperty(result, key, descriptor);
    }
    return result;
  }
});
var path$7 = path$y;
var getOwnPropertyDescriptors$2 = path$7.Object.getOwnPropertyDescriptors;
var parent$b = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$b;
var getOwnPropertyDescriptors2 = getOwnPropertyDescriptors$1;
var _Object$getOwnPropertyDescriptors = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertyDescriptors2);
var defineProperties$4 = { exports: {} };
var $$5 = _export;
var DESCRIPTORS = descriptors;
var defineProperties$3 = objectDefineProperties.f;
$$5({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties$3, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties$3
});
var path$6 = path$y;
var Object$2 = path$6.Object;
var defineProperties$2 = defineProperties$4.exports = function defineProperties3(T2, D) {
  return Object$2.defineProperties(T2, D);
};
if (Object$2.defineProperties.sham)
  defineProperties$2.sham = true;
var definePropertiesExports = defineProperties$4.exports;
var parent$a = definePropertiesExports;
var defineProperties$1 = parent$a;
var defineProperties4 = defineProperties$1;
var _Object$defineProperties = /* @__PURE__ */ getDefaultExportFromCjs(defineProperties4);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var _Symbol$iterator;
function ownKeys$4(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor$1(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context32, _context33;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context32 = ownKeys$4(Object(t), true)).call(_context32, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context33 = ownKeys$4(Object(t))).call(_context33, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor$1(t, r2));
    });
  }
  return e;
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _createForOfIteratorHelper$6(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$6(o, minLen) {
  var _context31;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$6(o, minLen);
  var n = _sliceInstanceProperty(_context31 = Object.prototype.toString.call(o)).call(_context31, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function isId(value) {
  return typeof value === "string" || typeof value === "number";
}
var Queue = /* @__PURE__ */ function() {
  function Queue2(options) {
    _classCallCheck(this, Queue2);
    _defineProperty(this, "delay", void 0);
    _defineProperty(this, "max", void 0);
    _defineProperty(this, "_queue", []);
    _defineProperty(this, "_timeout", null);
    _defineProperty(this, "_extended", null);
    this.delay = null;
    this.max = Infinity;
    this.setOptions(options);
  }
  _createClass(Queue2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options && typeof options.delay !== "undefined") {
        this.delay = options.delay;
      }
      if (options && typeof options.max !== "undefined") {
        this.max = options.max;
      }
      this._flushIfNeeded();
    }
    /**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     * @returns The created queue.
     */
  }, {
    key: "destroy",
    value: (
      /**
       * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
       */
      function destroy() {
        this.flush();
        if (this._extended) {
          var object2 = this._extended.object;
          var methods = this._extended.methods;
          for (var i = 0; i < methods.length; i++) {
            var method2 = methods[i];
            if (method2.original) {
              object2[method2.name] = method2.original;
            } else {
              delete object2[method2.name];
            }
          }
          this._extended = null;
        }
      }
    )
    /**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */
  }, {
    key: "replace",
    value: function replace2(object2, method2) {
      var me = this;
      var original = object2[method2];
      if (!original) {
        throw new Error("Method " + method2 + " undefined");
      }
      object2[method2] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        me.queue({
          args,
          fn: original,
          context: this
        });
      };
    }
    /**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */
  }, {
    key: "queue",
    value: function queue(entry) {
      if (typeof entry === "function") {
        this._queue.push({
          fn: entry
        });
      } else {
        this._queue.push(entry);
      }
      this._flushIfNeeded();
    }
    /**
     * Check whether the queue needs to be flushed.
     */
  }, {
    key: "_flushIfNeeded",
    value: function _flushIfNeeded() {
      var _this = this;
      if (this._queue.length > this.max) {
        this.flush();
      }
      if (this._timeout != null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }
      if (this.queue.length > 0 && typeof this.delay === "number") {
        this._timeout = _setTimeout(function() {
          _this.flush();
        }, this.delay);
      }
    }
    /**
     * Flush all queued calls
     */
  }, {
    key: "flush",
    value: function flush() {
      var _context5, _context6;
      _forEachInstanceProperty(_context5 = _spliceInstanceProperty(_context6 = this._queue).call(_context6, 0)).call(_context5, function(entry) {
        entry.fn.apply(entry.context || entry.fn, entry.args || []);
      });
    }
  }], [{
    key: "extend",
    value: function extend2(object2, options) {
      var queue = new Queue2(options);
      if (object2.flush !== void 0) {
        throw new Error("Target object already has a property flush");
      }
      object2.flush = function() {
        queue.flush();
      };
      var methods = [{
        name: "flush",
        original: void 0
      }];
      if (options && options.replace) {
        for (var i = 0; i < options.replace.length; i++) {
          var name2 = options.replace[i];
          methods.push({
            name: name2,
            // @TODO: better solution?
            original: object2[name2]
          });
          queue.replace(object2, name2);
        }
      }
      queue._extended = {
        object: object2,
        methods
      };
      return queue;
    }
  }]);
  return Queue2;
}();
var DataSetPart = /* @__PURE__ */ function() {
  function DataSetPart2() {
    _classCallCheck(this, DataSetPart2);
    _defineProperty(this, "_subscribers", {
      "*": [],
      add: [],
      remove: [],
      update: []
    });
    _defineProperty(this, "subscribe", DataSetPart2.prototype.on);
    _defineProperty(this, "unsubscribe", DataSetPart2.prototype.off);
  }
  _createClass(DataSetPart2, [{
    key: "_trigger",
    value: (
      /**
       * Trigger an event
       *
       * @param event - Event name.
       * @param payload - Event payload.
       * @param senderId - Id of the sender.
       */
      function _trigger(event, payload, senderId) {
        var _context7, _context8;
        if (event === "*") {
          throw new Error("Cannot trigger event *");
        }
        _forEachInstanceProperty(_context7 = _concatInstanceProperty(_context8 = []).call(_context8, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers["*"]))).call(_context7, function(subscriber) {
          subscriber(event, payload, senderId != null ? senderId : null);
        });
      }
    )
    /**
     * Subscribe to an event, add an event listener.
     *
     * @remarks Non-function callbacks are ignored.
     * @param event - Event name.
     * @param callback - Callback method.
     */
  }, {
    key: "on",
    value: function on(event, callback) {
      if (typeof callback === "function") {
        this._subscribers[event].push(callback);
      }
    }
    /**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     * @param event - Event name.
     * @param callback - Callback method.
     */
  }, {
    key: "off",
    value: function off(event, callback) {
      var _context9;
      this._subscribers[event] = _filterInstanceProperty(_context9 = this._subscribers[event]).call(_context9, function(subscriber) {
        return subscriber !== callback;
      });
    }
  }]);
  return DataSetPart2;
}();
_Symbol$iterator = _Symbol$iterator2;
var DataStream = /* @__PURE__ */ function() {
  function DataStream2(pairs2) {
    _classCallCheck(this, DataStream2);
    _defineProperty(this, "_pairs", void 0);
    this._pairs = pairs2;
  }
  _createClass(DataStream2, [{
    key: _Symbol$iterator,
    value: /* @__PURE__ */ _regeneratorRuntime.mark(function value() {
      var _iterator, _step, _step$value, id2, item;
      return _regeneratorRuntime.wrap(function value$(_context10) {
        while (1)
          switch (_context10.prev = _context10.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$6(this._pairs);
              _context10.prev = 1;
              _iterator.s();
            case 3:
              if ((_step = _iterator.n()).done) {
                _context10.next = 9;
                break;
              }
              _step$value = _slicedToArray(_step.value, 2), id2 = _step$value[0], item = _step$value[1];
              _context10.next = 7;
              return [id2, item];
            case 7:
              _context10.next = 3;
              break;
            case 9:
              _context10.next = 14;
              break;
            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](1);
              _iterator.e(_context10.t0);
            case 14:
              _context10.prev = 14;
              _iterator.f();
              return _context10.finish(14);
            case 17:
            case "end":
              return _context10.stop();
          }
      }, value, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of key, value pairs for every entry in the stream.
     */
  }, {
    key: "entries",
    value: /* @__PURE__ */ _regeneratorRuntime.mark(function entries2() {
      var _iterator2, _step2, _step2$value, id2, item;
      return _regeneratorRuntime.wrap(function entries$(_context11) {
        while (1)
          switch (_context11.prev = _context11.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper$6(this._pairs);
              _context11.prev = 1;
              _iterator2.s();
            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context11.next = 9;
                break;
              }
              _step2$value = _slicedToArray(_step2.value, 2), id2 = _step2$value[0], item = _step2$value[1];
              _context11.next = 7;
              return [id2, item];
            case 7:
              _context11.next = 3;
              break;
            case 9:
              _context11.next = 14;
              break;
            case 11:
              _context11.prev = 11;
              _context11.t0 = _context11["catch"](1);
              _iterator2.e(_context11.t0);
            case 14:
              _context11.prev = 14;
              _iterator2.f();
              return _context11.finish(14);
            case 17:
            case "end":
              return _context11.stop();
          }
      }, entries2, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of keys in the stream.
     */
  }, {
    key: "keys",
    value: /* @__PURE__ */ _regeneratorRuntime.mark(function keys4() {
      var _iterator3, _step3, _step3$value, id2;
      return _regeneratorRuntime.wrap(function keys$(_context12) {
        while (1)
          switch (_context12.prev = _context12.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper$6(this._pairs);
              _context12.prev = 1;
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context12.next = 9;
                break;
              }
              _step3$value = _slicedToArray(_step3.value, 1), id2 = _step3$value[0];
              _context12.next = 7;
              return id2;
            case 7:
              _context12.next = 3;
              break;
            case 9:
              _context12.next = 14;
              break;
            case 11:
              _context12.prev = 11;
              _context12.t0 = _context12["catch"](1);
              _iterator3.e(_context12.t0);
            case 14:
              _context12.prev = 14;
              _iterator3.f();
              return _context12.finish(14);
            case 17:
            case "end":
              return _context12.stop();
          }
      }, keys4, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an iterable of values in the stream.
     */
  }, {
    key: "values",
    value: /* @__PURE__ */ _regeneratorRuntime.mark(function values2() {
      var _iterator4, _step4, _step4$value, item;
      return _regeneratorRuntime.wrap(function values$(_context13) {
        while (1)
          switch (_context13.prev = _context13.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper$6(this._pairs);
              _context13.prev = 1;
              _iterator4.s();
            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context13.next = 9;
                break;
              }
              _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];
              _context13.next = 7;
              return item;
            case 7:
              _context13.next = 3;
              break;
            case 9:
              _context13.next = 14;
              break;
            case 11:
              _context13.prev = 11;
              _context13.t0 = _context13["catch"](1);
              _iterator4.e(_context13.t0);
            case 14:
              _context13.prev = 14;
              _iterator4.f();
              return _context13.finish(14);
            case 17:
            case "end":
              return _context13.stop();
          }
      }, values2, this, [[1, 11, 14, 17]]);
    })
    /**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all ids from this stream.
     */
  }, {
    key: "toIdArray",
    value: function toIdArray() {
      var _context14;
      return _mapInstanceProperty(_context14 = _toConsumableArray(this._pairs)).call(_context14, function(pair) {
        return pair[0];
      });
    }
    /**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all items from this stream.
     */
  }, {
    key: "toItemArray",
    value: function toItemArray() {
      var _context15;
      return _mapInstanceProperty(_context15 = _toConsumableArray(this._pairs)).call(_context15, function(pair) {
        return pair[1];
      });
    }
    /**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     * @returns The array with all entries from this stream.
     */
  }, {
    key: "toEntryArray",
    value: function toEntryArray() {
      return _toConsumableArray(this._pairs);
    }
    /**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     * @returns The object map of all id → item pairs from this stream.
     */
  }, {
    key: "toObjectMap",
    value: function toObjectMap() {
      var map3 = _Object$create$1(null);
      var _iterator5 = _createForOfIteratorHelper$6(this._pairs), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var _step5$value = _slicedToArray(_step5.value, 2), id2 = _step5$value[0], item = _step5$value[1];
          map3[id2] = item;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return map3;
    }
    /**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id → item pairs from this stream.
     */
  }, {
    key: "toMap",
    value: function toMap() {
      return new _Map(this._pairs);
    }
    /**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */
  }, {
    key: "toIdSet",
    value: function toIdSet() {
      return new _Set(this.toIdArray());
    }
    /**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */
  }, {
    key: "toItemSet",
    value: function toItemSet() {
      return new _Set(this.toItemArray());
    }
    /**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as {@link DataStream} would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([…])
     *
     * const cachedStream = ds.stream()
     *   .filter(…)
     *   .sort(…)
     *   .map(…)
     *   .cached(…) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     * @returns A new {@link DataStream} with cached items (detached from the original {@link DataSet}).
     */
  }, {
    key: "cache",
    value: function cache() {
      return new DataStream2(_toConsumableArray(this._pairs));
    }
    /**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @typeParam T - The type of the distinct value.
     * @returns A set of all distinct properties.
     */
  }, {
    key: "distinct",
    value: function distinct(callback) {
      var set3 = new _Set();
      var _iterator6 = _createForOfIteratorHelper$6(this._pairs), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var _step6$value = _slicedToArray(_step6.value, 2), id2 = _step6$value[0], item = _step6$value[1];
          set3.add(callback(item, id2));
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return set3;
    }
    /**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     * @returns A new data stream with the filtered items.
     */
  }, {
    key: "filter",
    value: function filter3(callback) {
      var pairs2 = this._pairs;
      return new DataStream2(_defineProperty({}, _Symbol$iterator2, /* @__PURE__ */ _regeneratorRuntime.mark(function _callee() {
        var _iterator7, _step7, _step7$value, id2, item;
        return _regeneratorRuntime.wrap(function _callee$(_context16) {
          while (1)
            switch (_context16.prev = _context16.next) {
              case 0:
                _iterator7 = _createForOfIteratorHelper$6(pairs2);
                _context16.prev = 1;
                _iterator7.s();
              case 3:
                if ((_step7 = _iterator7.n()).done) {
                  _context16.next = 10;
                  break;
                }
                _step7$value = _slicedToArray(_step7.value, 2), id2 = _step7$value[0], item = _step7$value[1];
                if (!callback(item, id2)) {
                  _context16.next = 8;
                  break;
                }
                _context16.next = 8;
                return [id2, item];
              case 8:
                _context16.next = 3;
                break;
              case 10:
                _context16.next = 15;
                break;
              case 12:
                _context16.prev = 12;
                _context16.t0 = _context16["catch"](1);
                _iterator7.e(_context16.t0);
              case 15:
                _context16.prev = 15;
                _iterator7.f();
                return _context16.finish(15);
              case 18:
              case "end":
                return _context16.stop();
            }
        }, _callee, null, [[1, 12, 15, 18]]);
      })));
    }
    /**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */
  }, {
    key: "forEach",
    value: function forEach4(callback) {
      var _iterator8 = _createForOfIteratorHelper$6(this._pairs), _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
          var _step8$value = _slicedToArray(_step8.value, 2), id2 = _step8$value[0], item = _step8$value[1];
          callback(item, id2);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     * @typeParam Mapped - The type of the item after mapping.
     * @returns A new data stream with the mapped items.
     */
  }, {
    key: "map",
    value: function map3(callback) {
      var pairs2 = this._pairs;
      return new DataStream2(_defineProperty({}, _Symbol$iterator2, /* @__PURE__ */ _regeneratorRuntime.mark(function _callee2() {
        var _iterator9, _step9, _step9$value, id2, item;
        return _regeneratorRuntime.wrap(function _callee2$(_context17) {
          while (1)
            switch (_context17.prev = _context17.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper$6(pairs2);
                _context17.prev = 1;
                _iterator9.s();
              case 3:
                if ((_step9 = _iterator9.n()).done) {
                  _context17.next = 9;
                  break;
                }
                _step9$value = _slicedToArray(_step9.value, 2), id2 = _step9$value[0], item = _step9$value[1];
                _context17.next = 7;
                return [id2, callback(item, id2)];
              case 7:
                _context17.next = 3;
                break;
              case 9:
                _context17.next = 14;
                break;
              case 11:
                _context17.prev = 11;
                _context17.t0 = _context17["catch"](1);
                _iterator9.e(_context17.t0);
              case 14:
                _context17.prev = 14;
                _iterator9.f();
                return _context17.finish(14);
              case 17:
              case "end":
                return _context17.stop();
            }
        }, _callee2, null, [[1, 11, 14, 17]]);
      })));
    }
    /**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the maximum if found otherwise null.
     */
  }, {
    key: "max",
    value: function max2(callback) {
      var iter = _getIterator(this._pairs);
      var curr = iter.next();
      if (curr.done) {
        return null;
      }
      var maxItem = curr.value[1];
      var maxValue = callback(curr.value[1], curr.value[0]);
      while (!(curr = iter.next()).done) {
        var _curr$value = _slicedToArray(curr.value, 2), id2 = _curr$value[0], item = _curr$value[1];
        var _value = callback(item, id2);
        if (_value > maxValue) {
          maxValue = _value;
          maxItem = item;
        }
      }
      return maxItem;
    }
    /**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     * @returns The item with the minimum if found otherwise null.
     */
  }, {
    key: "min",
    value: function min2(callback) {
      var iter = _getIterator(this._pairs);
      var curr = iter.next();
      if (curr.done) {
        return null;
      }
      var minItem = curr.value[1];
      var minValue = callback(curr.value[1], curr.value[0]);
      while (!(curr = iter.next()).done) {
        var _curr$value2 = _slicedToArray(curr.value, 2), id2 = _curr$value2[0], item = _curr$value2[1];
        var _value2 = callback(item, id2);
        if (_value2 < minValue) {
          minValue = _value2;
          minItem = item;
        }
      }
      return minItem;
    }
    /**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     * @typeParam T - The type of the accumulated value.
     * @returns The reduced value.
     */
  }, {
    key: "reduce",
    value: function reduce3(callback, accumulator) {
      var _iterator10 = _createForOfIteratorHelper$6(this._pairs), _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
          var _step10$value = _slicedToArray(_step10.value, 2), id2 = _step10$value[0], item = _step10$value[1];
          accumulator = callback(accumulator, item, id2);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      return accumulator;
    }
    /**
     * Sort the items.
     *
     * @param callback - Item comparator.
     * @returns A new stream with sorted items.
     */
  }, {
    key: "sort",
    value: function sort3(callback) {
      var _this2 = this;
      return new DataStream2(_defineProperty({}, _Symbol$iterator2, function() {
        var _context18;
        return _getIterator(_sortInstanceProperty(_context18 = _toConsumableArray(_this2._pairs)).call(_context18, function(_ref, _ref2) {
          var _ref3 = _slicedToArray(_ref, 2), idA = _ref3[0], itemA = _ref3[1];
          var _ref4 = _slicedToArray(_ref2, 2), idB = _ref4[0], itemB = _ref4[1];
          return callback(itemA, itemB, idA, idB);
        }));
      }));
    }
  }]);
  return DataStream2;
}();
function ensureFullItem(item, idProp) {
  if (item[idProp] == null) {
    item[idProp] = v4();
  }
  return item;
}
var DataSet = /* @__PURE__ */ function(_DataSetPart) {
  _inherits(DataSet2, _DataSetPart);
  var _super = _createSuper$t(DataSet2);
  function DataSet2(data2, options) {
    var _this3;
    _classCallCheck(this, DataSet2);
    _this3 = _super.call(this);
    _defineProperty(_assertThisInitialized(_this3), "flush", void 0);
    _defineProperty(_assertThisInitialized(_this3), "length", void 0);
    _defineProperty(_assertThisInitialized(_this3), "_options", void 0);
    _defineProperty(_assertThisInitialized(_this3), "_data", void 0);
    _defineProperty(_assertThisInitialized(_this3), "_idProp", void 0);
    _defineProperty(_assertThisInitialized(_this3), "_queue", null);
    if (data2 && !_Array$isArray(data2)) {
      options = data2;
      data2 = [];
    }
    _this3._options = options || {};
    _this3._data = new _Map();
    _this3.length = 0;
    _this3._idProp = _this3._options.fieldId || "id";
    if (data2 && data2.length) {
      _this3.add(data2);
    }
    _this3.setOptions(options);
    return _this3;
  }
  _createClass(DataSet2, [{
    key: "idProp",
    get: (
      /** @inheritDoc */
      function get2() {
        return this._idProp;
      }
    )
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options && options.queue !== void 0) {
        if (options.queue === false) {
          if (this._queue) {
            this._queue.destroy();
            this._queue = null;
          }
        } else {
          if (!this._queue) {
            this._queue = Queue.extend(this, {
              replace: ["add", "update", "remove"]
            });
          }
          if (options.queue && _typeof$1(options.queue) === "object") {
            this._queue.setOptions(options.queue);
          }
        }
      }
    }
    /**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     * @throws When an item with the same id as any of the added items already exists.
     */
  }, {
    key: "add",
    value: function add3(data2, senderId) {
      var _this4 = this;
      var addedIds = [];
      var id2;
      if (_Array$isArray(data2)) {
        var idsToAdd = _mapInstanceProperty(data2).call(data2, function(d) {
          return d[_this4._idProp];
        });
        if (_someInstanceProperty(idsToAdd).call(idsToAdd, function(id3) {
          return _this4._data.has(id3);
        })) {
          throw new Error("A duplicate id was found in the parameter array.");
        }
        for (var i = 0, len = data2.length; i < len; i++) {
          id2 = this._addItem(data2[i]);
          addedIds.push(id2);
        }
      } else if (data2 && _typeof$1(data2) === "object") {
        id2 = this._addItem(data2);
        addedIds.push(id2);
      } else {
        throw new Error("Unknown dataType");
      }
      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }
      return addedIds;
    }
    /**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     * @throws When the supplied data is neither an item nor an array of items.
     */
  }, {
    key: "update",
    value: function update2(data2, senderId) {
      var _this5 = this;
      var addedIds = [];
      var updatedIds = [];
      var oldData = [];
      var updatedData = [];
      var idProp = this._idProp;
      var addOrUpdate = function addOrUpdate2(item) {
        var origId = item[idProp];
        if (origId != null && _this5._data.has(origId)) {
          var fullItem = item;
          var oldItem = _Object$assign({}, _this5._data.get(origId));
          var id2 = _this5._updateItem(fullItem);
          updatedIds.push(id2);
          updatedData.push(fullItem);
          oldData.push(oldItem);
        } else {
          var _id = _this5._addItem(item);
          addedIds.push(_id);
        }
      };
      if (_Array$isArray(data2)) {
        for (var i = 0, len = data2.length; i < len; i++) {
          if (data2[i] && _typeof$1(data2[i]) === "object") {
            addOrUpdate(data2[i]);
          } else {
            console.warn("Ignoring input item, which is not an object at index " + i);
          }
        }
      } else if (data2 && _typeof$1(data2) === "object") {
        addOrUpdate(data2);
      } else {
        throw new Error("Unknown dataType");
      }
      if (addedIds.length) {
        this._trigger("add", {
          items: addedIds
        }, senderId);
      }
      if (updatedIds.length) {
        var props = {
          items: updatedIds,
          oldData,
          data: updatedData
        };
        this._trigger("update", props, senderId);
      }
      return _concatInstanceProperty(addedIds).call(addedIds, updatedIds);
    }
    /**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     * @returns updatedIds - The ids of the updated items.
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */
  }, {
    key: "updateOnly",
    value: function updateOnly(data2, senderId) {
      var _context19, _this6 = this;
      if (!_Array$isArray(data2)) {
        data2 = [data2];
      }
      var updateEventData = _mapInstanceProperty(_context19 = _mapInstanceProperty(data2).call(data2, function(update2) {
        var oldData = _this6._data.get(update2[_this6._idProp]);
        if (oldData == null) {
          throw new Error("Updating non-existent items is not allowed.");
        }
        return {
          oldData,
          update: update2
        };
      })).call(_context19, function(_ref5) {
        var oldData = _ref5.oldData, update2 = _ref5.update;
        var id2 = oldData[_this6._idProp];
        var updatedData = pureDeepObjectAssign(oldData, update2);
        _this6._data.set(id2, updatedData);
        return {
          id: id2,
          oldData,
          updatedData
        };
      });
      if (updateEventData.length) {
        var props = {
          items: _mapInstanceProperty(updateEventData).call(updateEventData, function(value) {
            return value.id;
          }),
          oldData: _mapInstanceProperty(updateEventData).call(updateEventData, function(value) {
            return value.oldData;
          }),
          data: _mapInstanceProperty(updateEventData).call(updateEventData, function(value) {
            return value.updatedData;
          })
        };
        this._trigger("update", props, senderId);
        return props.items;
      } else {
        return [];
      }
    }
    /** @inheritDoc */
  }, {
    key: "get",
    value: function get2(first2, second) {
      var id2 = void 0;
      var ids = void 0;
      var options = void 0;
      if (isId(first2)) {
        id2 = first2;
        options = second;
      } else if (_Array$isArray(first2)) {
        ids = first2;
        options = second;
      } else {
        options = first2;
      }
      var returnType = options && options.returnType === "Object" ? "Object" : "Array";
      var filter3 = options && _filterInstanceProperty(options);
      var items = [];
      var item = void 0;
      var itemIds = void 0;
      var itemId = void 0;
      if (id2 != null) {
        item = this._data.get(id2);
        if (item && filter3 && !filter3(item)) {
          item = void 0;
        }
      } else if (ids != null) {
        for (var i = 0, len = ids.length; i < len; i++) {
          item = this._data.get(ids[i]);
          if (item != null && (!filter3 || filter3(item))) {
            items.push(item);
          }
        }
      } else {
        var _context20;
        itemIds = _toConsumableArray(_keysInstanceProperty(_context20 = this._data).call(_context20));
        for (var _i = 0, _len2 = itemIds.length; _i < _len2; _i++) {
          itemId = itemIds[_i];
          item = this._data.get(itemId);
          if (item != null && (!filter3 || filter3(item))) {
            items.push(item);
          }
        }
      }
      if (options && options.order && id2 == void 0) {
        this._sort(items, options.order);
      }
      if (options && options.fields) {
        var fields = options.fields;
        if (id2 != void 0 && item != null) {
          item = this._filterFields(item, fields);
        } else {
          for (var _i2 = 0, _len3 = items.length; _i2 < _len3; _i2++) {
            items[_i2] = this._filterFields(items[_i2], fields);
          }
        }
      }
      if (returnType == "Object") {
        var result = {};
        for (var _i3 = 0, _len4 = items.length; _i3 < _len4; _i3++) {
          var resultant = items[_i3];
          var _id2 = resultant[this._idProp];
          result[_id2] = resultant;
        }
        return result;
      } else {
        if (id2 != null) {
          var _item;
          return (_item = item) !== null && _item !== void 0 ? _item : null;
        } else {
          return items;
        }
      }
    }
    /** @inheritDoc */
  }, {
    key: "getIds",
    value: function getIds(options) {
      var data2 = this._data;
      var filter3 = options && _filterInstanceProperty(options);
      var order = options && options.order;
      var itemIds = _toConsumableArray(_keysInstanceProperty(data2).call(data2));
      var ids = [];
      if (filter3) {
        if (order) {
          var items = [];
          for (var i = 0, len = itemIds.length; i < len; i++) {
            var id2 = itemIds[i];
            var item = this._data.get(id2);
            if (item != null && filter3(item)) {
              items.push(item);
            }
          }
          this._sort(items, order);
          for (var _i4 = 0, _len5 = items.length; _i4 < _len5; _i4++) {
            ids.push(items[_i4][this._idProp]);
          }
        } else {
          for (var _i5 = 0, _len6 = itemIds.length; _i5 < _len6; _i5++) {
            var _id3 = itemIds[_i5];
            var _item2 = this._data.get(_id3);
            if (_item2 != null && filter3(_item2)) {
              ids.push(_item2[this._idProp]);
            }
          }
        }
      } else {
        if (order) {
          var _items = [];
          for (var _i6 = 0, _len7 = itemIds.length; _i6 < _len7; _i6++) {
            var _id4 = itemIds[_i6];
            _items.push(data2.get(_id4));
          }
          this._sort(_items, order);
          for (var _i7 = 0, _len8 = _items.length; _i7 < _len8; _i7++) {
            ids.push(_items[_i7][this._idProp]);
          }
        } else {
          for (var _i8 = 0, _len9 = itemIds.length; _i8 < _len9; _i8++) {
            var _id5 = itemIds[_i8];
            var _item3 = data2.get(_id5);
            if (_item3 != null) {
              ids.push(_item3[this._idProp]);
            }
          }
        }
      }
      return ids;
    }
    /** @inheritDoc */
  }, {
    key: "getDataSet",
    value: function getDataSet() {
      return this;
    }
    /** @inheritDoc */
  }, {
    key: "forEach",
    value: function forEach4(callback, options) {
      var filter3 = options && _filterInstanceProperty(options);
      var data2 = this._data;
      var itemIds = _toConsumableArray(_keysInstanceProperty(data2).call(data2));
      if (options && options.order) {
        var items = this.get(options);
        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var id2 = item[this._idProp];
          callback(item, id2);
        }
      } else {
        for (var _i9 = 0, _len10 = itemIds.length; _i9 < _len10; _i9++) {
          var _id6 = itemIds[_i9];
          var _item4 = this._data.get(_id6);
          if (_item4 != null && (!filter3 || filter3(_item4))) {
            callback(_item4, _id6);
          }
        }
      }
    }
    /** @inheritDoc */
  }, {
    key: "map",
    value: function map3(callback, options) {
      var filter3 = options && _filterInstanceProperty(options);
      var mappedItems = [];
      var data2 = this._data;
      var itemIds = _toConsumableArray(_keysInstanceProperty(data2).call(data2));
      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id2 = itemIds[i];
        var item = this._data.get(id2);
        if (item != null && (!filter3 || filter3(item))) {
          mappedItems.push(callback(item, id2));
        }
      }
      if (options && options.order) {
        this._sort(mappedItems, options.order);
      }
      return mappedItems;
    }
    /**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     * @typeParam K - Field name type.
     * @returns The item without any additional fields.
     */
  }, {
    key: "_filterFields",
    value: function _filterFields(item, fields) {
      var _context21;
      if (!item) {
        return item;
      }
      return _reduceInstanceProperty(_context21 = _Array$isArray(fields) ? (
        // Use the supplied array
        fields
      ) : (
        // Use the keys of the supplied object
        _Object$keys(fields)
      )).call(_context21, function(filteredItem, field) {
        filteredItem[field] = item[field];
        return filteredItem;
      }, {});
    }
    /**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     * @typeParam T - The type of the items in the items array.
     */
  }, {
    key: "_sort",
    value: function _sort(items, order) {
      if (typeof order === "string") {
        var name2 = order;
        _sortInstanceProperty(items).call(items, function(a, b) {
          var av = a[name2];
          var bv = b[name2];
          return av > bv ? 1 : av < bv ? -1 : 0;
        });
      } else if (typeof order === "function") {
        _sortInstanceProperty(items).call(items, order);
      } else {
        throw new TypeError("Order must be a function or a string");
      }
    }
    /**
     * Remove an item or multiple items by “reference” (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     * @returns The ids of the removed items.
     */
  }, {
    key: "remove",
    value: function remove2(id2, senderId) {
      var removedIds = [];
      var removedItems = [];
      var ids = _Array$isArray(id2) ? id2 : [id2];
      for (var i = 0, len = ids.length; i < len; i++) {
        var item = this._remove(ids[i]);
        if (item) {
          var itemId = item[this._idProp];
          if (itemId != null) {
            removedIds.push(itemId);
            removedItems.push(item);
          }
        }
      }
      if (removedIds.length) {
        this._trigger("remove", {
          items: removedIds,
          oldData: removedItems
        }, senderId);
      }
      return removedIds;
    }
    /**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     * @returns The removed item if removed, null otherwise.
     */
  }, {
    key: "_remove",
    value: function _remove(id2) {
      var ident;
      if (isId(id2)) {
        ident = id2;
      } else if (id2 && _typeof$1(id2) === "object") {
        ident = id2[this._idProp];
      }
      if (ident != null && this._data.has(ident)) {
        var item = this._data.get(ident) || null;
        this._data.delete(ident);
        --this.length;
        return item;
      }
      return null;
    }
    /**
     * Clear the entire data set.
     *
     * After the items are removed, the {@link DataSet} will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     * @returns removedIds - The ids of all removed items.
     */
  }, {
    key: "clear",
    value: function clear2(senderId) {
      var _context22;
      var ids = _toConsumableArray(_keysInstanceProperty(_context22 = this._data).call(_context22));
      var items = [];
      for (var i = 0, len = ids.length; i < len; i++) {
        items.push(this._data.get(ids[i]));
      }
      this._data.clear();
      this.length = 0;
      this._trigger("remove", {
        items: ids,
        oldData: items
      }, senderId);
      return ids;
    }
    /**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     * @returns Item containing max value, or null if no items.
     */
  }, {
    key: "max",
    value: function max2(field) {
      var _context23;
      var max3 = null;
      var maxField = null;
      var _iterator11 = _createForOfIteratorHelper$6(_valuesInstanceProperty(_context23 = this._data).call(_context23)), _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
          var item = _step11.value;
          var itemField = item[field];
          if (typeof itemField === "number" && (maxField == null || itemField > maxField)) {
            max3 = item;
            maxField = itemField;
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      return max3 || null;
    }
    /**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     * @returns Item containing min value, or null if no items.
     */
  }, {
    key: "min",
    value: function min2(field) {
      var _context24;
      var min3 = null;
      var minField = null;
      var _iterator12 = _createForOfIteratorHelper$6(_valuesInstanceProperty(_context24 = this._data).call(_context24)), _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
          var item = _step12.value;
          var itemField = item[field];
          if (typeof itemField === "number" && (minField == null || itemField < minField)) {
            min3 = item;
            minField = itemField;
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      return min3 || null;
    }
    /**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */
  }, {
    key: "distinct",
    value: function distinct(prop2) {
      var data2 = this._data;
      var itemIds = _toConsumableArray(_keysInstanceProperty(data2).call(data2));
      var values2 = [];
      var count = 0;
      for (var i = 0, len = itemIds.length; i < len; i++) {
        var id2 = itemIds[i];
        var item = data2.get(id2);
        var _value3 = item[prop2];
        var exists = false;
        for (var j2 = 0; j2 < count; j2++) {
          if (values2[j2] == _value3) {
            exists = true;
            break;
          }
        }
        if (!exists && _value3 !== void 0) {
          values2[count] = _value3;
          count++;
        }
      }
      return values2;
    }
    /**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     * @returns Added item's id. An id is generated when it is not present in the item.
     */
  }, {
    key: "_addItem",
    value: function _addItem(item) {
      var fullItem = ensureFullItem(item, this._idProp);
      var id2 = fullItem[this._idProp];
      if (this._data.has(id2)) {
        throw new Error("Cannot add item: item with id " + id2 + " already exists");
      }
      this._data.set(id2, fullItem);
      ++this.length;
      return id2;
    }
    /**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     * @returns The id of the updated item.
     */
  }, {
    key: "_updateItem",
    value: function _updateItem(update2) {
      var id2 = update2[this._idProp];
      if (id2 == null) {
        throw new Error("Cannot update item: item has no id (item: " + _JSON$stringify(update2) + ")");
      }
      var item = this._data.get(id2);
      if (!item) {
        throw new Error("Cannot update item: no item with id " + id2 + " found");
      }
      this._data.set(id2, _objectSpread$4(_objectSpread$4({}, item), update2));
      return id2;
    }
    /** @inheritDoc */
  }, {
    key: "stream",
    value: function stream(ids) {
      if (ids) {
        var data2 = this._data;
        return new DataStream(_defineProperty({}, _Symbol$iterator2, /* @__PURE__ */ _regeneratorRuntime.mark(function _callee3() {
          var _iterator13, _step13, id2, item;
          return _regeneratorRuntime.wrap(function _callee3$(_context25) {
            while (1)
              switch (_context25.prev = _context25.next) {
                case 0:
                  _iterator13 = _createForOfIteratorHelper$6(ids);
                  _context25.prev = 1;
                  _iterator13.s();
                case 3:
                  if ((_step13 = _iterator13.n()).done) {
                    _context25.next = 11;
                    break;
                  }
                  id2 = _step13.value;
                  item = data2.get(id2);
                  if (!(item != null)) {
                    _context25.next = 9;
                    break;
                  }
                  _context25.next = 9;
                  return [id2, item];
                case 9:
                  _context25.next = 3;
                  break;
                case 11:
                  _context25.next = 16;
                  break;
                case 13:
                  _context25.prev = 13;
                  _context25.t0 = _context25["catch"](1);
                  _iterator13.e(_context25.t0);
                case 16:
                  _context25.prev = 16;
                  _iterator13.f();
                  return _context25.finish(16);
                case 19:
                case "end":
                  return _context25.stop();
              }
          }, _callee3, null, [[1, 13, 16, 19]]);
        })));
      } else {
        var _context26;
        return new DataStream(_defineProperty({}, _Symbol$iterator2, _bindInstanceProperty$1(_context26 = _entriesInstanceProperty(this._data)).call(_context26, this._data)));
      }
    }
  }]);
  return DataSet2;
}(DataSetPart);
function isDataSetLike(idProp, v2) {
  return _typeof$1(v2) === "object" && v2 !== null && idProp === v2.idProp && typeof v2.add === "function" && typeof v2.clear === "function" && typeof v2.distinct === "function" && typeof _forEachInstanceProperty(v2) === "function" && typeof v2.get === "function" && typeof v2.getDataSet === "function" && typeof v2.getIds === "function" && typeof v2.length === "number" && typeof _mapInstanceProperty(v2) === "function" && typeof v2.max === "function" && typeof v2.min === "function" && typeof v2.off === "function" && typeof v2.on === "function" && typeof v2.remove === "function" && typeof v2.setOptions === "function" && typeof v2.stream === "function" && typeof v2.update === "function" && typeof v2.updateOnly === "function";
}
function isDataViewLike(idProp, v2) {
  return _typeof$1(v2) === "object" && v2 !== null && idProp === v2.idProp && typeof _forEachInstanceProperty(v2) === "function" && typeof v2.get === "function" && typeof v2.getDataSet === "function" && typeof v2.getIds === "function" && typeof v2.length === "number" && typeof _mapInstanceProperty(v2) === "function" && typeof v2.off === "function" && typeof v2.on === "function" && typeof v2.stream === "function" && isDataSetLike(idProp, v2.getDataSet());
}
var global$2 = global$s;
var fails$2 = fails$z;
var uncurryThis$2 = functionUncurryThis;
var toString2 = toString$b;
var trim = stringTrim.trim;
var whitespaces = whitespaces$3;
var charAt = uncurryThis$2("".charAt);
var $parseFloat$1 = global$2.parseFloat;
var Symbol$1 = global$2.Symbol;
var ITERATOR = Symbol$1 && Symbol$1.iterator;
var FORCED$1 = 1 / $parseFloat$1(whitespaces + "-0") !== -Infinity || ITERATOR && !fails$2(function() {
  $parseFloat$1(Object(ITERATOR));
});
var numberParseFloat = FORCED$1 ? function parseFloat2(string2) {
  var trimmedString = trim(toString2(string2));
  var result = $parseFloat$1(trimmedString);
  return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
} : $parseFloat$1;
var $$4 = _export;
var $parseFloat = numberParseFloat;
$$4({ global: true, forced: parseFloat !== $parseFloat }, {
  parseFloat: $parseFloat
});
var path$5 = path$y;
var _parseFloat$3 = path$5.parseFloat;
var parent$9 = _parseFloat$3;
var _parseFloat$2 = parent$9;
var _parseFloat = _parseFloat$2;
var _parseFloat$1 = /* @__PURE__ */ getDefaultExportFromCjs(_parseFloat);
var $$3 = _export;
var fails$1 = fails$z;
var getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES = fails$1(function() {
  return !Object.getOwnPropertyNames(1);
});
$$3({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: getOwnPropertyNames$3
});
var path$4 = path$y;
var Object$1 = path$4.Object;
var getOwnPropertyNames$2 = function getOwnPropertyNames4(it3) {
  return Object$1.getOwnPropertyNames(it3);
};
var parent$8 = getOwnPropertyNames$2;
var getOwnPropertyNames$1 = parent$8;
var getOwnPropertyNames5 = getOwnPropertyNames$1;
var _Object$getOwnPropertyNames = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertyNames5);
function choosify(subOption, pile) {
  var allowed = ["node", "edge", "label"];
  var value = true;
  var chosen = topMost(pile, "chosen");
  if (typeof chosen === "boolean") {
    value = chosen;
  } else if (_typeof$1(chosen) === "object") {
    if (_indexOfInstanceProperty(allowed).call(allowed, subOption) === -1) {
      throw new Error("choosify: subOption '" + subOption + "' should be one of '" + allowed.join("', '") + "'");
    }
    var chosenEdge = topMost(pile, ["chosen", subOption]);
    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
      value = chosenEdge;
    }
  }
  return value;
}
function pointInRect(rect, point, rotationPoint) {
  if (rect.width <= 0 || rect.height <= 0) {
    return false;
  }
  if (rotationPoint !== void 0) {
    var tmp = {
      x: point.x - rotationPoint.x,
      y: point.y - rotationPoint.y
    };
    if (rotationPoint.angle !== 0) {
      var angle = -rotationPoint.angle;
      var tmp2 = {
        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
      };
      point = tmp2;
    } else {
      point = tmp;
    }
  }
  var right = rect.x + rect.width;
  var bottom = rect.y + rect.width;
  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
}
function isValidLabel(text2) {
  return typeof text2 === "string" && text2 !== "";
}
function getSelfRefCoordinates(ctx, angle, radius, node2) {
  var x2 = node2.x;
  var y2 = node2.y;
  if (typeof node2.distanceToBorder === "function") {
    var toBorderDist = node2.distanceToBorder(ctx, angle);
    var yFromNodeCenter = Math.sin(angle) * toBorderDist;
    var xFromNodeCenter = Math.cos(angle) * toBorderDist;
    if (xFromNodeCenter === toBorderDist) {
      x2 += toBorderDist;
      y2 = node2.y;
    } else if (yFromNodeCenter === toBorderDist) {
      x2 = node2.x;
      y2 -= toBorderDist;
    } else {
      x2 += xFromNodeCenter;
      y2 -= yFromNodeCenter;
    }
  } else if (node2.shape.width > node2.shape.height) {
    x2 = node2.x + node2.shape.width * 0.5;
    y2 = node2.y - radius;
  } else {
    x2 = node2.x + radius;
    y2 = node2.y - node2.shape.height * 0.5;
  }
  return {
    x: x2,
    y: y2
  };
}
var LabelAccumulator = /* @__PURE__ */ function() {
  function LabelAccumulator2(measureText) {
    _classCallCheck(this, LabelAccumulator2);
    this.measureText = measureText;
    this.current = 0;
    this.width = 0;
    this.height = 0;
    this.lines = [];
  }
  _createClass(LabelAccumulator2, [{
    key: "_add",
    value: function _add(l, text2) {
      var mod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "normal";
      if (this.lines[l] === void 0) {
        this.lines[l] = {
          width: 0,
          height: 0,
          blocks: []
        };
      }
      var tmpText = text2;
      if (text2 === void 0 || text2 === "")
        tmpText = " ";
      var result = this.measureText(tmpText, mod);
      var block2 = _Object$assign({}, _valuesInstanceProperty(result));
      block2.text = text2;
      block2.width = result.width;
      block2.mod = mod;
      if (text2 === void 0 || text2 === "") {
        block2.width = 0;
      }
      this.lines[l].blocks.push(block2);
      this.lines[l].width += block2.width;
    }
    /**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */
  }, {
    key: "curWidth",
    value: function curWidth() {
      var line = this.lines[this.current];
      if (line === void 0)
        return 0;
      return line.width;
    }
    /**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */
  }, {
    key: "append",
    value: function append2(text2) {
      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
      this._add(this.current, text2, mod);
    }
    /**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */
  }, {
    key: "newLine",
    value: function newLine(text2) {
      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
      this._add(this.current, text2, mod);
      this.current++;
    }
    /**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */
  }, {
    key: "determineLineHeights",
    value: function determineLineHeights() {
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];
        var height = 0;
        if (line.blocks !== void 0) {
          for (var l = 0; l < line.blocks.length; l++) {
            var block2 = line.blocks[l];
            if (height < block2.height) {
              height = block2.height;
            }
          }
        }
        line.height = height;
      }
    }
    /**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */
  }, {
    key: "determineLabelSize",
    value: function determineLabelSize() {
      var width = 0;
      var height = 0;
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];
        if (line.width > width) {
          width = line.width;
        }
        height += line.height;
      }
      this.width = width;
      this.height = height;
    }
    /**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */
  }, {
    key: "removeEmptyBlocks",
    value: function removeEmptyBlocks() {
      var tmpLines = [];
      for (var k = 0; k < this.lines.length; k++) {
        var line = this.lines[k];
        if (line.blocks.length === 0)
          continue;
        if (k === this.lines.length - 1) {
          if (line.width === 0)
            continue;
        }
        var tmpLine = {};
        _Object$assign(tmpLine, line);
        tmpLine.blocks = [];
        var firstEmptyBlock = void 0;
        var tmpBlocks = [];
        for (var l = 0; l < line.blocks.length; l++) {
          var block2 = line.blocks[l];
          if (block2.width !== 0) {
            tmpBlocks.push(block2);
          } else {
            if (firstEmptyBlock === void 0) {
              firstEmptyBlock = block2;
            }
          }
        }
        if (tmpBlocks.length === 0 && firstEmptyBlock !== void 0) {
          tmpBlocks.push(firstEmptyBlock);
        }
        tmpLine.blocks = tmpBlocks;
        tmpLines.push(tmpLine);
      }
      return tmpLines;
    }
    /**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */
  }, {
    key: "finalize",
    value: function finalize() {
      this.determineLineHeights();
      this.determineLabelSize();
      var tmpLines = this.removeEmptyBlocks();
      return {
        width: this.width,
        height: this.height,
        lines: tmpLines
      };
    }
  }]);
  return LabelAccumulator2;
}();
var tagPattern = {
  // HTML
  "<b>": /<b>/,
  "<i>": /<i>/,
  "<code>": /<code>/,
  "</b>": /<\/b>/,
  "</i>": /<\/i>/,
  "</code>": /<\/code>/,
  // Markdown
  "*": /\*/,
  // bold
  _: /_/,
  // ital
  "`": /`/,
  // mono
  afterBold: /[^*]/,
  afterItal: /[^_]/,
  afterMono: /[^`]/
};
var MarkupAccumulator = /* @__PURE__ */ function() {
  function MarkupAccumulator2(text2) {
    _classCallCheck(this, MarkupAccumulator2);
    this.text = text2;
    this.bold = false;
    this.ital = false;
    this.mono = false;
    this.spacing = false;
    this.position = 0;
    this.buffer = "";
    this.modStack = [];
    this.blocks = [];
  }
  _createClass(MarkupAccumulator2, [{
    key: "mod",
    value: function mod() {
      return this.modStack.length === 0 ? "normal" : this.modStack[0];
    }
    /**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */
  }, {
    key: "modName",
    value: function modName() {
      if (this.modStack.length === 0)
        return "normal";
      else if (this.modStack[0] === "mono")
        return "mono";
      else {
        if (this.bold && this.ital) {
          return "boldital";
        } else if (this.bold) {
          return "bold";
        } else if (this.ital) {
          return "ital";
        }
      }
    }
    /**
     * @private
     */
  }, {
    key: "emitBlock",
    value: function emitBlock() {
      if (this.spacing) {
        this.add(" ");
        this.spacing = false;
      }
      if (this.buffer.length > 0) {
        this.blocks.push({
          text: this.buffer,
          mod: this.modName()
        });
        this.buffer = "";
      }
    }
    /**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */
  }, {
    key: "add",
    value: function add3(text2) {
      if (text2 === " ") {
        this.spacing = true;
      }
      if (this.spacing) {
        this.buffer += " ";
        this.spacing = false;
      }
      if (text2 != " ") {
        this.buffer += text2;
      }
    }
    /**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */
  }, {
    key: "parseWS",
    value: function parseWS(ch) {
      if (/[ \t]/.test(ch)) {
        if (!this.mono) {
          this.spacing = true;
        } else {
          this.add(ch);
        }
        return true;
      }
      return false;
    }
    /**
     * @param {string} tagName  label for block type to set
     * @private
     */
  }, {
    key: "setTag",
    value: function setTag(tagName) {
      this.emitBlock();
      this[tagName] = true;
      this.modStack.unshift(tagName);
    }
    /**
     * @param {string} tagName  label for block type to unset
     * @private
     */
  }, {
    key: "unsetTag",
    value: function unsetTag(tagName) {
      this.emitBlock();
      this[tagName] = false;
      this.modStack.shift();
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */
  }, {
    key: "parseStartTag",
    value: function parseStartTag(tagName, tag) {
      if (!this.mono && !this[tagName] && this.match(tag)) {
        this.setTag(tagName);
        return true;
      }
      return false;
    }
    /**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */
  }, {
    key: "match",
    value: function match3(tag) {
      var advance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var _this$prepareRegExp = this.prepareRegExp(tag), _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2), regExp = _this$prepareRegExp2[0], length2 = _this$prepareRegExp2[1];
      var matched = regExp.test(this.text.substr(this.position, length2));
      if (matched && advance) {
        this.position += length2 - 1;
      }
      return matched;
    }
    /**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */
  }, {
    key: "parseEndTag",
    value: function parseEndTag(tagName, tag, nextTag) {
      var checkTag = this.mod() === tagName;
      if (tagName === "mono") {
        checkTag = checkTag && this.mono;
      } else {
        checkTag = checkTag && !this.mono;
      }
      if (checkTag && this.match(tag)) {
        if (nextTag !== void 0) {
          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {
            this.unsetTag(tagName);
          }
        } else {
          this.unsetTag(tagName);
        }
        return true;
      }
      return false;
    }
    /**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */
  }, {
    key: "replace",
    value: function replace2(tag, value) {
      if (this.match(tag)) {
        this.add(value);
        this.position += length - 1;
        return true;
      }
      return false;
    }
    /**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */
  }, {
    key: "prepareRegExp",
    value: function prepareRegExp(tag) {
      var length2;
      var regExp;
      if (tag instanceof RegExp) {
        regExp = tag;
        length2 = 1;
      } else {
        var prepared = tagPattern[tag];
        if (prepared !== void 0) {
          regExp = prepared;
        } else {
          regExp = new RegExp(tag);
        }
        length2 = tag.length;
      }
      return [regExp, length2];
    }
  }]);
  return MarkupAccumulator2;
}();
var LabelSplitter = /* @__PURE__ */ function() {
  function LabelSplitter2(ctx, parent2, selected, hover) {
    var _this = this;
    _classCallCheck(this, LabelSplitter2);
    this.ctx = ctx;
    this.parent = parent2;
    this.selected = selected;
    this.hover = hover;
    var textWidth = function textWidth2(text2, mod) {
      if (text2 === void 0)
        return 0;
      var values2 = _this.parent.getFormattingValues(ctx, selected, hover, mod);
      var width = 0;
      if (text2 !== "") {
        var measure = _this.ctx.measureText(text2);
        width = measure.width;
      }
      return {
        width,
        values: values2
      };
    };
    this.lines = new LabelAccumulator(textWidth);
  }
  _createClass(LabelSplitter2, [{
    key: "process",
    value: function process2(text2) {
      if (!isValidLabel(text2)) {
        return this.lines.finalize();
      }
      var font = this.parent.fontOptions;
      text2 = text2.replace(/\r\n/g, "\n");
      text2 = text2.replace(/\r/g, "\n");
      var nlLines = String(text2).split("\n");
      var lineCount = nlLines.length;
      if (font.multi) {
        for (var i = 0; i < lineCount; i++) {
          var blocks = this.splitBlocks(nlLines[i], font.multi);
          if (blocks === void 0)
            continue;
          if (blocks.length === 0) {
            this.lines.newLine("");
            continue;
          }
          if (font.maxWdt > 0) {
            for (var j2 = 0; j2 < blocks.length; j2++) {
              var mod = blocks[j2].mod;
              var _text = blocks[j2].text;
              this.splitStringIntoLines(_text, mod, true);
            }
          } else {
            for (var _j = 0; _j < blocks.length; _j++) {
              var _mod = blocks[_j].mod;
              var _text2 = blocks[_j].text;
              this.lines.append(_text2, _mod);
            }
          }
          this.lines.newLine();
        }
      } else {
        if (font.maxWdt > 0) {
          for (var _i = 0; _i < lineCount; _i++) {
            this.splitStringIntoLines(nlLines[_i]);
          }
        } else {
          for (var _i2 = 0; _i2 < lineCount; _i2++) {
            this.lines.newLine(nlLines[_i2]);
          }
        }
      }
      return this.lines.finalize();
    }
    /**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */
  }, {
    key: "decodeMarkupSystem",
    value: function decodeMarkupSystem(markupSystem) {
      var system = "none";
      if (markupSystem === "markdown" || markupSystem === "md") {
        system = "markdown";
      } else if (markupSystem === true || markupSystem === "html") {
        system = "html";
      }
      return system;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */
  }, {
    key: "splitHtmlBlocks",
    value: function splitHtmlBlocks(text2) {
      var s = new MarkupAccumulator(text2);
      var parseEntities = function parseEntities2(ch2) {
        if (/&/.test(ch2)) {
          var parsed2 = s.replace(s.text, "&lt;", "<") || s.replace(s.text, "&amp;", "&");
          if (!parsed2) {
            s.add("&");
          }
          return true;
        }
        return false;
      };
      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag("bold", "<b>") || s.parseStartTag("ital", "<i>") || s.parseStartTag("mono", "<code>") || s.parseEndTag("bold", "</b>") || s.parseEndTag("ital", "</i>") || s.parseEndTag("mono", "</code>")) || parseEntities(ch);
        if (!parsed) {
          s.add(ch);
        }
        s.position++;
      }
      s.emitBlock();
      return s.blocks;
    }
    /**
     *
     * @param {string} text
     * @returns {Array}
     */
  }, {
    key: "splitMarkdownBlocks",
    value: function splitMarkdownBlocks(text2) {
      var _this2 = this;
      var s = new MarkupAccumulator(text2);
      var beginable = true;
      var parseOverride = function parseOverride2(ch2) {
        if (/\\/.test(ch2)) {
          if (s.position < _this2.text.length + 1) {
            s.position++;
            ch2 = _this2.text.charAt(s.position);
            if (/ \t/.test(ch2)) {
              s.spacing = true;
            } else {
              s.add(ch2);
              beginable = false;
            }
          }
          return true;
        }
        return false;
      };
      while (s.position < s.text.length) {
        var ch = s.text.charAt(s.position);
        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag("bold", "*") || s.parseStartTag("ital", "_") || s.parseStartTag("mono", "`")) || s.parseEndTag("bold", "*", "afterBold") || s.parseEndTag("ital", "_", "afterItal") || s.parseEndTag("mono", "`", "afterMono");
        if (!parsed) {
          s.add(ch);
          beginable = false;
        }
        s.position++;
      }
      s.emitBlock();
      return s.blocks;
    }
    /**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */
  }, {
    key: "splitBlocks",
    value: function splitBlocks(text2, markupSystem) {
      var system = this.decodeMarkupSystem(markupSystem);
      if (system === "none") {
        return [{
          text: text2,
          mod: "normal"
        }];
      } else if (system === "markdown") {
        return this.splitMarkdownBlocks(text2);
      } else if (system === "html") {
        return this.splitHtmlBlocks(text2);
      }
    }
    /**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */
  }, {
    key: "overMaxWidth",
    value: function overMaxWidth(text2) {
      var width = this.ctx.measureText(text2).width;
      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
    }
    /**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @returns {number}      index of first item in string making string go over max
     * @private
     */
  }, {
    key: "getLongestFit",
    value: function getLongestFit(words) {
      var text2 = "";
      var w = 0;
      while (w < words.length) {
        var pre = text2 === "" ? "" : " ";
        var newText = text2 + pre + words[w];
        if (this.overMaxWidth(newText))
          break;
        text2 = newText;
        w++;
      }
      return w;
    }
    /**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @returns {number} index of first item in string making string go over max
     */
  }, {
    key: "getLongestFitWord",
    value: function getLongestFitWord(words) {
      var w = 0;
      while (w < words.length) {
        if (this.overMaxWidth(_sliceInstanceProperty(words).call(words, 0, w)))
          break;
        w++;
      }
      return w;
    }
    /**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */
  }, {
    key: "splitStringIntoLines",
    value: function splitStringIntoLines(str) {
      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
      var appendLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);
      str = str.replace(/^( +)/g, "$1\r");
      str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
      var words = str.split("\r");
      while (words.length > 0) {
        var w = this.getLongestFit(words);
        if (w === 0) {
          var word = words[0];
          var x2 = this.getLongestFitWord(word);
          this.lines.newLine(_sliceInstanceProperty(word).call(word, 0, x2), mod);
          words[0] = _sliceInstanceProperty(word).call(word, x2);
        } else {
          var newW = w;
          if (words[w - 1] === " ") {
            w--;
          } else if (words[newW] === " ") {
            newW++;
          }
          var text2 = _sliceInstanceProperty(words).call(words, 0, w).join("");
          if (w == words.length && appendLast) {
            this.lines.append(text2, mod);
          } else {
            this.lines.newLine(text2, mod);
          }
          words = _sliceInstanceProperty(words).call(words, newW);
        }
      }
    }
  }]);
  return LabelSplitter2;
}();
var multiFontStyle = ["bold", "ital", "boldital", "mono"];
var Label = /* @__PURE__ */ function() {
  function Label2(body, options) {
    var edgelabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    _classCallCheck(this, Label2);
    this.body = body;
    this.pointToSelf = false;
    this.baseSize = void 0;
    this.fontOptions = {};
    this.setOptions(options);
    this.size = {
      top: 0,
      left: 0,
      width: 0,
      height: 0,
      yLine: 0
    };
    this.isEdgeLabel = edgelabel;
  }
  _createClass(Label2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.elementOptions = options;
      this.initFontOptions(options.font);
      if (isValidLabel(options.label)) {
        this.labelDirty = true;
      } else {
        options.label = void 0;
      }
      if (options.font !== void 0 && options.font !== null) {
        if (typeof options.font === "string") {
          this.baseSize = this.fontOptions.size;
        } else if (_typeof$1(options.font) === "object") {
          var size = options.font.size;
          if (size !== void 0) {
            this.baseSize = size;
          }
        }
      }
    }
    /**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {object} newFontOptions the new font options to process
     * @private
     */
  }, {
    key: "initFontOptions",
    value: function initFontOptions(newFontOptions) {
      var _this = this;
      forEach$4(multiFontStyle, function(style) {
        _this.fontOptions[style] = {};
      });
      if (Label2.parseFontString(this.fontOptions, newFontOptions)) {
        this.fontOptions.vadjust = 0;
        return;
      }
      forEach$4(newFontOptions, function(prop2, n) {
        if (prop2 !== void 0 && prop2 !== null && _typeof$1(prop2) !== "object") {
          _this.fontOptions[n] = prop2;
        }
      });
    }
    /**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - Not all font options are set (vadjust, mod)
     *
     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {object} inOptions  font options to parse
     * @returns {boolean} true if font parsed as string, false otherwise
     * @static
     */
  }, {
    key: "constrain",
    value: (
      /**
       * Set the width and height constraints based on 'nearest' value
       *
       * @param {Array} pile array of option objects to consider
       * @returns {object} the actual constraint values to use
       * @private
       */
      function constrain(pile) {
        var fontOptions = {
          constrainWidth: false,
          maxWdt: -1,
          minWdt: -1,
          constrainHeight: false,
          minHgt: -1,
          valign: "middle"
        };
        var widthConstraint = topMost(pile, "widthConstraint");
        if (typeof widthConstraint === "number") {
          fontOptions.maxWdt = Number(widthConstraint);
          fontOptions.minWdt = Number(widthConstraint);
        } else if (_typeof$1(widthConstraint) === "object") {
          var widthConstraintMaximum = topMost(pile, ["widthConstraint", "maximum"]);
          if (typeof widthConstraintMaximum === "number") {
            fontOptions.maxWdt = Number(widthConstraintMaximum);
          }
          var widthConstraintMinimum = topMost(pile, ["widthConstraint", "minimum"]);
          if (typeof widthConstraintMinimum === "number") {
            fontOptions.minWdt = Number(widthConstraintMinimum);
          }
        }
        var heightConstraint = topMost(pile, "heightConstraint");
        if (typeof heightConstraint === "number") {
          fontOptions.minHgt = Number(heightConstraint);
        } else if (_typeof$1(heightConstraint) === "object") {
          var heightConstraintMinimum = topMost(pile, ["heightConstraint", "minimum"]);
          if (typeof heightConstraintMinimum === "number") {
            fontOptions.minHgt = Number(heightConstraintMinimum);
          }
          var heightConstraintValign = topMost(pile, ["heightConstraint", "valign"]);
          if (typeof heightConstraintValign === "string") {
            if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
              fontOptions.valign = heightConstraintValign;
            }
          }
        }
        return fontOptions;
      }
    )
    /**
     * Set options and update internal state
     *
     * @param {object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */
  }, {
    key: "update",
    value: function update2(options, pile) {
      this.setOptions(options, true);
      this.propagateFonts(pile);
      deepExtend(this.fontOptions, this.constrain(pile));
      this.fontOptions.chooser = choosify("label", pile);
    }
    /**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */
  }, {
    key: "adjustSizes",
    value: function adjustSizes(margins) {
      var widthBias = margins ? margins.right + margins.left : 0;
      if (this.fontOptions.constrainWidth) {
        this.fontOptions.maxWdt -= widthBias;
        this.fontOptions.minWdt -= widthBias;
      }
      var heightBias = margins ? margins.top + margins.bottom : 0;
      if (this.fontOptions.constrainHeight) {
        this.fontOptions.minHgt -= heightBias;
      }
    }
    /////////////////////////////////////////////////////////
    // Methods for handling options piles
    // Eventually, these will be moved to a separate class
    /////////////////////////////////////////////////////////
    /**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */
  }, {
    key: "addFontOptionsToPile",
    value: function addFontOptionsToPile(dstPile, srcPile) {
      for (var i = 0; i < srcPile.length; ++i) {
        this.addFontToPile(dstPile, srcPile[i]);
      }
    }
    /**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */
  }, {
    key: "addFontToPile",
    value: function addFontToPile(pile, options) {
      if (options === void 0)
        return;
      if (options.font === void 0 || options.font === null)
        return;
      var item = options.font;
      pile.push(item);
    }
    /**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */
  }, {
    key: "getBasicOptions",
    value: function getBasicOptions(pile) {
      var ret = {};
      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];
        var tmpShorthand = {};
        if (Label2.parseFontString(tmpShorthand, fontOptions)) {
          fontOptions = tmpShorthand;
        }
        forEach$4(fontOptions, function(opt, name2) {
          if (opt === void 0)
            return;
          if (Object.prototype.hasOwnProperty.call(ret, name2))
            return;
          if (_indexOfInstanceProperty(multiFontStyle).call(multiFontStyle, name2) !== -1) {
            ret[name2] = {};
          } else {
            ret[name2] = opt;
          }
        });
      }
      return ret;
    }
    /**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */
  }, {
    key: "getFontOption",
    value: function getFontOption(pile, multiName, option) {
      var multiFont;
      for (var n = 0; n < pile.length; ++n) {
        var fontOptions = pile[n];
        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {
          multiFont = fontOptions[multiName];
          if (multiFont === void 0 || multiFont === null)
            continue;
          var tmpShorthand = {};
          if (Label2.parseFontString(tmpShorthand, multiFont)) {
            multiFont = tmpShorthand;
          }
          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {
            return multiFont[option];
          }
        }
      }
      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {
        return this.fontOptions[option];
      }
      throw new Error("Did not find value for multi-font for property: '" + option + "'");
    }
    /**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */
  }, {
    key: "getFontOptions",
    value: function getFontOptions(pile, multiName) {
      var result = {};
      var optionNames = ["color", "size", "face", "mod", "vadjust"];
      for (var i = 0; i < optionNames.length; ++i) {
        var mod = optionNames[i];
        result[mod] = this.getFontOption(pile, multiName, mod);
      }
      return result;
    }
    /////////////////////////////////////////////////////////
    // End methods for handling options piles
    /////////////////////////////////////////////////////////
    /**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */
  }, {
    key: "propagateFonts",
    value: function propagateFonts(pile) {
      var _this2 = this;
      var fontPile = [];
      this.addFontOptionsToPile(fontPile, pile);
      this.fontOptions = this.getBasicOptions(fontPile);
      var _loop = function _loop2() {
        var mod = multiFontStyle[i];
        var modOptions = _this2.fontOptions[mod];
        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);
        forEach$4(tmpMultiFontOptions, function(option, n) {
          modOptions[n] = option;
        });
        modOptions.size = Number(modOptions.size);
        modOptions.vadjust = Number(modOptions.vadjust);
      };
      for (var i = 0; i < multiFontStyle.length; ++i) {
        _loop();
      }
    }
    /**
     * Main function. This is called from anything that wants to draw a label.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover) {
      var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
      if (this.elementOptions.label === void 0)
        return;
      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1)
        return;
      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
      }
      this.calculateLabelSize(ctx, selected, hover, x2, y2, baseline);
      this._drawBackground(ctx);
      this._drawText(ctx, x2, this.size.yLine, baseline, viewFontSize);
    }
    /**
     * Draws the label background
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */
  }, {
    key: "_drawBackground",
    value: function _drawBackground(ctx) {
      if (this.fontOptions.background !== void 0 && this.fontOptions.background !== "none") {
        ctx.fillStyle = this.fontOptions.background;
        var size = this.getSize();
        ctx.fillRect(size.left, size.top, size.width, size.height);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */
  }, {
    key: "_drawText",
    value: function _drawText(ctx, x2, y2) {
      var baseline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "middle";
      var viewFontSize = arguments.length > 4 ? arguments[4] : void 0;
      var _this$_setAlignment = this._setAlignment(ctx, x2, y2, baseline);
      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);
      x2 = _this$_setAlignment2[0];
      y2 = _this$_setAlignment2[1];
      ctx.textAlign = "left";
      x2 = x2 - this.size.width / 2;
      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
        if (this.fontOptions.valign === "top") {
          y2 -= (this.size.height - this.size.labelHeight) / 2;
        }
        if (this.fontOptions.valign === "bottom") {
          y2 += (this.size.height - this.size.labelHeight) / 2;
        }
      }
      for (var i = 0; i < this.lineCount; i++) {
        var line = this.lines[i];
        if (line && line.blocks) {
          var width = 0;
          if (this.isEdgeLabel || this.fontOptions.align === "center") {
            width += (this.size.width - line.width) / 2;
          } else if (this.fontOptions.align === "right") {
            width += this.size.width - line.width;
          }
          for (var j2 = 0; j2 < line.blocks.length; j2++) {
            var block2 = line.blocks[j2];
            ctx.font = block2.font;
            var _this$_getColor = this._getColor(block2.color, viewFontSize, block2.strokeColor), _this$_getColor2 = _slicedToArray(_this$_getColor, 2), fontColor = _this$_getColor2[0], strokeColor = _this$_getColor2[1];
            if (block2.strokeWidth > 0) {
              ctx.lineWidth = block2.strokeWidth;
              ctx.strokeStyle = strokeColor;
              ctx.lineJoin = "round";
            }
            ctx.fillStyle = fontColor;
            if (block2.strokeWidth > 0) {
              ctx.strokeText(block2.text, x2 + width, y2 + block2.vadjust);
            }
            ctx.fillText(block2.text, x2 + width, y2 + block2.vadjust);
            width += block2.width;
          }
          y2 += line.height;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */
  }, {
    key: "_setAlignment",
    value: function _setAlignment(ctx, x2, y2, baseline) {
      if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
        x2 = 0;
        y2 = 0;
        var lineMargin = 2;
        if (this.fontOptions.align === "top") {
          ctx.textBaseline = "alphabetic";
          y2 -= 2 * lineMargin;
        } else if (this.fontOptions.align === "bottom") {
          ctx.textBaseline = "hanging";
          y2 += 2 * lineMargin;
        } else {
          ctx.textBaseline = "middle";
        }
      } else {
        ctx.textBaseline = baseline;
      }
      return [x2, y2];
    }
    /**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */
  }, {
    key: "_getColor",
    value: function _getColor(color2, viewFontSize, initialStrokeColor) {
      var fontColor = color2 || "#000000";
      var strokeColor = initialStrokeColor || "#ffffff";
      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
        fontColor = overrideOpacity(fontColor, opacity);
        strokeColor = overrideOpacity(strokeColor, opacity);
      }
      return [fontColor, strokeColor];
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */
  }, {
    key: "getTextSize",
    value: function getTextSize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this._processLabel(ctx, selected, hover);
      return {
        width: this.size.width,
        height: this.size.height,
        lineCount: this.lineCount
      };
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */
  }, {
    key: "getSize",
    value: function getSize() {
      var lineMargin = 2;
      var x2 = this.size.left;
      var y2 = this.size.top - 0.5 * lineMargin;
      if (this.isEdgeLabel) {
        var x22 = -this.size.width * 0.5;
        switch (this.fontOptions.align) {
          case "middle":
            x2 = x22;
            y2 = -this.size.height * 0.5;
            break;
          case "top":
            x2 = x22;
            y2 = -(this.size.height + lineMargin);
            break;
          case "bottom":
            x2 = x22;
            y2 = lineMargin;
            break;
        }
      }
      var ret = {
        left: x2,
        top: y2,
        width: this.size.width,
        height: this.size.height
      };
      return ret;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */
  }, {
    key: "calculateLabelSize",
    value: function calculateLabelSize(ctx, selected, hover) {
      var x2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var y2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
      this._processLabel(ctx, selected, hover);
      this.size.left = x2 - this.size.width * 0.5;
      this.size.top = y2 - this.size.height * 0.5;
      this.size.yLine = y2 + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
      if (baseline === "hanging") {
        this.size.top += 0.5 * this.fontOptions.size;
        this.size.top += 4;
        this.size.yLine += 4;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */
  }, {
    key: "getFormattingValues",
    value: function getFormattingValues(ctx, selected, hover, mod) {
      var getValue = function getValue2(fontOptions, mod2, option) {
        if (mod2 === "normal") {
          if (option === "mod")
            return "";
          return fontOptions[option];
        }
        if (fontOptions[mod2][option] !== void 0) {
          return fontOptions[mod2][option];
        } else {
          return fontOptions[option];
        }
      };
      var values2 = {
        color: getValue(this.fontOptions, mod, "color"),
        size: getValue(this.fontOptions, mod, "size"),
        face: getValue(this.fontOptions, mod, "face"),
        mod: getValue(this.fontOptions, mod, "mod"),
        vadjust: getValue(this.fontOptions, mod, "vadjust"),
        strokeWidth: this.fontOptions.strokeWidth,
        strokeColor: this.fontOptions.strokeColor
      };
      if (selected || hover) {
        if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
          values2.mod = "bold";
        } else {
          if (typeof this.fontOptions.chooser === "function") {
            this.fontOptions.chooser(values2, this.elementOptions.id, selected, hover);
          }
        }
      }
      var fontString = "";
      if (values2.mod !== void 0 && values2.mod !== "") {
        fontString += values2.mod + " ";
      }
      fontString += values2.size + "px " + values2.face;
      ctx.font = fontString.replace(/"/g, "");
      values2.font = ctx.font;
      values2.height = values2.size;
      return values2;
    }
    /**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */
  }, {
    key: "differentState",
    value: function differentState(selected, hover) {
      return selected !== this.selectedState || hover !== this.hoverState;
    }
    /**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */
  }, {
    key: "_processLabelText",
    value: function _processLabelText(ctx, selected, hover, inText) {
      var splitter = new LabelSplitter(ctx, this, selected, hover);
      return splitter.process(inText);
    }
    /**
     * This explodes the label string into lines and sets the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */
  }, {
    key: "_processLabel",
    value: function _processLabel(ctx, selected, hover) {
      if (this.labelDirty === false && !this.differentState(selected, hover))
        return;
      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);
      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
        state.width = this.fontOptions.minWdt;
      }
      this.size.labelHeight = state.height;
      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
        state.height = this.fontOptions.minHgt;
      }
      this.lines = state.lines;
      this.lineCount = state.lines.length;
      this.size.width = state.width;
      this.size.height = state.height;
      this.selectedState = selected;
      this.hoverState = hover;
      this.labelDirty = false;
    }
    /**
     * Check if this label is visible
     *
     * @returns {boolean} true if this label will be show, false otherwise
     */
  }, {
    key: "visible",
    value: function visible() {
      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === void 0) {
        return false;
      }
      var viewFontSize = this.fontOptions.size * this.body.view.scale;
      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
        return false;
      }
      return true;
    }
  }], [{
    key: "parseFontString",
    value: function parseFontString(outOptions, inOptions) {
      if (!inOptions || typeof inOptions !== "string")
        return false;
      var newOptionsArray = inOptions.split(" ");
      outOptions.size = +newOptionsArray[0].replace("px", "");
      outOptions.face = newOptionsArray[1];
      outOptions.color = newOptionsArray[2];
      return true;
    }
  }]);
  return Label2;
}();
var NodeBase2 = /* @__PURE__ */ function() {
  function NodeBase3(options, body, labelModule) {
    _classCallCheck(this, NodeBase3);
    this.body = body;
    this.labelModule = labelModule;
    this.setOptions(options);
    this.top = void 0;
    this.left = void 0;
    this.height = void 0;
    this.width = void 0;
    this.radius = void 0;
    this.margin = void 0;
    this.refreshNeeded = true;
    this.boundingBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
  }
  _createClass(NodeBase3, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     *
     * @param {Label} labelModule
     * @private
     */
  }, {
    key: "_setMargins",
    value: function _setMargins(labelModule) {
      this.margin = {};
      if (this.options.margin) {
        if (_typeof$1(this.options.margin) == "object") {
          this.margin.top = this.options.margin.top;
          this.margin.right = this.options.margin.right;
          this.margin.bottom = this.options.margin.bottom;
          this.margin.left = this.options.margin.left;
        } else {
          this.margin.top = this.options.margin;
          this.margin.right = this.options.margin;
          this.margin.bottom = this.options.margin;
          this.margin.left = this.options.margin;
        }
      }
      labelModule.adjustSizes(this.margin);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */
  }, {
    key: "_distanceToBorder",
    value: function _distanceToBorder(ctx, angle) {
      var borderWidth = this.options.borderWidth;
      if (ctx) {
        this.resize(ctx);
      }
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values2) {
      if (values2.shadow) {
        ctx.shadowColor = values2.shadowColor;
        ctx.shadowBlur = values2.shadowSize;
        ctx.shadowOffsetX = values2.shadowX;
        ctx.shadowOffsetY = values2.shadowY;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values2) {
      if (values2.shadow) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "enableBorderDashes",
    value: function enableBorderDashes(ctx, values2) {
      if (values2.borderDashes !== false) {
        if (ctx.setLineDash !== void 0) {
          var dashes = values2.borderDashes;
          if (dashes === true) {
            dashes = [5, 15];
          }
          ctx.setLineDash(dashes);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values2.borderDashes = false;
        }
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "disableBorderDashes",
    value: function disableBorderDashes(ctx, values2) {
      if (values2.borderDashes !== false) {
        if (ctx.setLineDash !== void 0) {
          ctx.setLineDash([0]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
          this.options.shapeProperties.borderDashes = false;
          values2.borderDashes = false;
        }
      }
    }
    /**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */
  }, {
    key: "needsRefresh",
    value: function needsRefresh(selected, hover) {
      if (this.refreshNeeded === true) {
        this.refreshNeeded = false;
        return true;
      }
      return this.width === void 0 || this.labelModule.differentState(selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "initContextForDraw",
    value: function initContextForDraw(ctx, values2) {
      var borderWidth = values2.borderWidth / this.body.view.scale;
      ctx.lineWidth = Math.min(this.width, borderWidth);
      ctx.strokeStyle = values2.borderColor;
      ctx.fillStyle = values2.color;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "performStroke",
    value: function performStroke(ctx, values2) {
      var borderWidth = values2.borderWidth / this.body.view.scale;
      ctx.save();
      if (borderWidth > 0) {
        this.enableBorderDashes(ctx, values2);
        ctx.stroke();
        this.disableBorderDashes(ctx, values2);
      }
      ctx.restore();
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */
  }, {
    key: "performFill",
    value: function performFill(ctx, values2) {
      ctx.save();
      ctx.fillStyle = values2.color;
      this.enableShadow(ctx, values2);
      _fillInstanceProperty(ctx).call(ctx);
      this.disableShadow(ctx, values2);
      ctx.restore();
      this.performStroke(ctx, values2);
    }
    /**
     *
     * @param {number} margin
     * @private
     */
  }, {
    key: "_addBoundingBoxMargin",
    value: function _addBoundingBoxMargin(margin) {
      this.boundingBox.left -= margin;
      this.boundingBox.top -= margin;
      this.boundingBox.bottom += margin;
      this.boundingBox.right += margin;
    }
    /**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */
  }, {
    key: "_updateBoundingBox",
    value: function _updateBoundingBox(x2, y2, ctx, selected, hover) {
      if (ctx !== void 0) {
        this.resize(ctx, selected, hover);
      }
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
    }
    /**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2, ctx, selected, hover) {
      this._updateBoundingBox(x2, y2, ctx, selected, hover);
    }
    /**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */
  }, {
    key: "getDimensionsFromLabel",
    value: function getDimensionsFromLabel(ctx, selected, hover) {
      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
      var width = this.textSize.width;
      var height = this.textSize.height;
      var DEFAULT_SIZE = 14;
      if (width === 0) {
        width = DEFAULT_SIZE;
        height = DEFAULT_SIZE;
      }
      return {
        width,
        height
      };
    }
  }]);
  return NodeBase3;
}();
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Box$1 = /* @__PURE__ */ function(_NodeBase) {
  _inherits(Box2, _NodeBase);
  var _super = _createSuper$s(Box2);
  function Box2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, Box2);
    _this = _super.call(this, options, body, labelModule);
    _this._setMargins(labelModule);
    return _this;
  }
  _createClass(Box2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.width = dimensions.width + this.margin.right + this.margin.left;
        this.height = dimensions.height + this.margin.top + this.margin.bottom;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this.initContextForDraw(ctx, values2);
      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values2.borderRadius);
      this.performFill(ctx, values2);
      this.updateBoundingBox(x2, y2, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2, ctx, selected, hover) {
      this._updateBoundingBox(x2, y2, ctx, selected, hover);
      var borderRadius = this.options.shapeProperties.borderRadius;
      this._addBoundingBoxMargin(borderRadius);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }
      var borderWidth = this.options.borderWidth;
      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
    }
  }]);
  return Box2;
}(NodeBase2);
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var CircleImageBase = /* @__PURE__ */ function(_NodeBase) {
  _inherits(CircleImageBase2, _NodeBase);
  var _super = _createSuper$r(CircleImageBase2);
  function CircleImageBase2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, CircleImageBase2);
    _this = _super.call(this, options, body, labelModule);
    _this.labelOffset = 0;
    _this.selected = false;
    return _this;
  }
  _createClass(CircleImageBase2, [{
    key: "setOptions",
    value: function setOptions(options, imageObj, imageObjAlt) {
      this.options = options;
      if (!(imageObj === void 0 && imageObjAlt === void 0)) {
        this.setImages(imageObj, imageObjAlt);
      }
    }
    /**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */
  }, {
    key: "setImages",
    value: function setImages(imageObj, imageObjAlt) {
      if (imageObjAlt && this.selected) {
        this.imageObj = imageObjAlt;
        this.imageObjAlt = imageObj;
      } else {
        this.imageObj = imageObj;
        this.imageObjAlt = imageObjAlt;
      }
    }
    /**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */
  }, {
    key: "switchImages",
    value: function switchImages(selected) {
      var selection_changed = selected && !this.selected || !selected && this.selected;
      this.selected = selected;
      if (this.imageObjAlt !== void 0 && selection_changed) {
        var imageTmp = this.imageObj;
        this.imageObj = this.imageObjAlt;
        this.imageObjAlt = imageTmp;
      }
    }
    /**
     * Returns Image Padding from node options
     *
     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
     * @private
     */
  }, {
    key: "_getImagePadding",
    value: function _getImagePadding() {
      var imgPadding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      if (this.options.imagePadding) {
        var optImgPadding = this.options.imagePadding;
        if (_typeof$1(optImgPadding) == "object") {
          imgPadding.top = optImgPadding.top;
          imgPadding.right = optImgPadding.right;
          imgPadding.bottom = optImgPadding.bottom;
          imgPadding.left = optImgPadding.left;
        } else {
          imgPadding.top = optImgPadding;
          imgPadding.right = optImgPadding;
          imgPadding.bottom = optImgPadding;
          imgPadding.left = optImgPadding;
        }
      }
      return imgPadding;
    }
    /**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */
  }, {
    key: "_resizeImage",
    value: function _resizeImage() {
      var width, height;
      if (this.options.shapeProperties.useImageSize === false) {
        var ratio_width = 1;
        var ratio_height = 1;
        if (this.imageObj.width && this.imageObj.height) {
          if (this.imageObj.width > this.imageObj.height) {
            ratio_width = this.imageObj.width / this.imageObj.height;
          } else {
            ratio_height = this.imageObj.height / this.imageObj.width;
          }
        }
        width = this.options.size * 2 * ratio_width;
        height = this.options.size * 2 * ratio_height;
      } else {
        var imgPadding = this._getImagePadding();
        width = this.imageObj.width + imgPadding.left + imgPadding.right;
        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;
      }
      this.width = width;
      this.height = height;
      this.radius = 0.5 * this.width;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */
  }, {
    key: "_drawRawCircle",
    value: function _drawRawCircle(ctx, x2, y2, values2) {
      this.initContextForDraw(ctx, values2);
      drawCircle(ctx, x2, y2, values2.size);
      this.performFill(ctx, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */
  }, {
    key: "_drawImageAtPosition",
    value: function _drawImageAtPosition(ctx, values2) {
      if (this.imageObj.width != 0) {
        ctx.globalAlpha = values2.opacity !== void 0 ? values2.opacity : 1;
        this.enableShadow(ctx, values2);
        var factor = 1;
        if (this.options.shapeProperties.interpolation === true) {
          factor = this.imageObj.width / this.width / this.body.view.scale;
        }
        var imgPadding = this._getImagePadding();
        var imgPosLeft = this.left + imgPadding.left;
        var imgPosTop = this.top + imgPadding.top;
        var imgWidth = this.width - imgPadding.left - imgPadding.right;
        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;
        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight);
        this.disableShadow(ctx, values2);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */
  }, {
    key: "_drawImageLabel",
    value: function _drawImageLabel(ctx, x2, y2, selected, hover) {
      var offset = 0;
      if (this.height !== void 0) {
        offset = this.height * 0.5;
        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);
        if (labelDimensions.lineCount >= 1) {
          offset += labelDimensions.height / 2;
        }
      }
      var yLabel = y2 + offset;
      if (this.options.label) {
        this.labelOffset = offset;
      }
      this.labelModule.draw(ctx, x2, yLabel, selected, hover, "hanging");
    }
  }]);
  return CircleImageBase2;
}(NodeBase2);
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Circle$1 = /* @__PURE__ */ function(_CircleImageBase) {
  _inherits(Circle2, _CircleImageBase);
  var _super = _createSuper$q(Circle2);
  function Circle2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, Circle2);
    _this = _super.call(this, options, body, labelModule);
    _this._setMargins(labelModule);
    return _this;
  }
  _createClass(Circle2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
        this.options.size = diameter / 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this._drawRawCircle(ctx, x2, y2, values2);
      this.updateBoundingBox(x2, y2);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y2, selected, hover);
    }
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2) {
      this.boundingBox.top = y2 - this.options.size;
      this.boundingBox.left = x2 - this.options.size;
      this.boundingBox.right = x2 + this.options.size;
      this.boundingBox.bottom = y2 + this.options.size;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }
      return this.width * 0.5;
    }
  }]);
  return Circle2;
}(CircleImageBase);
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var CircularImage = /* @__PURE__ */ function(_CircleImageBase) {
  _inherits(CircularImage2, _CircleImageBase);
  var _super = _createSuper$p(CircularImage2);
  function CircularImage2(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;
    _classCallCheck(this, CircularImage2);
    _this = _super.call(this, options, body, labelModule);
    _this.setImages(imageObj, imageObjAlt);
    return _this;
  }
  _createClass(CircularImage2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
      if (imageAbsent) {
        var diameter = this.options.size * 2;
        this.width = diameter;
        this.height = diameter;
        this.radius = 0.5 * this.width;
        return;
      }
      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.switchImages(selected);
      this.resize();
      var labelX = x2, labelY = y2;
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x2;
        this.top = y2;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x2 - this.width / 2;
        this.top = y2 - this.height / 2;
      }
      this._drawRawCircle(ctx, labelX, labelY, values2);
      ctx.save();
      ctx.clip();
      this._drawImageAtPosition(ctx, values2);
      ctx.restore();
      this._drawImageLabel(ctx, labelX, labelY, selected, hover);
      this.updateBoundingBox(x2, y2);
    }
    // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here
    /**
     *
     * @param {number} x width
     * @param {number} y height
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2) {
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.boundingBox.top = y2;
        this.boundingBox.left = x2;
        this.boundingBox.right = x2 + this.options.size * 2;
        this.boundingBox.bottom = y2 + this.options.size * 2;
      } else {
        this.boundingBox.top = y2 - this.options.size;
        this.boundingBox.left = x2 - this.options.size;
        this.boundingBox.right = x2 + this.options.size;
        this.boundingBox.bottom = y2 + this.options.size;
      }
      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }
      return this.width * 0.5;
    }
  }]);
  return CircularImage2;
}(CircleImageBase);
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ShapeBase = /* @__PURE__ */ function(_NodeBase) {
  _inherits(ShapeBase2, _NodeBase);
  var _super = _createSuper$o(ShapeBase2);
  function ShapeBase2(options, body, labelModule) {
    _classCallCheck(this, ShapeBase2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(ShapeBase2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      var values2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        size: this.options.size
      };
      if (this.needsRefresh(selected, hover)) {
        var _this$customSizeWidth, _this$customSizeHeigh;
        this.labelModule.getTextSize(ctx, selected, hover);
        var size = 2 * values2.size;
        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;
        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */
  }, {
    key: "_drawShape",
    value: function _drawShape(ctx, shape, sizeMultiplier, x2, y2, selected, hover, values2) {
      var _this = this;
      this.resize(ctx, selected, hover, values2);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this.initContextForDraw(ctx, values2);
      getShape(shape)(ctx, x2, y2, values2.size);
      this.performFill(ctx, values2);
      if (this.options.icon !== void 0) {
        if (this.options.icon.code !== void 0) {
          ctx.font = (selected ? "bold " : "") + this.height / 2 + "px " + (this.options.icon.face || "FontAwesome");
          ctx.fillStyle = this.options.icon.color || "black";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.options.icon.code, x2, y2);
        }
      }
      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this.options.label !== void 0) {
            _this.labelModule.calculateLabelSize(ctx, selected, hover, x2, y2, "hanging");
            var yLabel = y2 + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;
            _this.labelModule.draw(ctx, x2, yLabel, selected, hover, "hanging");
          }
          _this.updateBoundingBox(x2, y2);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2) {
      this.boundingBox.top = y2 - this.options.size;
      this.boundingBox.left = x2 - this.options.size;
      this.boundingBox.right = x2 + this.options.size;
      this.boundingBox.bottom = y2 + this.options.size;
      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
      }
    }
  }]);
  return ShapeBase2;
}(NodeBase2);
function ownKeys$3(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor$1(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context, _context2;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context = ownKeys$3(Object(t), true)).call(_context, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys$3(Object(t))).call(_context2, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor$1(t, r2));
    });
  }
  return e;
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var CustomShape = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(CustomShape2, _ShapeBase);
  var _super = _createSuper$n(CustomShape2);
  function CustomShape2(options, body, labelModule, ctxRenderer) {
    var _this;
    _classCallCheck(this, CustomShape2);
    _this = _super.call(this, options, body, labelModule, ctxRenderer);
    _this.ctxRenderer = ctxRenderer;
    return _this;
  }
  _createClass(CustomShape2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover, values2);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      ctx.save();
      var drawLater = this.ctxRenderer({
        ctx,
        id: this.options.id,
        x: x2,
        y: y2,
        state: {
          selected,
          hover
        },
        style: _objectSpread$3({}, values2),
        label: this.options.label
      });
      if (drawLater.drawNode != null) {
        drawLater.drawNode();
      }
      ctx.restore();
      if (drawLater.drawExternalLabel) {
        var drawExternalLabel = drawLater.drawExternalLabel;
        drawLater.drawExternalLabel = function() {
          ctx.save();
          drawExternalLabel();
          ctx.restore();
        };
      }
      if (drawLater.nodeDimensions) {
        this.customSizeWidth = drawLater.nodeDimensions.width;
        this.customSizeHeight = drawLater.nodeDimensions.height;
      }
      return drawLater;
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return CustomShape2;
}(ShapeBase);
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Database = /* @__PURE__ */ function(_NodeBase) {
  _inherits(Database2, _NodeBase);
  var _super = _createSuper$m(Database2);
  function Database2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, Database2);
    _this = _super.call(this, options, body, labelModule);
    _this._setMargins(labelModule);
    return _this;
  }
  _createClass(Database2, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        var size = dimensions.width + this.margin.right + this.margin.left;
        this.width = size;
        this.height = size;
        this.radius = this.width / 2;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this.initContextForDraw(ctx, values2);
      drawDatabase(ctx, x2 - this.width / 2, y2 - this.height / 2, this.width, this.height);
      this.performFill(ctx, values2);
      this.updateBoundingBox(x2, y2, ctx, selected, hover);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Database2;
}(NodeBase2);
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Diamond$1 = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Diamond2, _ShapeBase);
  var _super = _createSuper$l(Diamond2);
  function Diamond2(options, body, labelModule) {
    _classCallCheck(this, Diamond2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Diamond2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "diamond", 4, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Diamond2;
}(ShapeBase);
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Dot = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Dot2, _ShapeBase);
  var _super = _createSuper$k(Dot2);
  function Dot2(options, body, labelModule) {
    _classCallCheck(this, Dot2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Dot2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "circle", 2, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx) {
      if (ctx) {
        this.resize(ctx);
      }
      return this.options.size;
    }
  }]);
  return Dot2;
}(ShapeBase);
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Ellipse = /* @__PURE__ */ function(_NodeBase) {
  _inherits(Ellipse2, _NodeBase);
  var _super = _createSuper$j(Ellipse2);
  function Ellipse2(options, body, labelModule) {
    _classCallCheck(this, Ellipse2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Ellipse2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      if (this.needsRefresh(selected, hover)) {
        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
        this.height = dimensions.height * 2;
        this.width = dimensions.width + dimensions.height;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover);
      this.left = x2 - this.width * 0.5;
      this.top = y2 - this.height * 0.5;
      this.initContextForDraw(ctx, values2);
      drawEllipse(ctx, this.left, this.top, this.width, this.height);
      this.performFill(ctx, values2);
      this.updateBoundingBox(x2, y2, ctx, selected, hover);
      this.labelModule.draw(ctx, x2, y2, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      if (ctx) {
        this.resize(ctx);
      }
      var a = this.width * 0.5;
      var b = this.height * 0.5;
      var w = Math.sin(angle) * a;
      var h2 = Math.cos(angle) * b;
      return a * b / Math.sqrt(w * w + h2 * h2);
    }
  }]);
  return Ellipse2;
}(NodeBase2);
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Icon = /* @__PURE__ */ function(_NodeBase) {
  _inherits(Icon2, _NodeBase);
  var _super = _createSuper$i(Icon2);
  function Icon2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, Icon2);
    _this = _super.call(this, options, body, labelModule);
    _this._setMargins(labelModule);
    return _this;
  }
  _createClass(Icon2, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.iconSize = {
          width: Number(this.options.icon.size),
          height: Number(this.options.icon.size)
        };
        this.width = this.iconSize.width + this.margin.right + this.margin.left;
        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @returns {object} Callbacks to draw later on higher layers.
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      var _this2 = this;
      this.resize(ctx, selected, hover);
      this.options.icon.size = this.options.icon.size || 50;
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this._icon(ctx, x2, y2, selected, hover, values2);
      return {
        drawExternalLabel: function drawExternalLabel() {
          if (_this2.options.label !== void 0) {
            var iconTextSpacing = 5;
            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y2 + _this2.height / 2 + iconTextSpacing, selected);
          }
          _this2.updateBoundingBox(x2, y2);
        }
      };
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2) {
      this.boundingBox.top = y2 - this.options.icon.size * 0.5;
      this.boundingBox.left = x2 - this.options.icon.size * 0.5;
      this.boundingBox.right = x2 + this.options.icon.size * 0.5;
      this.boundingBox.bottom = y2 + this.options.icon.size * 0.5;
      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
        var iconTextSpacing = 5;
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */
  }, {
    key: "_icon",
    value: function _icon(ctx, x2, y2, selected, hover, values2) {
      var iconSize = Number(this.options.icon.size);
      if (this.options.icon.code !== void 0) {
        ctx.font = [
          this.options.icon.weight != null ? this.options.icon.weight : selected ? "bold" : "",
          // If the weight is forced (for example to make Font Awesome 5 work
          // properly) substitute slightly bigger size for bold font face.
          (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + "px",
          this.options.icon.face
        ].join(" ");
        ctx.fillStyle = this.options.icon.color || "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        this.enableShadow(ctx, values2);
        ctx.fillText(this.options.icon.code, x2, y2);
        this.disableShadow(ctx, values2);
      } else {
        console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Icon2;
}(NodeBase2);
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Image$2 = /* @__PURE__ */ function(_CircleImageBase) {
  _inherits(Image2, _CircleImageBase);
  var _super = _createSuper$h(Image2);
  function Image2(options, body, labelModule, imageObj, imageObjAlt) {
    var _this;
    _classCallCheck(this, Image2);
    _this = _super.call(this, options, body, labelModule);
    _this.setImages(imageObj, imageObjAlt);
    return _this;
  }
  _createClass(Image2, [{
    key: "resize",
    value: function resize(ctx) {
      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
      var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
      if (imageAbsent) {
        var side = this.options.size * 2;
        this.width = side;
        this.height = side;
        return;
      }
      if (this.needsRefresh(selected, hover)) {
        this._resizeImage();
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      ctx.save();
      this.switchImages(selected);
      this.resize();
      var labelX = x2, labelY = y2;
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x2;
        this.top = y2;
        labelX += this.width / 2;
        labelY += this.height / 2;
      } else {
        this.left = x2 - this.width / 2;
        this.top = y2 - this.height / 2;
      }
      if (this.options.shapeProperties.useBorderWithImage === true) {
        var neutralborderWidth = this.options.borderWidth;
        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
        ctx.lineWidth = Math.min(this.width, borderWidth);
        ctx.beginPath();
        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
        if (values2.opacity !== void 0) {
          strokeStyle = overrideOpacity(strokeStyle, values2.opacity);
          fillStyle = overrideOpacity(fillStyle, values2.opacity);
        }
        ctx.strokeStyle = strokeStyle;
        ctx.fillStyle = fillStyle;
        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
        _fillInstanceProperty(ctx).call(ctx);
        this.performStroke(ctx, values2);
        ctx.closePath();
      }
      this._drawImageAtPosition(ctx, values2);
      this._drawImageLabel(ctx, labelX, labelY, selected, hover);
      this.updateBoundingBox(x2, y2);
      ctx.restore();
    }
    /**
     *
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(x2, y2) {
      this.resize();
      if (this.options.shapeProperties.coordinateOrigin === "top-left") {
        this.left = x2;
        this.top = y2;
      } else {
        this.left = x2 - this.width / 2;
        this.top = y2 - this.height / 2;
      }
      this.boundingBox.left = this.left;
      this.boundingBox.top = this.top;
      this.boundingBox.bottom = this.top + this.height;
      this.boundingBox.right = this.left + this.width;
      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Image2;
}(CircleImageBase);
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Square = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Square2, _ShapeBase);
  var _super = _createSuper$g(Square2);
  function Square2(options, body, labelModule) {
    _classCallCheck(this, Square2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Square2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "square", 2, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Square2;
}(ShapeBase);
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Hexagon = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Hexagon2, _ShapeBase);
  var _super = _createSuper$f(Hexagon2);
  function Hexagon2(options, body, labelModule) {
    _classCallCheck(this, Hexagon2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Hexagon2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "hexagon", 4, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Hexagon2;
}(ShapeBase);
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Star = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Star2, _ShapeBase);
  var _super = _createSuper$e(Star2);
  function Star2(options, body, labelModule) {
    _classCallCheck(this, Star2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Star2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "star", 4, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Star2;
}(ShapeBase);
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Text2 = /* @__PURE__ */ function(_NodeBase) {
  _inherits(Text3, _NodeBase);
  var _super = _createSuper$d(Text3);
  function Text3(options, body, labelModule) {
    var _this;
    _classCallCheck(this, Text3);
    _this = _super.call(this, options, body, labelModule);
    _this._setMargins(labelModule);
    return _this;
  }
  _createClass(Text3, [{
    key: "resize",
    value: function resize(ctx, selected, hover) {
      if (this.needsRefresh(selected, hover)) {
        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
        this.width = this.textSize.width + this.margin.right + this.margin.left;
        this.height = this.textSize.height + this.margin.top + this.margin.bottom;
        this.radius = 0.5 * this.width;
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */
  }, {
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      this.resize(ctx, selected, hover);
      this.left = x2 - this.width / 2;
      this.top = y2 - this.height / 2;
      this.enableShadow(ctx, values2);
      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
      this.disableShadow(ctx, values2);
      this.updateBoundingBox(x2, y2, ctx, selected, hover);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Text3;
}(NodeBase2);
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Triangle$1 = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(Triangle2, _ShapeBase);
  var _super = _createSuper$c(Triangle2);
  function Triangle2(options, body, labelModule) {
    _classCallCheck(this, Triangle2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(Triangle2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "triangle", 3, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return Triangle2;
}(ShapeBase);
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var TriangleDown = /* @__PURE__ */ function(_ShapeBase) {
  _inherits(TriangleDown2, _ShapeBase);
  var _super = _createSuper$b(TriangleDown2);
  function TriangleDown2(options, body, labelModule) {
    _classCallCheck(this, TriangleDown2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(TriangleDown2, [{
    key: "draw",
    value: function draw(ctx, x2, y2, selected, hover, values2) {
      return this._drawShape(ctx, "triangleDown", 3, x2, y2, selected, hover, values2);
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this._distanceToBorder(ctx, angle);
    }
  }]);
  return TriangleDown2;
}(ShapeBase);
function ownKeys$2(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor$1(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context5, _context6;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context5 = ownKeys$2(Object(t), true)).call(_context5, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context6 = ownKeys$2(Object(t))).call(_context6, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor$1(t, r2));
    });
  }
  return e;
}
var Node$1 = /* @__PURE__ */ function() {
  function Node3(options, body, imagelist, grouplist, globalOptions, defaultOptions2) {
    _classCallCheck(this, Node3);
    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions2;
    this.body = body;
    this.edges = [];
    this.id = void 0;
    this.imagelist = imagelist;
    this.grouplist = grouplist;
    this.x = void 0;
    this.y = void 0;
    this.baseSize = this.options.size;
    this.baseFontSize = this.options.font.size;
    this.predefinedPosition = false;
    this.selected = false;
    this.hover = false;
    this.labelModule = new Label(
      this.body,
      this.options,
      false
      /* Not edge label */
    );
    this.setOptions(options);
  }
  _createClass(Node3, [{
    key: "attachEdge",
    value: function attachEdge(edge) {
      var _context;
      if (_indexOfInstanceProperty(_context = this.edges).call(_context, edge) === -1) {
        this.edges.push(edge);
      }
    }
    /**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */
  }, {
    key: "detachEdge",
    value: function detachEdge(edge) {
      var _context2;
      var index2 = _indexOfInstanceProperty(_context2 = this.edges).call(_context2, edge);
      if (index2 != -1) {
        var _context3;
        _spliceInstanceProperty(_context3 = this.edges).call(_context3, index2, 1);
      }
    }
    /**
     * Set or overwrite options for the node
     *
     * @param {object} options an object with options
     * @returns {null|boolean}
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var currentShape = this.options.shape;
      if (!options) {
        return;
      }
      if (typeof options.color !== "undefined") {
        this._localColor = options.color;
      }
      if (options.id !== void 0) {
        this.id = options.id;
      }
      if (this.id === void 0) {
        throw new Error("Node must have an id");
      }
      Node3.checkMass(options, this.id);
      if (options.x !== void 0) {
        if (options.x === null) {
          this.x = void 0;
          this.predefinedPosition = false;
        } else {
          this.x = _parseInt$1(options.x);
          this.predefinedPosition = true;
        }
      }
      if (options.y !== void 0) {
        if (options.y === null) {
          this.y = void 0;
          this.predefinedPosition = false;
        } else {
          this.y = _parseInt$1(options.y);
          this.predefinedPosition = true;
        }
      }
      if (options.size !== void 0) {
        this.baseSize = options.size;
      }
      if (options.value !== void 0) {
        options.value = _parseFloat$1(options.value);
      }
      Node3.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("node", pile);
      this._load_images();
      this.updateLabelModule(options);
      if (options.opacity !== void 0 && Node3.checkOpacity(options.opacity)) {
        this.options.opacity = options.opacity;
      }
      this.updateShape(currentShape);
      return options.hidden !== void 0 || options.physics !== void 0;
    }
    /**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */
  }, {
    key: "_load_images",
    value: function _load_images() {
      if (this.options.shape === "circularImage" || this.options.shape === "image") {
        if (this.options.image === void 0) {
          throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
        }
      }
      if (this.options.image === void 0) {
        return;
      }
      if (this.imagelist === void 0) {
        throw new Error("Internal Error: No images provided");
      }
      if (typeof this.options.image === "string") {
        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
      } else {
        if (this.options.image.unselected === void 0) {
          throw new Error("No unselected image provided");
        }
        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);
        if (this.options.image.selected !== void 0) {
          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
        } else {
          this.imageObjAlt = void 0;
        }
      }
    }
    /**
     * Check that opacity is only between 0 and 1
     *
     * @param {number} opacity
     * @returns {boolean}
     */
  }, {
    key: "getFormattingValues",
    value: (
      /**
       *
       * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
       */
      function getFormattingValues() {
        var values2 = {
          color: this.options.color.background,
          opacity: this.options.opacity,
          borderWidth: this.options.borderWidth,
          borderColor: this.options.color.border,
          size: this.options.size,
          borderDashes: this.options.shapeProperties.borderDashes,
          borderRadius: this.options.shapeProperties.borderRadius,
          shadow: this.options.shadow.enabled,
          shadowColor: this.options.shadow.color,
          shadowSize: this.options.shadow.size,
          shadowX: this.options.shadow.x,
          shadowY: this.options.shadow.y
        };
        if (this.selected || this.hover) {
          if (this.chooser === true) {
            if (this.selected) {
              if (this.options.borderWidthSelected != null) {
                values2.borderWidth = this.options.borderWidthSelected;
              } else {
                values2.borderWidth *= 2;
              }
              values2.color = this.options.color.highlight.background;
              values2.borderColor = this.options.color.highlight.border;
              values2.shadow = this.options.shadow.enabled;
            } else if (this.hover) {
              values2.color = this.options.color.hover.background;
              values2.borderColor = this.options.color.hover.border;
              values2.shadow = this.options.shadow.enabled;
            }
          } else if (typeof this.chooser === "function") {
            this.chooser(values2, this.options.id, this.selected, this.hover);
            if (values2.shadow === false) {
              if (values2.shadowColor !== this.options.shadow.color || values2.shadowSize !== this.options.shadow.size || values2.shadowX !== this.options.shadow.x || values2.shadowY !== this.options.shadow.y) {
                values2.shadow = true;
              }
            }
          }
        } else {
          values2.shadow = this.options.shadow.enabled;
        }
        if (this.options.opacity !== void 0) {
          var opacity = this.options.opacity;
          values2.borderColor = overrideOpacity(values2.borderColor, opacity);
          values2.color = overrideOpacity(values2.color, opacity);
          values2.shadowColor = overrideOpacity(values2.shadowColor, opacity);
        }
        return values2;
      }
    )
    /**
     *
     * @param {object} options
     */
  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      if (this.options.label === void 0 || this.options.label === null) {
        this.options.label = "";
      }
      Node3.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {
        color: options && options.color || this._localColor || void 0
      }), this.grouplist);
      var currentGroup = this.grouplist.get(this.options.group, false);
      var pile = [
        options,
        // new options
        this.options,
        // current node options, see comment above for prototype
        currentGroup,
        // group options, if any
        this.globalOptions,
        // Currently set global node options
        this.defaultOptions
        // Default global node options
      ];
      this.labelModule.update(this.options, pile);
      if (this.labelModule.baseSize !== void 0) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     *
     * @param {string} currentShape
     */
  }, {
    key: "updateShape",
    value: function updateShape(currentShape) {
      if (currentShape === this.options.shape && this.shape) {
        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
      } else {
        switch (this.options.shape) {
          case "box":
            this.shape = new Box$1(this.options, this.body, this.labelModule);
            break;
          case "circle":
            this.shape = new Circle$1(this.options, this.body, this.labelModule);
            break;
          case "circularImage":
            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;
          case "custom":
            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);
            break;
          case "database":
            this.shape = new Database(this.options, this.body, this.labelModule);
            break;
          case "diamond":
            this.shape = new Diamond$1(this.options, this.body, this.labelModule);
            break;
          case "dot":
            this.shape = new Dot(this.options, this.body, this.labelModule);
            break;
          case "ellipse":
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
          case "icon":
            this.shape = new Icon(this.options, this.body, this.labelModule);
            break;
          case "image":
            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
            break;
          case "square":
            this.shape = new Square(this.options, this.body, this.labelModule);
            break;
          case "hexagon":
            this.shape = new Hexagon(this.options, this.body, this.labelModule);
            break;
          case "star":
            this.shape = new Star(this.options, this.body, this.labelModule);
            break;
          case "text":
            this.shape = new Text2(this.options, this.body, this.labelModule);
            break;
          case "triangle":
            this.shape = new Triangle$1(this.options, this.body, this.labelModule);
            break;
          case "triangleDown":
            this.shape = new TriangleDown(this.options, this.body, this.labelModule);
            break;
          default:
            this.shape = new Ellipse(this.options, this.body, this.labelModule);
            break;
        }
      }
      this.needsRefresh();
    }
    /**
     * select this node
     */
  }, {
    key: "select",
    value: function select2() {
      this.selected = true;
      this.needsRefresh();
    }
    /**
     * unselect this node
     */
  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
      this.needsRefresh();
    }
    /**
     * Reset the calculated size of the node, forces it to recalculate its size
     */
  }, {
    key: "needsRefresh",
    value: function needsRefresh() {
      this.shape.refreshNeeded = true;
    }
    /**
     * get the title of this node.
     *
     * @returns {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */
  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.options.title;
    }
    /**
     * Calculate the distance to the border of the Node
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */
  }, {
    key: "distanceToBorder",
    value: function distanceToBorder(ctx, angle) {
      return this.shape.distanceToBorder(ctx, angle);
    }
    /**
     * Check if this node has a fixed x and y position
     *
     * @returns {boolean}      true if fixed, false if not
     */
  }, {
    key: "isFixed",
    value: function isFixed() {
      return this.options.fixed.x && this.options.fixed.y;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */
  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the node. Can be undefined
     *
     * @returns {number} value
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */
  }, {
    key: "getLabelSize",
    value: function getLabelSize() {
      return this.labelModule.size();
    }
    /**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */
  }, {
    key: "setValueRange",
    value: function setValueRange(min2, max2, total) {
      if (this.options.value !== void 0) {
        var scale = this.options.scaling.customScalingFunction(min2, max2, total, this.options.value);
        var sizeDiff = this.options.scaling.max - this.options.scaling.min;
        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }
        this.options.size = this.options.scaling.min + scale * sizeDiff;
      } else {
        this.options.size = this.baseSize;
        this.options.font.size = this.baseFontSize;
      }
      this.updateLabelModule();
    }
    /**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @returns {object} Callbacks to draw later on higher layers.
     */
  }, {
    key: "draw",
    value: function draw(ctx) {
      var values2 = this.getFormattingValues();
      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values2) || {};
    }
    /**
     * Update the bounding box of the shape
     *
     * @param {CanvasRenderingContext2D}   ctx
     */
  }, {
    key: "updateBoundingBox",
    value: function updateBoundingBox(ctx) {
      this.shape.updateBoundingBox(this.x, this.y, ctx);
    }
    /**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */
  }, {
    key: "resize",
    value: function resize(ctx) {
      var values2 = this.getFormattingValues();
      this.shape.resize(ctx, this.selected, this.hover, values2);
    }
    /**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */
  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];
      if (this.labelModule.visible()) {
        if (pointInRect(this.labelModule.getSize(), point)) {
          ret.push({
            nodeId: this.id,
            labelId: 0
          });
        }
      }
      if (pointInRect(this.shape.boundingBox, point)) {
        ret.push({
          nodeId: this.id
        });
      }
      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */
  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */
  }, {
    key: "isBoundingBoxOverlappingWith",
    value: function isBoundingBoxOverlappingWith(obj) {
      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
    }
    /**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */
  }], [{
    key: "checkOpacity",
    value: function checkOpacity(opacity) {
      return 0 <= opacity && opacity <= 1;
    }
    /**
     * Check that origin is 'center' or 'top-left'
     *
     * @param {string} origin
     * @returns {boolean}
     */
  }, {
    key: "checkCoordinateOrigin",
    value: function checkCoordinateOrigin(origin) {
      return origin === void 0 || origin === "center" || origin === "top-left";
    }
    /**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {object} parentOptions
     * @param {object} newOptions  new values for the options, currently only passed in for check
     * @param {object} groupList
     */
  }, {
    key: "updateGroupOptions",
    value: function updateGroupOptions(parentOptions, newOptions, groupList) {
      var _context4;
      if (groupList === void 0)
        return;
      var group = parentOptions.group;
      if (newOptions !== void 0 && newOptions.group !== void 0 && group !== newOptions.group) {
        throw new Error("updateGroupOptions: group values in options don't match.");
      }
      var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
      if (!hasGroup)
        return;
      var groupObj = groupList.get(group);
      if (groupObj.opacity !== void 0 && newOptions.opacity === void 0) {
        if (!Node3.checkOpacity(groupObj.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + groupObj.opacity);
          groupObj.opacity = void 0;
        }
      }
      var skipProperties = _filterInstanceProperty(_context4 = _Object$getOwnPropertyNames(newOptions)).call(_context4, function(p) {
        return newOptions[p] != null;
      });
      skipProperties.push("font");
      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);
      parentOptions.color = parseColor(parentOptions.color);
    }
    /**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {object} [groupList]
     * @static
     */
  }, {
    key: "parseOptions",
    value: function parseOptions2(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var groupList = arguments.length > 4 ? arguments[4] : void 0;
      var fields = ["color", "fixed", "shadow"];
      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
      Node3.checkMass(newOptions);
      if (parentOptions.opacity !== void 0) {
        if (!Node3.checkOpacity(parentOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + parentOptions.opacity);
          parentOptions.opacity = void 0;
        }
      }
      if (newOptions.opacity !== void 0) {
        if (!Node3.checkOpacity(newOptions.opacity)) {
          console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + newOptions.opacity);
          newOptions.opacity = void 0;
        }
      }
      if (newOptions.shapeProperties && !Node3.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {
        console.error("Invalid option for node coordinateOrigin, found: " + newOptions.shapeProperties.coordinateOrigin);
      }
      mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
      if (newOptions.color !== void 0 && newOptions.color !== null) {
        var parsedColor = parseColor(newOptions.color);
        fillIfDefined(parentOptions.color, parsedColor);
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color);
      }
      if (newOptions.fixed !== void 0 && newOptions.fixed !== null) {
        if (typeof newOptions.fixed === "boolean") {
          parentOptions.fixed.x = newOptions.fixed;
          parentOptions.fixed.y = newOptions.fixed;
        } else {
          if (newOptions.fixed.x !== void 0 && typeof newOptions.fixed.x === "boolean") {
            parentOptions.fixed.x = newOptions.fixed.x;
          }
          if (newOptions.fixed.y !== void 0 && typeof newOptions.fixed.y === "boolean") {
            parentOptions.fixed.y = newOptions.fixed.y;
          }
        }
      }
      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font);
      }
      Node3.updateGroupOptions(parentOptions, newOptions, groupList);
      if (newOptions.scaling !== void 0) {
        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      }
    }
  }, {
    key: "checkMass",
    value: function checkMass(options, id2) {
      if (options.mass !== void 0 && options.mass <= 0) {
        var strId = "";
        if (id2 !== void 0) {
          strId = " in node id: " + id2;
        }
        console.error("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", VALIDATOR_PRINT_STYLE);
        options.mass = 1;
      }
    }
  }]);
  return Node3;
}();
function _createForOfIteratorHelper$5(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$5(o, minLen) {
  var _context4;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$5(o, minLen);
  var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var NodesHandler = /* @__PURE__ */ function() {
  function NodesHandler2(body, images2, groups, layoutEngine) {
    var _context, _this = this;
    _classCallCheck(this, NodesHandler2);
    this.body = body;
    this.images = images2;
    this.groups = groups;
    this.layoutEngine = layoutEngine;
    this.body.functions.createNode = _bindInstanceProperty$1(_context = this.create).call(_context, this);
    this.nodesListeners = {
      add: function add3(event, params) {
        _this.add(params.items);
      },
      update: function update2(event, params) {
        _this.update(params.items, params.data, params.oldData);
      },
      remove: function remove2(event, params) {
        _this.remove(params.items);
      }
    };
    this.defaultOptions = {
      borderWidth: 1,
      borderWidthSelected: void 0,
      brokenImage: void 0,
      color: {
        border: "#2B7CE9",
        background: "#97C2FC",
        highlight: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        },
        hover: {
          border: "#2B7CE9",
          background: "#D2E5FF"
        }
      },
      opacity: void 0,
      // number between 0 and 1
      fixed: {
        x: false,
        y: false
      },
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 0,
        // px
        strokeColor: "#ffffff",
        align: "center",
        vadjust: 0,
        multi: false,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "monospace",
          vadjust: 2
        }
      },
      group: void 0,
      hidden: false,
      icon: {
        face: "FontAwesome",
        //'FontAwesome',
        code: void 0,
        //'\uf007',
        size: 50,
        //50,
        color: "#2B7CE9"
        //'#aa00ff'
      },
      image: void 0,
      // --> URL
      imagePadding: {
        // only for image shape
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      label: void 0,
      labelHighlightBold: true,
      level: void 0,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      },
      mass: 1,
      physics: true,
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: false,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min2, max2, total, value) {
          if (max2 === min2) {
            return 0.5;
          } else {
            var scale = 1 / (max2 - min2);
            return Math.max(0, (value - min2) * scale);
          }
        }
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      shape: "ellipse",
      shapeProperties: {
        borderDashes: false,
        // only for borders
        borderRadius: 6,
        // only for box shape
        interpolation: true,
        // only for image and circularImage shapes
        useImageSize: false,
        // only for image and circularImage shapes
        useBorderWithImage: false,
        // only for image shape
        coordinateOrigin: "center"
        // only for image and circularImage shapes
      },
      size: 25,
      title: void 0,
      value: void 0,
      x: void 0,
      y: void 0
    };
    if (this.defaultOptions.mass <= 0) {
      throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
    }
    this.options = bridgeObject(this.defaultOptions);
    this.bindEventListeners();
  }
  _createClass(NodesHandler2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _context2, _context3, _this2 = this;
      this.body.emitter.on("refreshNodes", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function() {
        forEach$4(_this2.nodesListeners, function(callback, event) {
          if (_this2.body.data.nodes)
            _this2.body.data.nodes.off(event, callback);
        });
        delete _this2.body.functions.createNode;
        delete _this2.nodesListeners.add;
        delete _this2.nodesListeners.update;
        delete _this2.nodesListeners.remove;
        delete _this2.nodesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        Node$1.parseOptions(this.options, options);
        if (options.opacity !== void 0) {
          if (_Number$isNaN(options.opacity) || !_Number$isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {
            console.error("Invalid option for node opacity. Value must be between 0 and 1, found: " + options.opacity);
          } else {
            this.options.opacity = options.opacity;
          }
        }
        if (options.shape !== void 0) {
          for (var nodeId in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
              this.body.nodes[nodeId].updateShape();
            }
          }
        }
        if (typeof options.font !== "undefined" || typeof options.widthConstraint !== "undefined" || typeof options.heightConstraint !== "undefined") {
          for (var _i = 0, _Object$keys$1 = _Object$keys(this.body.nodes); _i < _Object$keys$1.length; _i++) {
            var _nodeId = _Object$keys$1[_i];
            this.body.nodes[_nodeId].updateLabelModule();
            this.body.nodes[_nodeId].needsRefresh();
          }
        }
        if (options.size !== void 0) {
          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.body.nodes[_nodeId2].needsRefresh();
            }
          }
        }
        if (options.hidden !== void 0 || options.physics !== void 0) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Set a data set with nodes for the network
     *
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */
  }, {
    key: "setData",
    value: function setData2(nodes) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var oldNodesData = this.body.data.nodes;
      if (isDataViewLike("id", nodes)) {
        this.body.data.nodes = nodes;
      } else if (_Array$isArray(nodes)) {
        this.body.data.nodes = new DataSet();
        this.body.data.nodes.add(nodes);
      } else if (!nodes) {
        this.body.data.nodes = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      }
      if (oldNodesData) {
        forEach$4(this.nodesListeners, function(callback, event) {
          oldNodesData.off(event, callback);
        });
      }
      this.body.nodes = {};
      if (this.body.data.nodes) {
        var me = this;
        forEach$4(this.nodesListeners, function(callback, event) {
          me.body.data.nodes.on(event, callback);
        });
        var ids = this.body.data.nodes.getIds();
        this.add(ids, true);
      }
      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add nodes
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */
  }, {
    key: "add",
    value: function add3(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var id2;
      var newNodes = [];
      for (var i = 0; i < ids.length; i++) {
        id2 = ids[i];
        var properties = this.body.data.nodes.get(id2);
        var node2 = this.create(properties);
        newNodes.push(node2);
        this.body.nodes[id2] = node2;
      }
      this.layoutEngine.positionInitially(newNodes);
      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing nodes, or create them when not yet existing
     *
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */
  }, {
    key: "update",
    value: function update2(ids, changedData, oldData) {
      var nodes = this.body.nodes;
      var dataChanged = false;
      for (var i = 0; i < ids.length; i++) {
        var id2 = ids[i];
        var node2 = nodes[id2];
        var data2 = changedData[i];
        if (node2 !== void 0) {
          if (node2.setOptions(data2)) {
            dataChanged = true;
          }
        } else {
          dataChanged = true;
          node2 = this.create(data2);
          nodes[id2] = node2;
        }
      }
      if (!dataChanged && oldData !== void 0) {
        dataChanged = _someInstanceProperty(changedData).call(changedData, function(newValue, index2) {
          var oldValue = oldData[index2];
          return oldValue && oldValue.level !== newValue.level;
        });
      }
      if (dataChanged === true) {
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     *
     * @param {number[] | string[]} ids
     * @private
     */
  }, {
    key: "remove",
    value: function remove2(ids) {
      var nodes = this.body.nodes;
      for (var i = 0; i < ids.length; i++) {
        var id2 = ids[i];
        delete nodes[id2];
      }
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * create a node
     *
     * @param {object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */
  }, {
    key: "create",
    value: function create5(properties) {
      var constructorClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Node$1;
      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
    }
    /**
     *
     * @param {boolean} [clearPositions=false]
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var _this3 = this;
      var clearPositions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      forEach$4(this.body.nodes, function(node2, nodeId) {
        var data2 = _this3.body.data.nodes.get(nodeId);
        if (data2 !== void 0) {
          if (clearPositions === true) {
            node2.setOptions({
              x: null,
              y: null
            });
          }
          node2.setOptions({
            fixed: false
          });
          node2.setOptions(data2);
        }
      });
    }
    /**
     * Returns the positions of the nodes.
     *
     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */
  }, {
    key: "getPositions",
    value: function getPositions(ids) {
      var dataArray = {};
      if (ids !== void 0) {
        if (_Array$isArray(ids) === true) {
          for (var i = 0; i < ids.length; i++) {
            if (this.body.nodes[ids[i]] !== void 0) {
              var node2 = this.body.nodes[ids[i]];
              dataArray[ids[i]] = {
                x: Math.round(node2.x),
                y: Math.round(node2.y)
              };
            }
          }
        } else {
          if (this.body.nodes[ids] !== void 0) {
            var _node = this.body.nodes[ids];
            dataArray[ids] = {
              x: Math.round(_node.x),
              y: Math.round(_node.y)
            };
          }
        }
      } else {
        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {
          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];
          dataArray[this.body.nodeIndices[_i2]] = {
            x: Math.round(_node2.x),
            y: Math.round(_node2.y)
          };
        }
      }
      return dataArray;
    }
    /**
     * Retrieves the x y position of a specific id.
     *
     * @param {string} id The id to retrieve.
     * @throws {TypeError} If no id is included.
     * @throws {ReferenceError} If an invalid id is provided.
     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
     */
  }, {
    key: "getPosition",
    value: function getPosition(id2) {
      if (id2 == void 0) {
        throw new TypeError("No id was specified for getPosition method.");
      } else if (this.body.nodes[id2] == void 0) {
        throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id2));
      } else {
        return {
          x: Math.round(this.body.nodes[id2].x),
          y: Math.round(this.body.nodes[id2].y)
        };
      }
    }
    /**
     * Load the XY positions of the nodes into the dataset.
     */
  }, {
    key: "storePositions",
    value: function storePositions() {
      var dataArray = [];
      var dataset = this.body.data.nodes.getDataSet();
      var _iterator = _createForOfIteratorHelper$5(dataset.get()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var dsNode = _step.value;
          var id2 = dsNode.id;
          var bodyNode = this.body.nodes[id2];
          var x2 = Math.round(bodyNode.x);
          var y2 = Math.round(bodyNode.y);
          if (dsNode.x !== x2 || dsNode.y !== y2) {
            dataArray.push({
              id: id2,
              x: x2,
              y: y2
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      dataset.update(dataArray);
    }
    /**
     * get the bounding box of a node.
     *
     * @param {Node.id} nodeId
     * @returns {j|*}
     */
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(nodeId) {
      if (this.body.nodes[nodeId] !== void 0) {
        return this.body.nodes[nodeId].shape.boundingBox;
      }
    }
    /**
     * Get the Ids of nodes connected to this node.
     *
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */
  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(nodeId, direction) {
      var nodeList = [];
      if (this.body.nodes[nodeId] !== void 0) {
        var node2 = this.body.nodes[nodeId];
        var nodeObj = {};
        for (var i = 0; i < node2.edges.length; i++) {
          var edge = node2.edges[i];
          if (direction !== "to" && edge.toId == node2.id) {
            if (nodeObj[edge.fromId] === void 0) {
              nodeList.push(edge.fromId);
              nodeObj[edge.fromId] = true;
            }
          } else if (direction !== "from" && edge.fromId == node2.id) {
            if (nodeObj[edge.toId] === void 0) {
              nodeList.push(edge.toId);
              nodeObj[edge.toId] = true;
            }
          }
        }
      }
      return nodeList;
    }
    /**
     * Get the ids of the edges connected to this node.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */
  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(nodeId) {
      var edgeList = [];
      if (this.body.nodes[nodeId] !== void 0) {
        var node2 = this.body.nodes[nodeId];
        for (var i = 0; i < node2.edges.length; i++) {
          edgeList.push(node2.edges[i].id);
        }
      } else {
        console.error("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
      }
      return edgeList;
    }
    /**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */
  }, {
    key: "moveNode",
    value: function moveNode(nodeId, x2, y2) {
      var _this4 = this;
      if (this.body.nodes[nodeId] !== void 0) {
        this.body.nodes[nodeId].x = Number(x2);
        this.body.nodes[nodeId].y = Number(y2);
        _setTimeout(function() {
          _this4.body.emitter.emit("startSimulation");
        }, 0);
      } else {
        console.error("Node id supplied to moveNode does not exist. Provided: ", nodeId);
      }
    }
  }]);
  return NodesHandler2;
}();
var hasOwn$1 = hasOwnProperty_1;
var isDataDescriptor$1 = function(descriptor) {
  return descriptor !== void 0 && (hasOwn$1(descriptor, "value") || hasOwn$1(descriptor, "writable"));
};
var $$2 = _export;
var call = functionCall;
var isObject$2 = isObject$m;
var anObject$1 = anObject$f;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var getPrototypeOf2 = objectGetPrototypeOf;
function get$5(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$1(target) === receiver)
    return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor)
    return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
  if (isObject$2(prototype = getPrototypeOf2(target)))
    return get$5(prototype, propertyKey, receiver);
}
$$2({ target: "Reflect", stat: true }, {
  get: get$5
});
var path$3 = path$y;
var get$4 = path$3.Reflect.get;
var parent$7 = get$4;
var get$3 = parent$7;
var parent$6 = get$3;
var get$2 = parent$6;
var parent$5 = get$2;
var get$1 = parent$5;
var get = get$1;
var _Reflect$get = /* @__PURE__ */ getDefaultExportFromCjs(get);
var parent$4 = getOwnPropertyDescriptor$4;
var getOwnPropertyDescriptor$2 = parent$4;
var parent$3 = getOwnPropertyDescriptor$2;
var getOwnPropertyDescriptor$1 = parent$3;
var getOwnPropertyDescriptor5 = getOwnPropertyDescriptor$1;
var _Object$getOwnPropertyDescriptor = /* @__PURE__ */ getDefaultExportFromCjs(getOwnPropertyDescriptor5);
function _superPropBase(object2, property) {
  while (!Object.prototype.hasOwnProperty.call(object2, property)) {
    object2 = _getPrototypeOf(object2);
    if (object2 === null)
      break;
  }
  return object2;
}
function _get() {
  if (typeof Reflect !== "undefined" && _Reflect$get) {
    var _context;
    _get = _bindInstanceProperty(_context = _Reflect$get).call(_context);
  } else {
    _get = function _get2(target, property, receiver) {
      var base2 = _superPropBase(target, property);
      if (!base2)
        return;
      var desc = _Object$getOwnPropertyDescriptor(base2, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var $$1 = _export;
var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt;
var FORCED = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
$$1({ target: "Math", stat: true, arity: 2, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else
        sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});
var path$2 = path$y;
var hypot$2 = path$2.Math.hypot;
var parent$2 = hypot$2;
var hypot$1 = parent$2;
var hypot2 = hypot$1;
var _Math$hypot = /* @__PURE__ */ getDefaultExportFromCjs(hypot2);
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var EndPoint = /* @__PURE__ */ function() {
  function EndPoint2() {
    _classCallCheck(this, EndPoint2);
  }
  _createClass(EndPoint2, null, [{
    key: "transform",
    value: (
      /**
       * Apply transformation on points for display.
       *
       * The following is done:
       * - rotate by the specified angle
       * - multiply the (normalized) coordinates by the passed length
       * - offset by the target coordinates
       *
       * @param points - The point(s) to be transformed.
       * @param arrowData - The data determining the result of the transformation.
       */
      function transform2(points, arrowData) {
        if (!_Array$isArray(points)) {
          points = [points];
        }
        var x2 = arrowData.point.x;
        var y2 = arrowData.point.y;
        var angle = arrowData.angle;
        var length2 = arrowData.length;
        for (var i = 0; i < points.length; ++i) {
          var p = points[i];
          var xt2 = p.x * Math.cos(angle) - p.y * Math.sin(angle);
          var yt2 = p.x * Math.sin(angle) + p.y * Math.cos(angle);
          p.x = x2 + length2 * xt2;
          p.y = y2 + length2 * yt2;
        }
      }
    )
    /**
     * Draw a closed path using the given real coordinates.
     *
     * @param ctx - The path will be rendered into this context.
     * @param points - The points of the path.
     */
  }, {
    key: "drawPath",
    value: function drawPath(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (var i = 1; i < points.length; ++i) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();
    }
  }]);
  return EndPoint2;
}();
var Image$1 = /* @__PURE__ */ function(_EndPoint) {
  _inherits(Image2, _EndPoint);
  var _super = _createSuper$a(Image2);
  function Image2() {
    _classCallCheck(this, Image2);
    return _super.apply(this, arguments);
  }
  _createClass(Image2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns False as there is no way to fill an image.
       */
      function draw(ctx, arrowData) {
        if (arrowData.image) {
          ctx.save();
          ctx.translate(arrowData.point.x, arrowData.point.y);
          ctx.rotate(Math.PI / 2 + arrowData.angle);
          var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;
          var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;
          arrowData.image.drawImageAtPosition(
            ctx,
            1,
            // scale
            -width / 2,
            // x
            0,
            // y
            width,
            height
          );
          ctx.restore();
        }
        return false;
      }
    )
  }]);
  return Image2;
}(EndPoint);
var Arrow = /* @__PURE__ */ function(_EndPoint2) {
  _inherits(Arrow2, _EndPoint2);
  var _super2 = _createSuper$a(Arrow2);
  function Arrow2() {
    _classCallCheck(this, Arrow2);
    return _super2.apply(this, arguments);
  }
  _createClass(Arrow2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0,
          y: 0
        }, {
          x: -1,
          y: 0.3
        }, {
          x: -0.9,
          y: 0
        }, {
          x: -1,
          y: -0.3
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Arrow2;
}(EndPoint);
var Crow = /* @__PURE__ */ function() {
  function Crow2() {
    _classCallCheck(this, Crow2);
  }
  _createClass(Crow2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: -1,
          y: 0
        }, {
          x: 0,
          y: 0.3
        }, {
          x: -0.4,
          y: 0
        }, {
          x: 0,
          y: -0.3
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Crow2;
}();
var Curve = /* @__PURE__ */ function() {
  function Curve2() {
    _classCallCheck(this, Curve2);
  }
  _createClass(Curve2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var point = {
          x: -0.4,
          y: 0
        };
        EndPoint.transform(point, arrowData);
        ctx.strokeStyle = ctx.fillStyle;
        ctx.fillStyle = "rgba(0, 0, 0, 0)";
        var pi2 = Math.PI;
        var startAngle = arrowData.angle - pi2 / 2;
        var endAngle = arrowData.angle + pi2 / 2;
        ctx.beginPath();
        ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
        ctx.stroke();
        return true;
      }
    )
  }]);
  return Curve2;
}();
var InvertedCurve = /* @__PURE__ */ function() {
  function InvertedCurve2() {
    _classCallCheck(this, InvertedCurve2);
  }
  _createClass(InvertedCurve2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var point = {
          x: -0.3,
          y: 0
        };
        EndPoint.transform(point, arrowData);
        ctx.strokeStyle = ctx.fillStyle;
        ctx.fillStyle = "rgba(0, 0, 0, 0)";
        var pi2 = Math.PI;
        var startAngle = arrowData.angle + pi2 / 2;
        var endAngle = arrowData.angle + 3 * pi2 / 2;
        ctx.beginPath();
        ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);
        ctx.stroke();
        return true;
      }
    )
  }]);
  return InvertedCurve2;
}();
var Triangle = /* @__PURE__ */ function() {
  function Triangle2() {
    _classCallCheck(this, Triangle2);
  }
  _createClass(Triangle2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0.02,
          y: 0
        }, {
          x: -1,
          y: 0.3
        }, {
          x: -1,
          y: -0.3
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Triangle2;
}();
var InvertedTriangle = /* @__PURE__ */ function() {
  function InvertedTriangle2() {
    _classCallCheck(this, InvertedTriangle2);
  }
  _createClass(InvertedTriangle2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0,
          y: 0.3
        }, {
          x: 0,
          y: -0.3
        }, {
          x: -1,
          y: 0
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return InvertedTriangle2;
}();
var Circle = /* @__PURE__ */ function() {
  function Circle2() {
    _classCallCheck(this, Circle2);
  }
  _createClass(Circle2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var point = {
          x: -0.4,
          y: 0
        };
        EndPoint.transform(point, arrowData);
        drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);
        return true;
      }
    )
  }]);
  return Circle2;
}();
var Bar = /* @__PURE__ */ function() {
  function Bar2() {
    _classCallCheck(this, Bar2);
  }
  _createClass(Bar2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0,
          y: 0.5
        }, {
          x: 0,
          y: -0.5
        }, {
          x: -0.15,
          y: -0.5
        }, {
          x: -0.15,
          y: 0.5
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Bar2;
}();
var Box = /* @__PURE__ */ function() {
  function Box2() {
    _classCallCheck(this, Box2);
  }
  _createClass(Box2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0,
          y: 0.3
        }, {
          x: 0,
          y: -0.3
        }, {
          x: -0.6,
          y: -0.3
        }, {
          x: -0.6,
          y: 0.3
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Box2;
}();
var Diamond = /* @__PURE__ */ function() {
  function Diamond2() {
    _classCallCheck(this, Diamond2);
  }
  _createClass(Diamond2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: 0,
          y: 0
        }, {
          x: -0.5,
          y: -0.3
        }, {
          x: -1,
          y: 0
        }, {
          x: -0.5,
          y: 0.3
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Diamond2;
}();
var Vee = /* @__PURE__ */ function() {
  function Vee2() {
    _classCallCheck(this, Vee2);
  }
  _createClass(Vee2, null, [{
    key: "draw",
    value: (
      /**
       * Draw this shape at the end of a line.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True because ctx.fill() can be used to fill the arrow.
       */
      function draw(ctx, arrowData) {
        var points = [{
          x: -1,
          y: 0.3
        }, {
          x: -0.5,
          y: 0
        }, {
          x: -1,
          y: -0.3
        }, {
          x: 0,
          y: 0
        }];
        EndPoint.transform(points, arrowData);
        EndPoint.drawPath(ctx, points);
        return true;
      }
    )
  }]);
  return Vee2;
}();
var EndPoints = /* @__PURE__ */ function() {
  function EndPoints2() {
    _classCallCheck(this, EndPoints2);
  }
  _createClass(EndPoints2, null, [{
    key: "draw",
    value: (
      /**
       * Draw an endpoint.
       *
       * @param ctx - The shape will be rendered into this context.
       * @param arrowData - The data determining the shape.
       * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
       */
      function draw(ctx, arrowData) {
        var type;
        if (arrowData.type) {
          type = arrowData.type.toLowerCase();
        }
        switch (type) {
          case "image":
            return Image$1.draw(ctx, arrowData);
          case "circle":
            return Circle.draw(ctx, arrowData);
          case "box":
            return Box.draw(ctx, arrowData);
          case "crow":
            return Crow.draw(ctx, arrowData);
          case "curve":
            return Curve.draw(ctx, arrowData);
          case "diamond":
            return Diamond.draw(ctx, arrowData);
          case "inv_curve":
            return InvertedCurve.draw(ctx, arrowData);
          case "triangle":
            return Triangle.draw(ctx, arrowData);
          case "inv_triangle":
            return InvertedTriangle.draw(ctx, arrowData);
          case "bar":
            return Bar.draw(ctx, arrowData);
          case "vee":
            return Vee.draw(ctx, arrowData);
          case "arrow":
          default:
            return Arrow.draw(ctx, arrowData);
        }
      }
    )
  }]);
  return EndPoints2;
}();
function ownKeys$1(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor$1(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context2, _context3;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context2 = ownKeys$1(Object(t), true)).call(_context2, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys$1(Object(t))).call(_context3, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor$1(t, r2));
    });
  }
  return e;
}
var EdgeBase = /* @__PURE__ */ function() {
  function EdgeBase2(options, _body, _labelModule) {
    _classCallCheck(this, EdgeBase2);
    this._body = _body;
    this._labelModule = _labelModule;
    this.color = {};
    this.colorDirty = true;
    this.hoverWidth = 1.5;
    this.selectionWidth = 2;
    this.setOptions(options);
    this.fromPoint = this.from;
    this.toPoint = this.to;
  }
  _createClass(EdgeBase2, [{
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
    }
    /** @inheritDoc */
  }, {
    key: "cleanup",
    value: function cleanup() {
      return false;
    }
    /**
     * Set new edge options.
     *
     * @param options - The new edge options object.
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      this.id = this.options.id;
    }
    /** @inheritDoc */
  }, {
    key: "drawLine",
    value: function drawLine(ctx, values2, _selected, _hover) {
      var viaNode = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.getViaNode();
      ctx.strokeStyle = this.getColor(ctx, values2);
      ctx.lineWidth = values2.width;
      if (values2.dashes !== false) {
        this._drawDashedLine(ctx, values2, viaNode);
      } else {
        this._drawLine(ctx, values2, viaNode);
      }
    }
    /**
     * Draw a line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param fromPoint - TODO: Seems ignored, remove?
     * @param toPoint - TODO: Seems ignored, remove?
     */
  }, {
    key: "_drawLine",
    value: function _drawLine(ctx, values2, viaNode, fromPoint, toPoint) {
      if (this.from != this.to) {
        this._line(ctx, values2, viaNode, fromPoint, toPoint);
      } else {
        var _this$_getCircleData = this._getCircleData(ctx), _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3), x2 = _this$_getCircleData2[0], y2 = _this$_getCircleData2[1], radius = _this$_getCircleData2[2];
        this._circle(ctx, values2, x2, y2, radius);
      }
    }
    /**
     * Draw a dashed line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param _fromPoint - Ignored (TODO: remove in the future).
     * @param _toPoint - Ignored (TODO: remove in the future).
     */
  }, {
    key: "_drawDashedLine",
    value: function _drawDashedLine(ctx, values2, viaNode, _fromPoint, _toPoint) {
      ctx.lineCap = "round";
      var pattern = _Array$isArray(values2.dashes) ? values2.dashes : [5, 5];
      if (ctx.setLineDash !== void 0) {
        ctx.save();
        ctx.setLineDash(pattern);
        ctx.lineDashOffset = 0;
        if (this.from != this.to) {
          this._line(ctx, values2, viaNode);
        } else {
          var _this$_getCircleData3 = this._getCircleData(ctx), _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3), x2 = _this$_getCircleData4[0], y2 = _this$_getCircleData4[1], radius = _this$_getCircleData4[2];
          this._circle(ctx, values2, x2, y2, radius);
        }
        ctx.setLineDash([0]);
        ctx.lineDashOffset = 0;
        ctx.restore();
      } else {
        if (this.from != this.to) {
          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);
        } else {
          var _this$_getCircleData5 = this._getCircleData(ctx), _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3), _x = _this$_getCircleData6[0], _y = _this$_getCircleData6[1], _radius = _this$_getCircleData6[2];
          this._circle(ctx, values2, _x, _y, _radius);
        }
        this.enableShadow(ctx, values2);
        ctx.stroke();
        this.disableShadow(ctx, values2);
      }
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @param node - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */
  }, {
    key: "findBorderPosition",
    value: function findBorderPosition(node2, ctx, options) {
      if (this.from != this.to) {
        return this._findBorderPosition(node2, ctx, options);
      } else {
        return this._findBorderPositionCircle(node2, ctx, options);
      }
    }
    /** @inheritDoc */
  }, {
    key: "findBorderPositions",
    value: function findBorderPositions(ctx) {
      if (this.from != this.to) {
        return {
          from: this._findBorderPosition(this.from, ctx),
          to: this._findBorderPosition(this.to, ctx)
        };
      } else {
        var _context;
        var _this$_getCircleData$ = _sliceInstanceProperty(_context = this._getCircleData(ctx)).call(_context, 0, 2), _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2), x2 = _this$_getCircleData$2[0], y2 = _this$_getCircleData$2[1];
        return {
          from: this._findBorderPositionCircle(this.from, ctx, {
            x: x2,
            y: y2,
            low: 0.25,
            high: 0.6,
            direction: -1
          }),
          to: this._findBorderPositionCircle(this.from, ctx, {
            x: x2,
            y: y2,
            low: 0.6,
            high: 0.8,
            direction: 1
          })
        };
      }
    }
    /**
     * Compute the center point and radius of an edge connected to the same node at both ends.
     *
     * @param ctx - The context that will be used for rendering.
     * @returns `[x, y, radius]`
     */
  }, {
    key: "_getCircleData",
    value: function _getCircleData(ctx) {
      var radius = this.options.selfReference.size;
      if (ctx !== void 0) {
        if (this.from.shape.width === void 0) {
          this.from.shape.resize(ctx);
        }
      }
      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);
      return [coordinates.x, coordinates.y, radius];
    }
    /**
     * Get a point on a circle.
     *
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     * @param position - Value between 0 (line start) and 1 (line end).
     * @returns Cartesian coordinates of requested point on the circle.
     */
  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x2, y2, radius, position) {
      var angle = position * 2 * Math.PI;
      return {
        x: x2 + radius * Math.cos(angle),
        y: y2 - radius * Math.sin(angle)
      };
    }
    /**
     * Find the intersection between the border of the node and the edge.
     *
     * @remarks
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     * @param nearNode - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */
  }, {
    key: "_findBorderPositionCircle",
    value: function _findBorderPositionCircle(nearNode, ctx, options) {
      var x2 = options.x;
      var y2 = options.y;
      var low2 = options.low;
      var high = options.high;
      var direction = options.direction;
      var maxIterations = 10;
      var radius = this.options.selfReference.size;
      var threshold = 0.05;
      var pos;
      var middle = (low2 + high) * 0.5;
      var endPointOffset = 0;
      if (this.options.arrowStrikethrough === true) {
        if (direction === -1) {
          endPointOffset = this.options.endPointOffset.from;
        } else if (direction === 1) {
          endPointOffset = this.options.endPointOffset.to;
        }
      }
      var iteration = 0;
      do {
        middle = (low2 + high) * 0.5;
        pos = this._pointOnCircle(x2, y2, radius, middle);
        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);
        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));
        var difference = distanceToBorder - distanceToPoint;
        if (Math.abs(difference) < threshold) {
          break;
        } else if (difference > 0) {
          if (direction > 0) {
            low2 = middle;
          } else {
            high = middle;
          }
        } else {
          if (direction > 0) {
            high = middle;
          } else {
            low2 = middle;
          }
        }
        ++iteration;
      } while (low2 <= high && iteration < maxIterations);
      return _objectSpread$1(_objectSpread$1({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
     *
     * @param selected - Determines wheter the line is selected.
     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
     * @returns The width of the line.
     */
  }, {
    key: "getLineWidth",
    value: function getLineWidth(selected, hover) {
      if (selected === true) {
        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);
      } else if (hover === true) {
        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);
      } else {
        return Math.max(this.options.width, 0.3 / this._body.view.scale);
      }
    }
    /**
     * Compute the color or gradient for given edge.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param _selected - Ignored (TODO: remove in the future).
     * @param _hover - Ignored (TODO: remove in the future).
     * @returns Color string if single color is inherited or gradient if two.
     */
  }, {
    key: "getColor",
    value: function getColor(ctx, values2) {
      if (values2.inheritsColor !== false) {
        if (values2.inheritsColor === "both" && this.from.id !== this.to.id) {
          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
          var fromColor = this.from.options.color.highlight.border;
          var toColor = this.to.options.color.highlight.border;
          if (this.from.selected === false && this.to.selected === false) {
            fromColor = overrideOpacity(this.from.options.color.border, values2.opacity);
            toColor = overrideOpacity(this.to.options.color.border, values2.opacity);
          } else if (this.from.selected === true && this.to.selected === false) {
            toColor = this.to.options.color.border;
          } else if (this.from.selected === false && this.to.selected === true) {
            fromColor = this.from.options.color.border;
          }
          grd.addColorStop(0, fromColor);
          grd.addColorStop(1, toColor);
          return grd;
        }
        if (values2.inheritsColor === "to") {
          return overrideOpacity(this.to.options.color.border, values2.opacity);
        } else {
          return overrideOpacity(this.from.options.color.border, values2.opacity);
        }
      } else {
        return overrideOpacity(values2.color, values2.opacity);
      }
    }
    /**
     * Draw a line from a node to itself, a circle.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     */
  }, {
    key: "_circle",
    value: function _circle(ctx, values2, x2, y2, radius) {
      this.enableShadow(ctx, values2);
      var angleFrom = 0;
      var angleTo = Math.PI * 2;
      if (!this.options.selfReference.renderBehindTheNode) {
        var low2 = this.options.selfReference.angle;
        var high = this.options.selfReference.angle + Math.PI;
        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {
          x: x2,
          y: y2,
          low: low2,
          high,
          direction: -1
        });
        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {
          x: x2,
          y: y2,
          low: low2,
          high,
          direction: 1
        });
        angleFrom = Math.atan2(pointTFrom.y - y2, pointTFrom.x - x2);
        angleTo = Math.atan2(pointTTo.y - y2, pointTTo.x - x2);
      }
      ctx.beginPath();
      ctx.arc(x2, y2, radius, angleFrom, angleTo, false);
      ctx.stroke();
      this.disableShadow(ctx, values2);
    }
    /**
     * @inheritDoc
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     */
  }, {
    key: "getDistanceToEdge",
    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      if (this.from != this.to) {
        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);
      } else {
        var _this$_getCircleData7 = this._getCircleData(void 0), _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3), x4 = _this$_getCircleData8[0], y4 = _this$_getCircleData8[1], radius = _this$_getCircleData8[2];
        var dx = x4 - x3;
        var dy = y4 - y3;
        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
      }
    }
    /**
     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @returns The distance between the line segment and the point.
     */
  }, {
    key: "_getDistanceToLine",
    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
      var px = x2 - x1;
      var py = y2 - y1;
      var something2 = px * px + py * py;
      var u = ((x3 - x1) * px + (y3 - y1) * py) / something2;
      if (u > 1) {
        u = 1;
      } else if (u < 0) {
        u = 0;
      }
      var x4 = x1 + u * px;
      var y4 = y1 + u * py;
      var dx = x4 - x3;
      var dy = y4 - y3;
      return Math.sqrt(dx * dx + dy * dy);
    }
    /** @inheritDoc */
  }, {
    key: "getArrowData",
    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values2) {
      var angle;
      var arrowPoint;
      var node1;
      var node2;
      var reversed;
      var scaleFactor;
      var type;
      var lineWidth = values2.width;
      if (position === "from") {
        node1 = this.from;
        node2 = this.to;
        reversed = values2.fromArrowScale < 0;
        scaleFactor = Math.abs(values2.fromArrowScale);
        type = values2.fromArrowType;
      } else if (position === "to") {
        node1 = this.to;
        node2 = this.from;
        reversed = values2.toArrowScale < 0;
        scaleFactor = Math.abs(values2.toArrowScale);
        type = values2.toArrowType;
      } else {
        node1 = this.to;
        node2 = this.from;
        reversed = values2.middleArrowScale < 0;
        scaleFactor = Math.abs(values2.middleArrowScale);
        type = values2.middleArrowType;
      }
      var length2 = 15 * scaleFactor + 3 * lineWidth;
      if (node1 != node2) {
        var approximateEdgeLength = _Math$hypot(node1.x - node2.x, node1.y - node2.y);
        var relativeLength = length2 / approximateEdgeLength;
        if (position !== "middle") {
          if (this.options.smooth.enabled === true) {
            var pointT = this._findBorderPosition(node1, ctx, {
              via: viaNode
            });
            var guidePos = this.getPoint(pointT.t + relativeLength * (position === "from" ? 1 : -1), viaNode);
            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);
            arrowPoint = pointT;
          } else {
            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
            arrowPoint = this._findBorderPosition(node1, ctx);
          }
        } else {
          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;
          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);
          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);
          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);
          arrowPoint = this.getPoint(0.5, viaNode);
        }
      } else {
        var _this$_getCircleData9 = this._getCircleData(ctx), _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3), x2 = _this$_getCircleData10[0], y2 = _this$_getCircleData10[1], radius = _this$_getCircleData10[2];
        if (position === "from") {
          var low2 = this.options.selfReference.angle;
          var high = this.options.selfReference.angle + Math.PI;
          var _pointT = this._findBorderPositionCircle(this.from, ctx, {
            x: x2,
            y: y2,
            low: low2,
            high,
            direction: -1
          });
          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
          arrowPoint = _pointT;
        } else if (position === "to") {
          var _low = this.options.selfReference.angle;
          var _high = this.options.selfReference.angle + Math.PI;
          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {
            x: x2,
            y: y2,
            low: _low,
            high: _high,
            direction: 1
          });
          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
          arrowPoint = _pointT2;
        } else {
          var pos = this.options.selfReference.angle / (2 * Math.PI);
          arrowPoint = this._pointOnCircle(x2, y2, radius, pos);
          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
        }
      }
      var xi = arrowPoint.x - length2 * 0.9 * Math.cos(angle);
      var yi = arrowPoint.y - length2 * 0.9 * Math.sin(angle);
      var arrowCore = {
        x: xi,
        y: yi
      };
      return {
        point: arrowPoint,
        core: arrowCore,
        angle,
        length: length2,
        type
      };
    }
    /** @inheritDoc */
  }, {
    key: "drawArrowHead",
    value: function drawArrowHead(ctx, values2, _selected, _hover, arrowData) {
      ctx.strokeStyle = this.getColor(ctx, values2);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = values2.width;
      var canFill = EndPoints.draw(ctx, arrowData);
      if (canFill) {
        this.enableShadow(ctx, values2);
        _fillInstanceProperty(ctx).call(ctx);
        this.disableShadow(ctx, values2);
      }
    }
    /**
     * Set the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */
  }, {
    key: "enableShadow",
    value: function enableShadow(ctx, values2) {
      if (values2.shadow === true) {
        ctx.shadowColor = values2.shadowColor;
        ctx.shadowBlur = values2.shadowSize;
        ctx.shadowOffsetX = values2.shadowX;
        ctx.shadowOffsetY = values2.shadowY;
      }
    }
    /**
     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */
  }, {
    key: "disableShadow",
    value: function disableShadow(ctx, values2) {
      if (values2.shadow === true) {
        ctx.shadowColor = "rgba(0,0,0,0)";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }
    }
    /**
     * Render the background according to the formatting values.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the background.
     */
  }, {
    key: "drawBackground",
    value: function drawBackground(ctx, values2) {
      if (values2.background !== false) {
        var origCtxAttr = {
          strokeStyle: ctx.strokeStyle,
          lineWidth: ctx.lineWidth,
          dashes: ctx.dashes
        };
        ctx.strokeStyle = values2.backgroundColor;
        ctx.lineWidth = values2.backgroundSize;
        this.setStrokeDashed(ctx, values2.backgroundDashes);
        ctx.stroke();
        ctx.strokeStyle = origCtxAttr.strokeStyle;
        ctx.lineWidth = origCtxAttr.lineWidth;
        ctx.dashes = origCtxAttr.dashes;
        this.setStrokeDashed(ctx, values2.dashes);
      }
    }
    /**
     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
     *
     * @param ctx - The context that will be used for rendering.
     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.
     */
  }, {
    key: "setStrokeDashed",
    value: function setStrokeDashed(ctx, dashes) {
      if (dashes !== false) {
        if (ctx.setLineDash !== void 0) {
          var pattern = _Array$isArray(dashes) ? dashes : [5, 5];
          ctx.setLineDash(pattern);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      } else {
        if (ctx.setLineDash !== void 0) {
          ctx.setLineDash([]);
        } else {
          console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");
        }
      }
    }
  }]);
  return EdgeBase2;
}();
function ownKeys2(e, r) {
  var t = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var o = _Object$getOwnPropertySymbols(e);
    r && (o = _filterInstanceProperty(o).call(o, function(r2) {
      return _Object$getOwnPropertyDescriptor$1(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var _context, _context2;
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? _forEachInstanceProperty(_context = ownKeys2(Object(t), true)).call(_context, function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys2(Object(t))).call(_context2, function(r2) {
      _Object$defineProperty(e, r2, _Object$getOwnPropertyDescriptor$1(t, r2));
    });
  }
  return e;
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var BezierEdgeBase = /* @__PURE__ */ function(_EdgeBase) {
  _inherits(BezierEdgeBase2, _EdgeBase);
  var _super = _createSuper$9(BezierEdgeBase2);
  function BezierEdgeBase2(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeBase2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(BezierEdgeBase2, [{
    key: "_findBorderPositionBezier",
    value: function _findBorderPositionBezier(nearNode, ctx) {
      var viaNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._getViaCoordinates();
      var maxIterations = 10;
      var threshold = 0.2;
      var from3 = false;
      var high = 1;
      var low2 = 0;
      var node2 = this.to;
      var pos;
      var middle;
      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;
      if (nearNode.id === this.from.id) {
        node2 = this.from;
        from3 = true;
        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;
      }
      if (this.options.arrowStrikethrough === false) {
        endPointOffset = 0;
      }
      var iteration = 0;
      do {
        middle = (low2 + high) * 0.5;
        pos = this.getPoint(middle, viaNode);
        var angle = Math.atan2(node2.y - pos.y, node2.x - pos.x);
        var distanceToBorder = node2.distanceToBorder(ctx, angle) + endPointOffset;
        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node2.x, 2) + Math.pow(pos.y - node2.y, 2));
        var difference = distanceToBorder - distanceToPoint;
        if (Math.abs(difference) < threshold) {
          break;
        } else if (difference < 0) {
          if (from3 === false) {
            low2 = middle;
          } else {
            high = middle;
          }
        } else {
          if (from3 === false) {
            high = middle;
          } else {
            low2 = middle;
          }
        }
        ++iteration;
      } while (low2 <= high && iteration < maxIterations);
      return _objectSpread(_objectSpread({}, pos), {}, {
        t: middle
      });
    }
    /**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @param via - The control point for the edge.
     * @returns The distance between the line segment and the point.
     */
  }, {
    key: "_getDistanceToBezierEdge",
    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
      var minDistance = 1e9;
      var distance;
      var i, t, x4, y4;
      var lastX = x1;
      var lastY = y1;
      for (i = 1; i < 10; i++) {
        t = 0.1 * i;
        x4 = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
        y4 = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
        if (i > 0) {
          distance = this._getDistanceToLine(lastX, lastY, x4, y4, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }
        lastX = x4;
        lastY = y4;
      }
      return minDistance;
    }
    /**
     * Render a bezier curve between two nodes.
     *
     * @remarks
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line.
     * @param ctx - The context that will be used for rendering.
     * @param values - Style options for edge drawing.
     * @param viaNode1 - First control point for curve drawing.
     * @param viaNode2 - Second control point for curve drawing.
     */
  }, {
    key: "_bezierCurve",
    value: function _bezierCurve(ctx, values2, viaNode1, viaNode2) {
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      if (viaNode1 != null && viaNode1.x != null) {
        if (viaNode2 != null && viaNode2.x != null) {
          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
        } else {
          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
        }
      } else {
        ctx.lineTo(this.toPoint.x, this.toPoint.y);
      }
      this.drawBackground(ctx, values2);
      this.enableShadow(ctx, values2);
      ctx.stroke();
      this.disableShadow(ctx, values2);
    }
    /** @inheritDoc */
  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
  }]);
  return BezierEdgeBase2;
}(EdgeBase);
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var BezierEdgeDynamic = /* @__PURE__ */ function(_BezierEdgeBase) {
  _inherits(BezierEdgeDynamic2, _BezierEdgeBase);
  var _super = _createSuper$8(BezierEdgeDynamic2);
  function BezierEdgeDynamic2(options, body, labelModule) {
    var _this;
    _classCallCheck(this, BezierEdgeDynamic2);
    _this = _super.call(this, options, body, labelModule);
    _this.via = _this.via;
    _this._boundFunction = function() {
      _this.positionBezierNode();
    };
    _this._body.emitter.on("_repositionBezierNodes", _this._boundFunction);
    return _this;
  }
  _createClass(BezierEdgeDynamic2, [{
    key: "setOptions",
    value: function setOptions(options) {
      _get(_getPrototypeOf(BezierEdgeDynamic2.prototype), "setOptions", this).call(this, options);
      var physicsChange = false;
      if (this.options.physics !== options.physics) {
        physicsChange = true;
      }
      this.options = options;
      this.id = this.options.id;
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      this.setupSupportNode();
      this.connect();
      if (physicsChange === true) {
        this.via.setOptions({
          physics: this.options.physics
        });
        this.positionBezierNode();
      }
    }
    /** @inheritDoc */
  }, {
    key: "connect",
    value: function connect() {
      this.from = this._body.nodes[this.options.from];
      this.to = this._body.nodes[this.options.to];
      if (this.from === void 0 || this.to === void 0 || this.options.physics === false) {
        this.via.setOptions({
          physics: false
        });
      } else {
        if (this.from.id === this.to.id) {
          this.via.setOptions({
            physics: false
          });
        } else {
          this.via.setOptions({
            physics: true
          });
        }
      }
    }
    /** @inheritDoc */
  }, {
    key: "cleanup",
    value: function cleanup() {
      this._body.emitter.off("_repositionBezierNodes", this._boundFunction);
      if (this.via !== void 0) {
        delete this._body.nodes[this.via.id];
        this.via = void 0;
        return true;
      }
      return false;
    }
    /**
     * Create and add a support node if not already present.
     *
     * @remarks
     * Bezier curves require an anchor point to calculate the smooth flow.
     * These points are nodes.
     * These nodes are invisible but are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     */
  }, {
    key: "setupSupportNode",
    value: function setupSupportNode() {
      if (this.via === void 0) {
        var nodeId = "edgeId:" + this.id;
        var node2 = this._body.functions.createNode({
          id: nodeId,
          shape: "circle",
          physics: true,
          hidden: true
        });
        this._body.nodes[nodeId] = node2;
        this.via = node2;
        this.via.parentEdgeId = this.id;
        this.positionBezierNode();
      }
    }
    /**
     * Position bezier node.
     */
  }, {
    key: "positionBezierNode",
    value: function positionBezierNode() {
      if (this.via !== void 0 && this.from !== void 0 && this.to !== void 0) {
        this.via.x = 0.5 * (this.from.x + this.to.x);
        this.via.y = 0.5 * (this.from.y + this.to.y);
      } else if (this.via !== void 0) {
        this.via.x = 0;
        this.via.y = 0;
      }
    }
    /** @inheritDoc */
  }, {
    key: "_line",
    value: function _line(ctx, values2, viaNode) {
      this._bezierCurve(ctx, values2, viaNode);
    }
    /** @inheritDoc */
  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      return this.via;
    }
    /** @inheritDoc */
  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this.via;
    }
    /** @inheritDoc */
  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.via;
      if (this.from === this.to) {
        var _this$_getCircleData = this._getCircleData(), _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3), cx = _this$_getCircleData2[0], cy = _this$_getCircleData2[1], cr = _this$_getCircleData2[2];
        var a = 2 * Math.PI * (1 - position);
        return {
          x: cx + cr * Math.sin(a),
          y: cy + cr - cr * (1 - Math.cos(a))
        };
      } else {
        return {
          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,
          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y
        };
      }
    }
    /** @inheritDoc */
  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx, this.via);
    }
    /** @inheritDoc */
  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
    }
  }]);
  return BezierEdgeDynamic2;
}(BezierEdgeBase);
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var BezierEdgeStatic = /* @__PURE__ */ function(_BezierEdgeBase) {
  _inherits(BezierEdgeStatic2, _BezierEdgeBase);
  var _super = _createSuper$7(BezierEdgeStatic2);
  function BezierEdgeStatic2(options, body, labelModule) {
    _classCallCheck(this, BezierEdgeStatic2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(BezierEdgeStatic2, [{
    key: "_line",
    value: function _line(ctx, values2, viaNode) {
      this._bezierCurve(ctx, values2, viaNode);
    }
    /** @inheritDoc */
  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /**
     * Compute the coordinates of the via node.
     *
     * @remarks
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     * @returns Cartesian coordinates of the via node.
     */
  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      var factor = this.options.smooth.roundness;
      var type = this.options.smooth.type;
      var dx = Math.abs(this.from.x - this.to.x);
      var dy = Math.abs(this.from.y - this.to.y);
      if (type === "discrete" || type === "diagonalCross") {
        var stepX;
        var stepY;
        if (dx <= dy) {
          stepX = stepY = factor * dy;
        } else {
          stepX = stepY = factor * dx;
        }
        if (this.from.x > this.to.x) {
          stepX = -stepX;
        }
        if (this.from.y >= this.to.y) {
          stepY = -stepY;
        }
        var xVia = this.from.x + stepX;
        var yVia = this.from.y + stepY;
        if (type === "discrete") {
          if (dx <= dy) {
            xVia = dx < factor * dy ? this.from.x : xVia;
          } else {
            yVia = dy < factor * dx ? this.from.y : yVia;
          }
        }
        return {
          x: xVia,
          y: yVia
        };
      } else if (type === "straightCross") {
        var _stepX = (1 - factor) * dx;
        var _stepY = (1 - factor) * dy;
        if (dx <= dy) {
          _stepX = 0;
          if (this.from.y < this.to.y) {
            _stepY = -_stepY;
          }
        } else {
          if (this.from.x < this.to.x) {
            _stepX = -_stepX;
          }
          _stepY = 0;
        }
        return {
          x: this.to.x + _stepX,
          y: this.to.y + _stepY
        };
      } else if (type === "horizontal") {
        var _stepX2 = (1 - factor) * dx;
        if (this.from.x < this.to.x) {
          _stepX2 = -_stepX2;
        }
        return {
          x: this.to.x + _stepX2,
          y: this.from.y
        };
      } else if (type === "vertical") {
        var _stepY2 = (1 - factor) * dy;
        if (this.from.y < this.to.y) {
          _stepY2 = -_stepY2;
        }
        return {
          x: this.from.x,
          y: this.to.y + _stepY2
        };
      } else if (type === "curvedCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var radius = Math.sqrt(dx * dx + dy * dy);
        var pi2 = Math.PI;
        var originalAngle = Math.atan2(dy, dx);
        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi2) % (2 * pi2);
        return {
          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)
        };
      } else if (type === "curvedCCW") {
        dx = this.to.x - this.from.x;
        dy = this.from.y - this.to.y;
        var _radius = Math.sqrt(dx * dx + dy * dy);
        var _pi = Math.PI;
        var _originalAngle = Math.atan2(dy, dx);
        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);
        return {
          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),
          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)
        };
      } else {
        var _stepX3;
        var _stepY3;
        if (dx <= dy) {
          _stepX3 = _stepY3 = factor * dy;
        } else {
          _stepX3 = _stepY3 = factor * dx;
        }
        if (this.from.x > this.to.x) {
          _stepX3 = -_stepX3;
        }
        if (this.from.y >= this.to.y) {
          _stepY3 = -_stepY3;
        }
        var _xVia = this.from.x + _stepX3;
        var _yVia = this.from.y + _stepY3;
        if (dx <= dy) {
          if (this.from.x <= this.to.x) {
            _xVia = this.to.x < _xVia ? this.to.x : _xVia;
          } else {
            _xVia = this.to.x > _xVia ? this.to.x : _xVia;
          }
        } else {
          if (this.from.y >= this.to.y) {
            _yVia = this.to.y > _yVia ? this.to.y : _yVia;
          } else {
            _yVia = this.to.y < _yVia ? this.to.y : _yVia;
          }
        }
        return {
          x: _xVia,
          y: _yVia
        };
      }
    }
    /** @inheritDoc */
  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._findBorderPositionBezier(nearNode, ctx, options.via);
    }
    /** @inheritDoc */
  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var viaNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates();
      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
    }
    /** @inheritDoc */
  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates();
      var t = position;
      var x2 = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
      var y2 = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
      return {
        x: x2,
        y: y2
      };
    }
  }]);
  return BezierEdgeStatic2;
}(BezierEdgeBase);
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var CubicBezierEdgeBase = /* @__PURE__ */ function(_BezierEdgeBase) {
  _inherits(CubicBezierEdgeBase2, _BezierEdgeBase);
  var _super = _createSuper$6(CubicBezierEdgeBase2);
  function CubicBezierEdgeBase2(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdgeBase2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(CubicBezierEdgeBase2, [{
    key: "_getDistanceToBezierEdge2",
    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {
      var minDistance = 1e9;
      var lastX = x1;
      var lastY = y1;
      var vec = [0, 0, 0, 0];
      for (var i = 1; i < 10; i++) {
        var t = 0.1 * i;
        vec[0] = Math.pow(1 - t, 3);
        vec[1] = 3 * t * Math.pow(1 - t, 2);
        vec[2] = 3 * Math.pow(t, 2) * (1 - t);
        vec[3] = Math.pow(t, 3);
        var x4 = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
        var y4 = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
        if (i > 0) {
          var distance = this._getDistanceToLine(lastX, lastY, x4, y4, x3, y3);
          minDistance = distance < minDistance ? distance : minDistance;
        }
        lastX = x4;
        lastY = y4;
      }
      return minDistance;
    }
  }]);
  return CubicBezierEdgeBase2;
}(BezierEdgeBase);
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var CubicBezierEdge = /* @__PURE__ */ function(_CubicBezierEdgeBase) {
  _inherits(CubicBezierEdge2, _CubicBezierEdgeBase);
  var _super = _createSuper$5(CubicBezierEdge2);
  function CubicBezierEdge2(options, body, labelModule) {
    _classCallCheck(this, CubicBezierEdge2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(CubicBezierEdge2, [{
    key: "_line",
    value: function _line(ctx, values2, viaNodes) {
      var via1 = viaNodes[0];
      var via2 = viaNodes[1];
      this._bezierCurve(ctx, values2, via1, via2);
    }
    /**
     * Compute the additional points the edge passes through.
     *
     * @returns Cartesian coordinates of the points the edge passes through.
     */
  }, {
    key: "_getViaCoordinates",
    value: function _getViaCoordinates() {
      var dx = this.from.x - this.to.x;
      var dy = this.from.y - this.to.y;
      var x1;
      var y1;
      var x2;
      var y2;
      var roundness = this.options.smooth.roundness;
      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
        y1 = this.from.y;
        y2 = this.to.y;
        x1 = this.from.x - roundness * dx;
        x2 = this.to.x + roundness * dx;
      } else {
        y1 = this.from.y - roundness * dy;
        y2 = this.to.y + roundness * dy;
        x1 = this.from.x;
        x2 = this.to.x;
      }
      return [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }];
    }
    /** @inheritDoc */
  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return this._getViaCoordinates();
    }
    /** @inheritDoc */
  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      return this._findBorderPositionBezier(nearNode, ctx);
    }
    /** @inheritDoc */
  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      var _ref = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates(), _ref2 = _slicedToArray(_ref, 2), via1 = _ref2[0], via2 = _ref2[1];
      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);
    }
    /** @inheritDoc */
  }, {
    key: "getPoint",
    value: function getPoint(position) {
      var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates(), _ref4 = _slicedToArray(_ref3, 2), via1 = _ref4[0], via2 = _ref4[1];
      var t = position;
      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];
      var x2 = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
      var y2 = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
      return {
        x: x2,
        y: y2
      };
    }
  }]);
  return CubicBezierEdge2;
}(CubicBezierEdgeBase);
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var StraightEdge = /* @__PURE__ */ function(_EdgeBase) {
  _inherits(StraightEdge2, _EdgeBase);
  var _super = _createSuper$4(StraightEdge2);
  function StraightEdge2(options, body, labelModule) {
    _classCallCheck(this, StraightEdge2);
    return _super.call(this, options, body, labelModule);
  }
  _createClass(StraightEdge2, [{
    key: "_line",
    value: function _line(ctx, values2) {
      ctx.beginPath();
      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
      ctx.lineTo(this.toPoint.x, this.toPoint.y);
      this.enableShadow(ctx, values2);
      ctx.stroke();
      this.disableShadow(ctx, values2);
    }
    /** @inheritDoc */
  }, {
    key: "getViaNode",
    value: function getViaNode() {
      return void 0;
    }
    /** @inheritDoc */
  }, {
    key: "getPoint",
    value: function getPoint(position) {
      return {
        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,
        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y
      };
    }
    /** @inheritDoc */
  }, {
    key: "_findBorderPosition",
    value: function _findBorderPosition(nearNode, ctx) {
      var node1 = this.to;
      var node2 = this.from;
      if (nearNode.id === this.from.id) {
        node1 = this.from;
        node2 = this.to;
      }
      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
      var toBorderDist = nearNode.distanceToBorder(ctx, angle);
      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
      return {
        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,
        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,
        t: 0
      };
    }
    /** @inheritDoc */
  }, {
    key: "_getDistanceToEdge",
    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
    }
  }]);
  return StraightEdge2;
}(EdgeBase);
var Edge = /* @__PURE__ */ function() {
  function Edge2(options, body, imagelist, globalOptions, defaultOptions2) {
    _classCallCheck(this, Edge2);
    if (body === void 0) {
      throw new Error("No body provided");
    }
    this.options = bridgeObject(globalOptions);
    this.globalOptions = globalOptions;
    this.defaultOptions = defaultOptions2;
    this.body = body;
    this.imagelist = imagelist;
    this.id = void 0;
    this.fromId = void 0;
    this.toId = void 0;
    this.selected = false;
    this.hover = false;
    this.labelDirty = true;
    this.baseWidth = this.options.width;
    this.baseFontSize = this.options.font.size;
    this.from = void 0;
    this.to = void 0;
    this.edgeType = void 0;
    this.connected = false;
    this.labelModule = new Label(
      this.body,
      this.options,
      true
      /* It's an edge label */
    );
    this.setOptions(options);
  }
  _createClass(Edge2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (!options) {
        return;
      }
      var affectsLayout = typeof options.physics !== "undefined" && this.options.physics !== options.physics || typeof options.hidden !== "undefined" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== "undefined" && this.options.from !== options.from || typeof options.to !== "undefined" && this.options.to !== options.to;
      Edge2.parseOptions(this.options, options, true, this.globalOptions);
      if (options.id !== void 0) {
        this.id = options.id;
      }
      if (options.from !== void 0) {
        this.fromId = options.from;
      }
      if (options.to !== void 0) {
        this.toId = options.to;
      }
      if (options.title !== void 0) {
        this.title = options.title;
      }
      if (options.value !== void 0) {
        options.value = _parseFloat$1(options.value);
      }
      var pile = [options, this.options, this.defaultOptions];
      this.chooser = choosify("edge", pile);
      this.updateLabelModule(options);
      affectsLayout = this.updateEdgeType() || affectsLayout;
      this._setInteractionWidths();
      this.connect();
      return affectsLayout;
    }
    /**
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */
  }, {
    key: "getFormattingValues",
    value: (
      /**
       *
       * @returns {ArrowOptions}
       */
      function getFormattingValues() {
        var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
        var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
        var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
        var inheritsColor = this.options.color.inherit;
        var values2 = {
          toArrow,
          toArrowScale: this.options.arrows.to.scaleFactor,
          toArrowType: this.options.arrows.to.type,
          toArrowSrc: this.options.arrows.to.src,
          toArrowImageWidth: this.options.arrows.to.imageWidth,
          toArrowImageHeight: this.options.arrows.to.imageHeight,
          middleArrow,
          middleArrowScale: this.options.arrows.middle.scaleFactor,
          middleArrowType: this.options.arrows.middle.type,
          middleArrowSrc: this.options.arrows.middle.src,
          middleArrowImageWidth: this.options.arrows.middle.imageWidth,
          middleArrowImageHeight: this.options.arrows.middle.imageHeight,
          fromArrow,
          fromArrowScale: this.options.arrows.from.scaleFactor,
          fromArrowType: this.options.arrows.from.type,
          fromArrowSrc: this.options.arrows.from.src,
          fromArrowImageWidth: this.options.arrows.from.imageWidth,
          fromArrowImageHeight: this.options.arrows.from.imageHeight,
          arrowStrikethrough: this.options.arrowStrikethrough,
          color: inheritsColor ? void 0 : this.options.color.color,
          inheritsColor,
          opacity: this.options.color.opacity,
          hidden: this.options.hidden,
          length: this.options.length,
          shadow: this.options.shadow.enabled,
          shadowColor: this.options.shadow.color,
          shadowSize: this.options.shadow.size,
          shadowX: this.options.shadow.x,
          shadowY: this.options.shadow.y,
          dashes: this.options.dashes,
          width: this.options.width,
          background: this.options.background.enabled,
          backgroundColor: this.options.background.color,
          backgroundSize: this.options.background.size,
          backgroundDashes: this.options.background.dashes
        };
        if (this.selected || this.hover) {
          if (this.chooser === true) {
            if (this.selected) {
              var selectedWidth = this.options.selectionWidth;
              if (typeof selectedWidth === "function") {
                values2.width = selectedWidth(values2.width);
              } else if (typeof selectedWidth === "number") {
                values2.width += selectedWidth;
              }
              values2.width = Math.max(values2.width, 0.3 / this.body.view.scale);
              values2.color = this.options.color.highlight;
              values2.shadow = this.options.shadow.enabled;
            } else if (this.hover) {
              var hoverWidth = this.options.hoverWidth;
              if (typeof hoverWidth === "function") {
                values2.width = hoverWidth(values2.width);
              } else if (typeof hoverWidth === "number") {
                values2.width += hoverWidth;
              }
              values2.width = Math.max(values2.width, 0.3 / this.body.view.scale);
              values2.color = this.options.color.hover;
              values2.shadow = this.options.shadow.enabled;
            }
          } else if (typeof this.chooser === "function") {
            this.chooser(values2, this.options.id, this.selected, this.hover);
            if (values2.color !== void 0) {
              values2.inheritsColor = false;
            }
            if (values2.shadow === false) {
              if (values2.shadowColor !== this.options.shadow.color || values2.shadowSize !== this.options.shadow.size || values2.shadowX !== this.options.shadow.x || values2.shadowY !== this.options.shadow.y) {
                values2.shadow = true;
              }
            }
          }
        } else {
          values2.shadow = this.options.shadow.enabled;
          values2.width = Math.max(values2.width, 0.3 / this.body.view.scale);
        }
        return values2;
      }
    )
    /**
     * update the options in the label module
     *
     * @param {object} options
     */
  }, {
    key: "updateLabelModule",
    value: function updateLabelModule(options) {
      var pile = [
        options,
        this.options,
        this.globalOptions,
        // Currently set global edge options
        this.defaultOptions
      ];
      this.labelModule.update(this.options, pile);
      if (this.labelModule.baseSize !== void 0) {
        this.baseFontSize = this.labelModule.baseSize;
      }
    }
    /**
     * update the edge type, set the options
     *
     * @returns {boolean}
     */
  }, {
    key: "updateEdgeType",
    value: function updateEdgeType() {
      var smooth = this.options.smooth;
      var dataChanged = false;
      var changeInType = true;
      if (this.edgeType !== void 0) {
        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
          changeInType = false;
        }
        if (changeInType === true) {
          dataChanged = this.cleanup();
        }
      }
      if (changeInType === true) {
        if (smooth.enabled === true) {
          if (smooth.type === "dynamic") {
            dataChanged = true;
            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
          } else if (smooth.type === "cubicBezier") {
            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
          } else {
            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
          }
        } else {
          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
        }
      } else {
        this.edgeType.setOptions(this.options);
      }
      return dataChanged;
    }
    /**
     * Connect an edge to its nodes
     */
  }, {
    key: "connect",
    value: function connect() {
      this.disconnect();
      this.from = this.body.nodes[this.fromId] || void 0;
      this.to = this.body.nodes[this.toId] || void 0;
      this.connected = this.from !== void 0 && this.to !== void 0;
      if (this.connected === true) {
        this.from.attachEdge(this);
        this.to.attachEdge(this);
      } else {
        if (this.from) {
          this.from.detachEdge(this);
        }
        if (this.to) {
          this.to.detachEdge(this);
        }
      }
      this.edgeType.connect();
    }
    /**
     * Disconnect an edge from its nodes
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.from) {
        this.from.detachEdge(this);
        this.from = void 0;
      }
      if (this.to) {
        this.to.detachEdge(this);
        this.to = void 0;
      }
      this.connected = false;
    }
    /**
     * get the title of this edge.
     *
     * @returns {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */
  }, {
    key: "getTitle",
    value: function getTitle() {
      return this.title;
    }
    /**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */
  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * Retrieve the value of the edge. Can be undefined
     *
     * @returns {number} value
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.options.value;
    }
    /**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */
  }, {
    key: "setValueRange",
    value: function setValueRange(min2, max2, total) {
      if (this.options.value !== void 0) {
        var scale = this.options.scaling.customScalingFunction(min2, max2, total, this.options.value);
        var widthDiff = this.options.scaling.max - this.options.scaling.min;
        if (this.options.scaling.label.enabled === true) {
          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
        }
        this.options.width = this.options.scaling.min + scale * widthDiff;
      } else {
        this.options.width = this.baseWidth;
        this.options.font.size = this.baseFontSize;
      }
      this._setInteractionWidths();
      this.updateLabelModule();
    }
    /**
     *
     * @private
     */
  }, {
    key: "_setInteractionWidths",
    value: function _setInteractionWidths() {
      if (typeof this.options.hoverWidth === "function") {
        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
      } else {
        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
      }
      if (typeof this.options.selectionWidth === "function") {
        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
      } else {
        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
      }
    }
    /**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */
  }, {
    key: "draw",
    value: function draw(ctx) {
      var values2 = this.getFormattingValues();
      if (values2.hidden) {
        return;
      }
      var viaNode = this.edgeType.getViaNode();
      this.edgeType.drawLine(ctx, values2, this.selected, this.hover, viaNode);
      this.drawLabel(ctx, viaNode);
    }
    /**
     * Redraw arrows
     * Draw this arrows in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */
  }, {
    key: "drawArrows",
    value: function drawArrows(ctx) {
      var values2 = this.getFormattingValues();
      if (values2.hidden) {
        return;
      }
      var viaNode = this.edgeType.getViaNode();
      var arrowData = {};
      this.edgeType.fromPoint = this.edgeType.from;
      this.edgeType.toPoint = this.edgeType.to;
      if (values2.fromArrow) {
        arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values2);
        if (values2.arrowStrikethrough === false)
          this.edgeType.fromPoint = arrowData.from.core;
        if (values2.fromArrowSrc) {
          arrowData.from.image = this.imagelist.load(values2.fromArrowSrc);
        }
        if (values2.fromArrowImageWidth) {
          arrowData.from.imageWidth = values2.fromArrowImageWidth;
        }
        if (values2.fromArrowImageHeight) {
          arrowData.from.imageHeight = values2.fromArrowImageHeight;
        }
      }
      if (values2.toArrow) {
        arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values2);
        if (values2.arrowStrikethrough === false)
          this.edgeType.toPoint = arrowData.to.core;
        if (values2.toArrowSrc) {
          arrowData.to.image = this.imagelist.load(values2.toArrowSrc);
        }
        if (values2.toArrowImageWidth) {
          arrowData.to.imageWidth = values2.toArrowImageWidth;
        }
        if (values2.toArrowImageHeight) {
          arrowData.to.imageHeight = values2.toArrowImageHeight;
        }
      }
      if (values2.middleArrow) {
        arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values2);
        if (values2.middleArrowSrc) {
          arrowData.middle.image = this.imagelist.load(values2.middleArrowSrc);
        }
        if (values2.middleArrowImageWidth) {
          arrowData.middle.imageWidth = values2.middleArrowImageWidth;
        }
        if (values2.middleArrowImageHeight) {
          arrowData.middle.imageHeight = values2.middleArrowImageHeight;
        }
      }
      if (values2.fromArrow) {
        this.edgeType.drawArrowHead(ctx, values2, this.selected, this.hover, arrowData.from);
      }
      if (values2.middleArrow) {
        this.edgeType.drawArrowHead(ctx, values2, this.selected, this.hover, arrowData.middle);
      }
      if (values2.toArrow) {
        this.edgeType.drawArrowHead(ctx, values2, this.selected, this.hover, arrowData.to);
      }
    }
    /**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */
  }, {
    key: "drawLabel",
    value: function drawLabel(ctx, viaNode) {
      if (this.options.label !== void 0) {
        var node1 = this.from;
        var node2 = this.to;
        if (this.labelModule.differentState(this.selected, this.hover)) {
          this.labelModule.getTextSize(ctx, this.selected, this.hover);
        }
        var point;
        if (node1.id != node2.id) {
          this.labelModule.pointToSelf = false;
          point = this.edgeType.getPoint(0.5, viaNode);
          ctx.save();
          var rotationPoint = this._getRotation(ctx);
          if (rotationPoint.angle != 0) {
            ctx.translate(rotationPoint.x, rotationPoint.y);
            ctx.rotate(rotationPoint.angle);
          }
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
          ctx.restore();
        } else {
          this.labelModule.pointToSelf = true;
          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);
          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);
          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
        }
      }
    }
    /**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */
  }, {
    key: "getItemsOnPoint",
    value: function getItemsOnPoint(point) {
      var ret = [];
      if (this.labelModule.visible()) {
        var rotationPoint = this._getRotation();
        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
          ret.push({
            edgeId: this.id,
            labelId: 0
          });
        }
      }
      var obj = {
        left: point.x,
        top: point.y
      };
      if (this.isOverlappingWith(obj)) {
        ret.push({
          edgeId: this.id
        });
      }
      return ret;
    }
    /**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top
     * @returns {boolean}     True if location is located on the edge
     */
  }, {
    key: "isOverlappingWith",
    value: function isOverlappingWith(obj) {
      if (this.connected) {
        var distMax = 10;
        var xFrom = this.from.x;
        var yFrom = this.from.y;
        var xTo = this.to.x;
        var yTo = this.to.y;
        var xObj = obj.left;
        var yObj = obj.top;
        var dist2 = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
        return dist2 < distMax;
      } else {
        return false;
      }
    }
    /**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */
  }, {
    key: "_getRotation",
    value: function _getRotation(ctx) {
      var viaNode = this.edgeType.getViaNode();
      var point = this.edgeType.getPoint(0.5, viaNode);
      if (ctx !== void 0) {
        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
      }
      var ret = {
        x: point.x,
        y: this.labelModule.size.yLine,
        angle: 0
      };
      if (!this.labelModule.visible()) {
        return ret;
      }
      if (this.options.font.align === "horizontal") {
        return ret;
      }
      var dy = this.from.y - this.to.y;
      var dx = this.from.x - this.to.x;
      var angle = Math.atan2(dy, dx);
      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
        angle += Math.PI;
      }
      ret.angle = angle;
      return ret;
    }
    /**
     * Get a point on a circle
     *
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} angle
     * @returns {object} point
     * @private
     */
  }, {
    key: "_pointOnCircle",
    value: function _pointOnCircle(x2, y2, radius, angle) {
      return {
        x: x2 + radius * Math.cos(angle),
        y: y2 - radius * Math.sin(angle)
      };
    }
    /**
     * Sets selected state to true
     */
  }, {
    key: "select",
    value: function select2() {
      this.selected = true;
    }
    /**
     * Sets selected state to false
     */
  }, {
    key: "unselect",
    value: function unselect() {
      this.selected = false;
    }
    /**
     * cleans all required things on delete
     *
     * @returns {*}
     */
  }, {
    key: "cleanup",
    value: function cleanup() {
      return this.edgeType.cleanup();
    }
    /**
     * Remove edge from the list and perform necessary cleanup.
     */
  }, {
    key: "remove",
    value: function remove2() {
      this.cleanup();
      this.disconnect();
      delete this.body.edges[this.id];
    }
    /**
     * Check if both connecting nodes exist
     *
     * @returns {boolean}
     */
  }, {
    key: "endPointsValid",
    value: function endPointsValid() {
      return this.body.nodes[this.fromId] !== void 0 && this.body.nodes[this.toId] !== void 0;
    }
  }], [{
    key: "parseOptions",
    value: function parseOptions2(parentOptions, newOptions) {
      var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var copyFromGlobals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var fields = ["endPointOffset", "arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "selfReference", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);
      if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.from !== void 0) {
        if (_Number$isFinite(newOptions.endPointOffset.from)) {
          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;
        } else {
          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== void 0 ? globalOptions.endPointOffset.from : 0;
          console.error("endPointOffset.from is not a valid number");
        }
      }
      if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.to !== void 0) {
        if (_Number$isFinite(newOptions.endPointOffset.to)) {
          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;
        } else {
          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== void 0 ? globalOptions.endPointOffset.to : 0;
          console.error("endPointOffset.to is not a valid number");
        }
      }
      if (isValidLabel(newOptions.label)) {
        parentOptions.label = newOptions.label;
      } else if (!isValidLabel(parentOptions.label)) {
        parentOptions.label = void 0;
      }
      mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
      mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
      mergeOptions(parentOptions, newOptions, "background", globalOptions);
      if (newOptions.dashes !== void 0 && newOptions.dashes !== null) {
        parentOptions.dashes = newOptions.dashes;
      } else if (allowDeletion === true && newOptions.dashes === null) {
        parentOptions.dashes = _Object$create$1(globalOptions.dashes);
      }
      if (newOptions.scaling !== void 0 && newOptions.scaling !== null) {
        if (newOptions.scaling.min !== void 0) {
          parentOptions.scaling.min = newOptions.scaling.min;
        }
        if (newOptions.scaling.max !== void 0) {
          parentOptions.scaling.max = newOptions.scaling.max;
        }
        mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
      } else if (allowDeletion === true && newOptions.scaling === null) {
        parentOptions.scaling = _Object$create$1(globalOptions.scaling);
      }
      if (newOptions.arrows !== void 0 && newOptions.arrows !== null) {
        if (typeof newOptions.arrows === "string") {
          var arrows = newOptions.arrows.toLowerCase();
          parentOptions.arrows.to.enabled = _indexOfInstanceProperty(arrows).call(arrows, "to") != -1;
          parentOptions.arrows.middle.enabled = _indexOfInstanceProperty(arrows).call(arrows, "middle") != -1;
          parentOptions.arrows.from.enabled = _indexOfInstanceProperty(arrows).call(arrows, "from") != -1;
        } else if (_typeof$1(newOptions.arrows) === "object") {
          mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
          mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
        } else {
          throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + _JSON$stringify(newOptions.arrows));
        }
      } else if (allowDeletion === true && newOptions.arrows === null) {
        parentOptions.arrows = _Object$create$1(globalOptions.arrows);
      }
      if (newOptions.color !== void 0 && newOptions.color !== null) {
        var fromColor = isString(newOptions.color) ? {
          color: newOptions.color,
          highlight: newOptions.color,
          hover: newOptions.color,
          inherit: false,
          opacity: 1
        } : newOptions.color;
        var toColor = parentOptions.color;
        if (copyFromGlobals) {
          deepExtend(toColor, globalOptions.color, false, allowDeletion);
        } else {
          for (var i in toColor) {
            if (Object.prototype.hasOwnProperty.call(toColor, i)) {
              delete toColor[i];
            }
          }
        }
        if (isString(toColor)) {
          toColor.color = toColor;
          toColor.highlight = toColor;
          toColor.hover = toColor;
          toColor.inherit = false;
          if (fromColor.opacity === void 0) {
            toColor.opacity = 1;
          }
        } else {
          var colorsDefined = false;
          if (fromColor.color !== void 0) {
            toColor.color = fromColor.color;
            colorsDefined = true;
          }
          if (fromColor.highlight !== void 0) {
            toColor.highlight = fromColor.highlight;
            colorsDefined = true;
          }
          if (fromColor.hover !== void 0) {
            toColor.hover = fromColor.hover;
            colorsDefined = true;
          }
          if (fromColor.inherit !== void 0) {
            toColor.inherit = fromColor.inherit;
          }
          if (fromColor.opacity !== void 0) {
            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
          }
          if (colorsDefined === true) {
            toColor.inherit = false;
          } else {
            if (toColor.inherit === void 0) {
              toColor.inherit = "from";
            }
          }
        }
      } else if (allowDeletion === true && newOptions.color === null) {
        parentOptions.color = bridgeObject(globalOptions.color);
      }
      if (allowDeletion === true && newOptions.font === null) {
        parentOptions.font = bridgeObject(globalOptions.font);
      }
      if (Object.prototype.hasOwnProperty.call(newOptions, "selfReferenceSize")) {
        console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");
        parentOptions.selfReference.size = newOptions.selfReferenceSize;
      }
    }
  }]);
  return Edge2;
}();
var EdgesHandler = /* @__PURE__ */ function() {
  function EdgesHandler2(body, images2, groups) {
    var _context, _this = this;
    _classCallCheck(this, EdgesHandler2);
    this.body = body;
    this.images = images2;
    this.groups = groups;
    this.body.functions.createEdge = _bindInstanceProperty$1(_context = this.create).call(_context, this);
    this.edgesListeners = {
      add: function add3(event, params) {
        _this.add(params.items);
      },
      update: function update2(event, params) {
        _this.update(params.items);
      },
      remove: function remove2(event, params) {
        _this.remove(params.items);
      }
    };
    this.options = {};
    this.defaultOptions = {
      arrows: {
        to: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
        middle: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        },
        from: {
          enabled: false,
          scaleFactor: 1,
          type: "arrow"
        }
      },
      endPointOffset: {
        from: 0,
        to: 0
      },
      arrowStrikethrough: true,
      color: {
        color: "#848484",
        highlight: "#848484",
        hover: "#848484",
        inherit: "from",
        opacity: 1
      },
      dashes: false,
      font: {
        color: "#343434",
        size: 14,
        // px
        face: "arial",
        background: "none",
        strokeWidth: 2,
        // px
        strokeColor: "#ffffff",
        align: "horizontal",
        multi: false,
        vadjust: 0,
        bold: {
          mod: "bold"
        },
        boldital: {
          mod: "bold italic"
        },
        ital: {
          mod: "italic"
        },
        mono: {
          mod: "",
          size: 15,
          // px
          face: "courier new",
          vadjust: 2
        }
      },
      hidden: false,
      hoverWidth: 1.5,
      label: void 0,
      labelHighlightBold: true,
      length: void 0,
      physics: true,
      scaling: {
        min: 1,
        max: 15,
        label: {
          enabled: true,
          min: 14,
          max: 30,
          maxVisible: 30,
          drawThreshold: 5
        },
        customScalingFunction: function customScalingFunction(min2, max2, total, value) {
          if (max2 === min2) {
            return 0.5;
          } else {
            var scale = 1 / (max2 - min2);
            return Math.max(0, (value - min2) * scale);
          }
        }
      },
      selectionWidth: 1.5,
      selfReference: {
        size: 20,
        angle: Math.PI / 4,
        renderBehindTheNode: true
      },
      shadow: {
        enabled: false,
        color: "rgba(0,0,0,0.5)",
        size: 10,
        x: 5,
        y: 5
      },
      background: {
        enabled: false,
        color: "rgba(111,111,111,1)",
        size: 10,
        dashes: false
      },
      smooth: {
        enabled: true,
        type: "dynamic",
        forceDirection: "none",
        roundness: 0.5
      },
      title: void 0,
      width: 1,
      value: void 0
    };
    deepExtend(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  _createClass(EdgesHandler2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this, _context2, _context3;
      this.body.emitter.on("_forceDisableDynamicCurves", function(type) {
        var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (type === "dynamic") {
          type = "continuous";
        }
        var dataChanged = false;
        for (var edgeId in _this2.body.edges) {
          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {
            var edge = _this2.body.edges[edgeId];
            var edgeData = _this2.body.data.edges.get(edgeId);
            if (edgeData != null) {
              var smoothOptions = edgeData.smooth;
              if (smoothOptions !== void 0) {
                if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                  if (type === void 0) {
                    edge.setOptions({
                      smooth: false
                    });
                  } else {
                    edge.setOptions({
                      smooth: {
                        type
                      }
                    });
                  }
                  dataChanged = true;
                }
              }
            }
          }
        }
        if (emit === true && dataChanged === true) {
          _this2.body.emitter.emit("_dataChanged");
        }
      });
      this.body.emitter.on("_dataUpdated", function() {
        _this2.reconnectEdges();
      });
      this.body.emitter.on("refreshEdges", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));
      this.body.emitter.on("refresh", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));
      this.body.emitter.on("destroy", function() {
        forEach$4(_this2.edgesListeners, function(callback, event) {
          if (_this2.body.data.edges)
            _this2.body.data.edges.off(event, callback);
        });
        delete _this2.body.functions.createEdge;
        delete _this2.edgesListeners.add;
        delete _this2.edgesListeners.update;
        delete _this2.edgesListeners.remove;
        delete _this2.edgesListeners;
      });
    }
    /**
     *
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        Edge.parseOptions(this.options, options, true, this.defaultOptions, true);
        var dataChanged = false;
        if (options.smooth !== void 0) {
          for (var edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {
              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
            }
          }
        }
        if (options.font !== void 0) {
          for (var _edgeId in this.body.edges) {
            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {
              this.body.edges[_edgeId].updateLabelModule();
            }
          }
        }
        if (options.hidden !== void 0 || options.physics !== void 0 || dataChanged === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     * Load edges by reading the data table
     *
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */
  }, {
    key: "setData",
    value: function setData2(edges) {
      var _this3 = this;
      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var oldEdgesData = this.body.data.edges;
      if (isDataViewLike("id", edges)) {
        this.body.data.edges = edges;
      } else if (_Array$isArray(edges)) {
        this.body.data.edges = new DataSet();
        this.body.data.edges.add(edges);
      } else if (!edges) {
        this.body.data.edges = new DataSet();
      } else {
        throw new TypeError("Array or DataSet expected");
      }
      if (oldEdgesData) {
        forEach$4(this.edgesListeners, function(callback, event) {
          oldEdgesData.off(event, callback);
        });
      }
      this.body.edges = {};
      if (this.body.data.edges) {
        forEach$4(this.edgesListeners, function(callback, event) {
          _this3.body.data.edges.on(event, callback);
        });
        var ids = this.body.data.edges.getIds();
        this.add(ids, true);
      }
      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Add edges
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */
  }, {
    key: "add",
    value: function add3(ids) {
      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      for (var i = 0; i < ids.length; i++) {
        var id2 = ids[i];
        var oldEdge = edges[id2];
        if (oldEdge) {
          oldEdge.disconnect();
        }
        var data2 = edgesData.get(id2, {
          showInternalIds: true
        });
        edges[id2] = this.create(data2);
      }
      this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
      if (doNotEmit === false) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Update existing edges, or create them when not yet existing
     *
     * @param {number[] | string[]} ids
     * @private
     */
  }, {
    key: "update",
    value: function update2(ids) {
      var edges = this.body.edges;
      var edgesData = this.body.data.edges;
      var dataChanged = false;
      for (var i = 0; i < ids.length; i++) {
        var id2 = ids[i];
        var data2 = edgesData.get(id2);
        var edge = edges[id2];
        if (edge !== void 0) {
          edge.disconnect();
          dataChanged = edge.setOptions(data2) || dataChanged;
          edge.connect();
        } else {
          this.body.edges[id2] = this.create(data2);
          dataChanged = true;
        }
      }
      if (dataChanged === true) {
        this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
        this.body.emitter.emit("_dataChanged");
      } else {
        this.body.emitter.emit("_dataUpdated");
      }
    }
    /**
     * Remove existing edges. Non existing ids will be ignored
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */
  }, {
    key: "remove",
    value: function remove2(ids) {
      var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (ids.length === 0)
        return;
      var edges = this.body.edges;
      forEach$4(ids, function(id2) {
        var edge = edges[id2];
        if (edge !== void 0) {
          edge.remove();
        }
      });
      if (emit) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Refreshes Edge Handler
     */
  }, {
    key: "refresh",
    value: function refresh() {
      var _this4 = this;
      forEach$4(this.body.edges, function(edge, edgeId) {
        var data2 = _this4.body.data.edges.get(edgeId);
        if (data2 !== void 0) {
          edge.setOptions(data2);
        }
      });
    }
    /**
     *
     * @param {object} properties
     * @returns {Edge}
     */
  }, {
    key: "create",
    value: function create5(properties) {
      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);
    }
    /**
     * Reconnect all edges
     *
     * @private
     */
  }, {
    key: "reconnectEdges",
    value: function reconnectEdges() {
      var id2;
      var nodes = this.body.nodes;
      var edges = this.body.edges;
      for (id2 in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
          nodes[id2].edges = [];
        }
      }
      for (id2 in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, id2)) {
          var edge = edges[id2];
          edge.from = null;
          edge.to = null;
          edge.connect();
        }
      }
    }
    /**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */
  }, {
    key: "getConnectedNodes",
    value: function getConnectedNodes(edgeId) {
      var nodeList = [];
      if (this.body.edges[edgeId] !== void 0) {
        var edge = this.body.edges[edgeId];
        if (edge.fromId !== void 0) {
          nodeList.push(edge.fromId);
        }
        if (edge.toId !== void 0) {
          nodeList.push(edge.toId);
        }
      }
      return nodeList;
    }
    /**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */
  }, {
    key: "_updateState",
    value: function _updateState() {
      this._addMissingEdges();
      this._removeInvalidEdges();
    }
    /**
     * Scan for missing nodes and remove corresponding edges, if any.
     *
     * @private
     */
  }, {
    key: "_removeInvalidEdges",
    value: function _removeInvalidEdges() {
      var _this5 = this;
      var edgesToDelete = [];
      forEach$4(this.body.edges, function(edge, id2) {
        var toNode = _this5.body.nodes[edge.toId];
        var fromNode = _this5.body.nodes[edge.fromId];
        if (toNode !== void 0 && toNode.isCluster === true || fromNode !== void 0 && fromNode.isCluster === true) {
          return;
        }
        if (toNode === void 0 || fromNode === void 0) {
          edgesToDelete.push(id2);
        }
      });
      this.remove(edgesToDelete, false);
    }
    /**
     * add all edges from dataset that are not in the cached state
     *
     * @private
     */
  }, {
    key: "_addMissingEdges",
    value: function _addMissingEdges() {
      var edgesData = this.body.data.edges;
      if (edgesData === void 0 || edgesData === null) {
        return;
      }
      var edges = this.body.edges;
      var addIds = [];
      _forEachInstanceProperty(edgesData).call(edgesData, function(edgeData, edgeId) {
        var edge = edges[edgeId];
        if (edge === void 0) {
          addIds.push(edgeId);
        }
      });
      this.add(addIds, true);
    }
  }]);
  return EdgesHandler2;
}();
var BarnesHutSolver = /* @__PURE__ */ function() {
  function BarnesHutSolver2(body, physicsBody, options) {
    _classCallCheck(this, BarnesHutSolver2);
    this.body = body;
    this.physicsBody = physicsBody;
    this.barnesHutTree;
    this.setOptions(options);
    this._rng = Alea("BARNES HUT SOLVER");
  }
  _createClass(BarnesHutSolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.thetaInversed = 1 / this.options.theta;
      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
    }
    /**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */
  }, {
    key: "solve",
    value: function solve() {
      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
        var node2;
        var nodes = this.body.nodes;
        var nodeIndices = this.physicsBody.physicsNodeIndices;
        var nodeCount = nodeIndices.length;
        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);
        this.barnesHutTree = barnesHutTree;
        for (var i = 0; i < nodeCount; i++) {
          node2 = nodes[nodeIndices[i]];
          if (node2.options.mass > 0) {
            this._getForceContributions(barnesHutTree.root, node2);
          }
        }
      }
    }
    /**
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */
  }, {
    key: "_getForceContributions",
    value: function _getForceContributions(parentBranch, node2) {
      this._getForceContribution(parentBranch.children.NW, node2);
      this._getForceContribution(parentBranch.children.NE, node2);
      this._getForceContribution(parentBranch.children.SW, node2);
      this._getForceContribution(parentBranch.children.SE, node2);
    }
    /**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */
  }, {
    key: "_getForceContribution",
    value: function _getForceContribution(parentBranch, node2) {
      if (parentBranch.childrenCount > 0) {
        var dx = parentBranch.centerOfMass.x - node2.x;
        var dy = parentBranch.centerOfMass.y - node2.y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        if (distance * parentBranch.calcSize > this.thetaInversed) {
          this._calculateForces(distance, dx, dy, node2, parentBranch);
        } else {
          if (parentBranch.childrenCount === 4) {
            this._getForceContributions(parentBranch, node2);
          } else {
            if (parentBranch.children.data.id != node2.id) {
              this._calculateForces(distance, dx, dy, node2, parentBranch);
            }
          }
        }
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {object} parentBranch
     * @private
     */
  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node2, parentBranch) {
      if (distance === 0) {
        distance = 0.1;
        dx = distance;
      }
      if (this.overlapAvoidanceFactor < 1 && node2.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node2.shape.radius, distance - node2.shape.radius);
      }
      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node2.options.mass / Math.pow(distance, 3);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node2.id].x += fx;
      this.physicsBody.forces[node2.id].y += fy;
    }
    /**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */
  }, {
    key: "_formBarnesHutTree",
    value: function _formBarnesHutTree(nodes, nodeIndices) {
      var node2;
      var nodeCount = nodeIndices.length;
      var minX = nodes[nodeIndices[0]].x;
      var minY = nodes[nodeIndices[0]].y;
      var maxX = nodes[nodeIndices[0]].x;
      var maxY = nodes[nodeIndices[0]].y;
      for (var i = 1; i < nodeCount; i++) {
        var _node = nodes[nodeIndices[i]];
        var x2 = _node.x;
        var y2 = _node.y;
        if (_node.options.mass > 0) {
          if (x2 < minX) {
            minX = x2;
          }
          if (x2 > maxX) {
            maxX = x2;
          }
          if (y2 < minY) {
            minY = y2;
          }
          if (y2 > maxY) {
            maxY = y2;
          }
        }
      }
      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY);
      if (sizeDiff > 0) {
        minY -= 0.5 * sizeDiff;
        maxY += 0.5 * sizeDiff;
      } else {
        minX += 0.5 * sizeDiff;
        maxX -= 0.5 * sizeDiff;
      }
      var minimumTreeSize = 1e-5;
      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
      var halfRootSize = 0.5 * rootSize;
      var centerX = 0.5 * (minX + maxX), centerY = 0.5 * (minY + maxY);
      var barnesHutTree = {
        root: {
          centerOfMass: {
            x: 0,
            y: 0
          },
          mass: 0,
          range: {
            minX: centerX - halfRootSize,
            maxX: centerX + halfRootSize,
            minY: centerY - halfRootSize,
            maxY: centerY + halfRootSize
          },
          size: rootSize,
          calcSize: 1 / rootSize,
          children: {
            data: null
          },
          maxWidth: 0,
          level: 0,
          childrenCount: 4
        }
      };
      this._splitBranch(barnesHutTree.root);
      for (var _i = 0; _i < nodeCount; _i++) {
        node2 = nodes[nodeIndices[_i]];
        if (node2.options.mass > 0) {
          this._placeInTree(barnesHutTree.root, node2);
        }
      }
      return barnesHutTree;
    }
    /**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */
  }, {
    key: "_updateBranchMass",
    value: function _updateBranchMass(parentBranch, node2) {
      var centerOfMass = parentBranch.centerOfMass;
      var totalMass = parentBranch.mass + node2.options.mass;
      var totalMassInv = 1 / totalMass;
      centerOfMass.x = centerOfMass.x * parentBranch.mass + node2.x * node2.options.mass;
      centerOfMass.x *= totalMassInv;
      centerOfMass.y = centerOfMass.y * parentBranch.mass + node2.y * node2.options.mass;
      centerOfMass.y *= totalMassInv;
      parentBranch.mass = totalMass;
      var biggestSize = Math.max(Math.max(node2.height, node2.radius), node2.width);
      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
    }
    /**
     * determine in which branch the node will be placed.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */
  }, {
    key: "_placeInTree",
    value: function _placeInTree(parentBranch, node2, skipMassUpdate) {
      if (skipMassUpdate != true || skipMassUpdate === void 0) {
        this._updateBranchMass(parentBranch, node2);
      }
      var range = parentBranch.children.NW.range;
      var region;
      if (range.maxX > node2.x) {
        if (range.maxY > node2.y) {
          region = "NW";
        } else {
          region = "SW";
        }
      } else {
        if (range.maxY > node2.y) {
          region = "NE";
        } else {
          region = "SE";
        }
      }
      this._placeInRegion(parentBranch, node2, region);
    }
    /**
     * actually place the node in a region (or branch)
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */
  }, {
    key: "_placeInRegion",
    value: function _placeInRegion(parentBranch, node2, region) {
      var children2 = parentBranch.children[region];
      switch (children2.childrenCount) {
        case 0:
          children2.children.data = node2;
          children2.childrenCount = 1;
          this._updateBranchMass(children2, node2);
          break;
        case 1:
          if (children2.children.data.x === node2.x && children2.children.data.y === node2.y) {
            node2.x += this._rng();
            node2.y += this._rng();
          } else {
            this._splitBranch(children2);
            this._placeInTree(children2, node2);
          }
          break;
        case 4:
          this._placeInTree(children2, node2);
          break;
      }
    }
    /**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {object} parentBranch
     * @private
     */
  }, {
    key: "_splitBranch",
    value: function _splitBranch(parentBranch) {
      var containedNode = null;
      if (parentBranch.childrenCount === 1) {
        containedNode = parentBranch.children.data;
        parentBranch.mass = 0;
        parentBranch.centerOfMass.x = 0;
        parentBranch.centerOfMass.y = 0;
      }
      parentBranch.childrenCount = 4;
      parentBranch.children.data = null;
      this._insertRegion(parentBranch, "NW");
      this._insertRegion(parentBranch, "NE");
      this._insertRegion(parentBranch, "SW");
      this._insertRegion(parentBranch, "SE");
      if (containedNode != null) {
        this._placeInTree(parentBranch, containedNode);
      }
    }
    /**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */
  }, {
    key: "_insertRegion",
    value: function _insertRegion(parentBranch, region) {
      var minX, maxX, minY, maxY;
      var childSize = 0.5 * parentBranch.size;
      switch (region) {
        case "NW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;
        case "NE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY;
          maxY = parentBranch.range.minY + childSize;
          break;
        case "SW":
          minX = parentBranch.range.minX;
          maxX = parentBranch.range.minX + childSize;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
        case "SE":
          minX = parentBranch.range.minX + childSize;
          maxX = parentBranch.range.maxX;
          minY = parentBranch.range.minY + childSize;
          maxY = parentBranch.range.maxY;
          break;
      }
      parentBranch.children[region] = {
        centerOfMass: {
          x: 0,
          y: 0
        },
        mass: 0,
        range: {
          minX,
          maxX,
          minY,
          maxY
        },
        size: 0.5 * parentBranch.size,
        calcSize: 2 * parentBranch.calcSize,
        children: {
          data: null
        },
        maxWidth: 0,
        level: parentBranch.level + 1,
        childrenCount: 0
      };
    }
    //---------------------------  DEBUGGING BELOW  ---------------------------//
    /**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */
  }, {
    key: "_debug",
    value: function _debug(ctx, color2) {
      if (this.barnesHutTree !== void 0) {
        ctx.lineWidth = 1;
        this._drawBranch(this.barnesHutTree.root, ctx, color2);
      }
    }
    /**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */
  }, {
    key: "_drawBranch",
    value: function _drawBranch(branch, ctx, color2) {
      if (color2 === void 0) {
        color2 = "#FF0000";
      }
      if (branch.childrenCount === 4) {
        this._drawBranch(branch.children.NW, ctx);
        this._drawBranch(branch.children.NE, ctx);
        this._drawBranch(branch.children.SE, ctx);
        this._drawBranch(branch.children.SW, ctx);
      }
      ctx.strokeStyle = color2;
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.minY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.minY);
      ctx.lineTo(branch.range.maxX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.maxX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.maxY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(branch.range.minX, branch.range.maxY);
      ctx.lineTo(branch.range.minX, branch.range.minY);
      ctx.stroke();
    }
  }]);
  return BarnesHutSolver2;
}();
var RepulsionSolver = /* @__PURE__ */ function() {
  function RepulsionSolver2(body, physicsBody, options) {
    _classCallCheck(this, RepulsionSolver2);
    this._rng = Alea("REPULSION SOLVER");
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  _createClass(RepulsionSolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */
  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;
      var nodeDistance = this.options.nodeDistance;
      var a = -2 / 3 / nodeDistance;
      var b = 4 / 3;
      for (var i = 0; i < nodeIndices.length - 1; i++) {
        node1 = nodes[nodeIndices[i]];
        for (var j2 = i + 1; j2 < nodeIndices.length; j2++) {
          node2 = nodes[nodeIndices[j2]];
          dx = node2.x - node1.x;
          dy = node2.y - node1.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          if (distance === 0) {
            distance = 0.1 * this._rng();
            dx = distance;
          }
          if (distance < 2 * nodeDistance) {
            if (distance < 0.5 * nodeDistance) {
              repulsingForce = 1;
            } else {
              repulsingForce = a * distance + b;
            }
            repulsingForce = repulsingForce / distance;
            fx = dx * repulsingForce;
            fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);
  return RepulsionSolver2;
}();
var HierarchicalRepulsionSolver = /* @__PURE__ */ function() {
  function HierarchicalRepulsionSolver2(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalRepulsionSolver2);
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  _createClass(HierarchicalRepulsionSolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));
    }
    /**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */
  }, {
    key: "solve",
    value: function solve() {
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;
      var nodeDistance = this.options.nodeDistance;
      for (var i = 0; i < nodeIndices.length - 1; i++) {
        var node1 = nodes[nodeIndices[i]];
        for (var j2 = i + 1; j2 < nodeIndices.length; j2++) {
          var node2 = nodes[nodeIndices[j2]];
          if (node1.level === node2.level) {
            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);
            var dx = node2.x - node1.x;
            var dy = node2.y - node1.y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            var steepness = 0.05;
            var repulsingForce = void 0;
            if (distance < theseNodesDistance) {
              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);
            } else {
              repulsingForce = 0;
            }
            if (distance !== 0) {
              repulsingForce = repulsingForce / distance;
            }
            var fx = dx * repulsingForce;
            var fy = dy * repulsingForce;
            forces[node1.id].x -= fx;
            forces[node1.id].y -= fy;
            forces[node2.id].x += fx;
            forces[node2.id].y += fy;
          }
        }
      }
    }
  }]);
  return HierarchicalRepulsionSolver2;
}();
var SpringSolver = /* @__PURE__ */ function() {
  function SpringSolver2(body, physicsBody, options) {
    _classCallCheck(this, SpringSolver2);
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  _createClass(SpringSolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */
  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var edges = this.body.edges;
      var node1, node2, node3;
      for (var i = 0; i < edgeIndices.length; i++) {
        edge = edges[edgeIndices[i]];
        if (edge.connected === true && edge.toId !== edge.fromId) {
          if (this.body.nodes[edge.toId] !== void 0 && this.body.nodes[edge.fromId] !== void 0) {
            if (edge.edgeType.via !== void 0) {
              edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
              node1 = edge.to;
              node2 = edge.edgeType.via;
              node3 = edge.from;
              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
            } else {
              edgeLength = edge.options.length === void 0 ? this.options.springLength * 1.5 : edge.options.length;
              this._calculateSpringForce(edge.from, edge.to, edgeLength);
            }
          }
        }
      }
    }
    /**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */
  }, {
    key: "_calculateSpringForce",
    value: function _calculateSpringForce(node1, node2, edgeLength) {
      var dx = node1.x - node2.x;
      var dy = node1.y - node2.y;
      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);
      var springForce = this.options.springConstant * (edgeLength - distance) / distance;
      var fx = dx * springForce;
      var fy = dy * springForce;
      if (this.physicsBody.forces[node1.id] !== void 0) {
        this.physicsBody.forces[node1.id].x += fx;
        this.physicsBody.forces[node1.id].y += fy;
      }
      if (this.physicsBody.forces[node2.id] !== void 0) {
        this.physicsBody.forces[node2.id].x -= fx;
        this.physicsBody.forces[node2.id].y -= fy;
      }
    }
  }]);
  return SpringSolver2;
}();
var HierarchicalSpringSolver = /* @__PURE__ */ function() {
  function HierarchicalSpringSolver2(body, physicsBody, options) {
    _classCallCheck(this, HierarchicalSpringSolver2);
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  _createClass(HierarchicalSpringSolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */
  }, {
    key: "solve",
    value: function solve() {
      var edgeLength, edge;
      var dx, dy, fx, fy, springForce, distance;
      var edges = this.body.edges;
      var factor = 0.5;
      var edgeIndices = this.physicsBody.physicsEdgeIndices;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;
      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        forces[nodeId].springFx = 0;
        forces[nodeId].springFy = 0;
      }
      for (var _i = 0; _i < edgeIndices.length; _i++) {
        edge = edges[edgeIndices[_i]];
        if (edge.connected === true) {
          edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
          dx = edge.from.x - edge.to.x;
          dy = edge.from.y - edge.to.y;
          distance = Math.sqrt(dx * dx + dy * dy);
          distance = distance === 0 ? 0.01 : distance;
          springForce = this.options.springConstant * (edgeLength - distance) / distance;
          fx = dx * springForce;
          fy = dy * springForce;
          if (edge.to.level != edge.from.level) {
            if (forces[edge.toId] !== void 0) {
              forces[edge.toId].springFx -= fx;
              forces[edge.toId].springFy -= fy;
            }
            if (forces[edge.fromId] !== void 0) {
              forces[edge.fromId].springFx += fx;
              forces[edge.fromId].springFy += fy;
            }
          } else {
            if (forces[edge.toId] !== void 0) {
              forces[edge.toId].x -= factor * fx;
              forces[edge.toId].y -= factor * fy;
            }
            if (forces[edge.fromId] !== void 0) {
              forces[edge.fromId].x += factor * fx;
              forces[edge.fromId].y += factor * fy;
            }
          }
        }
      }
      springForce = 1;
      var springFx, springFy;
      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
        var _nodeId = nodeIndices[_i2];
        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
        forces[_nodeId].x += springFx;
        forces[_nodeId].y += springFy;
      }
      var totalFx = 0;
      var totalFy = 0;
      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
        var _nodeId2 = nodeIndices[_i3];
        totalFx += forces[_nodeId2].x;
        totalFy += forces[_nodeId2].y;
      }
      var correctionFx = totalFx / nodeIndices.length;
      var correctionFy = totalFy / nodeIndices.length;
      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
        var _nodeId3 = nodeIndices[_i4];
        forces[_nodeId3].x -= correctionFx;
        forces[_nodeId3].y -= correctionFy;
      }
    }
  }]);
  return HierarchicalSpringSolver2;
}();
var CentralGravitySolver = /* @__PURE__ */ function() {
  function CentralGravitySolver2(body, physicsBody, options) {
    _classCallCheck(this, CentralGravitySolver2);
    this.body = body;
    this.physicsBody = physicsBody;
    this.setOptions(options);
  }
  _createClass(CentralGravitySolver2, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
    }
    /**
     * Calculates forces for each node
     */
  }, {
    key: "solve",
    value: function solve() {
      var dx, dy, distance, node2;
      var nodes = this.body.nodes;
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var forces = this.physicsBody.forces;
      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        node2 = nodes[nodeId];
        dx = -node2.x;
        dy = -node2.y;
        distance = Math.sqrt(dx * dx + dy * dy);
        this._calculateForces(distance, dx, dy, forces, node2);
      }
    }
    /**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */
  }, {
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node2) {
      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
      forces[node2.id].x = dx * gravityForce;
      forces[node2.id].y = dy * gravityForce;
    }
  }]);
  return CentralGravitySolver2;
}();
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ForceAtlas2BasedRepulsionSolver = /* @__PURE__ */ function(_BarnesHutSolver) {
  _inherits(ForceAtlas2BasedRepulsionSolver2, _BarnesHutSolver);
  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver2);
  function ForceAtlas2BasedRepulsionSolver2(body, physicsBody, options) {
    var _this;
    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver2);
    _this = _super.call(this, body, physicsBody, options);
    _this._rng = Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");
    return _this;
  }
  _createClass(ForceAtlas2BasedRepulsionSolver2, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, node2, parentBranch) {
      if (distance === 0) {
        distance = 0.1 * this._rng();
        dx = distance;
      }
      if (this.overlapAvoidanceFactor < 1 && node2.shape.radius) {
        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node2.shape.radius, distance - node2.shape.radius);
      }
      var degree = node2.edges.length + 1;
      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node2.options.mass * degree / Math.pow(distance, 2);
      var fx = dx * gravityForce;
      var fy = dy * gravityForce;
      this.physicsBody.forces[node2.id].x += fx;
      this.physicsBody.forces[node2.id].y += fy;
    }
  }]);
  return ForceAtlas2BasedRepulsionSolver2;
}(BarnesHutSolver);
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ForceAtlas2BasedCentralGravitySolver = /* @__PURE__ */ function(_CentralGravitySolver) {
  _inherits(ForceAtlas2BasedCentralGravitySolver2, _CentralGravitySolver);
  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver2);
  function ForceAtlas2BasedCentralGravitySolver2(body, physicsBody, options) {
    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver2);
    return _super.call(this, body, physicsBody, options);
  }
  _createClass(ForceAtlas2BasedCentralGravitySolver2, [{
    key: "_calculateForces",
    value: function _calculateForces(distance, dx, dy, forces, node2) {
      if (distance > 0) {
        var degree = node2.edges.length + 1;
        var gravityForce = this.options.centralGravity * degree * node2.options.mass;
        forces[node2.id].x = dx * gravityForce;
        forces[node2.id].y = dy * gravityForce;
      }
    }
  }]);
  return ForceAtlas2BasedCentralGravitySolver2;
}(CentralGravitySolver);
var PhysicsEngine = /* @__PURE__ */ function() {
  function PhysicsEngine2(body) {
    _classCallCheck(this, PhysicsEngine2);
    this.body = body;
    this.physicsBody = {
      physicsNodeIndices: [],
      physicsEdgeIndices: [],
      forces: {},
      velocities: {}
    };
    this.physicsEnabled = true;
    this.simulationInterval = 1e3 / 60;
    this.requiresTimeout = true;
    this.previousStates = {};
    this.referenceState = {};
    this.freezeCache = {};
    this.renderTimer = void 0;
    this.adaptiveTimestep = false;
    this.adaptiveTimestepEnabled = false;
    this.adaptiveCounter = 0;
    this.adaptiveInterval = 3;
    this.stabilized = false;
    this.startedStabilization = false;
    this.stabilizationIterations = 0;
    this.ready = false;
    this.options = {};
    this.defaultOptions = {
      enabled: true,
      barnesHut: {
        theta: 0.5,
        gravitationalConstant: -2e3,
        centralGravity: 0.3,
        springLength: 95,
        springConstant: 0.04,
        damping: 0.09,
        avoidOverlap: 0
      },
      forceAtlas2Based: {
        theta: 0.5,
        gravitationalConstant: -50,
        centralGravity: 0.01,
        springConstant: 0.08,
        springLength: 100,
        damping: 0.4,
        avoidOverlap: 0
      },
      repulsion: {
        centralGravity: 0.2,
        springLength: 200,
        springConstant: 0.05,
        nodeDistance: 100,
        damping: 0.09,
        avoidOverlap: 0
      },
      hierarchicalRepulsion: {
        centralGravity: 0,
        springLength: 100,
        springConstant: 0.01,
        nodeDistance: 120,
        damping: 0.09
      },
      maxVelocity: 50,
      minVelocity: 0.75,
      // px/s
      solver: "barnesHut",
      stabilization: {
        enabled: true,
        iterations: 1e3,
        // maximum number of iteration to stabilize
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true
      },
      timestep: 0.5,
      adaptiveTimestep: true,
      wind: {
        x: 0,
        y: 0
      }
    };
    _Object$assign(this.options, this.defaultOptions);
    this.timestep = 0.5;
    this.layoutFailed = false;
    this.bindEventListeners();
  }
  _createClass(PhysicsEngine2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;
      this.body.emitter.on("initPhysics", function() {
        _this.initPhysics();
      });
      this.body.emitter.on("_layoutFailed", function() {
        _this.layoutFailed = true;
      });
      this.body.emitter.on("resetPhysics", function() {
        _this.stopSimulation();
        _this.ready = false;
      });
      this.body.emitter.on("disablePhysics", function() {
        _this.physicsEnabled = false;
        _this.stopSimulation();
      });
      this.body.emitter.on("restorePhysics", function() {
        _this.setOptions(_this.options);
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("startSimulation", function() {
        if (_this.ready === true) {
          _this.startSimulation();
        }
      });
      this.body.emitter.on("stopSimulation", function() {
        _this.stopSimulation();
      });
      this.body.emitter.on("destroy", function() {
        _this.stopSimulation(false);
        _this.body.emitter.off();
      });
      this.body.emitter.on("_dataChanged", function() {
        _this.updatePhysicsData();
      });
    }
    /**
     * set the physics options
     *
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        if (options === false) {
          this.options.enabled = false;
          this.physicsEnabled = false;
          this.stopSimulation();
        } else if (options === true) {
          this.options.enabled = true;
          this.physicsEnabled = true;
          this.startSimulation();
        } else {
          this.physicsEnabled = true;
          selectiveNotDeepExtend(["stabilization"], this.options, options);
          mergeOptions(this.options, options, "stabilization");
          if (options.enabled === void 0) {
            this.options.enabled = true;
          }
          if (this.options.enabled === false) {
            this.physicsEnabled = false;
            this.stopSimulation();
          }
          var wind = this.options.wind;
          if (wind) {
            if (typeof wind.x !== "number" || _Number$isNaN(wind.x)) {
              wind.x = 0;
            }
            if (typeof wind.y !== "number" || _Number$isNaN(wind.y)) {
              wind.y = 0;
            }
          }
          this.timestep = this.options.timestep;
        }
      }
      this.init();
    }
    /**
     * configure the engine.
     */
  }, {
    key: "init",
    value: function init2() {
      var options;
      if (this.options.solver === "forceAtlas2Based") {
        options = this.options.forceAtlas2Based;
        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "repulsion") {
        options = this.options.repulsion;
        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else if (this.options.solver === "hierarchicalRepulsion") {
        options = this.options.hierarchicalRepulsion;
        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      } else {
        options = this.options.barnesHut;
        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
      }
      this.modelOptions = options;
    }
    /**
     * initialize the engine
     */
  }, {
    key: "initPhysics",
    value: function initPhysics() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        if (this.options.stabilization.enabled === true) {
          this.stabilize();
        } else {
          this.stabilized = false;
          this.ready = true;
          this.body.emitter.emit("fit", {}, this.layoutFailed);
          this.startSimulation();
        }
      } else {
        this.ready = true;
        this.body.emitter.emit("fit");
      }
    }
    /**
     * Start the simulation
     */
  }, {
    key: "startSimulation",
    value: function startSimulation() {
      if (this.physicsEnabled === true && this.options.enabled === true) {
        this.stabilized = false;
        this.adaptiveTimestep = false;
        this.body.emitter.emit("_resizeNodes");
        if (this.viewFunction === void 0) {
          var _context;
          this.viewFunction = _bindInstanceProperty$1(_context = this.simulationStep).call(_context, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
          this.body.emitter.emit("_startRendering");
        }
      } else {
        this.body.emitter.emit("_redraw");
      }
    }
    /**
     * Stop the simulation, force stabilization.
     *
     * @param {boolean} [emit=true]
     */
  }, {
    key: "stopSimulation",
    value: function stopSimulation() {
      var emit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.stabilized = true;
      if (emit === true) {
        this._emitStabilized();
      }
      if (this.viewFunction !== void 0) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.viewFunction = void 0;
        if (emit === true) {
          this.body.emitter.emit("_stopRendering");
        }
      }
    }
    /**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */
  }, {
    key: "simulationStep",
    value: function simulationStep() {
      var startTime = _Date$now();
      this.physicsTick();
      var physicsTime = _Date$now() - startTime;
      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
        this.physicsTick();
        this.runDoubleSpeed = true;
      }
      if (this.stabilized === true) {
        this.stopSimulation();
      }
    }
    /**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */
  }, {
    key: "_emitStabilized",
    value: function _emitStabilized() {
      var _this2 = this;
      var amountOfIterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.stabilizationIterations;
      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
        _setTimeout(function() {
          _this2.body.emitter.emit("stabilized", {
            iterations: amountOfIterations
          });
          _this2.startedStabilization = false;
          _this2.stabilizationIterations = 0;
        }, 0);
      }
    }
    /**
     * Calculate the forces for one physics iteration and move the nodes.
     *
     * @private
     */
  }, {
    key: "physicsStep",
    value: function physicsStep() {
      this.gravitySolver.solve();
      this.nodesSolver.solve();
      this.edgesSolver.solve();
      this.moveNodes();
    }
    /**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     *
     * @private
     */
  }, {
    key: "adjustTimeStep",
    value: function adjustTimeStep() {
      var factor = 1.2;
      if (this._evaluateStepQuality() === true) {
        this.timestep = factor * this.timestep;
      } else {
        if (this.timestep / factor < this.options.timestep) {
          this.timestep = this.options.timestep;
        } else {
          this.adaptiveCounter = -1;
          this.timestep = Math.max(this.options.timestep, this.timestep / factor);
        }
      }
    }
    /**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */
  }, {
    key: "physicsTick",
    value: function physicsTick() {
      this._startStabilizing();
      if (this.stabilized === true)
        return;
      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;
        if (doAdaptive) {
          this.timestep = 2 * this.timestep;
          this.physicsStep();
          this.revert();
          this.timestep = 0.5 * this.timestep;
          this.physicsStep();
          this.physicsStep();
          this.adjustTimeStep();
        } else {
          this.physicsStep();
        }
        this.adaptiveCounter += 1;
      } else {
        this.timestep = this.options.timestep;
        this.physicsStep();
      }
      if (this.stabilized === true)
        this.revert();
      this.stabilizationIterations++;
    }
    /**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */
  }, {
    key: "updatePhysicsData",
    value: function updatePhysicsData() {
      this.physicsBody.forces = {};
      this.physicsBody.physicsNodeIndices = [];
      this.physicsBody.physicsEdgeIndices = [];
      var nodes = this.body.nodes;
      var edges = this.body.edges;
      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (nodes[nodeId].options.physics === true) {
            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
          }
        }
      }
      for (var edgeId in edges) {
        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
          if (edges[edgeId].options.physics === true) {
            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
          }
        }
      }
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var _nodeId = this.physicsBody.physicsNodeIndices[i];
        this.physicsBody.forces[_nodeId] = {
          x: 0,
          y: 0
        };
        if (this.physicsBody.velocities[_nodeId] === void 0) {
          this.physicsBody.velocities[_nodeId] = {
            x: 0,
            y: 0
          };
        }
      }
      for (var _nodeId2 in this.physicsBody.velocities) {
        if (nodes[_nodeId2] === void 0) {
          delete this.physicsBody.velocities[_nodeId2];
        }
      }
    }
    /**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */
  }, {
    key: "revert",
    value: function revert() {
      var nodeIds = _Object$keys(this.previousStates);
      var nodes = this.body.nodes;
      var velocities = this.physicsBody.velocities;
      this.referenceState = {};
      for (var i = 0; i < nodeIds.length; i++) {
        var nodeId = nodeIds[i];
        if (nodes[nodeId] !== void 0) {
          if (nodes[nodeId].options.physics === true) {
            this.referenceState[nodeId] = {
              positions: {
                x: nodes[nodeId].x,
                y: nodes[nodeId].y
              }
            };
            velocities[nodeId].x = this.previousStates[nodeId].vx;
            velocities[nodeId].y = this.previousStates[nodeId].vy;
            nodes[nodeId].x = this.previousStates[nodeId].x;
            nodes[nodeId].y = this.previousStates[nodeId].y;
          }
        } else {
          delete this.previousStates[nodeId];
        }
      }
    }
    /**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */
  }, {
    key: "_evaluateStepQuality",
    value: function _evaluateStepQuality() {
      var dx, dy, dpos;
      var nodes = this.body.nodes;
      var reference2 = this.referenceState;
      var posThreshold = 0.3;
      for (var nodeId in this.referenceState) {
        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== void 0) {
          dx = nodes[nodeId].x - reference2[nodeId].positions.x;
          dy = nodes[nodeId].y - reference2[nodeId].positions.y;
          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          if (dpos > posThreshold) {
            return false;
          }
        }
      }
      return true;
    }
    /**
     * move the nodes one timestep and check if they are stabilized
     */
  }, {
    key: "moveNodes",
    value: function moveNodes() {
      var nodeIndices = this.physicsBody.physicsNodeIndices;
      var maxNodeVelocity = 0;
      var averageNodeVelocity = 0;
      var velocityAdaptiveThreshold = 5;
      for (var i = 0; i < nodeIndices.length; i++) {
        var nodeId = nodeIndices[i];
        var nodeVelocity = this._performStep(nodeId);
        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
        averageNodeVelocity += nodeVelocity;
      }
      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
      this.stabilized = maxNodeVelocity < this.options.minVelocity;
    }
    /**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */
  }, {
    key: "calculateComponentVelocity",
    value: function calculateComponentVelocity(v2, f, m) {
      var df = this.modelOptions.damping * v2;
      var a = (f - df) / m;
      v2 += a * this.timestep;
      var maxV = this.options.maxVelocity || 1e9;
      if (Math.abs(v2) > maxV) {
        v2 = v2 > 0 ? maxV : -maxV;
      }
      return v2;
    }
    /**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */
  }, {
    key: "_performStep",
    value: function _performStep(nodeId) {
      var node2 = this.body.nodes[nodeId];
      var force = this.physicsBody.forces[nodeId];
      if (this.options.wind) {
        force.x += this.options.wind.x;
        force.y += this.options.wind.y;
      }
      var velocity = this.physicsBody.velocities[nodeId];
      this.previousStates[nodeId] = {
        x: node2.x,
        y: node2.y,
        vx: velocity.x,
        vy: velocity.y
      };
      if (node2.options.fixed.x === false) {
        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node2.options.mass);
        node2.x += velocity.x * this.timestep;
      } else {
        force.x = 0;
        velocity.x = 0;
      }
      if (node2.options.fixed.y === false) {
        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node2.options.mass);
        node2.y += velocity.y * this.timestep;
      } else {
        force.y = 0;
        velocity.y = 0;
      }
      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
      return totalVelocity;
    }
    /**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */
  }, {
    key: "_freezeNodes",
    value: function _freezeNodes() {
      var nodes = this.body.nodes;
      for (var id2 in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
          if (nodes[id2].x && nodes[id2].y) {
            var fixed = nodes[id2].options.fixed;
            this.freezeCache[id2] = {
              x: fixed.x,
              y: fixed.y
            };
            fixed.x = true;
            fixed.y = true;
          }
        }
      }
    }
    /**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */
  }, {
    key: "_restoreFrozenNodes",
    value: function _restoreFrozenNodes() {
      var nodes = this.body.nodes;
      for (var id2 in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, id2)) {
          if (this.freezeCache[id2] !== void 0) {
            nodes[id2].options.fixed.x = this.freezeCache[id2].x;
            nodes[id2].options.fixed.y = this.freezeCache[id2].y;
          }
        }
      }
      this.freezeCache = {};
    }
    /**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */
  }, {
    key: "stabilize",
    value: function stabilize() {
      var _this3 = this;
      var iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.stabilization.iterations;
      if (typeof iterations !== "number") {
        iterations = this.options.stabilization.iterations;
        console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
      }
      if (this.physicsBody.physicsNodeIndices.length === 0) {
        this.ready = true;
        return;
      }
      this.adaptiveTimestep = this.options.adaptiveTimestep;
      this.body.emitter.emit("_resizeNodes");
      this.stopSimulation();
      this.stabilized = false;
      this.body.emitter.emit("_blockRedraw");
      this.targetIterations = iterations;
      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._freezeNodes();
      }
      this.stabilizationIterations = 0;
      _setTimeout(function() {
        return _this3._stabilizationBatch();
      }, 0);
    }
    /**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */
  }, {
    key: "_startStabilizing",
    value: function _startStabilizing() {
      if (this.startedStabilization === true)
        return false;
      this.body.emitter.emit("startStabilizing");
      this.startedStabilization = true;
      return true;
    }
    /**
     * One batch of stabilization
     *
     * @private
     */
  }, {
    key: "_stabilizationBatch",
    value: function _stabilizationBatch() {
      var _this4 = this;
      var running = function running2() {
        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
      };
      var sendProgress = function sendProgress2() {
        _this4.body.emitter.emit("stabilizationProgress", {
          iterations: _this4.stabilizationIterations,
          total: _this4.targetIterations
        });
      };
      if (this._startStabilizing()) {
        sendProgress();
      }
      var count = 0;
      while (running() && count < this.options.stabilization.updateInterval) {
        this.physicsTick();
        count++;
      }
      sendProgress();
      if (running()) {
        var _context2;
        _setTimeout(_bindInstanceProperty$1(_context2 = this._stabilizationBatch).call(_context2, this), 0);
      } else {
        this._finalizeStabilization();
      }
    }
    /**
     * Wrap up the stabilization, fit and emit the events.
     *
     * @private
     */
  }, {
    key: "_finalizeStabilization",
    value: function _finalizeStabilization() {
      this.body.emitter.emit("_allowRedraw");
      if (this.options.stabilization.fit === true) {
        this.body.emitter.emit("fit");
      }
      if (this.options.stabilization.onlyDynamicEdges === true) {
        this._restoreFrozenNodes();
      }
      this.body.emitter.emit("stabilizationIterationsDone");
      this.body.emitter.emit("_requestRedraw");
      if (this.stabilized === true) {
        this._emitStabilized();
      } else {
        this.startSimulation();
      }
      this.ready = true;
    }
    //---------------------------  DEBUGGING BELOW  ---------------------------//
    /**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */
  }, {
    key: "_drawForces",
    value: function _drawForces(ctx) {
      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
        var index2 = this.physicsBody.physicsNodeIndices[i];
        var node2 = this.body.nodes[index2];
        var force = this.physicsBody.forces[index2];
        var factor = 20;
        var colorFactor = 0.03;
        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
        var size = Math.min(Math.max(5, forceSize), 15);
        var arrowSize = 3 * size;
        var color2 = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
        var point = {
          x: node2.x + factor * force.x,
          y: node2.y + factor * force.y
        };
        ctx.lineWidth = size;
        ctx.strokeStyle = color2;
        ctx.beginPath();
        ctx.moveTo(node2.x, node2.y);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
        var angle = Math.atan2(force.y, force.x);
        ctx.fillStyle = color2;
        EndPoints.draw(ctx, {
          type: "arrow",
          point,
          angle,
          length: arrowSize
        });
        _fillInstanceProperty(ctx).call(ctx);
      }
    }
  }]);
  return PhysicsEngine2;
}();
var NetworkUtil = /* @__PURE__ */ function() {
  function NetworkUtil2() {
    _classCallCheck(this, NetworkUtil2);
  }
  _createClass(NetworkUtil2, null, [{
    key: "getRange",
    value: function getRange(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node2;
      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node2 = allNodes[specificNodes[i]];
          if (minX > node2.shape.boundingBox.left) {
            minX = node2.shape.boundingBox.left;
          }
          if (maxX < node2.shape.boundingBox.right) {
            maxX = node2.shape.boundingBox.right;
          }
          if (minY > node2.shape.boundingBox.top) {
            minY = node2.shape.boundingBox.top;
          }
          if (maxY < node2.shape.boundingBox.bottom) {
            maxY = node2.shape.boundingBox.bottom;
          }
        }
      }
      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }
      return {
        minX,
        maxX,
        minY,
        maxY
      };
    }
    /**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */
  }, {
    key: "getRangeCore",
    value: function getRangeCore(allNodes) {
      var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node2;
      if (specificNodes.length > 0) {
        for (var i = 0; i < specificNodes.length; i++) {
          node2 = allNodes[specificNodes[i]];
          if (minX > node2.x) {
            minX = node2.x;
          }
          if (maxX < node2.x) {
            maxX = node2.x;
          }
          if (minY > node2.y) {
            minY = node2.y;
          }
          if (maxY < node2.y) {
            maxY = node2.y;
          }
        }
      }
      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
        minY = 0, maxY = 0, minX = 0, maxX = 0;
      }
      return {
        minX,
        maxX,
        minY,
        maxY
      };
    }
    /**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */
  }, {
    key: "findCenter",
    value: function findCenter(range) {
      return {
        x: 0.5 * (range.maxX + range.minX),
        y: 0.5 * (range.maxY + range.minY)
      };
    }
    /**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     *
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */
  }, {
    key: "cloneOptions",
    value: function cloneOptions(item, type) {
      var clonedOptions = {};
      if (type === void 0 || type === "node") {
        deepExtend(clonedOptions, item.options, true);
        clonedOptions.x = item.x;
        clonedOptions.y = item.y;
        clonedOptions.amountOfConnections = item.edges.length;
      } else {
        deepExtend(clonedOptions, item.options, true);
      }
      return clonedOptions;
    }
  }]);
  return NetworkUtil2;
}();
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Cluster = /* @__PURE__ */ function(_Node) {
  _inherits(Cluster2, _Node);
  var _super = _createSuper$1(Cluster2);
  function Cluster2(options, body, imagelist, grouplist, globalOptions, defaultOptions2) {
    var _this;
    _classCallCheck(this, Cluster2);
    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions2);
    _this.isCluster = true;
    _this.containedNodes = {};
    _this.containedEdges = {};
    return _this;
  }
  _createClass(Cluster2, [{
    key: "_openChildCluster",
    value: function _openChildCluster(childClusterId) {
      var _this2 = this;
      var childCluster = this.body.nodes[childClusterId];
      if (this.containedNodes[childClusterId] === void 0) {
        throw new Error("node with id: " + childClusterId + " not in current cluster");
      }
      if (!childCluster.isCluster) {
        throw new Error("node with id: " + childClusterId + " is not a cluster");
      }
      delete this.containedNodes[childClusterId];
      forEach$4(childCluster.edges, function(edge) {
        delete _this2.containedEdges[edge.id];
      });
      forEach$4(childCluster.containedNodes, function(node2, nodeId) {
        _this2.containedNodes[nodeId] = node2;
      });
      childCluster.containedNodes = {};
      forEach$4(childCluster.containedEdges, function(edge, edgeId) {
        _this2.containedEdges[edgeId] = edge;
      });
      childCluster.containedEdges = {};
      forEach$4(childCluster.edges, function(clusterEdge) {
        forEach$4(_this2.edges, function(parentClusterEdge) {
          var _context, _context2;
          var index2 = _indexOfInstanceProperty(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);
          if (index2 === -1)
            return;
          forEach$4(clusterEdge.clusteringEdgeReplacingIds, function(srcId) {
            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);
            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
          });
          _spliceInstanceProperty(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index2, 1);
        });
      });
      childCluster.edges = [];
    }
  }]);
  return Cluster2;
}(Node$1);
var ClusterEngine = /* @__PURE__ */ function() {
  function ClusterEngine2(body) {
    var _this = this;
    _classCallCheck(this, ClusterEngine2);
    this.body = body;
    this.clusteredNodes = {};
    this.clusteredEdges = {};
    this.options = {};
    this.defaultOptions = {};
    _Object$assign(this.options, this.defaultOptions);
    this.body.emitter.on("_resetData", function() {
      _this.clusteredNodes = {};
      _this.clusteredEdges = {};
    });
  }
  _createClass(ClusterEngine2, [{
    key: "clusterByHubsize",
    value: function clusterByHubsize(hubsize, options) {
      if (hubsize === void 0) {
        hubsize = this._getHubSize();
      } else if (_typeof$1(hubsize) === "object") {
        options = this._checkOptions(hubsize);
        hubsize = this._getHubSize();
      }
      var nodesToCluster = [];
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node2 = this.body.nodes[this.body.nodeIndices[i]];
        if (node2.edges.length >= hubsize) {
          nodesToCluster.push(node2.id);
        }
      }
      for (var _i = 0; _i < nodesToCluster.length; _i++) {
        this.clusterByConnection(nodesToCluster[_i], options, true);
      }
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */
  }, {
    key: "cluster",
    value: function cluster() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (options.joinCondition === void 0) {
        throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
      }
      options = this._checkOptions(options);
      var childNodesObj = {};
      var childEdgesObj = {};
      forEach$4(this.body.nodes, function(node2, nodeId) {
        if (node2.options && options.joinCondition(node2.options) === true) {
          childNodesObj[nodeId] = node2;
          forEach$4(node2.edges, function(edge) {
            if (_this2.clusteredEdges[edge.id] === void 0) {
              childEdgesObj[edge.id] = edge;
            }
          });
        }
      });
      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only X edges
     *
     * @param {number} edgeCount
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */
  }, {
    key: "clusterByEdgeCount",
    value: function clusterByEdgeCount(edgeCount, options) {
      var _this3 = this;
      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      options = this._checkOptions(options);
      var clusters = [];
      var usedNodes = {};
      var edge, edges, relevantEdgeCount;
      var _loop = function _loop2() {
        var childNodesObj = {};
        var childEdgesObj = {};
        var nodeId = _this3.body.nodeIndices[i];
        var node2 = _this3.body.nodes[nodeId];
        if (usedNodes[nodeId] === void 0) {
          relevantEdgeCount = 0;
          edges = [];
          for (var j2 = 0; j2 < node2.edges.length; j2++) {
            edge = node2.edges[j2];
            if (_this3.clusteredEdges[edge.id] === void 0) {
              if (edge.toId !== edge.fromId) {
                relevantEdgeCount++;
              }
              edges.push(edge);
            }
          }
          if (relevantEdgeCount === edgeCount) {
            var checkJoinCondition = function checkJoinCondition2(node3) {
              if (options.joinCondition === void 0 || options.joinCondition === null) {
                return true;
              }
              var clonedOptions = NetworkUtil.cloneOptions(node3);
              return options.joinCondition(clonedOptions);
            };
            var gatheringSuccessful = true;
            for (var _j = 0; _j < edges.length; _j++) {
              edge = edges[_j];
              var childNodeId = _this3._getConnectedId(edge, nodeId);
              if (checkJoinCondition(node2)) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[nodeId] = node2;
                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                usedNodes[nodeId] = true;
              } else {
                gatheringSuccessful = false;
                break;
              }
            }
            if (_Object$keys(childNodesObj).length > 0 && _Object$keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {
              var findClusterData = function findClusterData2() {
                for (var n = 0; n < clusters.length; ++n) {
                  for (var m2 in childNodesObj) {
                    if (clusters[n].nodes[m2] !== void 0) {
                      return clusters[n];
                    }
                  }
                }
                return void 0;
              };
              var foundCluster = findClusterData();
              if (foundCluster !== void 0) {
                for (var m in childNodesObj) {
                  if (foundCluster.nodes[m] === void 0) {
                    foundCluster.nodes[m] = childNodesObj[m];
                  }
                }
                for (var _m in childEdgesObj) {
                  if (foundCluster.edges[_m] === void 0) {
                    foundCluster.edges[_m] = childEdgesObj[_m];
                  }
                }
              } else {
                clusters.push({
                  nodes: childNodesObj,
                  edges: childEdgesObj
                });
              }
            }
          }
        }
      };
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        _loop();
      }
      for (var _i2 = 0; _i2 < clusters.length; _i2++) {
        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);
      }
      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     * Cluster all nodes in the network that have only 1 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */
  }, {
    key: "clusterOutliers",
    value: function clusterOutliers(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.clusterByEdgeCount(1, options, refreshData);
    }
    /**
     * Cluster all nodes in the network that have only 2 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */
  }, {
    key: "clusterBridges",
    value: function clusterBridges(options) {
      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      this.clusterByEdgeCount(2, options, refreshData);
    }
    /**
     * suck all connected nodes of a node into the node.
     *
     * @param {Node.id} nodeId
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */
  }, {
    key: "clusterByConnection",
    value: function clusterByConnection(nodeId, options) {
      var _context;
      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (nodeId === void 0) {
        throw new Error("No nodeId supplied to clusterByConnection!");
      }
      if (this.body.nodes[nodeId] === void 0) {
        throw new Error("The nodeId given to clusterByConnection does not exist!");
      }
      var node2 = this.body.nodes[nodeId];
      options = this._checkOptions(options, node2);
      if (options.clusterNodeProperties.x === void 0) {
        options.clusterNodeProperties.x = node2.x;
      }
      if (options.clusterNodeProperties.y === void 0) {
        options.clusterNodeProperties.y = node2.y;
      }
      if (options.clusterNodeProperties.fixed === void 0) {
        options.clusterNodeProperties.fixed = {};
        options.clusterNodeProperties.fixed.x = node2.options.fixed.x;
        options.clusterNodeProperties.fixed.y = node2.options.fixed.y;
      }
      var childNodesObj = {};
      var childEdgesObj = {};
      var parentNodeId = node2.id;
      var parentClonedOptions = NetworkUtil.cloneOptions(node2);
      childNodesObj[parentNodeId] = node2;
      for (var i = 0; i < node2.edges.length; i++) {
        var edge = node2.edges[i];
        if (this.clusteredEdges[edge.id] === void 0) {
          var childNodeId = this._getConnectedId(edge, parentNodeId);
          if (this.clusteredNodes[childNodeId] === void 0) {
            if (childNodeId !== parentNodeId) {
              if (options.joinCondition === void 0) {
                childEdgesObj[edge.id] = edge;
                childNodesObj[childNodeId] = this.body.nodes[childNodeId];
              } else {
                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);
                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                  childEdgesObj[edge.id] = edge;
                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                }
              }
            } else {
              childEdgesObj[edge.id] = edge;
            }
          }
        }
      }
      var childNodeIDs = _mapInstanceProperty(_context = _Object$keys(childNodesObj)).call(_context, function(childNode2) {
        return childNodesObj[childNode2].id;
      });
      for (var childNodeKey in childNodesObj) {
        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey))
          continue;
        var childNode = childNodesObj[childNodeKey];
        for (var y2 = 0; y2 < childNode.edges.length; y2++) {
          var childEdge = childNode.edges[y2];
          if (_indexOfInstanceProperty(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {
            childEdgesObj[childEdge.id] = childEdge;
          }
        }
      }
      this._cluster(childNodesObj, childEdgesObj, options, refreshData);
    }
    /**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {object} clusterNodeProperties
     * @param {object} clusterEdgeProperties
     * @private
     */
  }, {
    key: "_createClusterEdges",
    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
      var edge, childNodeId, childNode, toId, fromId, otherNodeId;
      var childKeys = _Object$keys(childNodesObj);
      var createEdges = [];
      for (var i = 0; i < childKeys.length; i++) {
        childNodeId = childKeys[i];
        childNode = childNodesObj[childNodeId];
        for (var j2 = 0; j2 < childNode.edges.length; j2++) {
          edge = childNode.edges[j2];
          if (this.clusteredEdges[edge.id] === void 0) {
            if (edge.toId == edge.fromId) {
              childEdgesObj[edge.id] = edge;
            } else {
              if (edge.toId == childNodeId) {
                toId = clusterNodeProperties.id;
                fromId = edge.fromId;
                otherNodeId = fromId;
              } else {
                toId = edge.toId;
                fromId = clusterNodeProperties.id;
                otherNodeId = toId;
              }
            }
            if (childNodesObj[otherNodeId] === void 0) {
              createEdges.push({
                edge,
                fromId,
                toId
              });
            }
          }
        }
      }
      var newEdges = [];
      var getNewEdge = function getNewEdge2(createdEdge2) {
        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
          var newEdge2 = newEdges[_j2];
          var matchToDirection = createdEdge2.fromId === newEdge2.fromId && createdEdge2.toId === newEdge2.toId;
          var matchFromDirection = createdEdge2.fromId === newEdge2.toId && createdEdge2.toId === newEdge2.fromId;
          if (matchToDirection || matchFromDirection) {
            return newEdge2;
          }
        }
        return null;
      };
      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
        var createdEdge = createEdges[_j3];
        var _edge = createdEdge.edge;
        var newEdge = getNewEdge(createdEdge);
        if (newEdge === null) {
          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
          newEdges.push(newEdge);
        } else {
          newEdge.clusteringEdgeReplacingIds.push(_edge.id);
        }
        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;
        this._backupEdgeOptions(_edge);
        _edge.setOptions({
          physics: false
        });
      }
    }
    /**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     *
     * @param {object} options
     * @returns {*}
     * @private
     */
  }, {
    key: "_checkOptions",
    value: function _checkOptions() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (options.clusterEdgeProperties === void 0) {
        options.clusterEdgeProperties = {};
      }
      if (options.clusterNodeProperties === void 0) {
        options.clusterNodeProperties = {};
      }
      return options;
    }
    /**
     *
     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */
  }, {
    key: "_cluster",
    value: function _cluster(childNodesObj, childEdgesObj, options) {
      var refreshData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var tmpNodesToRemove = [];
      for (var nodeId in childNodesObj) {
        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {
          if (this.clusteredNodes[nodeId] !== void 0) {
            tmpNodesToRemove.push(nodeId);
          }
        }
      }
      for (var n = 0; n < tmpNodesToRemove.length; ++n) {
        delete childNodesObj[tmpNodesToRemove[n]];
      }
      if (_Object$keys(childNodesObj).length == 0) {
        return;
      }
      if (_Object$keys(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
        return;
      }
      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties);
      if (options.processProperties !== void 0) {
        var childNodesOptions = [];
        for (var _nodeId in childNodesObj) {
          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {
            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);
            childNodesOptions.push(clonedOptions);
          }
        }
        var childEdgesOptions = [];
        for (var edgeId in childEdgesObj) {
          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {
            if (edgeId.substr(0, 12) !== "clusterEdge:") {
              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");
              childEdgesOptions.push(_clonedOptions);
            }
          }
        }
        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
        if (!clusterNodeProperties) {
          throw new Error("The processProperties function does not return properties!");
        }
      }
      if (clusterNodeProperties.id === void 0) {
        clusterNodeProperties.id = "cluster:" + v4();
      }
      var clusterId = clusterNodeProperties.id;
      if (clusterNodeProperties.label === void 0) {
        clusterNodeProperties.label = "cluster";
      }
      var pos = void 0;
      if (clusterNodeProperties.x === void 0) {
        pos = this._getClusterPosition(childNodesObj);
        clusterNodeProperties.x = pos.x;
      }
      if (clusterNodeProperties.y === void 0) {
        if (pos === void 0) {
          pos = this._getClusterPosition(childNodesObj);
        }
        clusterNodeProperties.y = pos.y;
      }
      clusterNodeProperties.id = clusterId;
      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
      clusterNode.containedNodes = childNodesObj;
      clusterNode.containedEdges = childEdgesObj;
      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;
      this.body.nodes[clusterNodeProperties.id] = clusterNode;
      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);
      clusterNodeProperties.id = void 0;
      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */
  }, {
    key: "_backupEdgeOptions",
    value: function _backupEdgeOptions(edge) {
      if (this.clusteredEdges[edge.id] === void 0) {
        this.clusteredEdges[edge.id] = {
          physics: edge.options.physics
        };
      }
    }
    /**
     *
     * @param {Edge} edge
     * @private
     */
  }, {
    key: "_restoreEdge",
    value: function _restoreEdge(edge) {
      var originalOptions = this.clusteredEdges[edge.id];
      if (originalOptions !== void 0) {
        edge.setOptions({
          physics: originalOptions.physics
        });
        delete this.clusteredEdges[edge.id];
      }
    }
    /**
     * Check if a node is a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */
  }, {
    key: "isCluster",
    value: function isCluster(nodeId) {
      if (this.body.nodes[nodeId] !== void 0) {
        return this.body.nodes[nodeId].isCluster === true;
      } else {
        console.error("Node does not exist.");
        return false;
      }
    }
    /**
     * get the position of the cluster node based on what's inside
     *
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */
  }, {
    key: "_getClusterPosition",
    value: function _getClusterPosition(childNodesObj) {
      var childKeys = _Object$keys(childNodesObj);
      var minX = childNodesObj[childKeys[0]].x;
      var maxX = childNodesObj[childKeys[0]].x;
      var minY = childNodesObj[childKeys[0]].y;
      var maxY = childNodesObj[childKeys[0]].y;
      var node2;
      for (var i = 1; i < childKeys.length; i++) {
        node2 = childNodesObj[childKeys[i]];
        minX = node2.x < minX ? node2.x : minX;
        maxX = node2.x > maxX ? node2.x : maxX;
        minY = node2.y < minY ? node2.y : minY;
        maxY = node2.y > maxY ? node2.y : maxY;
      }
      return {
        x: 0.5 * (minX + maxX),
        y: 0.5 * (minY + maxY)
      };
    }
    /**
     * Open a cluster by calling this function.
     *
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */
  }, {
    key: "openCluster",
    value: function openCluster(clusterNodeId, options) {
      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (clusterNodeId === void 0) {
        throw new Error("No clusterNodeId supplied to openCluster.");
      }
      var clusterNode = this.body.nodes[clusterNodeId];
      if (clusterNode === void 0) {
        throw new Error("The clusterNodeId supplied to openCluster does not exist.");
      }
      if (clusterNode.isCluster !== true || clusterNode.containedNodes === void 0 || clusterNode.containedEdges === void 0) {
        throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
      }
      var stack = this.findNode(clusterNodeId);
      var parentIndex = _indexOfInstanceProperty(stack).call(stack, clusterNodeId) - 1;
      if (parentIndex >= 0) {
        var parentClusterNodeId = stack[parentIndex];
        var parentClusterNode = this.body.nodes[parentClusterNodeId];
        parentClusterNode._openChildCluster(clusterNodeId);
        delete this.body.nodes[clusterNodeId];
        if (refreshData === true) {
          this.body.emitter.emit("_dataChanged");
        }
        return;
      }
      var containedNodes = clusterNode.containedNodes;
      var containedEdges = clusterNode.containedEdges;
      if (options !== void 0 && options.releaseFunction !== void 0 && typeof options.releaseFunction === "function") {
        var positions = {};
        var clusterPosition = {
          x: clusterNode.x,
          y: clusterNode.y
        };
        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            var containedNode = this.body.nodes[nodeId];
            positions[nodeId] = {
              x: containedNode.x,
              y: containedNode.y
            };
          }
        }
        var newPositions = options.releaseFunction(clusterPosition, positions);
        for (var _nodeId2 in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {
            var _containedNode = this.body.nodes[_nodeId2];
            if (newPositions[_nodeId2] !== void 0) {
              _containedNode.x = newPositions[_nodeId2].x === void 0 ? clusterNode.x : newPositions[_nodeId2].x;
              _containedNode.y = newPositions[_nodeId2].y === void 0 ? clusterNode.y : newPositions[_nodeId2].y;
            }
          }
        }
      } else {
        forEach$4(containedNodes, function(containedNode2) {
          if (containedNode2.options.fixed.x === false) {
            containedNode2.x = clusterNode.x;
          }
          if (containedNode2.options.fixed.y === false) {
            containedNode2.y = clusterNode.y;
          }
        });
      }
      for (var _nodeId3 in containedNodes) {
        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {
          var _containedNode2 = this.body.nodes[_nodeId3];
          _containedNode2.vx = clusterNode.vx;
          _containedNode2.vy = clusterNode.vy;
          _containedNode2.setOptions({
            physics: true
          });
          delete this.clusteredNodes[_nodeId3];
        }
      }
      var edgesToBeDeleted = [];
      for (var i = 0; i < clusterNode.edges.length; i++) {
        edgesToBeDeleted.push(clusterNode.edges[i]);
      }
      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {
        var edge = edgesToBeDeleted[_i3];
        var otherNodeId = this._getConnectedId(edge, clusterNodeId);
        var otherNode = this.clusteredNodes[otherNodeId];
        for (var j2 = 0; j2 < edge.clusteringEdgeReplacingIds.length; j2++) {
          var transferId = edge.clusteringEdgeReplacingIds[j2];
          var transferEdge = this.body.edges[transferId];
          if (transferEdge === void 0)
            continue;
          if (otherNode !== void 0) {
            var otherCluster = this.body.nodes[otherNode.clusterId];
            otherCluster.containedEdges[transferEdge.id] = transferEdge;
            delete containedEdges[transferEdge.id];
            var fromId = transferEdge.fromId;
            var toId = transferEdge.toId;
            if (transferEdge.toId == otherNodeId) {
              toId = otherNode.clusterId;
            } else {
              fromId = otherNode.clusterId;
            }
            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {
              hidden: false,
              physics: true
            });
          } else {
            this._restoreEdge(transferEdge);
          }
        }
        edge.remove();
      }
      for (var edgeId in containedEdges) {
        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {
          this._restoreEdge(containedEdges[edgeId]);
        }
      }
      delete this.body.nodes[clusterNodeId];
      if (refreshData === true) {
        this.body.emitter.emit("_dataChanged");
      }
    }
    /**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */
  }, {
    key: "getNodesInCluster",
    value: function getNodesInCluster(clusterId) {
      var nodesArray = [];
      if (this.isCluster(clusterId) === true) {
        var containedNodes = this.body.nodes[clusterId].containedNodes;
        for (var nodeId in containedNodes) {
          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {
            nodesArray.push(this.body.nodes[nodeId].id);
          }
        }
      }
      return nodesArray;
    }
    /**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */
  }, {
    key: "findNode",
    value: function findNode(nodeId) {
      var stack = [];
      var max2 = 100;
      var counter2 = 0;
      var node2;
      while (this.clusteredNodes[nodeId] !== void 0 && counter2 < max2) {
        node2 = this.body.nodes[nodeId];
        if (node2 === void 0)
          return [];
        stack.push(node2.id);
        nodeId = this.clusteredNodes[nodeId].clusterId;
        counter2++;
      }
      node2 = this.body.nodes[nodeId];
      if (node2 === void 0)
        return [];
      stack.push(node2.id);
      _reverseInstanceProperty(stack).call(stack);
      return stack;
    }
    /**
     * Using a clustered nodeId, update with the new options
     *
     * @param {Node.id} clusteredNodeId
     * @param {object} newOptions
     */
  }, {
    key: "updateClusteredNode",
    value: function updateClusteredNode(clusteredNodeId, newOptions) {
      if (clusteredNodeId === void 0) {
        throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
      }
      if (newOptions === void 0) {
        throw new Error("No newOptions supplied to updateClusteredNode.");
      }
      if (this.body.nodes[clusteredNodeId] === void 0) {
        throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
      }
      this.body.nodes[clusteredNodeId].setOptions(newOptions);
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Using a base edgeId, update all related clustered edges with the new options
     *
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */
  }, {
    key: "updateEdge",
    value: function updateEdge(startEdgeId, newOptions) {
      if (startEdgeId === void 0) {
        throw new Error("No startEdgeId supplied to updateEdge.");
      }
      if (newOptions === void 0) {
        throw new Error("No newOptions supplied to updateEdge.");
      }
      if (this.body.edges[startEdgeId] === void 0) {
        throw new Error("The startEdgeId supplied to updateEdge does not exist.");
      }
      var allEdgeIds = this.getClusteredEdges(startEdgeId);
      for (var i = 0; i < allEdgeIds.length; i++) {
        var edge = this.body.edges[allEdgeIds[i]];
        edge.setOptions(newOptions);
      }
      this.body.emitter.emit("_dataChanged");
    }
    /**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     *
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */
  }, {
    key: "getClusteredEdges",
    value: function getClusteredEdges(edgeId) {
      var stack = [];
      var max2 = 100;
      var counter2 = 0;
      while (edgeId !== void 0 && this.body.edges[edgeId] !== void 0 && counter2 < max2) {
        stack.push(this.body.edges[edgeId].id);
        edgeId = this.body.edges[edgeId].edgeReplacedById;
        counter2++;
      }
      _reverseInstanceProperty(stack).call(stack);
      return stack;
    }
    /**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */
  }, {
    key: "getBaseEdge",
    value: function getBaseEdge(clusteredEdgeId) {
      return this.getBaseEdges(clusteredEdgeId)[0];
    }
    /**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */
  }, {
    key: "getBaseEdges",
    value: function getBaseEdges(clusteredEdgeId) {
      var IdsToHandle = [clusteredEdgeId];
      var doneIds = [];
      var foundIds = [];
      var max2 = 100;
      var counter2 = 0;
      while (IdsToHandle.length > 0 && counter2 < max2) {
        var nextId = IdsToHandle.pop();
        if (nextId === void 0)
          continue;
        var nextEdge = this.body.edges[nextId];
        if (nextEdge === void 0)
          continue;
        counter2++;
        var replacingIds = nextEdge.clusteringEdgeReplacingIds;
        if (replacingIds === void 0) {
          foundIds.push(nextId);
        } else {
          for (var i = 0; i < replacingIds.length; ++i) {
            var replacingId = replacingIds[i];
            if (_indexOfInstanceProperty(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || _indexOfInstanceProperty(doneIds).call(doneIds, replacingIds) !== -1) {
              continue;
            }
            IdsToHandle.push(replacingId);
          }
        }
        doneIds.push(nextId);
      }
      return foundIds;
    }
    /**
     * Get the Id the node is connected to
     *
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */
  }, {
    key: "_getConnectedId",
    value: function _getConnectedId(edge, nodeId) {
      if (edge.toId != nodeId) {
        return edge.toId;
      } else if (edge.fromId != nodeId) {
        return edge.fromId;
      } else {
        return edge.fromId;
      }
    }
    /**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */
  }, {
    key: "_getHubSize",
    value: function _getHubSize() {
      var average = 0;
      var averageSquared = 0;
      var hubCounter = 0;
      var largestHub = 0;
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node2 = this.body.nodes[this.body.nodeIndices[i]];
        if (node2.edges.length > largestHub) {
          largestHub = node2.edges.length;
        }
        average += node2.edges.length;
        averageSquared += Math.pow(node2.edges.length, 2);
        hubCounter += 1;
      }
      average = average / hubCounter;
      averageSquared = averageSquared / hubCounter;
      var variance = averageSquared - Math.pow(average, 2);
      var standardDeviation = Math.sqrt(variance);
      var hubThreshold = Math.floor(average + 2 * standardDeviation);
      if (hubThreshold > largestHub) {
        hubThreshold = largestHub;
      }
      return hubThreshold;
    }
    /**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {object} clusterEdgeProperties
     * @param {object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */
  }, {
    key: "_createClusteredEdge",
    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge");
      deepExtend(clonedOptions, clusterEdgeProperties);
      clonedOptions.from = fromId;
      clonedOptions.to = toId;
      clonedOptions.id = "clusterEdge:" + v4();
      if (extraOptions !== void 0) {
        deepExtend(clonedOptions, extraOptions);
      }
      var newEdge = this.body.functions.createEdge(clonedOptions);
      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
      newEdge.connect();
      this.body.edges[newEdge.id] = newEdge;
      return newEdge;
    }
    /**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster
     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {object} [clusterEdgeProperties]
     * @private
     */
  }, {
    key: "_clusterEdges",
    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
      if (childEdges instanceof Edge) {
        var edge = childEdges;
        var obj = {};
        obj[edge.id] = edge;
        childEdges = obj;
      }
      if (childNodes instanceof Node$1) {
        var node2 = childNodes;
        var _obj = {};
        _obj[node2.id] = node2;
        childNodes = _obj;
      }
      if (clusterNode === void 0 || clusterNode === null) {
        throw new Error("_clusterEdges: parameter clusterNode required");
      }
      if (clusterEdgeProperties === void 0) {
        clusterEdgeProperties = clusterNode.clusterEdgeProperties;
      }
      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);
      for (var edgeId in childEdges) {
        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {
          if (this.body.edges[edgeId] !== void 0) {
            var _edge2 = this.body.edges[edgeId];
            this._backupEdgeOptions(_edge2);
            _edge2.setOptions({
              physics: false
            });
          }
        }
      }
      for (var nodeId in childNodes) {
        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {
          this.clusteredNodes[nodeId] = {
            clusterId: clusterNode.id,
            node: this.body.nodes[nodeId]
          };
          this.body.nodes[nodeId].setOptions({
            physics: false
          });
        }
      }
    }
    /**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */
  }, {
    key: "_getClusterNodeForNode",
    value: function _getClusterNodeForNode(nodeId) {
      if (nodeId === void 0)
        return void 0;
      var clusteredNode = this.clusteredNodes[nodeId];
      if (clusteredNode === void 0)
        return void 0;
      var clusterId = clusteredNode.clusterId;
      if (clusterId === void 0)
        return void 0;
      return this.body.nodes[clusterId];
    }
    /**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {Function} callback
     * @returns {Array}
     * @private
     */
  }, {
    key: "_filter",
    value: function _filter(arr, callback) {
      var ret = [];
      forEach$4(arr, function(item) {
        if (callback(item)) {
          ret.push(item);
        }
      });
      return ret;
    }
    /**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */
  }, {
    key: "_updateState",
    value: function _updateState() {
      var _this4 = this;
      var nodeId;
      var deletedNodeIds = [];
      var deletedEdgeIds = {};
      var eachClusterNode = function eachClusterNode2(callback) {
        forEach$4(_this4.body.nodes, function(node3) {
          if (node3.isCluster === true) {
            callback(node3);
          }
        });
      };
      for (nodeId in this.clusteredNodes) {
        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId))
          continue;
        var node2 = this.body.nodes[nodeId];
        if (node2 === void 0) {
          deletedNodeIds.push(nodeId);
        }
      }
      eachClusterNode(function(clusterNode) {
        for (var n2 = 0; n2 < deletedNodeIds.length; n2++) {
          delete clusterNode.containedNodes[deletedNodeIds[n2]];
        }
      });
      for (var n = 0; n < deletedNodeIds.length; n++) {
        delete this.clusteredNodes[deletedNodeIds[n]];
      }
      forEach$4(this.clusteredEdges, function(edgeId) {
        var edge = _this4.body.edges[edgeId];
        if (edge === void 0 || !edge.endPointsValid()) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      });
      eachClusterNode(function(clusterNode) {
        forEach$4(clusterNode.containedEdges, function(edge, edgeId) {
          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {
            deletedEdgeIds[edgeId] = edgeId;
          }
        });
      });
      forEach$4(this.body.edges, function(edge, edgeId) {
        var isValid = true;
        var replacedIds = edge.clusteringEdgeReplacingIds;
        if (replacedIds !== void 0) {
          var numValid = 0;
          forEach$4(replacedIds, function(containedEdgeId) {
            var containedEdge = _this4.body.edges[containedEdgeId];
            if (containedEdge !== void 0 && containedEdge.endPointsValid()) {
              numValid += 1;
            }
          });
          isValid = numValid > 0;
        }
        if (!edge.endPointsValid() || !isValid) {
          deletedEdgeIds[edgeId] = edgeId;
        }
      });
      eachClusterNode(function(clusterNode) {
        forEach$4(deletedEdgeIds, function(deletedEdgeId) {
          delete clusterNode.containedEdges[deletedEdgeId];
          forEach$4(clusterNode.edges, function(edge, m) {
            if (edge.id === deletedEdgeId) {
              clusterNode.edges[m] = null;
              return;
            }
            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function(id2) {
              return !deletedEdgeIds[id2];
            });
          });
          clusterNode.edges = _this4._filter(clusterNode.edges, function(item) {
            return item !== null;
          });
        });
      });
      forEach$4(deletedEdgeIds, function(edgeId) {
        delete _this4.clusteredEdges[edgeId];
      });
      forEach$4(deletedEdgeIds, function(edgeId) {
        delete _this4.body.edges[edgeId];
      });
      var ids = _Object$keys(this.body.edges);
      forEach$4(ids, function(edgeId) {
        var edge = _this4.body.edges[edgeId];
        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);
        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
          return;
        }
        if (shouldBeClustered) {
          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);
          if (clusterFrom !== void 0) {
            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
          }
          var clusterTo = _this4._getClusterNodeForNode(edge.toId);
          if (clusterTo !== void 0) {
            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
          }
        } else {
          delete _this4._clusterEdges[edgeId];
          _this4._restoreEdge(edge);
        }
      });
      var changed = false;
      var continueLoop = true;
      var _loop2 = function _loop22() {
        var clustersToOpen = [];
        eachClusterNode(function(clusterNode) {
          var numNodes = _Object$keys(clusterNode.containedNodes).length;
          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;
          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
            clustersToOpen.push(clusterNode.id);
          }
        });
        for (var _n = 0; _n < clustersToOpen.length; ++_n) {
          _this4.openCluster(
            clustersToOpen[_n],
            {},
            false
            /* Don't refresh, we're in an refresh/update already */
          );
        }
        continueLoop = clustersToOpen.length > 0;
        changed = changed || continueLoop;
      };
      while (continueLoop) {
        _loop2();
      }
      if (changed) {
        this._updateState();
      }
    }
    /**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {boolean} true if part of a cluster.
     */
  }, {
    key: "_isClusteredNode",
    value: function _isClusteredNode(nodeId) {
      return this.clusteredNodes[nodeId] !== void 0;
    }
    /**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @returns {boolean} true if part of a cluster.
     */
  }, {
    key: "_isClusteredEdge",
    value: function _isClusteredEdge(edgeId) {
      return this.clusteredEdges[edgeId] !== void 0;
    }
  }]);
  return ClusterEngine2;
}();
function _initRequestAnimationFrame() {
  var func;
  if (window !== void 0) {
    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  }
  if (func === void 0) {
    window.requestAnimationFrame = function(callback) {
      callback();
    };
  } else {
    window.requestAnimationFrame = func;
  }
}
var CanvasRenderer = /* @__PURE__ */ function() {
  function CanvasRenderer2(body, canvas) {
    _classCallCheck(this, CanvasRenderer2);
    _initRequestAnimationFrame();
    this.body = body;
    this.canvas = canvas;
    this.redrawRequested = false;
    this.renderTimer = void 0;
    this.requiresTimeout = true;
    this.renderingActive = false;
    this.renderRequests = 0;
    this.allowRedraw = true;
    this.dragging = false;
    this.zooming = false;
    this.options = {};
    this.defaultOptions = {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: false,
      hideNodesOnDrag: false
    };
    _Object$assign(this.options, this.defaultOptions);
    this._determineBrowserMethod();
    this.bindEventListeners();
  }
  _createClass(CanvasRenderer2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this, _context2;
      this.body.emitter.on("dragStart", function() {
        _this.dragging = true;
      });
      this.body.emitter.on("dragEnd", function() {
        _this.dragging = false;
      });
      this.body.emitter.on("zoom", function() {
        _this.zooming = true;
        window.clearTimeout(_this.zoomTimeoutId);
        _this.zoomTimeoutId = _setTimeout(function() {
          var _context;
          _this.zooming = false;
          _bindInstanceProperty$1(_context = _this._requestRedraw).call(_context, _this)();
        }, 250);
      });
      this.body.emitter.on("_resizeNodes", function() {
        _this._resizeNodes();
      });
      this.body.emitter.on("_redraw", function() {
        if (_this.renderingActive === false) {
          _this._redraw();
        }
      });
      this.body.emitter.on("_blockRedraw", function() {
        _this.allowRedraw = false;
      });
      this.body.emitter.on("_allowRedraw", function() {
        _this.allowRedraw = true;
        _this.redrawRequested = false;
      });
      this.body.emitter.on("_requestRedraw", _bindInstanceProperty$1(_context2 = this._requestRedraw).call(_context2, this));
      this.body.emitter.on("_startRendering", function() {
        _this.renderRequests += 1;
        _this.renderingActive = true;
        _this._startRendering();
      });
      this.body.emitter.on("_stopRendering", function() {
        _this.renderRequests -= 1;
        _this.renderingActive = _this.renderRequests > 0;
        _this.renderTimer = void 0;
      });
      this.body.emitter.on("destroy", function() {
        _this.renderRequests = 0;
        _this.allowRedraw = false;
        _this.renderingActive = false;
        if (_this.requiresTimeout === true) {
          clearTimeout(_this.renderTimer);
        } else {
          window.cancelAnimationFrame(_this.renderTimer);
        }
        _this.body.emitter.off();
      });
    }
    /**
     *
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {Function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {Function | undefined}
     * @private
     */
  }, {
    key: "_requestNextFrame",
    value: function _requestNextFrame(callback, delay) {
      if (typeof window === "undefined")
        return;
      var timer2;
      var myWindow = window;
      if (this.requiresTimeout === true) {
        timer2 = _setTimeout(callback, delay);
      } else {
        if (myWindow.requestAnimationFrame) {
          timer2 = myWindow.requestAnimationFrame(callback);
        }
      }
      return timer2;
    }
    /**
     *
     * @private
     */
  }, {
    key: "_startRendering",
    value: function _startRendering() {
      if (this.renderingActive === true) {
        if (this.renderTimer === void 0) {
          var _context3;
          this.renderTimer = this._requestNextFrame(_bindInstanceProperty$1(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);
        }
      }
    }
    /**
     *
     * @private
     */
  }, {
    key: "_renderStep",
    value: function _renderStep() {
      if (this.renderingActive === true) {
        this.renderTimer = void 0;
        if (this.requiresTimeout === true) {
          this._startRendering();
        }
        this._redraw();
        if (this.requiresTimeout === false) {
          this._startRendering();
        }
      }
    }
    /**
     * Redraw the network with the current data
     * chart will be resized too.
     */
  }, {
    key: "redraw",
    value: function redraw() {
      this.body.emitter.emit("setSize");
      this._redraw();
    }
    /**
     * Redraw the network with the current data
     *
     * @private
     */
  }, {
    key: "_requestRedraw",
    value: function _requestRedraw() {
      var _this2 = this;
      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
        this.redrawRequested = true;
        this._requestNextFrame(function() {
          _this2._redraw(false);
        }, 0);
      }
    }
    /**
     * Redraw the network with the current data
     *
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */
  }, {
    key: "_redraw",
    value: function _redraw() {
      var hidden = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (this.allowRedraw === true) {
        this.body.emitter.emit("initRedraw");
        this.redrawRequested = false;
        var drawLater = {
          drawExternalLabels: null
        };
        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
          this.canvas.setSize();
        }
        this.canvas.setTransform();
        var ctx = this.canvas.getContext();
        var w = this.canvas.frame.canvas.clientWidth;
        var h2 = this.canvas.frame.canvas.clientHeight;
        ctx.clearRect(0, 0, w, h2);
        if (this.canvas.frame.clientWidth === 0) {
          return;
        }
        ctx.save();
        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
        ctx.scale(this.body.view.scale, this.body.view.scale);
        ctx.beginPath();
        this.body.emitter.emit("beforeDrawing", ctx);
        ctx.closePath();
        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawEdges(ctx);
          }
        }
        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
          var _this$_drawNodes = this._drawNodes(ctx, hidden), drawExternalLabels = _this$_drawNodes.drawExternalLabels;
          drawLater.drawExternalLabels = drawExternalLabels;
        }
        if (hidden === false) {
          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {
            this._drawArrows(ctx);
          }
        }
        if (drawLater.drawExternalLabels != null) {
          drawLater.drawExternalLabels();
        }
        if (hidden === false) {
          this._drawSelectionBox(ctx);
        }
        ctx.beginPath();
        this.body.emitter.emit("afterDrawing", ctx);
        ctx.closePath();
        ctx.restore();
        if (hidden === true) {
          ctx.clearRect(0, 0, w, h2);
        }
      }
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */
  }, {
    key: "_resizeNodes",
    value: function _resizeNodes() {
      this.canvas.setTransform();
      var ctx = this.canvas.getContext();
      ctx.save();
      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
      ctx.scale(this.body.view.scale, this.body.view.scale);
      var nodes = this.body.nodes;
      var node2;
      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          node2 = nodes[nodeId];
          node2.resize(ctx);
          node2.updateBoundingBox(ctx, node2.selected);
        }
      }
      ctx.restore();
    }
    /**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     * @returns {object} Callbacks to draw later on higher layers.
     */
  }, {
    key: "_drawNodes",
    value: function _drawNodes(ctx) {
      var alwaysShow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nodes = this.body.nodes;
      var nodeIndices = this.body.nodeIndices;
      var node2;
      var selected = [];
      var hovered = [];
      var margin = 20;
      var topLeft = this.canvas.DOMtoCanvas({
        x: -margin,
        y: -margin
      });
      var bottomRight = this.canvas.DOMtoCanvas({
        x: this.canvas.frame.canvas.clientWidth + margin,
        y: this.canvas.frame.canvas.clientHeight + margin
      });
      var viewableArea = {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
      var _drawExternalLabels = [];
      for (var _i = 0; _i < nodeIndices.length; _i++) {
        node2 = nodes[nodeIndices[_i]];
        if (node2.hover) {
          hovered.push(nodeIndices[_i]);
        } else if (node2.isSelected()) {
          selected.push(nodeIndices[_i]);
        } else {
          if (alwaysShow === true) {
            var drawLater = node2.draw(ctx);
            if (drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(drawLater.drawExternalLabel);
            }
          } else if (node2.isBoundingBoxOverlappingWith(viewableArea) === true) {
            var _drawLater = node2.draw(ctx);
            if (_drawLater.drawExternalLabel != null) {
              _drawExternalLabels.push(_drawLater.drawExternalLabel);
            }
          } else {
            node2.updateBoundingBox(ctx, node2.selected);
          }
        }
      }
      var i;
      var selectedLength = selected.length;
      var hoveredLength = hovered.length;
      for (i = 0; i < selectedLength; i++) {
        node2 = nodes[selected[i]];
        var _drawLater2 = node2.draw(ctx);
        if (_drawLater2.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater2.drawExternalLabel);
        }
      }
      for (i = 0; i < hoveredLength; i++) {
        node2 = nodes[hovered[i]];
        var _drawLater3 = node2.draw(ctx);
        if (_drawLater3.drawExternalLabel != null) {
          _drawExternalLabels.push(_drawLater3.drawExternalLabel);
        }
      }
      return {
        drawExternalLabels: function drawExternalLabels() {
          for (var _i2 = 0, _drawExternalLabels2 = _drawExternalLabels; _i2 < _drawExternalLabels2.length; _i2++) {
            var draw = _drawExternalLabels2[_i2];
            draw();
          }
        }
      };
    }
    /**
     * Redraw all edges
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */
  }, {
    key: "_drawEdges",
    value: function _drawEdges(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;
      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];
        if (edge.connected === true) {
          edge.draw(ctx);
        }
      }
    }
    /**
     * Redraw all arrows
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */
  }, {
    key: "_drawArrows",
    value: function _drawArrows(ctx) {
      var edges = this.body.edges;
      var edgeIndices = this.body.edgeIndices;
      for (var i = 0; i < edgeIndices.length; i++) {
        var edge = edges[edgeIndices[i]];
        if (edge.connected === true) {
          edge.drawArrows(ctx);
        }
      }
    }
    /**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     *
     * @private
     */
  }, {
    key: "_determineBrowserMethod",
    value: function _determineBrowserMethod() {
      if (typeof window !== "undefined") {
        var browserType = navigator.userAgent.toLowerCase();
        this.requiresTimeout = false;
        if (_indexOfInstanceProperty(browserType).call(browserType, "msie 9.0") != -1) {
          this.requiresTimeout = true;
        } else if (_indexOfInstanceProperty(browserType).call(browserType, "safari") != -1) {
          if (_indexOfInstanceProperty(browserType).call(browserType, "chrome") <= -1) {
            this.requiresTimeout = true;
          }
        }
      } else {
        this.requiresTimeout = true;
      }
    }
    /**
     * Redraw selection box
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */
  }, {
    key: "_drawSelectionBox",
    value: function _drawSelectionBox(ctx) {
      if (this.body.selectionBox.show) {
        ctx.beginPath();
        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;
        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;
        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.fillStyle = "rgba(151, 194, 252, 0.2)";
        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);
        ctx.strokeStyle = "rgba(151, 194, 252, 1)";
        ctx.stroke();
      } else {
        ctx.closePath();
      }
    }
  }]);
  return CanvasRenderer2;
}();
var path$1 = path$y;
var setInterval$1 = path$1.setInterval;
var setInterval$3 = setInterval$1;
var _setInterval = /* @__PURE__ */ getDefaultExportFromCjs(setInterval$3);
function onTouch(hammer, callback) {
  callback.inputHandler = function(event) {
    if (event.isFirst) {
      callback(event);
    }
  };
  hammer.on("hammer.input", callback.inputHandler);
}
function onRelease(hammer, callback) {
  callback.inputHandler = function(event) {
    if (event.isFinal) {
      callback(event);
    }
  };
  return hammer.on("hammer.input", callback.inputHandler);
}
var Canvas = /* @__PURE__ */ function() {
  function Canvas2(body) {
    _classCallCheck(this, Canvas2);
    this.body = body;
    this.pixelRatio = 1;
    this.cameraState = {};
    this.initialized = false;
    this.canvasViewCenter = {};
    this._cleanupCallbacks = [];
    this.options = {};
    this.defaultOptions = {
      autoResize: true,
      height: "100%",
      width: "100%"
    };
    _Object$assign(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  _createClass(Canvas2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this, _context;
      this.body.emitter.once("resize", function(obj) {
        if (obj.width !== 0) {
          _this.body.view.translation.x = obj.width * 0.5;
        }
        if (obj.height !== 0) {
          _this.body.view.translation.y = obj.height * 0.5;
        }
      });
      this.body.emitter.on("setSize", _bindInstanceProperty$1(_context = this.setSize).call(_context, this));
      this.body.emitter.on("destroy", function() {
        _this.hammerFrame.destroy();
        _this.hammer.destroy();
        _this._cleanUp();
      });
    }
    /**
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var _this2 = this;
      if (options !== void 0) {
        var fields = ["width", "height", "autoResize"];
        selectiveDeepExtend(fields, this.options, options);
      }
      this._cleanUp();
      if (this.options.autoResize === true) {
        var _context2;
        if (window.ResizeObserver) {
          var observer = new ResizeObserver(function() {
            var changed = _this2.setSize();
            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          });
          var frame2 = this.frame;
          observer.observe(frame2);
          this._cleanupCallbacks.push(function() {
            observer.unobserve(frame2);
          });
        } else {
          var resizeTimer = _setInterval(function() {
            var changed = _this2.setSize();
            if (changed === true) {
              _this2.body.emitter.emit("_requestRedraw");
            }
          }, 1e3);
          this._cleanupCallbacks.push(function() {
            clearInterval(resizeTimer);
          });
        }
        var resizeFunction = _bindInstanceProperty$1(_context2 = this._onResize).call(_context2, this);
        window.addEventListener("resize", resizeFunction);
        this._cleanupCallbacks.push(function() {
          window.removeEventListener("resize", resizeFunction);
        });
      }
    }
    /**
     * @private
     */
  }, {
    key: "_cleanUp",
    value: function _cleanUp() {
      var _context3, _context4, _context5;
      _forEachInstanceProperty(_context3 = _reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function(callback) {
        try {
          callback();
        } catch (error2) {
          console.error(error2);
        }
      });
    }
    /**
     * @private
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this.setSize();
      this.body.emitter.emit("_redraw");
    }
    /**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */
  }, {
    key: "_getCameraState",
    value: function _getCameraState() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pixelRatio;
      if (this.initialized === true) {
        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
        this.cameraState.scale = this.body.view.scale;
        this.cameraState.position = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.width / pixelRatio,
          y: 0.5 * this.frame.canvas.height / pixelRatio
        });
      }
    }
    /**
     * Set the cameraState
     *
     * @private
     */
  }, {
    key: "_setCameraState",
    value: function _setCameraState() {
      if (this.cameraState.scale !== void 0 && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {
        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
        var newScale = this.cameraState.scale;
        if (widthRatio != 1 && heightRatio != 1) {
          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
        } else if (widthRatio != 1) {
          newScale = this.cameraState.scale * widthRatio;
        } else if (heightRatio != 1) {
          newScale = this.cameraState.scale * heightRatio;
        }
        this.body.view.scale = newScale;
        var currentViewCenter = this.DOMtoCanvas({
          x: 0.5 * this.frame.canvas.clientWidth,
          y: 0.5 * this.frame.canvas.clientHeight
        });
        var distanceFromCenter = {
          // offset from view, distance view has to change by these x and y to center the node
          x: currentViewCenter.x - this.cameraState.position.x,
          y: currentViewCenter.y - this.cameraState.position.y
        };
        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
      }
    }
    /**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */
  }, {
    key: "_prepareValue",
    value: function _prepareValue(value) {
      if (typeof value === "number") {
        return value + "px";
      } else if (typeof value === "string") {
        if (_indexOfInstanceProperty(value).call(value, "%") !== -1 || _indexOfInstanceProperty(value).call(value, "px") !== -1) {
          return value;
        } else if (_indexOfInstanceProperty(value).call(value, "%") === -1) {
          return value + "px";
        }
      }
      throw new Error("Could not use the value supplied for width or height:" + value);
    }
    /**
     * Create the HTML
     */
  }, {
    key: "_create",
    value: function _create() {
      while (this.body.container.hasChildNodes()) {
        this.body.container.removeChild(this.body.container.firstChild);
      }
      this.frame = document.createElement("div");
      this.frame.className = "vis-network";
      this.frame.style.position = "relative";
      this.frame.style.overflow = "hidden";
      this.frame.tabIndex = 0;
      this.frame.canvas = document.createElement("canvas");
      this.frame.canvas.style.position = "relative";
      this.frame.appendChild(this.frame.canvas);
      if (!this.frame.canvas.getContext) {
        var noCanvas = document.createElement("DIV");
        noCanvas.style.color = "red";
        noCanvas.style.fontWeight = "bold";
        noCanvas.style.padding = "10px";
        noCanvas.innerText = "Error: your browser does not support HTML canvas";
        this.frame.canvas.appendChild(noCanvas);
      } else {
        this._setPixelRatio();
        this.setTransform();
      }
      this.body.container.appendChild(this.frame);
      this.body.view.scale = 1;
      this.body.view.translation = {
        x: 0.5 * this.frame.canvas.clientWidth,
        y: 0.5 * this.frame.canvas.clientHeight
      };
      this._bindHammer();
    }
    /**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     *
     * @private
     */
  }, {
    key: "_bindHammer",
    value: function _bindHammer() {
      var _this3 = this;
      if (this.hammer !== void 0) {
        this.hammer.destroy();
      }
      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.frame.canvas);
      this.hammer.get("pinch").set({
        enable: true
      });
      this.hammer.get("pan").set({
        threshold: 5,
        direction: Hammer.DIRECTION_ALL
      });
      onTouch(this.hammer, function(event) {
        _this3.body.eventListeners.onTouch(event);
      });
      this.hammer.on("tap", function(event) {
        _this3.body.eventListeners.onTap(event);
      });
      this.hammer.on("doubletap", function(event) {
        _this3.body.eventListeners.onDoubleTap(event);
      });
      this.hammer.on("press", function(event) {
        _this3.body.eventListeners.onHold(event);
      });
      this.hammer.on("panstart", function(event) {
        _this3.body.eventListeners.onDragStart(event);
      });
      this.hammer.on("panmove", function(event) {
        _this3.body.eventListeners.onDrag(event);
      });
      this.hammer.on("panend", function(event) {
        _this3.body.eventListeners.onDragEnd(event);
      });
      this.hammer.on("pinch", function(event) {
        _this3.body.eventListeners.onPinch(event);
      });
      this.frame.canvas.addEventListener("wheel", function(event) {
        _this3.body.eventListeners.onMouseWheel(event);
      });
      this.frame.canvas.addEventListener("mousemove", function(event) {
        _this3.body.eventListeners.onMouseMove(event);
      });
      this.frame.canvas.addEventListener("contextmenu", function(event) {
        _this3.body.eventListeners.onContext(event);
      });
      this.hammerFrame = new Hammer(this.frame);
      onRelease(this.hammerFrame, function(event) {
        _this3.body.eventListeners.onRelease(event);
      });
    }
    /**
     * Set a new size for the network
     *
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */
  }, {
    key: "setSize",
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.width;
      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.height;
      width = this._prepareValue(width);
      height = this._prepareValue(height);
      var emitEvent = false;
      var oldWidth = this.frame.canvas.width;
      var oldHeight = this.frame.canvas.height;
      var previousRatio = this.pixelRatio;
      this._setPixelRatio();
      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
        this._getCameraState(previousRatio);
        this.frame.style.width = width;
        this.frame.style.height = height;
        this.frame.canvas.style.width = "100%";
        this.frame.canvas.style.height = "100%";
        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        this.options.width = width;
        this.options.height = height;
        this.canvasViewCenter = {
          x: 0.5 * this.frame.clientWidth,
          y: 0.5 * this.frame.clientHeight
        };
        emitEvent = true;
      } else {
        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
          this._getCameraState(previousRatio);
        }
        if (this.frame.canvas.width !== newWidth) {
          this.frame.canvas.width = newWidth;
          emitEvent = true;
        }
        if (this.frame.canvas.height !== newHeight) {
          this.frame.canvas.height = newHeight;
          emitEvent = true;
        }
      }
      if (emitEvent === true) {
        this.body.emitter.emit("resize", {
          width: Math.round(this.frame.canvas.width / this.pixelRatio),
          height: Math.round(this.frame.canvas.height / this.pixelRatio),
          oldWidth: Math.round(oldWidth / this.pixelRatio),
          oldHeight: Math.round(oldHeight / this.pixelRatio)
        });
        this._setCameraState();
      }
      this.initialized = true;
      return emitEvent;
    }
    /**
     *
     * @returns {CanvasRenderingContext2D}
     */
  }, {
    key: "getContext",
    value: function getContext() {
      return this.frame.canvas.getContext("2d");
    }
    /**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */
  }, {
    key: "_determinePixelRatio",
    value: function _determinePixelRatio() {
      var ctx = this.getContext();
      if (ctx === void 0) {
        throw new Error("Could not get canvax context");
      }
      var numerator = 1;
      if (typeof window !== "undefined") {
        numerator = window.devicePixelRatio || 1;
      }
      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
      return numerator / denominator;
    }
    /**
     * Lazy determination of pixel ratio.
     *
     * @private
     */
  }, {
    key: "_setPixelRatio",
    value: function _setPixelRatio() {
      this.pixelRatio = this._determinePixelRatio();
    }
    /**
     * Set the transform in the contained context, based on its pixelRatio
     */
  }, {
    key: "setTransform",
    value: function setTransform() {
      var ctx = this.getContext();
      if (ctx === void 0) {
        throw new Error("Could not get canvax context");
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    }
    /**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */
  }, {
    key: "_XconvertDOMtoCanvas",
    value: function _XconvertDOMtoCanvas(x2) {
      return (x2 - this.body.view.translation.x) / this.body.view.scale;
    }
    /**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */
  }, {
    key: "_XconvertCanvasToDOM",
    value: function _XconvertCanvasToDOM(x2) {
      return x2 * this.body.view.scale + this.body.view.translation.x;
    }
    /**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */
  }, {
    key: "_YconvertDOMtoCanvas",
    value: function _YconvertDOMtoCanvas(y2) {
      return (y2 - this.body.view.translation.y) / this.body.view.scale;
    }
    /**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */
  }, {
    key: "_YconvertCanvasToDOM",
    value: function _YconvertCanvasToDOM(y2) {
      return y2 * this.body.view.scale + this.body.view.translation.y;
    }
    /**
     * @param {point} pos
     * @returns {point}
     */
  }, {
    key: "canvasToDOM",
    value: function canvasToDOM(pos) {
      return {
        x: this._XconvertCanvasToDOM(pos.x),
        y: this._YconvertCanvasToDOM(pos.y)
      };
    }
    /**
     *
     * @param {point} pos
     * @returns {point}
     */
  }, {
    key: "DOMtoCanvas",
    value: function DOMtoCanvas(pos) {
      return {
        x: this._XconvertDOMtoCanvas(pos.x),
        y: this._YconvertDOMtoCanvas(pos.y)
      };
    }
  }]);
  return Canvas2;
}();
function normalizeFitOptions(rawOptions, allNodeIds) {
  var options = _Object$assign({
    nodes: allNodeIds,
    minZoomLevel: Number.MIN_VALUE,
    maxZoomLevel: 1
  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});
  if (!_Array$isArray(options.nodes)) {
    throw new TypeError("Nodes has to be an array of ids.");
  }
  if (options.nodes.length === 0) {
    options.nodes = allNodeIds;
  }
  if (!(typeof options.minZoomLevel === "number" && options.minZoomLevel > 0)) {
    throw new TypeError("Min zoom level has to be a number higher than zero.");
  }
  if (!(typeof options.maxZoomLevel === "number" && options.minZoomLevel <= options.maxZoomLevel)) {
    throw new TypeError("Max zoom level has to be a number higher than min zoom level.");
  }
  return options;
}
var View = /* @__PURE__ */ function() {
  function View2(body, canvas) {
    var _context, _this = this, _context2;
    _classCallCheck(this, View2);
    this.body = body;
    this.canvas = canvas;
    this.animationSpeed = 1 / this.renderRefreshRate;
    this.animationEasingFunction = "easeInOutQuint";
    this.easingTime = 0;
    this.sourceScale = 0;
    this.targetScale = 0;
    this.sourceTranslation = 0;
    this.targetTranslation = 0;
    this.lockedOnNodeId = void 0;
    this.lockedOnNodeOffset = void 0;
    this.touchTime = 0;
    this.viewFunction = void 0;
    this.body.emitter.on("fit", _bindInstanceProperty$1(_context = this.fit).call(_context, this));
    this.body.emitter.on("animationFinished", function() {
      _this.body.emitter.emit("_stopRendering");
    });
    this.body.emitter.on("unlockNode", _bindInstanceProperty$1(_context2 = this.releaseNode).call(_context2, this));
  }
  _createClass(View2, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.options = options;
    }
    /**
     * This function zooms out to fit all data on screen based on amount of nodes
     *
     * @param {object} [options={{nodes=Array}}]
     * @param options
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */
  }, {
    key: "fit",
    value: function fit(options) {
      var initialZoom = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      options = normalizeFitOptions(options, this.body.nodeIndices);
      var canvasWidth = this.canvas.frame.canvas.clientWidth;
      var canvasHeight = this.canvas.frame.canvas.clientHeight;
      var range;
      var zoomLevel;
      if (canvasWidth === 0 || canvasHeight === 0) {
        zoomLevel = 1;
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
      } else if (initialZoom === true) {
        var positionDefined = 0;
        for (var nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            var node2 = this.body.nodes[nodeId];
            if (node2.predefinedPosition === true) {
              positionDefined += 1;
            }
          }
        }
        if (positionDefined > 0.5 * this.body.nodeIndices.length) {
          this.fit(options, false);
          return;
        }
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var numberOfNodes = this.body.nodeIndices.length;
        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822;
        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);
        zoomLevel *= factor;
      } else {
        this.body.emitter.emit("_resizeNodes");
        range = NetworkUtil.getRange(this.body.nodes, options.nodes);
        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
        var xZoomLevel = canvasWidth / xDistance;
        var yZoomLevel = canvasHeight / yDistance;
        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
      }
      if (zoomLevel > options.maxZoomLevel) {
        zoomLevel = options.maxZoomLevel;
      } else if (zoomLevel < options.minZoomLevel) {
        zoomLevel = options.minZoomLevel;
      }
      var center = NetworkUtil.findCenter(range);
      var animationOptions = {
        position: center,
        scale: zoomLevel,
        animation: options.animation
      };
      this.moveTo(animationOptions);
    }
    // animation
    /**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */
  }, {
    key: "focus",
    value: function focus(nodeId) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.body.nodes[nodeId] !== void 0) {
        var nodePosition = {
          x: this.body.nodes[nodeId].x,
          y: this.body.nodes[nodeId].y
        };
        options.position = nodePosition;
        options.lockedOnNode = nodeId;
        this.moveTo(options);
      } else {
        console.error("Node: " + nodeId + " cannot be found.");
      }
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */
  }, {
    key: "moveTo",
    value: function moveTo(options) {
      if (options === void 0) {
        options = {};
        return;
      }
      if (options.offset != null) {
        if (options.offset.x != null) {
          options.offset.x = +options.offset.x;
          if (!_Number$isFinite(options.offset.x)) {
            throw new TypeError('The option "offset.x" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }
        if (options.offset.y != null) {
          options.offset.y = +options.offset.y;
          if (!_Number$isFinite(options.offset.y)) {
            throw new TypeError('The option "offset.y" has to be a finite number.');
          }
        } else {
          options.offset.x = 0;
        }
      } else {
        options.offset = {
          x: 0,
          y: 0
        };
      }
      if (options.position != null) {
        if (options.position.x != null) {
          options.position.x = +options.position.x;
          if (!_Number$isFinite(options.position.x)) {
            throw new TypeError('The option "position.x" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }
        if (options.position.y != null) {
          options.position.y = +options.position.y;
          if (!_Number$isFinite(options.position.y)) {
            throw new TypeError('The option "position.y" has to be a finite number.');
          }
        } else {
          options.position.x = 0;
        }
      } else {
        options.position = this.getViewPosition();
      }
      if (options.scale != null) {
        options.scale = +options.scale;
        if (!(options.scale > 0)) {
          throw new TypeError('The option "scale" has to be a number greater than zero.');
        }
      } else {
        options.scale = this.body.view.scale;
      }
      if (options.animation === void 0) {
        options.animation = {
          duration: 0
        };
      }
      if (options.animation === false) {
        options.animation = {
          duration: 0
        };
      }
      if (options.animation === true) {
        options.animation = {};
      }
      if (options.animation.duration === void 0) {
        options.animation.duration = 1e3;
      }
      if (options.animation.easingFunction === void 0) {
        options.animation.easingFunction = "easeInOutQuad";
      }
      this.animateView(options);
    }
    /**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */
  }, {
    key: "animateView",
    value: function animateView(options) {
      if (options === void 0) {
        return;
      }
      this.animationEasingFunction = options.animation.easingFunction;
      this.releaseNode();
      if (options.locked === true) {
        this.lockedOnNodeId = options.lockedOnNode;
        this.lockedOnNodeOffset = options.offset;
      }
      if (this.easingTime != 0) {
        this._transitionRedraw(true);
      }
      this.sourceScale = this.body.view.scale;
      this.sourceTranslation = this.body.view.translation;
      this.targetScale = options.scale;
      this.body.view.scale = this.targetScale;
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - options.position.x,
        y: viewCenter.y - options.position.y
      };
      this.targetTranslation = {
        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
      };
      if (options.animation.duration === 0) {
        if (this.lockedOnNodeId != void 0) {
          var _context3;
          this.viewFunction = _bindInstanceProperty$1(_context3 = this._lockedRedraw).call(_context3, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        } else {
          this.body.view.scale = this.targetScale;
          this.body.view.translation = this.targetTranslation;
          this.body.emitter.emit("_requestRedraw");
        }
      } else {
        var _context4;
        this.animationSpeed = 1 / (60 * options.animation.duration * 1e-3) || 1 / 60;
        this.animationEasingFunction = options.animation.easingFunction;
        this.viewFunction = _bindInstanceProperty$1(_context4 = this._transitionRedraw).call(_context4, this);
        this.body.emitter.on("initRedraw", this.viewFunction);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     * used to animate smoothly by hijacking the redraw function.
     *
     * @private
     */
  }, {
    key: "_lockedRedraw",
    value: function _lockedRedraw() {
      var nodePosition = {
        x: this.body.nodes[this.lockedOnNodeId].x,
        y: this.body.nodes[this.lockedOnNodeId].y
      };
      var viewCenter = this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
      var distanceFromCenter = {
        // offset from view, distance view has to change by these x and y to center the node
        x: viewCenter.x - nodePosition.x,
        y: viewCenter.y - nodePosition.y
      };
      var sourceTranslation = this.body.view.translation;
      var targetTranslation = {
        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
      };
      this.body.view.translation = targetTranslation;
    }
    /**
     * Resets state of a locked on Node
     */
  }, {
    key: "releaseNode",
    value: function releaseNode() {
      if (this.lockedOnNodeId !== void 0 && this.viewFunction !== void 0) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.lockedOnNodeId = void 0;
        this.lockedOnNodeOffset = void 0;
      }
    }
    /**
     * @param {boolean} [finished=false]
     * @private
     */
  }, {
    key: "_transitionRedraw",
    value: function _transitionRedraw() {
      var finished = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      this.easingTime += this.animationSpeed;
      this.easingTime = finished === true ? 1 : this.easingTime;
      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);
      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
      this.body.view.translation = {
        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
      };
      if (this.easingTime >= 1) {
        this.body.emitter.off("initRedraw", this.viewFunction);
        this.easingTime = 0;
        if (this.lockedOnNodeId != void 0) {
          var _context5;
          this.viewFunction = _bindInstanceProperty$1(_context5 = this._lockedRedraw).call(_context5, this);
          this.body.emitter.on("initRedraw", this.viewFunction);
        }
        this.body.emitter.emit("animationFinished");
      }
    }
    /**
     *
     * @returns {number}
     */
  }, {
    key: "getScale",
    value: function getScale2() {
      return this.body.view.scale;
    }
    /**
     *
     * @returns {{x: number, y: number}}
     */
  }, {
    key: "getViewPosition",
    value: function getViewPosition() {
      return this.canvas.DOMtoCanvas({
        x: 0.5 * this.canvas.frame.canvas.clientWidth,
        y: 0.5 * this.canvas.frame.canvas.clientHeight
      });
    }
  }]);
  return View2;
}();
var css_248z$1 = "div.vis-network div.vis-navigation div.vis-button {\n  width: 34px;\n  height: 34px;\n  -moz-border-radius: 17px;\n  border-radius: 17px;\n  position: absolute;\n  display: inline-block;\n  background-position: 2px 2px;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n  box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABphJREFUeNqcV2twU9cR/nbPlVTHxpKRbNnBLyEbPyJisLEcPwgwUMKQtjNJAzNJZkgNNJOmJaZAaDKlxaXDTIBAcJtOOzSYKSkdiimhAdIMjyT4bYgBYxA2BgcUQPLrCiGDR4qt2x+yXTASFt1/957d7zt3z3d39xDCMQWUfgAz/RI/T4pSTAJpAGL8rECAXX7QFQGq9wOHOxYO1oCgjAdJj1wtB095Giv9TFuZAIWHAziATMPhTAwiHgUkYPXFJu92lMP/2MTpB1AKUCVEgNAcleUo1M+2F8TO6crSTncb1QleAOj2OTSX3Ge1p+Va42m5JrnzbnsCE8Ov+EHgpa0LPLvCJjZ/whuIlN8wAcXG+e1LUn9hm238QU84p1Ld83nsXvuO7Lq+LzKYGAT6/dn58m/HJTYf4O3EShkT8Irpzab1Uz9sGevT5+tWn+j6NB4A5hp/5NSr43xjfd5rW5tT9e3OAhCBiCua5/WsDEls/hdvYklZSwDefmrT8eXmtzuDkb5YZ33p9ndylICAVjWxf39xw/5g5Luv/9H84ZWNcwNEypZT87rXjqyJB85UYDMJYN3U7UdLJ6/6JlgqV517teRqf9uTlug8e1zEk27HgD22o98WsTBh8fWxvjm6ApdONbGvse8LM5NUPOm1Cfabuz3nACAgxX0QEFTJAnjNvLJ+Sepb14KRHnN+Ev+1XJOhZs3Qu1mbG97J2NQgsXroa1dtxrGuf8cHi1mUtPTay0lv1DMJSCRVLtoX+FgGgDQNysBAcez89l9nbbsQSji7rlXkEhjPxb/QatHOcFu0M9zz419oFSRhj/3PuaHiyqasv1Con9NGxHAYUsoCxAqImbYSgCWmFbZQwdsur7N0eC4m6tT6/jUZ750Zeb82c+OZGLWh/2p/W+Kfrmy0hIp/aVKpTSIJEqu2QgFx2iE8CwDp0RbH7Ljng/4yXr+XT3QdyhYsodS0slGr0g2OrEUK7eCrKW82SqzCVz3/yfb6vRwM4xn9rN7JkRkOQRLmfJn2LBPxQjDBqp9lD7XbX7X8pKTP160zR2bdeiX5jYeU/nLSTztNkem3XL5eXbltRUkonBxdgZ2IIUmahUxERQSCVT+rK5hzQ89xQ6P8VaaK1f5VmRvqQ4G+lba+nlnlb5brMhvlk7FBiaPzuwQEmEQhg5BOxMjWTncHc2501cQLkjDTsMCWpyuRQxFP0xXIJfp5FyVW4Zy7KajC06ItbiIGg6ZITBxDxIgbrr1jTSM0fibGIHz8O9sKK0GAibEua9spANh4aY2VmcEg+DEkiBgR/L2hYFgGtcErkQQAMVJgBxyy9hboZzv32v+Kpr7qbEECTAIMAoaJa3qPTmNiiAAgJAjk6J5xhu6HDAIgQYGLmI29PocmMcI8MNYvT1ckfzD9H/ub5br4e4Me9WfOKqtyX6Ud2cwC449PRamifDm6Auc0rTXokci+Xo1EAgBckiDuYGLjpTvntcGIA+SFcp6uUAaAI879VhWrRteYAqn/edq758brXJ1327QMhgJcZjA3EBjNrgZjOG1PkAjyTGENMjZPq5ECQ0MDE9ERBqFZrk0OJ3i4x/7vyIjBxGERt3takgVJEAp9xq3f769WiPDNvSsJdT3HDOEASPelmoBRYT3Kzt5uMtwauJEgSOCpwrk1DIJCoNUMwj9v7MweP9XSQ8/hJPp496fZTAICvLqcyv2B7nRbrgCA03JN5h8ub7A8VqpB437xHvsOy3l3cyaB4L2uqxhti1WLMcSgZQCw7+bOooO3Pk4JBZIYYXISMV5sKH59UePM10GESRGpIf/bE92HU452HywSJIGIllctrhp6YAK5+fHds0lLtJFMXNwkV6fFqA29mROefqiMJj1h6um4a5vY/92dKGaBxIhU5zJTWW2cJmEgGOmeb3c8FxAfb9mdf2RzyGGv5MvU7QwuEySwKHFp/c/M71zA/2F7b1RajnYdLAqMukMVu2YcfmDYE2MD7H+7/Xlq6cRIJqm4zXM+qd3TGjVBir43KSLlXjiELe5TsX+3/yW/ST45PaAHbKmccWh12AP93JNZywj0kSABIobpiXRHjtZ6faout2tyZMadGLXBCxBcvl6NfaAz+tKdFmObpzWl2+tIIBACYy0t/yj34M7HvsKUK+CGassvicX7alYDwwq+vykIEqPVa+Q9gdYk5+V+UE7lj3+FGbuBM/X5JUT8QwIVSSSZiTgmoFR2MfiqYFFPfjpkyrfWPopwxP47AP1pK1g9/dqeAAAAAElFTkSuQmCC');\n  bottom: 50px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABpdJREFUeNqcV21QlNcVfp5zX9ikoAvLEsAIIgsoHwpqWAQUNKLNaNv8iZ1JMkNG6/Qj/dDUyCSTtCHpmEkwVk3TToZRMjXj5MOG2KidjIkxQYSAQUAtX6IgIN8su8KCoOzbH4sk4q5g77/33uee555z7rnneYmZDB2MKcJKlyYbqOsZVIgGEOgSHQoy4AKbFFjqAo5dWn/rNAh9OpO852oeJHYxtrmEu4WALhMbxG2ZE9uFAlImDRLY/t/y0b3Ig+u+iWOKsAlgIZSb0OIf15kWtKo1NXh1d5xxiSPEN2wUAHrGOg11jirjWVtJyFnb6YgrzoYwocClu0DI5guPDb43Y2LLp/Iaqf9JCGSErGvIifxd7aqQn/TOJCvFvZ8Hf9haEH+m/6sFQgHBv1Sts/15WmJLkeyl6FuFwFPzny1/ZdE7Nfg/xhv1uUmH2w6kggQp+yqze7d5JbZ8Im+KpucSwI6EN7/cYtlxZarBCts3ptfrtq9odjaGKihE+sV0vRC3u8RqWmmbij149W+Wd5p2rnET6bsqsntyb6+pO3KqkE8FvLxo74lNUX9s9uTJb8/9fG2L81KoogJFYfCm3b9usNq0MXxzw1RsUkDqQICPqf/b/q8sQi3j4WdmtV47OFgNAO6r+DEUFAtFAc9YtpXmRP6hxVsI24cvhyoqnFtrK6jM7isgBa3Dl0O94TeGb255MvzXpUIFjVrhxo/dzgoARBuwFQJkBK9reCnurxfvXX8CRW3yW1G749vT2Br7ysW0oNX1pKDTPG+rm1gHRbibAHLm/7522sKnQCZqFgCUaBCqaS/bEw9vqtWoQROf3dBBiT6KTACImZ3YueqhDdOWjDbFQ4IzIl4elNUX5begU1HD6lPRmULKeghhDcpqnUmZuD3+nkgTH6gZEE9ctlZSoGmG9UIynSCsQVndMyX+IZGiBoHMjHh2SreCglClaSBiSEG8cYnD24bv7CWms/3FocO3hnw13plTggAFb196NdlPM44tC0zrSg5ItXmyEz070UEKCMRqQgkkBQ9NvL2eSJ+revoJTORSpoT6do4/7/7UShBFHQexM+HdfyUHWO8iN/uaRzX3/QjUSLlnqM72F4cCRIY5u9Zf+Y+BAv4AvzpkQ7WAIBRujA/7Vg6cia9xlId6InafVEAAGnQMUCSkb6zTMPdBy8hU3JjrphIq+CrD+Mvxeyumrr+4IH9y7o2GF5eDghuuGx4L2zbWZ9Dc0RoQRbkkFNRdP2/0BH7EtLJLKCjr+zqh2l5u8haZ847vTBW24kRFQXKAtcsT5oqz3igQENIoECkjBJUDZSGewBlBj/ammjLrdX1c/t70ero34gMte9IByLLAjPrUwKweT5jawQshdIuGMiF5XEBU2koivBl9NeEfJeYHwuxtI81zPrn2z6ip60c6DkV1jLTOCTaE2HNjd5Z4s9MwWBOhqEHp/I9cWDtUrJNoHm4KO9P7hdnTBoMYXI8Gb6gVCg63FS53jg9O5tA57tSOdHywnCAygrJrfcTgUe5U2cvNHSPtYYoKCWlrTgsIneB2AfFR+4F4b6f9ZdTzF6P8Ytud407/dy/nL7k9X9i8J9l5y+Ef6RfbnjPvWa8N5suez+KFCgqyPY95Lnd3stv2AcBZ2+mFbze+lui1xc3dXCUUlPafXNx4/aKxcajWWNp/MklRw8/mPFntbd+h1oLE847KhQQxejVg36QQqD0MPTzHv42Ux+uGasJNBnPfwllJd71kkX7RQ3WDNf7dox3BLcNNs6vt34bbbvYHJhlTGp6O+JVHb0/2HJtX1PH+aqECqG/5YN1nlXcokGvvO6vCc4x+QskotxVHB/qa+xbOWuzw8NB3nuo+Ht0z2hHsuGU3GrWAoZfi3jrxgHpw3BPpobaCH7vbqOw6mHI836vYW3Eqcq9AtioqbJy7ufQ3lhfu8sR+s9+3vL8klACsQSu7AnxMY1MxH7YXJp7oPpLulrrj+9575Ni2aeVt1teWfEWfHQLCaspseHzOU7VWU+aM5G2NoyL4i+6j8XWDNQsmGsKu/cv+nTtjQb/mm7hfENyvqEAK5v8opjPJaL26KGBpd5TfguuBvuZRgBgY6zO0jlyZXXe9JqR+8MK8ntHOMHfHIkhu2b/0yIH7/oXJ0yFlxYnPUdRbvuILgO7+y+91l6Ka6M+cnCf4fMSypXvymHf/vzBTD3CuNGUFKT8lmK5Rs5ASqKiBlAGBXFaiSuni0fkp1pJ7Ed4e/xsAqLk46EWsG1EAAAAASUVORK5CYII=');\n  bottom: 10px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABt5JREFUeNqsl2lUlOcVx//3Pi9DZRsGBgYiS2RYBQKIjAhEJW4pNrXNMbZpWtTGNkttYmJMG5soSZckRk+0p+dYPYY0Gk0ihlhRj63GhVUgBhDD5oIOy8AAMwzD4lCYtx+GqCQKuNyP7/Pc+3u2+7/3JUzEZFBYLh62S7yIZDmVBEIBqOwsQ4DNdtBFASq2A4cuZAwVgCCPF5LGHM0Chz+E1XamzUyAzCMO7IhMI+5MDCK+HpCANd+U2rYgC/Y7BoflYgVA2RAOoNYtyjDTe45+hk96e5QywaJR+NsAwDhocK61VCjLTYWaclNB0OW+en8mhl22g8C/rn7U+uGEwdov+C0i+Q0mIFWzoD7zwVU1czQ/6pjIreR3HPX5VL9jalHXiQgmBoH+XLHAtH5csDaXtxDLLzIBv5jyfOmG2H9U4S7snbpX43KaPpgBIhDx1rPzOlbfPC5GQT/nd1mS1zABa6PfPf5y5F/rcJeWpp7fPkly6f7KXBRCoOSATFfXll19x74HDsvFCghsJAG8HrvlvytCXm7EPVqc5wyzp5NX15muE1omKXXyMnd9yy5r5Q3wPghvJzrLAlimXV38+7D1DbhPFq1M6O4b6rPVWKsCBfHi5EWWv9TkQBYAEPpLvERMC9N8FtRvjt9dPl6wwo5jPvuas7WV5jNqEjz8wA+CBsaan+w9x1hrrXJtuaZX97ooLfqPLCUEGRR+iOwAsF2X98Uc30W3fb02u41frVqeVmo6FUkkwCAwCWxJ2Ls/0TPFNBb8TNdp9WvnVz4OAKdmX2QOzcMsAAjziDGMBd3asCF6SXHyknJTfqQTK+zpvhnVKT5zawCgzFTgN94pJXvP7gxxjTAIkpB+MnSWRMQZYEDnPVt/K4ejbZ/77726Lb6h95tAAiPELaJ1bcTbRfGeM8xv1azWSeyEa0P9igk+Nr1+oNFfkpwzJCJKIQA679ntN08yDXYo3qh+LuUrc0E4EcNL4dP7VNDzpU8FP3vpekoQQ5CEw4bPdEfa9+sAgEZUmkmAAAS5hLQ9p11XGO+pM8V5JLUfMeQARDMlEMKIGFOVCZYb0C7Fz0oeXmIZ6nZzYoV9od/jVS+GbahUOnn9b7T6sEOviUGyA8bMDlUa0W79wBW/bZf+lrY98cDBUI8YCxGDgHCJiVVEDN8R7QWAE8Z/+1mGut2i3eP1r0S+XRztkdBzq6NbF7WpbF3UprKxjvfHxbrfttla/QBArVDbJJIAQCURMRg8ugrKIAKBSNxzHtN3VdmxY0iQYSZmTeegwTlgknYAAB7RZBh2Nm7urbeeC1r19ROT52kWn3shfH2Fu1AO3RxjY/0fdac7/hPPJMDE11GC+HpBJmIEuAS3Oa6w01lybMbMgvgCE6O255zy24DeCr/Bvckn9+u8ZjXYIYvjxoMJy8oeXZrT9GHIqMWTwA2oI6cFMeDIcAiSEOyibXsmZG0hAFzuq1OyY6xBAnMJgdPOmks08zU/bbsB9x18P37PqS/b8+o/a96ZcLm3PmBH46Z5x40HW1eFvl4Uq0w0MwiCBOb7/qTsd6GvVY537DXWas1Iw1AiNJnOgwJi+bXhAbE08OnvaXSIW0TvYw88eaF/uM/WNdju3m5r9TlhPBzVNNDoPGC/5tRma/GJ80xqjPPUjVuvP2narrMOWd1Jlv/E1fN782UiNPZf9C/qOKa+ndOz2j+cz046sn+6KrVOsODirpOxld0lUxmEBK/ktvGgFd2l6taBZn9BAtEz5xYIvAn4/8rFKkgstAyZ6Yf+S67ezlkiSU73XXRV6xqh93TyssR4JF75efBvymLdE03jgT/Wb5tutLWpGbTm7wHZxQQAT+yDuKLyHRIk4cnAZ4pfCF9/HvfR9uh3xBxtz00BANsVDylnac6wAICaHMiBmW5NRLy4trcq0MtZ3RnpHme5H9AvjYeCc1t3pzMJgOSVnyw4eHZUB9Kyu68iMFPpysSppab8UJVC3Rnp/pDlXqF7mnYsdKQbv7cr6fDGW/Zczbt6jgUtV6kIlFxuyg/tH+6zJXmlGe8G+mlzdsyB1j3pTAwZ9q3/Sspbc9tmDwD0H3UffXCFlyuTlFpnPRdYb612c5c8+idPCu6fCLDKUubzsf6fSaWm0wmO9hbvZU8fDR2zoZ97OuppAu0UJEDEmOISZohT6q7Gek5rD3GN6FEp1DaAYB7sdNYPXPao7anS1Fmrg402g7+jYhGIaOXOaQc+uONfmCwZXJIf8xKx2KRgxYgOS+CROuyoyQKCxIhkOr4T6JWgxGnvZ1HWnf/CfHcBXxcnpRHxYwRKkUjSErFKkAQiNjP4kmBRTHbKm5KkKxwL+K39fwDX1XGF8ct++QAAAABJRU5ErkJggg==');\n  bottom: 10px;\n  left: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABs1JREFUeNqsl3tQlOcVxp9z3m+XygK7C4sLxkW5o4CAkYssFSkRjabjJEOSJm1IbZx2krapiZdeprW0NVVJ0pqMM0kYJQlqkoZImGioE1ItiCAgIsFwE4Es99vCslwChf36xy5EW1A0Pn9+73fO772e93kJC5EMCszFd20SbyFZNpJAAACtjWUI8KAN1CRAJTbg9LXNU+dBkG+Xkm7Zmg4OWoUdNqZXmQCZHQFsz0yOcCYGEc8mJGDnl2UTh5AO2x2DA3OxDaAsCDvQ32VF11qP9aZYz6SeFeooi17pPQEAvZNdTnWWKnWFuVhfYT7v0zza4M3EsMk2EPgnNZusby8Y7P8x/5lI/gMTYNSnNKQt/0Xtev1DfQtZlaK+M54fmDJXXhg4G8zEINBfqlLMe28L9s/lQ8Tyr5iAJ32fK/tj+OFq3IUO1O+JyGk7GgsiEPFrlQ/07bixXdwEPckHWZJ3MgG7Qw9+/mLIS/W4SyXoNvQskpyHLg1e8CNQ3NI0laoje7Tg/8CBudgGgQwSwO/DD322ze/FFnxLRWhiBzUK94GLA2f9mSTjfU+7mjqyrVe+AX8I4aGgShbA0/47Sn4ZuLcR90ih6qih0anRiVprtUEQb43bYtlXmwNZAEDAj/ACMW1M8ExpeDXyWMVCEl4yF7vntR/zLeov8JJlWfZR+Y3N92+cx/reOmu1quNrk27EWW0xvWspJcigoNNkA4C3Yk59vH7xltvu3ktDxe7PX34ilQCQfeci1j2xfn94ZrGCneY8uxcHCnW/vbr9EQD4d2ITc8AprAOAQLewroVAAaB8oMiLiRHvmVy7znNTjWCFrXKoJOSHFQ+kvnF9f+jco07s91MFdwmSkHQuYB0T8WYwIcYj0bTQdRufGlFKJMFVaCb/GvZW6aGI4yeXOwd2mr/u05zsyDY+W5X64Nm+fO85NpuJiCFJTpslIoonADEeiT2zIzIXuh+o25PQNtbsNVMOBUn2g08MiSTHN3uZjNTEDr4dnX/6H+1H/XPasmKvW+sMGfW/MXzende4K3h/ibvSYxIAItyie/K7cgCitQxCIBFjpTrKMgM+WPfrhLbxFi9iMQtlYjAJSCSBSYBAIPBNI3p86TPXj8bk56R4PVylFE626uFLQc9efiTVPDmgBIAAtzALEYNBQRITa4kYix21FwBax655CVagPLk7806Pj1qo/7MraF/FQ14/aMhszYhvGqn3KTef89rklWrSKXUTkn3mtJK9Bzf3XJA0e/PcrdgxIwSCDPmbZMQgABJkDBKzvn+yy2npIv9xAPB1Ceo2jTZ7Gc8afipIgEhAkACDwcSQQZBIIGnx5it7gg+U3wgcnbZKR1r+FnW+v2DVtDwtXCXNSKz797oAwDzZ7ySRAIBBFsTXmBh1w1+oZ4J3h+wv9lUFdbMDOrO+5IAqWIGZthuV13nC77nKRx8r7PssyibLIkoT1/h65HsfzWyu5tF6NYNB4EYJzKUETqgcLNVv0D/cDQBrNAnm9+LOfTLfNB5u2hf5z+6TMexYji+tVdrM5leMbWOtSwQx/F1C2rcuebIqwSO568a4WmuN3mEYSiUi+pRl2l1pLvYBsKArUKVwnZRYgdHpMWVG4+/WXhwoDBXE7OmkHzJ6JNemLfv51bniGqzVPoIkyLbpfK7ZMFIkE6FlrMn7Ql+BbiHg+zXGbgLjylDpyosD58KZmKM0cfWHI9//aD5o1VCZrnO83VuQQOja5PMCfwK8n3K2ChIbLVOD9KB36le3A+u/s2Q81C2yRavQmQNdVnamLnmq4nHD9jpB0rwm77jpjTW9E906Bu18fWlWCQHAox9CtGoXTwmS8IThZyXPB+29inuoE6bMsDM9ufEAMNHqJuU8ljMtAKA2B7IhzaWNiLfWjVQb3J10/SGuEZZ7Af1X7+lluZ3HkpgEQPL291M+qbzJgXQcG60ypKlVTGwsMxcFaJW6/hDXVZZvCz3RlrmRiQHwy9nRn2bM6bnas4cLfH6s1RIorsJcFDA2PToR7Z7QezfQD9qzwvI6TyTZC47ttXeiT+2c1+wBgOndoTPLt7mrmCRjvfULQ4O1xsVVchu7b9GysYUAqy3lnsdNb0aXmQuj7PYWL2etuRl6S0OfXLjiGQIdEY6K5esc2BWhjvkqXLO6x08VPKxV6iYAwuBkv5NpvNmtbrhaX2+tWdY70eVNINhtLW0/sjrv6B0/YdJlcGlR2AvE4hUlKwHQ7BU5cz8LRx0HaPY7gXb53L/67+mUfudPmP/twOWS6AQi/j6B4iWS/IlYK+yGYJDB1wWLErLRKd/omOJbAWf03wEAyO9m+/TtS3AAAAAASUVORK5CYII=');\n  bottom: 10px;\n  left: 95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABiBJREFUeNqkV2tQlOcVfp7zvgvDRe66y8htXUBR1GoFI+BtFJvRtjPJBGeaH2a8DGmbttgSTWbSJEw6TWOsrbbpTIeJZGqaTipTa6LJZDTVUTYQdNAohoso6qLucnERN0Axcb/8+HaJUHDX9Pz6vnnPe57vXJ5zzkeEIwaYcwBL/VrW0TCKqZANINEvBhSk3w9eUmC9HzjcsfarOhBGKJN84GkVJHcetvqFu4SAIYELYlpm4LpQQMqoQQKVnzeO7EYV/A8NnHMAGwHWQJmAjtg895LkFa7FU1d258UvGLBGpI4AQM9dd2TrwNn4016n9bS3LqNzsD1VKPAbfhCyqflR31thAzv+La+QxotCoNi6pn1D1s9aVli/3xtOVk72fjT1XVf17E9uHZspFBD8zdk13pdCAjsOyG6KUSEEnrT/tPHluW+cw7eQ19q2z6/t2rsYJEjZ07S6d+ukwI5/yQ7RxnYC2DZnx8dbHNs6xxs85T2R9GprZcmVwYs2BYWsmBzP83m7nIVJS73jdfdd+7PjjUu/XWUCGTtPre7ZHjxTY3Kq8DoV8Ou5u49snPGrKxN58syZ9aVXBztsigoUBd+Xt2NbfZ8llaVvah+vOz9hcX+CJenWp7eOOYS6ePpTU1w39vk+AwCzFPdDQbFGFPCUY2v9hqxfXJ0shNeHLtsUFc6UequbVvdVkwLX0GXbZPpl6Zuu/ij9x/VCBU1dU7bfdFYAIDsSFRCgeOqa9hfy/nDhwfwTKOrRd0U95n0iqch9+cKS5JVtpMCdkllhAhugCHcRwAb7z1tCEp8CCXAWAJRoCFXIYnti+sYWTQ0tll0wQMk+hGUAkBOX714xbV1IyuhxHhIMC/iR5OV9M2JmuhU1Vh7PXiakrIUQhcnLXeHQxPT4GyAtFqgwgAPF5iIFWkeu1SSLCKAweXn3/ZR5rXV7SddQpy3YDoNems9qTI5hGCitm1MOAAx0aaFCerTd84zjBed3Egq9ADA/rqD7Q3ctQC4REDmkYHb8goGgsR2tz5V0DV+xUdQoqAQ81RybU4IgFWgACgpaLLCIBUo0bv63y/aXy6+WBHWz4/IHSIGAuVooiaRgWqD3AsDVoQ6bEgtOrfJUhwrf0WUtk+r8sL6wvHvk5ijVUiJSRrQZuURtfoGMuaCoRyfP/yMy0XykgAA0DPRTxNp31x2ZFuUYBgB7bK7HNdhpKz6WXq6oQCooKghMKhkgji77vBoA1jkXlAvVfRQjFMUcmxSkRWd6gpjeu32R2kxTvyhKh1DQeud8fFBh26zfOe0xuR4JgAbzywCoRSzfeDUKatJKUQK+CjKiHZ6nZ2xzBnU7B9vixTy7qCHSQEhJU3+DtdT6mAcAFiWUeP/xyPH3Jwrfo3XzysemRcEA8F5RY8h6aPE1WwMLQ4OQ/EBANHmdGWHlzZyxk3ayB0m771yGooYy+KE0l35x0iBxZehS6ie9R1PCMaDvCzWDXA4hZ283ptwcvp6qqDBnyao6AWEQrBQQ/7y+d3YoA+NBTAaElo973p8tVFCQyipW+c3pdNu7BwBOe+tm/eniK/kPFWowpMfvuKrzzw80zSKIkWsJe0bHYu163BNwMwDsv7G36ODNtzMnM5IWZfeQgscbisvLPl1aDhLTo7I8k+n/p+dw5pGeg0WKGiS31K6vvTdmA7nx9uDZ9A3xMUIpbvSezE6MSOmbNWXewHhD6dH23o7BlqQvvrwTK6KQFpXl2WyvcE6LTB2eCPSdrurvmcUnO/cVfPD6pMteyfGs3QKpUFQoS9tU/xPH8xe+Tdd693pN/pHug0Xmqntvz1uLDo9Z9v5nnrn+dvujrI1JMUJd3OY7n97ua46douOGpkdlDoUDeG7g1NS/u/5a0Og9scCsB+ysWXSoMuyFftWJvM0E31SBjmWPznHPjy+8NjdhYfeMmJl3EiNSRgCi/25fpGu4M671zjlrm685s2fEnUoQ5lrLLW8uPLj3oX9hqgxIw8n8X1LU7yMkItCHzREZrGQV6ONmy5TggHk247sL/1jFqof/hRn/AWfqC0pI+QHBIk3tICXRrFTpF8hlJaqefh6yFxQ6HwQYlK8HAKyt3WsWxl7fAAAAAElFTkSuQmCC');\n  bottom: 10px;\n  right: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABV5JREFUeNq0l2tQVVUYht/3W/vACMr16IFRQDiAgChpgiikMqY1WjnN9KsfGOXYTOVgkvbDUsZuXrK0qZmGUSvNspjI8TZOmo6AGBoZYly8YB6Qw80DBwQ6jJ3dj30OZZmiwvtv77XW96y91l7v9y1iMNLBuCI84tZkIXU9gwqxAILdokNBOtzgJQWWuYEDFxfcLAGh3y0k79iaD4mfjOVu4WYhoItngBiR6RkuFJAyEJBA3m/lri3Ih/uewXFFyAG4A8oAWkcm2meEzrFNH53Vkhg4xWnxCXcBQGu/3bfGeTbwjKPUcsZRElnfUxcuFLh1Nwh5vurx7s8GDbZ+L+tI/U0hkGGZX5c9/pXqOZYn2gazK8Vth0fvsRUknbx+bIJQQPCts/Mda+4KthbJFoqeKwSejX6pfO2kjytxH1pfuyqlsGH7dJAgZWvFo23L/9muboF+JxtE0/OEwMqJG46uSHinFvepTPO8lhGaX+fPHSdjCKaPy/b3v7az58h/wHFFyIHCRirgjUlbfsiJWXEFD6iUoOkdQaaQ6z9dP2YVahljF4+yXdvZ/evf4G+hQk2sEAUsti4vWxa35gKGSBMDp3T23OxxVXdXRijKovSFzrerC6ELAMT6IhcCZIyeX7c68YPzGGLlxq89PyM0q5YU2M1RuQAg0EERbiaA7Ohl1RgmPTM2p1qjBk1Mm6GDErsfswAgLiDZPmfMwrbhAqeHzm6P8Z9gV9SQdTx2lpCyAEKkhc62YZiVEjTdRgo0zXeBRnImAaSFzm7xdjjtOBGyvmZVZkNvfZjXDhU14+BToFEDKRAQpAJ0HRTjP6XHpYUKEX7RzS9bV5c+FJTmAICUgNSWQ/ZCgJwhIOJIQVLgFKcXvKHm9cyGvithFDUAFQqECho1CBUIggYapAJ1QEFBExNMYoISDU1/NIR9cvndTG/c2IBkp2fC8ZpQgknBGI/3AsDvvRfDlJhwem5zwYMs7VNlaUtbXE1h3mezj9mlGSsXrBkzkFsGKGoDmedBJLfLjxQQgAYdHRSxtPfbfceNsPYBQPTI+GZbT31YxrGIpYoKpIKigkAgFOggNBrbQBBCBaEM2L+iGGmTgnF+Uc1epqO/3VejAoAOUZSLQkFN17lAb4eVCe+VRvvHN4sH6t1feqAmMUGoPHvvhdLzTjzfKoj0sza/GLOy1Bu3vqc20Pgl5YIGkVOEZFZ0nLLMszzdDADTgjIdX6Uf3zfUx6m6u8riKRhOCcmDAqLCURo53Oe4rrsyUlGD0nlIqubdKNZJXOm9FH6y7Yh5uKBnO8vNTX2N4YoKE2fMLREQOsE8AfFN4/ak4QIfbd2XJFRQkLx85ruN7NTp2AoAZxwlCR9dWJc81NDdtoLkc86KBIJwXQ3aOpCPqwuhR2SPbCBlUc2NyogQX3N7wqgU51BAf2w9EFXUtCtLqADqS76ev6/ilgrk2q6esxHZgf5CySh3FMcG+5jbE0ZNdj4odHdDwWPGcZNNO1MPbrxtzdW4s+tI5HPBwQTTzziKY3v/7HGlhmS23g90T+OO5L1Nu7MMw3Fv/Tx1f97/FnsAYPui8/D4nBB/oZZR230uoq67auQoLaB37Iio3sEAK52nR39p+zS13HFiilHeYtOOabdC71jQzz2R+ALBbcrjWNF+cfaUwLSrk4KmtsT4T+gK9jG7AKKjv93X1lcfUNNVaantropqddnDCcIoa7lk29S92+/5CpOvQ04VJ79KUe/7iI/Hh40U6c3PyuPjhmWKN8G8Fvnw1A/zmX/vV5h/T+CXstRMUp4kOFOjZiUlWBkFQYdALitRZXRzf3RqWumdgF79NQDBOa2V/iYSHAAAAABJRU5ErkJggg==');\n  bottom: 10px;\n  right: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABptJREFUeNqsl21QlNcVx///cx9hIipuAJHasgHlRdw0xay7yK7smg6sb2DSdtqZduLUNENmOk1tQuM4U7UzTvshSRlFZzoNCWSSSTJp+6VNkLCAeQHBoCCgqNBE0wUqL+KuwIiiZZ9+eHa3aAS3Sf8zO8/L3nt+95x7z7n3YWlpKUQEJAEgch9+Jola9xEC2ADBVgAOKqwCYAqKDgUJBIHPBWwFWQNdbyZFBwAC0GGIAHQSj3/8HHRdhzYbdDfwg4IjAsGvICgXAroYBiCEDkBBACBZoyST4gDwQqh7mQ4cEkhQD0EBIIggRMQAh2EiEvEYAGrdR3YSqIYCIEDaotVDeYnu/ryEjSOr43PHl8WmTBPA6PRQ7IWJrvhT/ubkU/7m1EvX+1KEUh7Ug+WkPEXgdUSkR+xrd0NJ4qjr8AEI9pGAI7mo78mHfnF+Y/K2K7iHUheuvJG6cOUNz/LvDwPobrpSl/Ruf2VOy9UPs4RSTSANwH4Y449EVdnt9ojHIeghCHYLgR+n/7zt4Np32tIWZU4hSpnjVk1t/caPfOO3/f++MNH5TVJcisoEoo4ksgbsXwYfdR1+kQplQuCFNS82Pp/9+158RTkTC0ce0OKutQeOp5PME0qcUBqyBmwGOC8vz4AWVOyE4CUqYO/Dh+p3pj//Bb6mHllqCyxd8ODVT69+uFKoOYTSnzFg7SJpzHFNQYWiQrUIsCN9V+uOh375zz179pSGI1FSUuK12+2+aGDt7e3muro6T/h57969lZdvDrT+ZbA6n0B1nfPVN7e0PjMjIgIIdkEAR1JR329yDvaE0+l/hQKA1Wr1bd682SsikUW7K+O3PesTNvaSAiXaLhGBvO86RFEoJ4Adac+eDxsgiZKSEm9NTY3n5MmT5mjBHR0d5vr6es+mTZu8SqnI+x+s+Ol5jRo0auX1jtepQaEAADKWWIbcy7ZGUmb79u1eu93uI+mtra31HLj5TGDs9rBJICCNn1GRCKGCUJAUuzzw6CfbTB6Px7t27VofAG/YXl6Ceyw9LmvIN3UxZUafKRACWyCELcHVP3vk4fDabDZf+2N/D9g+fsLEEFSooFGDogZNFkBRgSCsTcWm066jgRAU4et/F5u9nxRosmCLRmE+QdgSXCNzhW/s9rDJ63wVJx77V+V8YS6UNaW8BdOcqzx+3Ujt0F8Bcr1GMIMU5CzJHZ+rg6IGCYV2PimoyIK6lzIWrxkPTVGmRoqJFCyLTZmeq4MB5f3BVADnbpcQkzStUQMAk0YKBPfzxlhA95NQQe43QBotBECAFFyZHo6dz6CKCizAPFPivzUWqxm2AqIgnwkFvZNn4uczGK3Hah7wpet98UZ85R8aKScIcXYEWpMLkx8fvleHpNjlAWtTsakQa0pVKGcJQqMGUqCHBvfdjp/gTP6xwFzg85PdyaH2J4SUowKiw3889e4KBACnT582W5uKTV2uusAdUFlgzBcFQoFGDT35HwW+82mhqaenxwwA4WtYfRNnUkMZUqsJpEkn8cXU5yktYw2JjsTCMQDwer0ekt6GhgZPUVGRd3fu7qjqdU9Mj7mlpcVD0tvS0uKxWCyVANB5rS3x8s3BFEUFgTTLtuZndQHLBMSfB6pyZtfqMDQ3NzfqTcJisficTqc3BI+8bxh9L8corarM3fnDoIT+rACAU/7m7MOfHbCEwQDQ2Njo6erqinqTOHfuXNjjiI23+ystZ8c7smmkWgVJcN++fRARfLDhlacEUqVEQ1nm77xPrHjSh/+Djo3WmN/s/6OHEOgIPr2h63tVuq5Dud1ukETWoK3zorkzTiiONn/TKlNM4lj24m+Pf13o2wOVHqGA5MsAXjKPrDaqnMvlQnjTzhy0Nlw0d5oI5p3yN62amrk+ve5B5+hXgb47WGX52+V3NgoFOvQKAGUkkTqcbZy5XC7XHYf4zEFr3aXU7jih5uidPPOtvsmzixZr8VMrHjBHddLsHj+Z9Fb/n9a1+T/JDaXey0IpEzEKkHnU8Jj79++PeEwSSimQRGP+Gz8j5DVFBVKQtjBj6JGlNt/D8Y+OpMdlTphiEqcB4tqtsVjfjUtLLkx0J/dOnjWPTg+lEARIEHwaQJVQIYggACC/qxi6rn8ZHL4XETSsf0MU1HOk/CFGYgAwskUqY5eBitRxzn7/a0V1EEBwdqkN6jPI7y4xPmHmC5unbWdQRMqP2d86qANOksU6gvmArNQRNClqABnQgYuK0krI+wCOAyH3DK/vqOXhaf3PAO7mIRjDNV25AAAAAElFTkSuQmCC');\n  bottom: 50px;\n  right: 15px;\n}\n";
styleInject(css_248z$1);
function keycharm(options) {
  var preventDefault = options && options.preventDefault || false;
  var container = options && options.container || window;
  var _exportFunctions = {};
  var _bound = { keydown: {}, keyup: {} };
  var _keys = {};
  var i;
  for (i = 97; i <= 122; i++) {
    _keys[String.fromCharCode(i)] = { code: 65 + (i - 97), shift: false };
  }
  for (i = 65; i <= 90; i++) {
    _keys[String.fromCharCode(i)] = { code: i, shift: true };
  }
  for (i = 0; i <= 9; i++) {
    _keys["" + i] = { code: 48 + i, shift: false };
  }
  for (i = 1; i <= 12; i++) {
    _keys["F" + i] = { code: 111 + i, shift: false };
  }
  for (i = 0; i <= 9; i++) {
    _keys["num" + i] = { code: 96 + i, shift: false };
  }
  _keys["num*"] = { code: 106, shift: false };
  _keys["num+"] = { code: 107, shift: false };
  _keys["num-"] = { code: 109, shift: false };
  _keys["num/"] = { code: 111, shift: false };
  _keys["num."] = { code: 110, shift: false };
  _keys["left"] = { code: 37, shift: false };
  _keys["up"] = { code: 38, shift: false };
  _keys["right"] = { code: 39, shift: false };
  _keys["down"] = { code: 40, shift: false };
  _keys["space"] = { code: 32, shift: false };
  _keys["enter"] = { code: 13, shift: false };
  _keys["shift"] = { code: 16, shift: void 0 };
  _keys["esc"] = { code: 27, shift: false };
  _keys["backspace"] = { code: 8, shift: false };
  _keys["tab"] = { code: 9, shift: false };
  _keys["ctrl"] = { code: 17, shift: false };
  _keys["alt"] = { code: 18, shift: false };
  _keys["delete"] = { code: 46, shift: false };
  _keys["pageup"] = { code: 33, shift: false };
  _keys["pagedown"] = { code: 34, shift: false };
  _keys["="] = { code: 187, shift: false };
  _keys["-"] = { code: 189, shift: false };
  _keys["]"] = { code: 221, shift: false };
  _keys["["] = { code: 219, shift: false };
  var down = function(event) {
    handleEvent(event, "keydown");
  };
  var up = function(event) {
    handleEvent(event, "keyup");
  };
  var handleEvent = function(event, type) {
    if (_bound[type][event.keyCode] !== void 0) {
      var bound = _bound[type][event.keyCode];
      for (var i2 = 0; i2 < bound.length; i2++) {
        if (bound[i2].shift === void 0) {
          bound[i2].fn(event);
        } else if (bound[i2].shift == true && event.shiftKey == true) {
          bound[i2].fn(event);
        } else if (bound[i2].shift == false && event.shiftKey == false) {
          bound[i2].fn(event);
        }
      }
      if (preventDefault == true) {
        event.preventDefault();
      }
    }
  };
  _exportFunctions.bind = function(key, callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    if (_keys[key] === void 0) {
      throw new Error("unsupported key: " + key);
    }
    if (_bound[type][_keys[key].code] === void 0) {
      _bound[type][_keys[key].code] = [];
    }
    _bound[type][_keys[key].code].push({ fn: callback, shift: _keys[key].shift });
  };
  _exportFunctions.bindAll = function(callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        _exportFunctions.bind(key, callback, type);
      }
    }
  };
  _exportFunctions.getKey = function(event) {
    for (var key in _keys) {
      if (_keys.hasOwnProperty(key)) {
        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
          return key;
        } else if (event.keyCode == _keys[key].code && key == "shift") {
          return key;
        }
      }
    }
    return "unknown key, currently not supported";
  };
  _exportFunctions.unbind = function(key, callback, type) {
    if (type === void 0) {
      type = "keydown";
    }
    if (_keys[key] === void 0) {
      throw new Error("unsupported key: " + key);
    }
    if (callback !== void 0) {
      var newBindings = [];
      var bound = _bound[type][_keys[key].code];
      if (bound !== void 0) {
        for (var i2 = 0; i2 < bound.length; i2++) {
          if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {
            newBindings.push(_bound[type][_keys[key].code][i2]);
          }
        }
      }
      _bound[type][_keys[key].code] = newBindings;
    } else {
      _bound[type][_keys[key].code] = [];
    }
  };
  _exportFunctions.reset = function() {
    _bound = { keydown: {}, keyup: {} };
  };
  _exportFunctions.destroy = function() {
    _bound = { keydown: {}, keyup: {} };
    container.removeEventListener("keydown", down, true);
    container.removeEventListener("keyup", up, true);
  };
  container.addEventListener("keydown", down, true);
  container.addEventListener("keyup", up, true);
  return _exportFunctions;
}
var NavigationHandler = /* @__PURE__ */ function() {
  function NavigationHandler2(body, canvas) {
    var _this = this;
    _classCallCheck(this, NavigationHandler2);
    this.body = body;
    this.canvas = canvas;
    this.iconsCreated = false;
    this.navigationHammers = [];
    this.boundFunctions = {};
    this.touchTime = 0;
    this.activated = false;
    this.body.emitter.on("activate", function() {
      _this.activated = true;
      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("deactivate", function() {
      _this.activated = false;
      _this.configureKeyboardBindings();
    });
    this.body.emitter.on("destroy", function() {
      if (_this.keycharm !== void 0) {
        _this.keycharm.destroy();
      }
    });
    this.options = {};
  }
  _createClass(NavigationHandler2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        this.options = options;
        this.create();
      }
    }
    /**
     * Creates or refreshes navigation and sets key bindings
     */
  }, {
    key: "create",
    value: function create5() {
      if (this.options.navigationButtons === true) {
        if (this.iconsCreated === false) {
          this.loadNavigationElements();
        }
      } else if (this.iconsCreated === true) {
        this.cleanNavigation();
      }
      this.configureKeyboardBindings();
    }
    /**
     * Cleans up previous navigation items
     */
  }, {
    key: "cleanNavigation",
    value: function cleanNavigation() {
      if (this.navigationHammers.length != 0) {
        for (var i = 0; i < this.navigationHammers.length; i++) {
          this.navigationHammers[i].destroy();
        }
        this.navigationHammers = [];
      }
      if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
        this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
      }
      this.iconsCreated = false;
    }
    /**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */
  }, {
    key: "loadNavigationElements",
    value: function loadNavigationElements() {
      var _this2 = this;
      this.cleanNavigation();
      this.navigationDOM = {};
      var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
      var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
      this.navigationDOM["wrapper"] = document.createElement("div");
      this.navigationDOM["wrapper"].className = "vis-navigation";
      this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);
      for (var i = 0; i < navigationDivs.length; i++) {
        this.navigationDOM[navigationDivs[i]] = document.createElement("div");
        this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
        this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
        if (navigationDivActions[i] === "_fit") {
          var _context;
          onTouch(hammer, _bindInstanceProperty$1(_context = this._fit).call(_context, this));
        } else {
          var _context2;
          onTouch(hammer, _bindInstanceProperty$1(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));
        }
        this.navigationHammers.push(hammer);
      }
      var hammerFrame = new Hammer(this.canvas.frame);
      onRelease(hammerFrame, function() {
        _this2._stopMovement();
      });
      this.navigationHammers.push(hammerFrame);
      this.iconsCreated = true;
    }
    /**
     *
     * @param {string} action
     */
  }, {
    key: "bindToRedraw",
    value: function bindToRedraw(action) {
      if (this.boundFunctions[action] === void 0) {
        var _context3;
        this.boundFunctions[action] = _bindInstanceProperty$1(_context3 = this[action]).call(_context3, this);
        this.body.emitter.on("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_startRendering");
      }
    }
    /**
     *
     * @param {string} action
     */
  }, {
    key: "unbindFromRedraw",
    value: function unbindFromRedraw(action) {
      if (this.boundFunctions[action] !== void 0) {
        this.body.emitter.off("initRedraw", this.boundFunctions[action]);
        this.body.emitter.emit("_stopRendering");
        delete this.boundFunctions[action];
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */
  }, {
    key: "_fit",
    value: function _fit() {
      if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 700) {
        this.body.emitter.emit("fit", {
          duration: 700
        });
        this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
      }
    }
    /**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */
  }, {
    key: "_stopMovement",
    value: function _stopMovement() {
      for (var boundAction in this.boundFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {
          this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
          this.body.emitter.emit("_stopRendering");
        }
      }
      this.boundFunctions = {};
    }
    /**
     *
     * @private
     */
  }, {
    key: "_moveUp",
    value: function _moveUp() {
      this.body.view.translation.y += this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */
  }, {
    key: "_moveDown",
    value: function _moveDown() {
      this.body.view.translation.y -= this.options.keyboard.speed.y;
    }
    /**
     *
     * @private
     */
  }, {
    key: "_moveLeft",
    value: function _moveLeft() {
      this.body.view.translation.x += this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */
  }, {
    key: "_moveRight",
    value: function _moveRight() {
      this.body.view.translation.x -= this.options.keyboard.speed.x;
    }
    /**
     *
     * @private
     */
  }, {
    key: "_zoomIn",
    value: function _zoomIn() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "+",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     *
     * @private
     */
  }, {
    key: "_zoomOut",
    value: function _zoomOut() {
      var scaleOld = this.body.view.scale;
      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
      var translation = this.body.view.translation;
      var scaleFrac = scale / scaleOld;
      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
      this.body.view.scale = scale;
      this.body.view.translation = {
        x: tx,
        y: ty
      };
      this.body.emitter.emit("zoom", {
        direction: "-",
        scale: this.body.view.scale,
        pointer: null
      });
    }
    /**
     * bind all keys using keycharm.
     */
  }, {
    key: "configureKeyboardBindings",
    value: function configureKeyboardBindings() {
      var _this3 = this;
      if (this.keycharm !== void 0) {
        this.keycharm.destroy();
      }
      if (this.options.keyboard.enabled === true) {
        if (this.options.keyboard.bindToWindow === true) {
          this.keycharm = keycharm({
            container: window,
            preventDefault: true
          });
        } else {
          this.keycharm = keycharm({
            container: this.canvas.frame,
            preventDefault: true
          });
        }
        this.keycharm.reset();
        if (this.activated === true) {
          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;
          _bindInstanceProperty$1(_context4 = this.keycharm).call(_context4, "up", function() {
            _this3.bindToRedraw("_moveUp");
          }, "keydown");
          _bindInstanceProperty$1(_context5 = this.keycharm).call(_context5, "down", function() {
            _this3.bindToRedraw("_moveDown");
          }, "keydown");
          _bindInstanceProperty$1(_context6 = this.keycharm).call(_context6, "left", function() {
            _this3.bindToRedraw("_moveLeft");
          }, "keydown");
          _bindInstanceProperty$1(_context7 = this.keycharm).call(_context7, "right", function() {
            _this3.bindToRedraw("_moveRight");
          }, "keydown");
          _bindInstanceProperty$1(_context8 = this.keycharm).call(_context8, "=", function() {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");
          _bindInstanceProperty$1(_context9 = this.keycharm).call(_context9, "num+", function() {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");
          _bindInstanceProperty$1(_context10 = this.keycharm).call(_context10, "num-", function() {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");
          _bindInstanceProperty$1(_context11 = this.keycharm).call(_context11, "-", function() {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");
          _bindInstanceProperty$1(_context12 = this.keycharm).call(_context12, "[", function() {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");
          _bindInstanceProperty$1(_context13 = this.keycharm).call(_context13, "]", function() {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");
          _bindInstanceProperty$1(_context14 = this.keycharm).call(_context14, "pageup", function() {
            _this3.bindToRedraw("_zoomIn");
          }, "keydown");
          _bindInstanceProperty$1(_context15 = this.keycharm).call(_context15, "pagedown", function() {
            _this3.bindToRedraw("_zoomOut");
          }, "keydown");
          _bindInstanceProperty$1(_context16 = this.keycharm).call(_context16, "up", function() {
            _this3.unbindFromRedraw("_moveUp");
          }, "keyup");
          _bindInstanceProperty$1(_context17 = this.keycharm).call(_context17, "down", function() {
            _this3.unbindFromRedraw("_moveDown");
          }, "keyup");
          _bindInstanceProperty$1(_context18 = this.keycharm).call(_context18, "left", function() {
            _this3.unbindFromRedraw("_moveLeft");
          }, "keyup");
          _bindInstanceProperty$1(_context19 = this.keycharm).call(_context19, "right", function() {
            _this3.unbindFromRedraw("_moveRight");
          }, "keyup");
          _bindInstanceProperty$1(_context20 = this.keycharm).call(_context20, "=", function() {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");
          _bindInstanceProperty$1(_context21 = this.keycharm).call(_context21, "num+", function() {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");
          _bindInstanceProperty$1(_context22 = this.keycharm).call(_context22, "num-", function() {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
          _bindInstanceProperty$1(_context23 = this.keycharm).call(_context23, "-", function() {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
          _bindInstanceProperty$1(_context24 = this.keycharm).call(_context24, "[", function() {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
          _bindInstanceProperty$1(_context25 = this.keycharm).call(_context25, "]", function() {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");
          _bindInstanceProperty$1(_context26 = this.keycharm).call(_context26, "pageup", function() {
            _this3.unbindFromRedraw("_zoomIn");
          }, "keyup");
          _bindInstanceProperty$1(_context27 = this.keycharm).call(_context27, "pagedown", function() {
            _this3.unbindFromRedraw("_zoomOut");
          }, "keyup");
        }
      }
    }
  }]);
  return NavigationHandler2;
}();
function _createForOfIteratorHelper$4(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$4(o, minLen) {
  var _context15;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n = _sliceInstanceProperty(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var InteractionHandler = /* @__PURE__ */ function() {
  function InteractionHandler2(body, canvas, selectionHandler) {
    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;
    _classCallCheck(this, InteractionHandler2);
    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.navigationHandler = new NavigationHandler(body, canvas);
    this.body.eventListeners.onTap = _bindInstanceProperty$1(_context = this.onTap).call(_context, this);
    this.body.eventListeners.onTouch = _bindInstanceProperty$1(_context2 = this.onTouch).call(_context2, this);
    this.body.eventListeners.onDoubleTap = _bindInstanceProperty$1(_context3 = this.onDoubleTap).call(_context3, this);
    this.body.eventListeners.onHold = _bindInstanceProperty$1(_context4 = this.onHold).call(_context4, this);
    this.body.eventListeners.onDragStart = _bindInstanceProperty$1(_context5 = this.onDragStart).call(_context5, this);
    this.body.eventListeners.onDrag = _bindInstanceProperty$1(_context6 = this.onDrag).call(_context6, this);
    this.body.eventListeners.onDragEnd = _bindInstanceProperty$1(_context7 = this.onDragEnd).call(_context7, this);
    this.body.eventListeners.onMouseWheel = _bindInstanceProperty$1(_context8 = this.onMouseWheel).call(_context8, this);
    this.body.eventListeners.onPinch = _bindInstanceProperty$1(_context9 = this.onPinch).call(_context9, this);
    this.body.eventListeners.onMouseMove = _bindInstanceProperty$1(_context10 = this.onMouseMove).call(_context10, this);
    this.body.eventListeners.onRelease = _bindInstanceProperty$1(_context11 = this.onRelease).call(_context11, this);
    this.body.eventListeners.onContext = _bindInstanceProperty$1(_context12 = this.onContext).call(_context12, this);
    this.touchTime = 0;
    this.drag = {};
    this.pinch = {};
    this.popup = void 0;
    this.popupObj = void 0;
    this.popupTimer = void 0;
    this.body.functions.getPointer = _bindInstanceProperty$1(_context13 = this.getPointer).call(_context13, this);
    this.options = {};
    this.defaultOptions = {
      dragNodes: true,
      dragView: true,
      hover: false,
      keyboard: {
        enabled: false,
        speed: {
          x: 10,
          y: 10,
          zoom: 0.02
        },
        bindToWindow: true,
        autoFocus: true
      },
      navigationButtons: false,
      tooltipDelay: 300,
      zoomView: true,
      zoomSpeed: 1
    };
    _Object$assign(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  _createClass(InteractionHandler2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this = this;
      this.body.emitter.on("destroy", function() {
        clearTimeout(_this.popupTimer);
        delete _this.body.functions.getPointer;
      });
    }
    /**
     *
     * @param {object} options
     */
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        var fields = ["hideEdgesOnDrag", "hideEdgesOnZoom", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
        selectiveNotDeepExtend(fields, this.options, options);
        mergeOptions(this.options, options, "keyboard");
        if (options.tooltip) {
          _Object$assign(this.options.tooltip, options.tooltip);
          if (options.tooltip.color) {
            this.options.tooltip.color = parseColor(options.tooltip.color);
          }
        }
      }
      this.navigationHandler.setOptions(this.options);
    }
    /**
     * Get the pointer location from a touch location
     *
     * @param {{x: number, y: number}} touch
     * @returns {{x: number, y: number}} pointer
     * @private
     */
  }, {
    key: "getPointer",
    value: function getPointer(touch) {
      return {
        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),
        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)
      };
    }
    /**
     * On start of a touch gesture, store the pointer
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "onTouch",
    value: function onTouch2(event) {
      if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 50) {
        this.drag.pointer = this.getPointer(event.center);
        this.drag.pinched = false;
        this.pinch.scale = this.body.view.scale;
        this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
      }
    }
    /**
     * handle tap/click event: select/unselect a node
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onTap",
    value: function onTap(event) {
      var pointer2 = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
      this.checkSelectionChanges(pointer2, multiselect);
      this.selectionHandler.commitAndEmit(pointer2, event);
      this.selectionHandler.generateClickEvent("click", event, pointer2);
    }
    /**
     * handle doubletap event
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onDoubleTap",
    value: function onDoubleTap(event) {
      var pointer2 = this.getPointer(event.center);
      this.selectionHandler.generateClickEvent("doubleClick", event, pointer2);
    }
    /**
     * handle long tap event: multi select nodes
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onHold",
    value: function onHold(event) {
      var pointer2 = this.getPointer(event.center);
      var multiselect = this.selectionHandler.options.multiselect;
      this.checkSelectionChanges(pointer2, multiselect);
      this.selectionHandler.commitAndEmit(pointer2, event);
      this.selectionHandler.generateClickEvent("click", event, pointer2);
      this.selectionHandler.generateClickEvent("hold", event, pointer2);
    }
    /**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onRelease",
    value: function onRelease2(event) {
      if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 10) {
        var pointer2 = this.getPointer(event.center);
        this.selectionHandler.generateClickEvent("release", event, pointer2);
        this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     */
  }, {
    key: "onContext",
    value: function onContext(event) {
      var pointer2 = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      this.selectionHandler.generateClickEvent("oncontext", event, pointer2);
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [add=false]
     */
  }, {
    key: "checkSelectionChanges",
    value: function checkSelectionChanges(pointer2) {
      var add3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (add3 === true) {
        this.selectionHandler.selectAdditionalOnPoint(pointer2);
      } else {
        this.selectionHandler.selectOnPoint(pointer2);
      }
    }
    /**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */
  }, {
    key: "_determineDifference",
    value: function _determineDifference(firstSet, secondSet) {
      var arrayDiff = function arrayDiff2(firstArr, secondArr) {
        var result = [];
        for (var i = 0; i < firstArr.length; i++) {
          var value = firstArr[i];
          if (_indexOfInstanceProperty(secondArr).call(secondArr, value) === -1) {
            result.push(value);
          }
        }
        return result;
      };
      return {
        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
        edges: arrayDiff(firstSet.edges, secondSet.edges)
      };
    }
    /**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      if (this.drag.dragging) {
        return;
      }
      if (this.drag.pointer === void 0) {
        this.onTouch(event);
      }
      var node2 = this.selectionHandler.getNodeAt(this.drag.pointer);
      this.drag.dragging = true;
      this.drag.selection = [];
      this.drag.translation = _Object$assign({}, this.body.view.translation);
      this.drag.nodeId = void 0;
      if (event.srcEvent.shiftKey) {
        this.body.selectionBox.show = true;
        var pointer2 = this.getPointer(event.center);
        this.body.selectionBox.position.start = {
          x: this.canvas._XconvertDOMtoCanvas(pointer2.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer2.y)
        };
        this.body.selectionBox.position.end = {
          x: this.canvas._XconvertDOMtoCanvas(pointer2.x),
          y: this.canvas._YconvertDOMtoCanvas(pointer2.y)
        };
      } else if (node2 !== void 0 && this.options.dragNodes === true) {
        this.drag.nodeId = node2.id;
        if (node2.isSelected() === false) {
          this.selectionHandler.setSelection({
            nodes: [node2.id]
          });
        }
        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer);
        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _node = _step.value;
            var s = {
              id: _node.id,
              node: _node,
              // store original x, y, xFixed and yFixed, make the node temporarily Fixed
              x: _node.x,
              y: _node.y,
              xFixed: _node.options.fixed.x,
              yFixed: _node.options.fixed.y
            };
            _node.options.fixed.x = true;
            _node.options.fixed.y = true;
            this.drag.selection.push(s);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        this.selectionHandler.generateClickEvent("dragStart", event, this.drag.pointer, void 0, true);
      }
    }
    /**
     * handle drag event
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onDrag",
    value: function onDrag(event) {
      var _this2 = this;
      if (this.drag.pinched === true) {
        return;
      }
      this.body.emitter.emit("unlockNode");
      var pointer2 = this.getPointer(event.center);
      var selection2 = this.drag.selection;
      if (selection2 && selection2.length && this.options.dragNodes === true) {
        this.selectionHandler.generateClickEvent("dragging", event, pointer2);
        var deltaX = pointer2.x - this.drag.pointer.x;
        var deltaY = pointer2.y - this.drag.pointer.y;
        _forEachInstanceProperty(selection2).call(selection2, function(selection3) {
          var node2 = selection3.node;
          if (selection3.xFixed === false) {
            node2.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection3.x) + deltaX);
          }
          if (selection3.yFixed === false) {
            node2.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection3.y) + deltaY);
          }
        });
        this.body.emitter.emit("startSimulation");
      } else {
        if (event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer2, void 0, true);
          if (this.drag.pointer === void 0) {
            this.onDragStart(event);
            return;
          }
          this.body.selectionBox.position.end = {
            x: this.canvas._XconvertDOMtoCanvas(pointer2.x),
            y: this.canvas._YconvertDOMtoCanvas(pointer2.y)
          };
          this.body.emitter.emit("_requestRedraw");
        }
        if (this.options.dragView === true && !event.srcEvent.shiftKey) {
          this.selectionHandler.generateClickEvent("dragging", event, pointer2, void 0, true);
          if (this.drag.pointer === void 0) {
            this.onDragStart(event);
            return;
          }
          var diffX = pointer2.x - this.drag.pointer.x;
          var diffY = pointer2.y - this.drag.pointer.y;
          this.body.view.translation = {
            x: this.drag.translation.x + diffX,
            y: this.drag.translation.y + diffY
          };
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * handle drag start event
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      var _this3 = this;
      this.drag.dragging = false;
      if (this.body.selectionBox.show) {
        var _context14;
        this.body.selectionBox.show = false;
        var selectionBoxPosition = this.body.selectionBox.position;
        var selectionBoxPositionMinMax = {
          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),
          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),
          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)
        };
        var toBeSelectedNodes = _filterInstanceProperty(_context14 = this.body.nodeIndices).call(_context14, function(nodeId) {
          var node2 = _this3.body.nodes[nodeId];
          return node2.x >= selectionBoxPositionMinMax.minX && node2.x <= selectionBoxPositionMinMax.maxX && node2.y >= selectionBoxPositionMinMax.minY && node2.y <= selectionBoxPositionMinMax.maxY;
        });
        _forEachInstanceProperty(toBeSelectedNodes).call(toBeSelectedNodes, function(nodeId) {
          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);
        });
        var pointer2 = this.getPointer(event.center);
        this.selectionHandler.commitAndEmit(pointer2, event);
        this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
        this.body.emitter.emit("_requestRedraw");
      } else {
        var selection2 = this.drag.selection;
        if (selection2 && selection2.length) {
          _forEachInstanceProperty(selection2).call(selection2, function(s) {
            s.node.options.fixed.x = s.xFixed;
            s.node.options.fixed.y = s.yFixed;
          });
          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center));
          this.body.emitter.emit("startSimulation");
        } else {
          this.selectionHandler.generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
          this.body.emitter.emit("_requestRedraw");
        }
      }
    }
    /**
     * Handle pinch event
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "onPinch",
    value: function onPinch(event) {
      var pointer2 = this.getPointer(event.center);
      this.drag.pinched = true;
      if (this.pinch["scale"] === void 0) {
        this.pinch.scale = 1;
      }
      var scale = this.pinch.scale * event.scale;
      this.zoom(scale, pointer2);
    }
    /**
     * Zoom the network in or out
     *
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */
  }, {
    key: "zoom",
    value: function zoom(scale, pointer2) {
      if (this.options.zoomView === true) {
        var scaleOld = this.body.view.scale;
        if (scale < 1e-5) {
          scale = 1e-5;
        }
        if (scale > 10) {
          scale = 10;
        }
        var preScaleDragPointer = void 0;
        if (this.drag !== void 0) {
          if (this.drag.dragging === true) {
            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
          }
        }
        var translation = this.body.view.translation;
        var scaleFrac = scale / scaleOld;
        var tx = (1 - scaleFrac) * pointer2.x + translation.x * scaleFrac;
        var ty = (1 - scaleFrac) * pointer2.y + translation.y * scaleFrac;
        this.body.view.scale = scale;
        this.body.view.translation = {
          x: tx,
          y: ty
        };
        if (preScaleDragPointer != void 0) {
          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
          this.drag.pointer.x = postScaleDragPointer.x;
          this.drag.pointer.y = postScaleDragPointer.y;
        }
        this.body.emitter.emit("_requestRedraw");
        if (scaleOld < scale) {
          this.body.emitter.emit("zoom", {
            direction: "+",
            scale: this.body.view.scale,
            pointer: pointer2
          });
        } else {
          this.body.emitter.emit("zoom", {
            direction: "-",
            scale: this.body.view.scale,
            pointer: pointer2
          });
        }
      }
    }
    /**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     *
     * @param {MouseEvent}  event
     * @private
     */
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(event) {
      if (this.options.zoomView === true) {
        if (event.deltaY !== 0) {
          var scale = this.body.view.scale;
          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1);
          var pointer2 = this.getPointer({
            x: event.clientX,
            y: event.clientY
          });
          this.zoom(scale, pointer2);
        }
        event.preventDefault();
      }
    }
    /**
     * Mouse move handler for checking whether the title moves over a node with a title.
     *
     * @param  {Event} event
     * @private
     */
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var _this4 = this;
      var pointer2 = this.getPointer({
        x: event.clientX,
        y: event.clientY
      });
      var popupVisible = false;
      if (this.popup !== void 0) {
        if (this.popup.hidden === false) {
          this._checkHidePopup(pointer2);
        }
        if (this.popup.hidden === false) {
          popupVisible = true;
          this.popup.setPosition(pointer2.x + 3, pointer2.y - 5);
          this.popup.show();
        }
      }
      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
        this.canvas.frame.focus();
      }
      if (popupVisible === false) {
        if (this.popupTimer !== void 0) {
          clearInterval(this.popupTimer);
          this.popupTimer = void 0;
        }
        if (!this.drag.dragging) {
          this.popupTimer = _setTimeout(function() {
            return _this4._checkShowPopup(pointer2);
          }, this.options.tooltipDelay);
        }
      }
      if (this.options.hover === true) {
        this.selectionHandler.hoverObject(event, pointer2);
      }
    }
    /**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */
  }, {
    key: "_checkShowPopup",
    value: function _checkShowPopup(pointer2) {
      var x2 = this.canvas._XconvertDOMtoCanvas(pointer2.x);
      var y2 = this.canvas._YconvertDOMtoCanvas(pointer2.y);
      var pointerObj = {
        left: x2,
        top: y2,
        right: x2,
        bottom: y2
      };
      var previousPopupObjId = this.popupObj === void 0 ? void 0 : this.popupObj.id;
      var nodeUnderCursor = false;
      var popupType = "node";
      if (this.popupObj === void 0) {
        var nodeIndices = this.body.nodeIndices;
        var nodes = this.body.nodes;
        var node2;
        var overlappingNodes = [];
        for (var i = 0; i < nodeIndices.length; i++) {
          node2 = nodes[nodeIndices[i]];
          if (node2.isOverlappingWith(pointerObj) === true) {
            nodeUnderCursor = true;
            if (node2.getTitle() !== void 0) {
              overlappingNodes.push(nodeIndices[i]);
            }
          }
        }
        if (overlappingNodes.length > 0) {
          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
          nodeUnderCursor = true;
        }
      }
      if (this.popupObj === void 0 && nodeUnderCursor === false) {
        var edgeIndices = this.body.edgeIndices;
        var edges = this.body.edges;
        var edge;
        var overlappingEdges = [];
        for (var _i = 0; _i < edgeIndices.length; _i++) {
          edge = edges[edgeIndices[_i]];
          if (edge.isOverlappingWith(pointerObj) === true) {
            if (edge.connected === true && edge.getTitle() !== void 0) {
              overlappingEdges.push(edgeIndices[_i]);
            }
          }
        }
        if (overlappingEdges.length > 0) {
          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
          popupType = "edge";
        }
      }
      if (this.popupObj !== void 0) {
        if (this.popupObj.id !== previousPopupObjId) {
          if (this.popup === void 0) {
            this.popup = new Popup(this.canvas.frame);
          }
          this.popup.popupTargetType = popupType;
          this.popup.popupTargetId = this.popupObj.id;
          this.popup.setPosition(pointer2.x + 3, pointer2.y - 5);
          this.popup.setText(this.popupObj.getTitle());
          this.popup.show();
          this.body.emitter.emit("showPopup", this.popupObj.id);
        }
      } else {
        if (this.popup !== void 0) {
          this.popup.hide();
          this.body.emitter.emit("hidePopup");
        }
      }
    }
    /**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */
  }, {
    key: "_checkHidePopup",
    value: function _checkHidePopup(pointer2) {
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer2);
      var stillOnObj = false;
      if (this.popup.popupTargetType === "node") {
        if (this.body.nodes[this.popup.popupTargetId] !== void 0) {
          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          if (stillOnObj === true) {
            var overNode = this.selectionHandler.getNodeAt(pointer2);
            stillOnObj = overNode === void 0 ? false : overNode.id === this.popup.popupTargetId;
          }
        }
      } else {
        if (this.selectionHandler.getNodeAt(pointer2) === void 0) {
          if (this.body.edges[this.popup.popupTargetId] !== void 0) {
            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
          }
        }
      }
      if (stillOnObj === false) {
        this.popupObj = void 0;
        this.popup.hide();
        this.body.emitter.emit("hidePopup");
      }
    }
  }]);
  return InteractionHandler2;
}();
var uncurryThis$1 = functionUncurryThis;
var defineBuiltIns$1 = defineBuiltIns$3;
var getWeakData = internalMetadataExports.getWeakData;
var anInstance = anInstance$4;
var anObject = anObject$f;
var isNullOrUndefined = isNullOrUndefined$7;
var isObject$1 = isObject$m;
var iterate = iterate$8;
var ArrayIterationModule = arrayIteration;
var hasOwn2 = hasOwnProperty_1;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice2 = uncurryThis$1([].splice);
var id = 0;
var uncaughtFrozenStore = function(state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store2, key) {
  return find(store2.entries, function(it3) {
    return it3[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      entry[1] = value;
    else
      this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index2 = findIndex(this.entries, function(it3) {
      return it3[0] === key;
    });
    if (~index2)
      splice2(this.entries, index2, 1);
    return !!~index2;
  }
};
var collectionWeak$1 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: void 0
      });
      if (!isNullOrUndefined(iterable))
        iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define2 = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject(key), true);
      if (data2 === true)
        uncaughtFrozenStore(state).set(key, value);
      else
        data2[state.id] = value;
      return that;
    };
    defineBuiltIns$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$1(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn2(data2, state.id) && delete data2[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has2(key) {
        var state = getInternalState2(this);
        if (!isObject$1(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn2(data2, state.id);
      }
    });
    defineBuiltIns$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get2(key) {
        var state = getInternalState2(this);
        if (isObject$1(key)) {
          var data2 = getWeakData(key);
          if (data2 === true)
            return uncaughtFrozenStore(state).get(key);
          return data2 ? data2[state.id] : void 0;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set3(key, value) {
        return define2(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add3(value) {
        return define2(this, value, true);
      }
    });
    return Constructor;
  }
};
var FREEZING = freezing;
var global$1 = global$s;
var uncurryThis = functionUncurryThis;
var defineBuiltIns = defineBuiltIns$3;
var InternalMetadataModule = internalMetadataExports;
var collection = collection$3;
var collectionWeak = collectionWeak$1;
var isObject = isObject$m;
var enforceInternalState = internalState.enforce;
var fails = fails$z;
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var $Object = Object;
var isArray2 = Array.isArray;
var isExtensible2 = $Object.isExtensible;
var isFrozen = $Object.isFrozen;
var isSealed = $Object.isSealed;
var freeze = $Object.freeze;
var seal = $Object.seal;
var FROZEN = {};
var SEALED = {};
var IS_IE11 = !global$1.ActiveXObject && "ActiveXObject" in global$1;
var InternalWeakMap;
var wrapper = function(init2) {
  return function WeakMap2() {
    return init2(this, arguments.length ? arguments[0] : void 0);
  };
};
var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);
var hasMSEdgeFreezingBug = function() {
  return FREEZING && fails(function() {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};
if (NATIVE_WEAK_MAP) {
  if (IS_IE11) {
    InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
    InternalMetadataModule.enable();
    var nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
    var nativeHas = uncurryThis(WeakMapPrototype.has);
    var nativeGet = uncurryThis(WeakMapPrototype.get);
    defineBuiltIns(WeakMapPrototype, {
      "delete": function(key) {
        if (isObject(key) && !isExtensible2(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen)
            state.frozen = new InternalWeakMap();
          return nativeDelete(this, key) || state.frozen["delete"](key);
        }
        return nativeDelete(this, key);
      },
      has: function has2(key) {
        if (isObject(key) && !isExtensible2(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen)
            state.frozen = new InternalWeakMap();
          return nativeHas(this, key) || state.frozen.has(key);
        }
        return nativeHas(this, key);
      },
      get: function get2(key) {
        if (isObject(key) && !isExtensible2(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen)
            state.frozen = new InternalWeakMap();
          return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
        }
        return nativeGet(this, key);
      },
      set: function set3(key, value) {
        if (isObject(key) && !isExtensible2(key)) {
          var state = enforceInternalState(this);
          if (!state.frozen)
            state.frozen = new InternalWeakMap();
          nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
        } else
          nativeSet(this, key, value);
        return this;
      }
    });
  } else if (hasMSEdgeFreezingBug()) {
    defineBuiltIns(WeakMapPrototype, {
      set: function set3(key, value) {
        var arrayIntegrityLevel;
        if (isArray2(key)) {
          if (isFrozen(key))
            arrayIntegrityLevel = FROZEN;
          else if (isSealed(key))
            arrayIntegrityLevel = SEALED;
        }
        nativeSet(this, key, value);
        if (arrayIntegrityLevel === FROZEN)
          freeze(key);
        if (arrayIntegrityLevel === SEALED)
          seal(key);
        return this;
      }
    });
  }
}
var path = path$y;
var weakMap$2 = path.WeakMap;
var parent$1 = weakMap$2;
var weakMap$1 = parent$1;
var weakMap = weakMap$1;
var _WeakMap = /* @__PURE__ */ getDefaultExportFromCjs(weakMap);
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function _createForOfIteratorHelper$3(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$3(o, minLen) {
  var _context2;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n = _sliceInstanceProperty(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;
function diffSets(prev2, next3) {
  var diff = new _Set();
  var _iterator = _createForOfIteratorHelper$3(next3), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var item = _step.value;
      if (!prev2.has(item)) {
        diff.add(item);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return diff;
}
var SingleTypeSelectionAccumulator = /* @__PURE__ */ function() {
  function SingleTypeSelectionAccumulator2() {
    _classCallCheck(this, SingleTypeSelectionAccumulator2);
    _SingleTypeSelectionAccumulator_previousSelection.set(this, new _Set());
    _SingleTypeSelectionAccumulator_selection.set(this, new _Set());
  }
  _createClass(SingleTypeSelectionAccumulator2, [{
    key: "size",
    get: function get2() {
      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").size;
    }
  }, {
    key: "add",
    value: function add3() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }
      for (var _i = 0, _items = items; _i < _items.length; _i++) {
        var item = _items[_i];
        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").add(item);
      }
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {
        var item = _items2[_i2];
        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").delete(item);
      }
    }
  }, {
    key: "clear",
    value: function clear2() {
      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f").clear();
    }
  }, {
    key: "getSelection",
    value: function getSelection() {
      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"));
    }
  }, {
    key: "getChanges",
    value: function getChanges() {
      return {
        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"))),
        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        previous: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f"))),
        current: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f")))
      };
    }
  }, {
    key: "commit",
    value: function commit() {
      var changes = this.getChanges();
      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, "f"), "f");
      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, "f")), "f");
      var _iterator2 = _createForOfIteratorHelper$3(changes.added), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var item = _step2.value;
          item.select();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _item = _step3.value;
          _item.unselect();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return changes;
    }
  }]);
  return SingleTypeSelectionAccumulator2;
}();
_SingleTypeSelectionAccumulator_previousSelection = new _WeakMap(), _SingleTypeSelectionAccumulator_selection = new _WeakMap();
var SelectionAccumulator = /* @__PURE__ */ function() {
  function SelectionAccumulator2() {
    var commitHandler = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    _classCallCheck(this, SelectionAccumulator2);
    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());
    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());
    _SelectionAccumulator_commitHandler.set(this, void 0);
    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, "f");
  }
  _createClass(SelectionAccumulator2, [{
    key: "sizeNodes",
    get: function get2() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").size;
    }
  }, {
    key: "sizeEdges",
    get: function get2() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").size;
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").getSelection();
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").getSelection();
    }
  }, {
    key: "addNodes",
    value: function addNodes() {
      var _classPrivateFieldGe;
      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f")).add.apply(_classPrivateFieldGe, arguments);
    }
  }, {
    key: "addEdges",
    value: function addEdges() {
      var _classPrivateFieldGe2;
      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f")).add.apply(_classPrivateFieldGe2, arguments);
    }
  }, {
    key: "deleteNodes",
    value: function deleteNodes(node2) {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").delete(node2);
    }
  }, {
    key: "deleteEdges",
    value: function deleteEdges(edge) {
      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").delete(edge);
    }
  }, {
    key: "clear",
    value: function clear2() {
      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").clear();
      __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").clear();
    }
  }, {
    key: "commit",
    value: function commit() {
      var _classPrivateFieldGe3, _context;
      var summary = {
        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, "f").commit(),
        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, "f").commit()
      };
      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        rest[_key3] = arguments[_key3];
      }
      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, "f")).call.apply(_classPrivateFieldGe3, _concatInstanceProperty(_context = [this, summary]).call(_context, rest));
      return summary;
    }
  }]);
  return SelectionAccumulator2;
}();
_SelectionAccumulator_nodes = new _WeakMap(), _SelectionAccumulator_edges = new _WeakMap(), _SelectionAccumulator_commitHandler = new _WeakMap();
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  var _context3;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = _sliceInstanceProperty(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var SelectionHandler = /* @__PURE__ */ function() {
  function SelectionHandler2(body, canvas) {
    var _this = this;
    _classCallCheck(this, SelectionHandler2);
    this.body = body;
    this.canvas = canvas;
    this._selectionAccumulator = new SelectionAccumulator();
    this.hoverObj = {
      nodes: {},
      edges: {}
    };
    this.options = {};
    this.defaultOptions = {
      multiselect: false,
      selectable: true,
      selectConnectedEdges: true,
      hoverConnectedEdges: true
    };
    _Object$assign(this.options, this.defaultOptions);
    this.body.emitter.on("_dataChanged", function() {
      _this.updateSelection();
    });
  }
  _createClass(SelectionHandler2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== void 0) {
        var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
        selectiveDeepExtend(fields, this.options, options);
      }
    }
    /**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */
  }, {
    key: "selectOnPoint",
    value: function selectOnPoint(pointer2) {
      var selected = false;
      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer2) || this.getEdgeAt(pointer2);
        this.unselectAll();
        if (obj !== void 0) {
          selected = this.selectObject(obj);
        }
        this.body.emitter.emit("_requestRedraw");
      }
      return selected;
    }
    /**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */
  }, {
    key: "selectAdditionalOnPoint",
    value: function selectAdditionalOnPoint(pointer2) {
      var selectionChanged = false;
      if (this.options.selectable === true) {
        var obj = this.getNodeAt(pointer2) || this.getEdgeAt(pointer2);
        if (obj !== void 0) {
          selectionChanged = true;
          if (obj.isSelected() === true) {
            this.deselectObject(obj);
          } else {
            this.selectObject(obj);
          }
          this.body.emitter.emit("_requestRedraw");
        }
      }
      return selectionChanged;
    }
    /**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */
  }, {
    key: "_initBaseEvent",
    value: function _initBaseEvent(event, pointer2) {
      var properties = {};
      properties["pointer"] = {
        DOM: {
          x: pointer2.x,
          y: pointer2.y
        },
        canvas: this.canvas.DOMtoCanvas(pointer2)
      };
      properties["event"] = event;
      return properties;
    }
    /**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {object | undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */
  }, {
    key: "generateClickEvent",
    value: function generateClickEvent(eventType, event, pointer2, oldSelection) {
      var emptySelection = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var properties = this._initBaseEvent(event, pointer2);
      if (emptySelection === true) {
        properties.nodes = [];
        properties.edges = [];
      } else {
        var tmp = this.getSelection();
        properties.nodes = tmp.nodes;
        properties.edges = tmp.edges;
      }
      if (oldSelection !== void 0) {
        properties["previousSelection"] = oldSelection;
      }
      if (eventType == "click") {
        properties.items = this.getClickedItems(pointer2);
      }
      if (event.controlEdge !== void 0) {
        properties.controlEdge = event.controlEdge;
      }
      this.body.emitter.emit(eventType, properties);
    }
    /**
     *
     * @param {object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */
  }, {
    key: "selectObject",
    value: function selectObject(obj) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.selectConnectedEdges;
      if (obj !== void 0) {
        if (obj instanceof Node$1) {
          if (highlightEdges === true) {
            var _this$_selectionAccum;
            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));
          }
          this._selectionAccumulator.addNodes(obj);
        } else {
          this._selectionAccumulator.addEdges(obj);
        }
        return true;
      }
      return false;
    }
    /**
     *
     * @param {object} obj
     */
  }, {
    key: "deselectObject",
    value: function deselectObject(obj) {
      if (obj.isSelected() === true) {
        obj.selected = false;
        this._removeFromSelection(obj);
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */
  }, {
    key: "_getAllNodesOverlappingWith",
    value: function _getAllNodesOverlappingWith(object2) {
      var overlappingNodes = [];
      var nodes = this.body.nodes;
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var nodeId = this.body.nodeIndices[i];
        if (nodes[nodeId].isOverlappingWith(object2)) {
          overlappingNodes.push(nodeId);
        }
      }
      return overlappingNodes;
    }
    /**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */
  }, {
    key: "_pointerToPositionObject",
    value: function _pointerToPositionObject(pointer2) {
      var canvasPos = this.canvas.DOMtoCanvas(pointer2);
      return {
        left: canvasPos.x - 1,
        top: canvasPos.y + 1,
        right: canvasPos.x + 1,
        bottom: canvasPos.y - 1
      };
    }
    /**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @returns {Node | undefined} node
     */
  }, {
    key: "getNodeAt",
    value: function getNodeAt(pointer2) {
      var returnNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var positionObject = this._pointerToPositionObject(pointer2);
      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
      if (overlappingNodes.length > 0) {
        if (returnNode === true) {
          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
        } else {
          return overlappingNodes[overlappingNodes.length - 1];
        }
      } else {
        return void 0;
      }
    }
    /**
     * retrieve all edges overlapping with given object, selector is around center
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */
  }, {
    key: "_getEdgesOverlappingWith",
    value: function _getEdgesOverlappingWith(object2, overlappingEdges) {
      var edges = this.body.edges;
      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        if (edges[edgeId].isOverlappingWith(object2)) {
          overlappingEdges.push(edgeId);
        }
      }
    }
    /**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */
  }, {
    key: "_getAllEdgesOverlappingWith",
    value: function _getAllEdgesOverlappingWith(object2) {
      var overlappingEdges = [];
      this._getEdgesOverlappingWith(object2, overlappingEdges);
      return overlappingEdges;
    }
    /**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @returns {Edge | undefined} node
     */
  }, {
    key: "getEdgeAt",
    value: function getEdgeAt(pointer2) {
      var returnEdge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var canvasPos = this.canvas.DOMtoCanvas(pointer2);
      var mindist = 10;
      var overlappingEdge = null;
      var edges = this.body.edges;
      for (var i = 0; i < this.body.edgeIndices.length; i++) {
        var edgeId = this.body.edgeIndices[i];
        var edge = edges[edgeId];
        if (edge.connected) {
          var xFrom = edge.from.x;
          var yFrom = edge.from.y;
          var xTo = edge.to.x;
          var yTo = edge.to.y;
          var dist2 = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
          if (dist2 < mindist) {
            overlappingEdge = edgeId;
            mindist = dist2;
          }
        }
      }
      if (overlappingEdge !== null) {
        if (returnEdge === true) {
          return this.body.edges[overlappingEdge];
        } else {
          return overlappingEdge;
        }
      } else {
        return void 0;
      }
    }
    /**
     * Add object to the selection array.
     *
     * @param {object} obj
     * @private
     */
  }, {
    key: "_addToHover",
    value: function _addToHover(obj) {
      if (obj instanceof Node$1) {
        this.hoverObj.nodes[obj.id] = obj;
      } else {
        this.hoverObj.edges[obj.id] = obj;
      }
    }
    /**
     * Remove a single option from selection.
     *
     * @param {object} obj
     * @private
     */
  }, {
    key: "_removeFromSelection",
    value: function _removeFromSelection(obj) {
      if (obj instanceof Node$1) {
        var _this$_selectionAccum2;
        this._selectionAccumulator.deleteNodes(obj);
        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));
      } else {
        this._selectionAccumulator.deleteEdges(obj);
      }
    }
    /**
     * Unselect all nodes and edges.
     */
  }, {
    key: "unselectAll",
    value: function unselectAll() {
      this._selectionAccumulator.clear();
    }
    /**
     * return the number of selected nodes
     *
     * @returns {number}
     */
  }, {
    key: "getSelectedNodeCount",
    value: function getSelectedNodeCount() {
      return this._selectionAccumulator.sizeNodes;
    }
    /**
     * return the number of selected edges
     *
     * @returns {number}
     */
  }, {
    key: "getSelectedEdgeCount",
    value: function getSelectedEdgeCount() {
      return this._selectionAccumulator.sizeEdges;
    }
    /**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */
  }, {
    key: "_hoverConnectedEdges",
    value: function _hoverConnectedEdges(node2) {
      for (var i = 0; i < node2.edges.length; i++) {
        var edge = node2.edges[i];
        edge.hover = true;
        this._addToHover(edge);
      }
    }
    /**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */
  }, {
    key: "emitBlurEvent",
    value: function emitBlurEvent(event, pointer2, object2) {
      var properties = this._initBaseEvent(event, pointer2);
      if (object2.hover === true) {
        object2.hover = false;
        if (object2 instanceof Node$1) {
          properties.node = object2.id;
          this.body.emitter.emit("blurNode", properties);
        } else {
          properties.edge = object2.id;
          this.body.emitter.emit("blurEdge", properties);
        }
      }
    }
    /**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */
  }, {
    key: "emitHoverEvent",
    value: function emitHoverEvent(event, pointer2, object2) {
      var properties = this._initBaseEvent(event, pointer2);
      var hoverChanged = false;
      if (object2.hover === false) {
        object2.hover = true;
        this._addToHover(object2);
        hoverChanged = true;
        if (object2 instanceof Node$1) {
          properties.node = object2.id;
          this.body.emitter.emit("hoverNode", properties);
        } else {
          properties.edge = object2.id;
          this.body.emitter.emit("hoverEdge", properties);
        }
      }
      return hoverChanged;
    }
    /**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */
  }, {
    key: "hoverObject",
    value: function hoverObject(event, pointer2) {
      var object2 = this.getNodeAt(pointer2);
      if (object2 === void 0) {
        object2 = this.getEdgeAt(pointer2);
      }
      var hoverChanged = false;
      for (var nodeId in this.hoverObj.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {
          if (object2 === void 0 || object2 instanceof Node$1 && object2.id != nodeId || object2 instanceof Edge) {
            this.emitBlurEvent(event, pointer2, this.hoverObj.nodes[nodeId]);
            delete this.hoverObj.nodes[nodeId];
            hoverChanged = true;
          }
        }
      }
      for (var edgeId in this.hoverObj.edges) {
        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {
          if (hoverChanged === true) {
            this.hoverObj.edges[edgeId].hover = false;
            delete this.hoverObj.edges[edgeId];
          } else if (object2 === void 0 || object2 instanceof Edge && object2.id != edgeId || object2 instanceof Node$1 && !object2.hover) {
            this.emitBlurEvent(event, pointer2, this.hoverObj.edges[edgeId]);
            delete this.hoverObj.edges[edgeId];
            hoverChanged = true;
          }
        }
      }
      if (object2 !== void 0) {
        var hoveredEdgesCount = _Object$keys(this.hoverObj.edges).length;
        var hoveredNodesCount = _Object$keys(this.hoverObj.nodes).length;
        var newOnlyHoveredEdge = object2 instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
        var newOnlyHoveredNode = object2 instanceof Node$1 && hoveredEdgesCount === 0 && hoveredNodesCount === 0;
        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {
          hoverChanged = this.emitHoverEvent(event, pointer2, object2);
        }
        if (object2 instanceof Node$1 && this.options.hoverConnectedEdges === true) {
          this._hoverConnectedEdges(object2);
        }
      }
      if (hoverChanged === true) {
        this.body.emitter.emit("_requestRedraw");
      }
    }
    /**
     * Commit the selection changes but don't emit any events.
     */
  }, {
    key: "commitWithoutEmitting",
    value: function commitWithoutEmitting() {
      this._selectionAccumulator.commit();
    }
    /**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the
     * same click the other node is selected, no events for the edge will fire. It
     * was selected and it will remain selected.
     *
     * @param {{x: number, y: number}} pointer - The x and y coordinates of the
     * click, tap, dragend… that triggered this.
     * @param {UIEvent} event - The event that triggered this.
     */
  }, {
    key: "commitAndEmit",
    value: function commitAndEmit(pointer2, event) {
      var selected = false;
      var selectionChanges = this._selectionAccumulator.commit();
      var previousSelection = {
        nodes: selectionChanges.nodes.previous,
        edges: selectionChanges.edges.previous
      };
      if (selectionChanges.edges.deleted.length > 0) {
        this.generateClickEvent("deselectEdge", event, pointer2, previousSelection);
        selected = true;
      }
      if (selectionChanges.nodes.deleted.length > 0) {
        this.generateClickEvent("deselectNode", event, pointer2, previousSelection);
        selected = true;
      }
      if (selectionChanges.nodes.added.length > 0) {
        this.generateClickEvent("selectNode", event, pointer2);
        selected = true;
      }
      if (selectionChanges.edges.added.length > 0) {
        this.generateClickEvent("selectEdge", event, pointer2);
        selected = true;
      }
      if (selected === true) {
        this.generateClickEvent("select", event, pointer2);
      }
    }
    /**
     * Retrieve the currently selected node and edge ids.
     *
     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the
     * ids of the selected nodes and edges.
     */
  }, {
    key: "getSelection",
    value: function getSelection() {
      return {
        nodes: this.getSelectedNodeIds(),
        edges: this.getSelectedEdgeIds()
      };
    }
    /**
     * Retrieve the currently selected nodes.
     *
     * @returns {Array} An array with selected nodes.
     */
  }, {
    key: "getSelectedNodes",
    value: function getSelectedNodes() {
      return this._selectionAccumulator.getNodes();
    }
    /**
     * Retrieve the currently selected edges.
     *
     * @returns {Array} An array with selected edges.
     */
  }, {
    key: "getSelectedEdges",
    value: function getSelectedEdges() {
      return this._selectionAccumulator.getEdges();
    }
    /**
     * Retrieve the currently selected node ids.
     *
     * @returns {Array} An array with the ids of the selected nodes.
     */
  }, {
    key: "getSelectedNodeIds",
    value: function getSelectedNodeIds() {
      var _context;
      return _mapInstanceProperty(_context = this._selectionAccumulator.getNodes()).call(_context, function(node2) {
        return node2.id;
      });
    }
    /**
     * Retrieve the currently selected edge ids.
     *
     * @returns {Array} An array with the ids of the selected edges.
     */
  }, {
    key: "getSelectedEdgeIds",
    value: function getSelectedEdgeIds() {
      var _context2;
      return _mapInstanceProperty(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function(edge) {
        return edge.id;
      });
    }
    /**
     * Updates the current selection
     *
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {object} options                                 Options
     */
  }, {
    key: "setSelection",
    value: function setSelection(selection2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!selection2 || !selection2.nodes && !selection2.edges) {
        throw new TypeError("Selection must be an object with nodes and/or edges properties");
      }
      if (options.unselectAll || options.unselectAll === void 0) {
        this.unselectAll();
      }
      if (selection2.nodes) {
        var _iterator = _createForOfIteratorHelper$2(selection2.nodes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var id2 = _step.value;
            var node2 = this.body.nodes[id2];
            if (!node2) {
              throw new RangeError('Node with id "' + id2 + '" not found');
            }
            this.selectObject(node2, options.highlightEdges);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (selection2.edges) {
        var _iterator2 = _createForOfIteratorHelper$2(selection2.edges), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _id = _step2.value;
            var edge = this.body.edges[_id];
            if (!edge) {
              throw new RangeError('Edge with id "' + _id + '" not found');
            }
            this.selectObject(edge);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      this.body.emitter.emit("_requestRedraw");
      this._selectionAccumulator.commit();
    }
    /**
     * select zero or more nodes with the option to highlight edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */
  }, {
    key: "selectNodes",
    value: function selectNodes(selection2) {
      var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!selection2 || selection2.length === void 0)
        throw "Selection must be an array with ids";
      this.setSelection({
        nodes: selection2
      }, {
        highlightEdges
      });
    }
    /**
     * select zero or more edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */
  }, {
    key: "selectEdges",
    value: function selectEdges(selection2) {
      if (!selection2 || selection2.length === void 0)
        throw "Selection must be an array with ids";
      this.setSelection({
        edges: selection2
      });
    }
    /**
     * Validate the selection: remove ids of nodes which no longer exist
     *
     * @private
     */
  }, {
    key: "updateSelection",
    value: function updateSelection() {
      for (var node2 in this._selectionAccumulator.getNodes()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node2.id)) {
          this._selectionAccumulator.deleteNodes(node2);
        }
      }
      for (var edge in this._selectionAccumulator.getEdges()) {
        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {
          this._selectionAccumulator.deleteEdges(edge);
        }
      }
    }
    /**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */
  }, {
    key: "getClickedItems",
    value: function getClickedItems(pointer2) {
      var point = this.canvas.DOMtoCanvas(pointer2);
      var items = [];
      var nodeIndices = this.body.nodeIndices;
      var nodes = this.body.nodes;
      for (var i = nodeIndices.length - 1; i >= 0; i--) {
        var node2 = nodes[nodeIndices[i]];
        var ret = node2.getItemsOnPoint(point);
        items.push.apply(items, ret);
      }
      var edgeIndices = this.body.edgeIndices;
      var edges = this.body.edges;
      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
        var edge = edges[edgeIndices[_i]];
        var _ret = edge.getItemsOnPoint(point);
        items.push.apply(items, _ret);
      }
      return items;
    }
  }]);
  return SelectionHandler2;
}();
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = _Reflect$construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !_Reflect$construct)
    return false;
  if (_Reflect$construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DirectionInterface = /* @__PURE__ */ function() {
  function DirectionInterface2() {
    _classCallCheck(this, DirectionInterface2);
  }
  _createClass(DirectionInterface2, [{
    key: "abstract",
    value: (
      /**
       * @ignore
       */
      function abstract() {
        throw new Error("Can't instantiate abstract class!");
      }
    )
    /**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     */
  }, {
    key: "fake_use",
    value: function fake_use() {
    }
    /**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @returns {string} Direction, either 'vertical' or 'horizontal'
     */
  }, {
    key: "curveType",
    value: function curveType() {
      return this.abstract();
    }
    /**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @returns {number} Value of the unfixed coordinate
     */
  }, {
    key: "getPosition",
    value: function getPosition(node2) {
      this.fake_use(node2);
      return this.abstract();
    }
    /**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */
  }, {
    key: "setPosition",
    value: function setPosition(node2, position) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      this.fake_use(node2, position, level);
      this.abstract();
    }
    /**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @returns {number} the width of a tree in the view coordinates
     */
  }, {
    key: "getTreeSize",
    value: function getTreeSize(index2) {
      this.fake_use(index2);
      return this.abstract();
    }
    /**
     * Sort array of nodes on the unfixed coordinates.
     *
     * Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */
  }, {
    key: "sort",
    value: function sort3(nodeArray) {
      this.fake_use(nodeArray);
      this.abstract();
    }
    /**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */
  }, {
    key: "fix",
    value: function fix(node2, level) {
      this.fake_use(node2, level);
      this.abstract();
    }
    /**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */
  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.fake_use(nodeId, diff);
      this.abstract();
    }
  }]);
  return DirectionInterface2;
}();
var VerticalStrategy = /* @__PURE__ */ function(_DirectionInterface) {
  _inherits(VerticalStrategy2, _DirectionInterface);
  var _super = _createSuper(VerticalStrategy2);
  function VerticalStrategy2(layout) {
    var _this;
    _classCallCheck(this, VerticalStrategy2);
    _this = _super.call(this);
    _this.layout = layout;
    return _this;
  }
  _createClass(VerticalStrategy2, [{
    key: "curveType",
    value: function curveType() {
      return "horizontal";
    }
    /** @inheritDoc */
  }, {
    key: "getPosition",
    value: function getPosition(node2) {
      return node2.x;
    }
    /** @inheritDoc */
  }, {
    key: "setPosition",
    value: function setPosition(node2, position) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      if (level !== void 0) {
        this.layout.hierarchical.addToOrdering(node2, level);
      }
      node2.x = position;
    }
    /** @inheritDoc */
  }, {
    key: "getTreeSize",
    value: function getTreeSize(index2) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);
      return {
        min: res.min_x,
        max: res.max_x
      };
    }
    /** @inheritDoc */
  }, {
    key: "sort",
    value: function sort3(nodeArray) {
      _sortInstanceProperty(nodeArray).call(nodeArray, function(a, b) {
        return a.x - b.x;
      });
    }
    /** @inheritDoc */
  }, {
    key: "fix",
    value: function fix(node2, level) {
      node2.y = this.layout.options.hierarchical.levelSeparation * level;
      node2.options.fixed.y = true;
    }
    /** @inheritDoc */
  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].x += diff;
    }
  }]);
  return VerticalStrategy2;
}(DirectionInterface);
var HorizontalStrategy = /* @__PURE__ */ function(_DirectionInterface2) {
  _inherits(HorizontalStrategy2, _DirectionInterface2);
  var _super2 = _createSuper(HorizontalStrategy2);
  function HorizontalStrategy2(layout) {
    var _this2;
    _classCallCheck(this, HorizontalStrategy2);
    _this2 = _super2.call(this);
    _this2.layout = layout;
    return _this2;
  }
  _createClass(HorizontalStrategy2, [{
    key: "curveType",
    value: function curveType() {
      return "vertical";
    }
    /** @inheritDoc */
  }, {
    key: "getPosition",
    value: function getPosition(node2) {
      return node2.y;
    }
    /** @inheritDoc */
  }, {
    key: "setPosition",
    value: function setPosition(node2, position) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      if (level !== void 0) {
        this.layout.hierarchical.addToOrdering(node2, level);
      }
      node2.y = position;
    }
    /** @inheritDoc */
  }, {
    key: "getTreeSize",
    value: function getTreeSize(index2) {
      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);
      return {
        min: res.min_y,
        max: res.max_y
      };
    }
    /** @inheritDoc */
  }, {
    key: "sort",
    value: function sort3(nodeArray) {
      _sortInstanceProperty(nodeArray).call(nodeArray, function(a, b) {
        return a.y - b.y;
      });
    }
    /** @inheritDoc */
  }, {
    key: "fix",
    value: function fix(node2, level) {
      node2.x = this.layout.options.hierarchical.levelSeparation * level;
      node2.options.fixed.x = true;
    }
    /** @inheritDoc */
  }, {
    key: "shift",
    value: function shift(nodeId, diff) {
      this.layout.body.nodes[nodeId].y += diff;
    }
  }]);
  return HorizontalStrategy2;
}(DirectionInterface);
var $ = _export;
var $every = arrayIteration.every;
var arrayMethodIsStrict = arrayMethodIsStrict$6;
var STRICT_METHOD = arrayMethodIsStrict("every");
$({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
  every: function every(callbackfn) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual = entryVirtual$l;
var every$3 = entryVirtual("Array").every;
var isPrototypeOf = objectIsPrototypeOf;
var method = every$3;
var ArrayPrototype = Array.prototype;
var every$2 = function(it3) {
  var own = it3.every;
  return it3 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it3) && own === ArrayPrototype.every ? method : own;
};
var parent = every$2;
var every$1 = parent;
var every2 = every$1;
var _everyInstanceProperty = /* @__PURE__ */ getDefaultExportFromCjs(every2);
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  var _context9;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = _sliceInstanceProperty(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function fillLevelsByDirectionCyclic(nodes, levels) {
  var edges = new _Set();
  _forEachInstanceProperty(nodes).call(nodes, function(node2) {
    var _context;
    _forEachInstanceProperty(_context = node2.edges).call(_context, function(edge) {
      if (edge.connected) {
        edges.add(edge);
      }
    });
  });
  _forEachInstanceProperty(edges).call(edges, function(edge) {
    var fromId = edge.from.id;
    var toId = edge.to.id;
    if (levels[fromId] == null) {
      levels[fromId] = 0;
    }
    if (levels[toId] == null || levels[fromId] >= levels[toId]) {
      levels[toId] = levels[fromId] + 1;
    }
  });
  return levels;
}
function fillLevelsByDirectionLeaves(nodes) {
  return fillLevelsByDirection(
    // Pick only leaves (nodes without children).
    function(node2) {
      var _context2, _context3;
      return _everyInstanceProperty(
        _context2 = _filterInstanceProperty(
          _context3 = node2.edges
          // Take only visible nodes into account.
        ).call(_context3, function(edge) {
          return nodes.has(edge.toId);
        })
        // Check that all edges lead to this node (leaf).
      ).call(_context2, function(edge) {
        return edge.to === node2;
      });
    },
    // Use the lowest level.
    function(newLevel, oldLevel) {
      return oldLevel > newLevel;
    },
    // Go against the direction of the edges.
    "from",
    nodes
  );
}
function fillLevelsByDirectionRoots(nodes) {
  return fillLevelsByDirection(
    // Pick only roots (nodes without parents).
    function(node2) {
      var _context4, _context5;
      return _everyInstanceProperty(
        _context4 = _filterInstanceProperty(
          _context5 = node2.edges
          // Take only visible nodes into account.
        ).call(_context5, function(edge) {
          return nodes.has(edge.toId);
        })
        // Check that all edges lead from this node (root).
      ).call(_context4, function(edge) {
        return edge.from === node2;
      });
    },
    // Use the highest level.
    function(newLevel, oldLevel) {
      return oldLevel < newLevel;
    },
    // Go in the direction of the edges.
    "to",
    nodes
  );
}
function fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {
  var _context6;
  var levels = _Object$create$1(null);
  var limit = _reduceInstanceProperty(_context6 = _toConsumableArray(_valuesInstanceProperty(nodes).call(nodes))).call(_context6, function(acc, node2) {
    return acc + 1 + node2.edges.length;
  }, 0);
  var edgeIdProp = direction + "Id";
  var newLevelDiff = direction === "to" ? 1 : -1;
  var _iterator = _createForOfIteratorHelper$1(nodes), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), entryNodeId = _step$value[0], entryNode = _step$value[1];
      if (
        // Skip if the node is not visible.
        !nodes.has(entryNodeId) || // Skip if the node is not an entry node.
        !isEntryNode(entryNode)
      ) {
        return 0;
      }
      levels[entryNodeId] = 0;
      var stack = [entryNode];
      var done = 0;
      var node2;
      var _loop22 = function _loop23() {
        var _context7, _context8;
        if (!nodes.has(entryNodeId)) {
          return 0;
        }
        var newLevel = levels[node2.id] + newLevelDiff;
        _forEachInstanceProperty(_context7 = _filterInstanceProperty(_context8 = node2.edges).call(_context8, function(edge) {
          return (
            // Ignore disconnected edges.
            edge.connected && // Ignore circular edges.
            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.
            edge[direction] !== node2 && // Ignore edges connecting to an invisible node.
            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.
            nodes.has(edge.fromId)
          );
        })).call(_context7, function(edge) {
          var targetNodeId = edge[edgeIdProp];
          var oldLevel = levels[targetNodeId];
          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {
            levels[targetNodeId] = newLevel;
            stack.push(edge[direction]);
          }
        });
        if (done > limit) {
          return {
            v: {
              v: fillLevelsByDirectionCyclic(nodes, levels)
            }
          };
        } else {
          ++done;
        }
      }, _ret2;
      while (node2 = stack.pop()) {
        _ret2 = _loop22();
        if (_ret2 === 0)
          continue;
        if (_ret2)
          return _ret2.v;
      }
    }, _ret;
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _ret = _loop();
      if (_ret === 0)
        continue;
      if (_ret)
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return levels;
}
var HierarchicalStatus = /* @__PURE__ */ function() {
  function HierarchicalStatus2() {
    _classCallCheck(this, HierarchicalStatus2);
    this.childrenReference = {};
    this.parentReference = {};
    this.trees = {};
    this.distributionOrdering = {};
    this.levels = {};
    this.distributionIndex = {};
    this.isTree = false;
    this.treeIndex = -1;
  }
  _createClass(HierarchicalStatus2, [{
    key: "addRelation",
    value: function addRelation(parentNodeId, childNodeId) {
      if (this.childrenReference[parentNodeId] === void 0) {
        this.childrenReference[parentNodeId] = [];
      }
      this.childrenReference[parentNodeId].push(childNodeId);
      if (this.parentReference[childNodeId] === void 0) {
        this.parentReference[childNodeId] = [];
      }
      this.parentReference[childNodeId].push(parentNodeId);
    }
    /**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */
  }, {
    key: "checkIfTree",
    value: function checkIfTree() {
      for (var i in this.parentReference) {
        if (this.parentReference[i].length > 1) {
          this.isTree = false;
          return;
        }
      }
      this.isTree = true;
    }
    /**
     * Return the number of separate trees in the current network.
     *
     * @returns {number}
     */
  }, {
    key: "numTrees",
    value: function numTrees() {
      return this.treeIndex + 1;
    }
    /**
     * Assign a tree id to a node
     *
     * @param {Node} node
     * @param {string|number} treeId
     */
  }, {
    key: "setTreeIndex",
    value: function setTreeIndex(node2, treeId) {
      if (treeId === void 0)
        return;
      if (this.trees[node2.id] === void 0) {
        this.trees[node2.id] = treeId;
        this.treeIndex = Math.max(treeId, this.treeIndex);
      }
    }
    /**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */
  }, {
    key: "ensureLevel",
    value: function ensureLevel(nodeId) {
      if (this.levels[nodeId] === void 0) {
        this.levels[nodeId] = 0;
      }
    }
    /**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     *
     * @param {Node.id} nodeId
     * @returns {number}
     */
  }, {
    key: "getMaxLevel",
    value: function getMaxLevel(nodeId) {
      var _this = this;
      var accumulator = {};
      var _getMaxLevel = function _getMaxLevel2(nodeId2) {
        if (accumulator[nodeId2] !== void 0) {
          return accumulator[nodeId2];
        }
        var level = _this.levels[nodeId2];
        if (_this.childrenReference[nodeId2]) {
          var children2 = _this.childrenReference[nodeId2];
          if (children2.length > 0) {
            for (var i = 0; i < children2.length; i++) {
              level = Math.max(level, _getMaxLevel2(children2[i]));
            }
          }
        }
        accumulator[nodeId2] = level;
        return level;
      };
      return _getMaxLevel(nodeId);
    }
    /**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */
  }, {
    key: "levelDownstream",
    value: function levelDownstream(nodeA, nodeB) {
      if (this.levels[nodeB.id] === void 0) {
        if (this.levels[nodeA.id] === void 0) {
          this.levels[nodeA.id] = 0;
        }
        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
      }
    }
    /**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */
  }, {
    key: "setMinLevelToZero",
    value: function setMinLevelToZero(nodes) {
      var minLevel = 1e9;
      for (var nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
          if (this.levels[nodeId] !== void 0) {
            minLevel = Math.min(this.levels[nodeId], minLevel);
          }
        }
      }
      for (var _nodeId in nodes) {
        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {
          if (this.levels[_nodeId] !== void 0) {
            this.levels[_nodeId] -= minLevel;
          }
        }
      }
    }
    /**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */
  }, {
    key: "getTreeSize",
    value: function getTreeSize(nodes, index2) {
      var min_x = 1e9;
      var max_x = -1e9;
      var min_y = 1e9;
      var max_y = -1e9;
      for (var nodeId in this.trees) {
        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {
          if (this.trees[nodeId] === index2) {
            var node2 = nodes[nodeId];
            min_x = Math.min(node2.x, min_x);
            max_x = Math.max(node2.x, max_x);
            min_y = Math.min(node2.y, min_y);
            max_y = Math.max(node2.y, max_y);
          }
        }
      }
      return {
        min_x,
        max_x,
        min_y,
        max_y
      };
    }
    /**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise
     */
  }, {
    key: "hasSameParent",
    value: function hasSameParent(node1, node2) {
      var parents1 = this.parentReference[node1.id];
      var parents2 = this.parentReference[node2.id];
      if (parents1 === void 0 || parents2 === void 0) {
        return false;
      }
      for (var i = 0; i < parents1.length; i++) {
        for (var j2 = 0; j2 < parents2.length; j2++) {
          if (parents1[i] == parents2[j2]) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if this is so, false otherwise
     */
  }, {
    key: "inSameSubNetwork",
    value: function inSameSubNetwork(node1, node2) {
      return this.trees[node1.id] === this.trees[node2.id];
    }
    /**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */
  }, {
    key: "getLevels",
    value: function getLevels() {
      return _Object$keys(this.distributionOrdering);
    }
    /**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */
  }, {
    key: "addToOrdering",
    value: function addToOrdering(node2, level) {
      if (this.distributionOrdering[level] === void 0) {
        this.distributionOrdering[level] = [];
      }
      var isPresent = false;
      var curLevel = this.distributionOrdering[level];
      for (var n in curLevel) {
        if (curLevel[n] === node2) {
          isPresent = true;
          break;
        }
      }
      if (!isPresent) {
        this.distributionOrdering[level].push(node2);
        this.distributionIndex[node2.id] = this.distributionOrdering[level].length - 1;
      }
    }
  }]);
  return HierarchicalStatus2;
}();
var LayoutEngine = /* @__PURE__ */ function() {
  function LayoutEngine2(body) {
    _classCallCheck(this, LayoutEngine2);
    this.body = body;
    this._resetRNG(Math.random() + ":" + _Date$now());
    this.setPhysics = false;
    this.options = {};
    this.optionsBackup = {
      physics: {}
    };
    this.defaultOptions = {
      randomSeed: void 0,
      improvedLayout: true,
      clusterThreshold: 150,
      hierarchical: {
        enabled: false,
        levelSeparation: 150,
        nodeSpacing: 100,
        treeSpacing: 200,
        blockShifting: true,
        edgeMinimization: true,
        parentCentralization: true,
        direction: "UD",
        // UD, DU, LR, RL
        sortMethod: "hubsize"
        // hubsize, directed
      }
    };
    _Object$assign(this.options, this.defaultOptions);
    this.bindEventListeners();
  }
  _createClass(LayoutEngine2, [{
    key: "bindEventListeners",
    value: function bindEventListeners() {
      var _this2 = this;
      this.body.emitter.on("_dataChanged", function() {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_dataLoaded", function() {
        _this2.layoutNetwork();
      });
      this.body.emitter.on("_resetHierarchicalLayout", function() {
        _this2.setupHierarchicalLayout();
      });
      this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function() {
        if (_this2.options.hierarchical.enabled !== true) {
          return;
        }
        var type = _this2.direction.curveType();
        _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
      });
    }
    /**
     *
     * @param {object} options
     * @param {object} allOptions
     * @returns {object}
     */
  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions2) {
      if (options !== void 0) {
        var hierarchical = this.options.hierarchical;
        var prevHierarchicalState = hierarchical.enabled;
        selectiveDeepExtend(["randomSeed", "improvedLayout", "clusterThreshold"], this.options, options);
        mergeOptions(this.options, options, "hierarchical");
        if (options.randomSeed !== void 0) {
          this._resetRNG(options.randomSeed);
        }
        if (hierarchical.enabled === true) {
          if (prevHierarchicalState === true) {
            this.body.emitter.emit("refresh", true);
          }
          if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
            if (hierarchical.levelSeparation > 0) {
              hierarchical.levelSeparation *= -1;
            }
          } else {
            if (hierarchical.levelSeparation < 0) {
              hierarchical.levelSeparation *= -1;
            }
          }
          this.setDirectionStrategy();
          this.body.emitter.emit("_resetHierarchicalLayout");
          return this.adaptAllOptionsForHierarchicalLayout(allOptions2);
        } else {
          if (prevHierarchicalState === true) {
            this.body.emitter.emit("refresh");
            return deepExtend(allOptions2, this.optionsBackup);
          }
        }
      }
      return allOptions2;
    }
    /**
     * Reset the random number generator with given seed.
     *
     * @param {any} seed - The seed that will be forwarded the the RNG.
     */
  }, {
    key: "_resetRNG",
    value: function _resetRNG(seed) {
      this.initialRandomSeed = seed;
      this._rng = Alea(this.initialRandomSeed);
    }
    /**
     *
     * @param {object} allOptions
     * @returns {object}
     */
  }, {
    key: "adaptAllOptionsForHierarchicalLayout",
    value: function adaptAllOptionsForHierarchicalLayout(allOptions2) {
      if (this.options.hierarchical.enabled === true) {
        var backupPhysics = this.optionsBackup.physics;
        if (allOptions2.physics === void 0 || allOptions2.physics === true) {
          allOptions2.physics = {
            enabled: backupPhysics.enabled === void 0 ? true : backupPhysics.enabled,
            solver: "hierarchicalRepulsion"
          };
          backupPhysics.enabled = backupPhysics.enabled === void 0 ? true : backupPhysics.enabled;
          backupPhysics.solver = backupPhysics.solver || "barnesHut";
        } else if (_typeof$1(allOptions2.physics) === "object") {
          backupPhysics.enabled = allOptions2.physics.enabled === void 0 ? true : allOptions2.physics.enabled;
          backupPhysics.solver = allOptions2.physics.solver || "barnesHut";
          allOptions2.physics.solver = "hierarchicalRepulsion";
        } else if (allOptions2.physics !== false) {
          backupPhysics.solver = "barnesHut";
          allOptions2.physics = {
            solver: "hierarchicalRepulsion"
          };
        }
        var type = this.direction.curveType();
        if (allOptions2.edges === void 0) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions2.edges = {
            smooth: false
          };
        } else if (allOptions2.edges.smooth === void 0) {
          this.optionsBackup.edges = {
            smooth: {
              enabled: true,
              type: "dynamic"
            }
          };
          allOptions2.edges.smooth = false;
        } else {
          if (typeof allOptions2.edges.smooth === "boolean") {
            this.optionsBackup.edges = {
              smooth: allOptions2.edges.smooth
            };
            allOptions2.edges.smooth = {
              enabled: allOptions2.edges.smooth,
              type
            };
          } else {
            var smooth = allOptions2.edges.smooth;
            if (smooth.type !== void 0 && smooth.type !== "dynamic") {
              type = smooth.type;
            }
            this.optionsBackup.edges = {
              smooth: {
                enabled: smooth.enabled === void 0 ? true : smooth.enabled,
                type: smooth.type === void 0 ? "dynamic" : smooth.type,
                roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
              }
            };
            allOptions2.edges.smooth = {
              enabled: smooth.enabled === void 0 ? true : smooth.enabled,
              type,
              roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
              forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
            };
          }
        }
        this.body.emitter.emit("_forceDisableDynamicCurves", type);
      }
      return allOptions2;
    }
    /**
     *
     * @param {Array.<Node>} nodesArray
     */
  }, {
    key: "positionInitially",
    value: function positionInitially(nodesArray) {
      if (this.options.hierarchical.enabled !== true) {
        this._resetRNG(this.initialRandomSeed);
        var radius = nodesArray.length + 50;
        for (var i = 0; i < nodesArray.length; i++) {
          var node2 = nodesArray[i];
          var angle = 2 * Math.PI * this._rng();
          if (node2.x === void 0) {
            node2.x = radius * Math.cos(angle);
          }
          if (node2.y === void 0) {
            node2.y = radius * Math.sin(angle);
          }
        }
      }
    }
    /**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */
  }, {
    key: "layoutNetwork",
    value: function layoutNetwork() {
      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
        var indices = this.body.nodeIndices;
        var positionDefined = 0;
        for (var i = 0; i < indices.length; i++) {
          var node2 = this.body.nodes[indices[i]];
          if (node2.predefinedPosition === true) {
            positionDefined += 1;
          }
        }
        if (positionDefined < 0.5 * indices.length) {
          var MAX_LEVELS = 10;
          var level = 0;
          var clusterThreshold = this.options.clusterThreshold;
          var clusterOptions = {
            clusterNodeProperties: {
              shape: "ellipse",
              // Bugfix: avoid type 'image', no images supplied
              label: "",
              // avoid label handling
              group: "",
              // avoid group handling
              font: {
                multi: false
              }
              // avoid font propagation
            },
            clusterEdgeProperties: {
              label: "",
              // avoid label handling
              font: {
                multi: false
              },
              // avoid font propagation
              smooth: {
                enabled: false
                // avoid drawing penalty for complex edges
              }
            }
          };
          if (indices.length > clusterThreshold) {
            var startLength = indices.length;
            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
              level += 1;
              var before2 = indices.length;
              if (level % 3 === 0) {
                this.body.modules.clustering.clusterBridges(clusterOptions);
              } else {
                this.body.modules.clustering.clusterOutliers(clusterOptions);
              }
              var after2 = indices.length;
              if (before2 == after2 && level % 3 !== 0) {
                this._declusterAll();
                this.body.emitter.emit("_layoutFailed");
                console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                return;
              }
            }
            this.body.modules.kamadaKawai.setOptions({
              springLength: Math.max(150, 2 * startLength)
            });
          }
          if (level > MAX_LEVELS) {
            console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result.");
          }
          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);
          this._shiftToCenter();
          var offset = 70;
          for (var _i = 0; _i < indices.length; _i++) {
            var _node = this.body.nodes[indices[_i]];
            if (_node.predefinedPosition === false) {
              _node.x += (0.5 - this._rng()) * offset;
              _node.y += (0.5 - this._rng()) * offset;
            }
          }
          this._declusterAll();
          this.body.emitter.emit("_repositionBezierNodes");
        }
      }
    }
    /**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     *
     * @private
     */
  }, {
    key: "_shiftToCenter",
    value: function _shiftToCenter() {
      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
      var center = NetworkUtil.findCenter(range);
      for (var i = 0; i < this.body.nodeIndices.length; i++) {
        var node2 = this.body.nodes[this.body.nodeIndices[i]];
        node2.x -= center.x;
        node2.y -= center.y;
      }
    }
    /**
     * Expands all clusters
     *
     * @private
     */
  }, {
    key: "_declusterAll",
    value: function _declusterAll() {
      var clustersPresent = true;
      while (clustersPresent === true) {
        clustersPresent = false;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
            clustersPresent = true;
            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
          }
        }
        if (clustersPresent === true) {
          this.body.emitter.emit("_dataChanged");
        }
      }
    }
    /**
     *
     * @returns {number|*}
     */
  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.initialRandomSeed;
    }
    /**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */
  }, {
    key: "setupHierarchicalLayout",
    value: function setupHierarchicalLayout() {
      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
        var node2, nodeId;
        var definedLevel = false;
        var undefinedLevel = false;
        this.lastNodeOnLevel = {};
        this.hierarchical = new HierarchicalStatus();
        for (nodeId in this.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
            node2 = this.body.nodes[nodeId];
            if (node2.options.level !== void 0) {
              definedLevel = true;
              this.hierarchical.levels[nodeId] = node2.options.level;
            } else {
              undefinedLevel = true;
            }
          }
        }
        if (undefinedLevel === true && definedLevel === true) {
          throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");
        } else {
          if (undefinedLevel === true) {
            var sortMethod = this.options.hierarchical.sortMethod;
            if (sortMethod === "hubsize") {
              this._determineLevelsByHubsize();
            } else if (sortMethod === "directed") {
              this._determineLevelsDirected();
            } else if (sortMethod === "custom") {
              this._determineLevelsCustomCallback();
            }
          }
          for (var _nodeId2 in this.body.nodes) {
            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {
              this.hierarchical.ensureLevel(_nodeId2);
            }
          }
          var distribution = this._getDistribution();
          this._generateMap();
          this._placeNodesByHierarchy(distribution);
          this._condenseHierarchy();
          this._shiftToCenter();
        }
      }
    }
    /**
     * @private
     */
  }, {
    key: "_condenseHierarchy",
    value: function _condenseHierarchy() {
      var _this3 = this;
      var stillShifting = false;
      var branches = {};
      var shiftTrees = function shiftTrees2() {
        var treeSizes = getTreeSizes();
        var shiftBy = 0;
        for (var i = 0; i < treeSizes.length - 1; i++) {
          var diff = treeSizes[i].max - treeSizes[i + 1].min;
          shiftBy += diff + _this3.options.hierarchical.treeSpacing;
          shiftTree(i + 1, shiftBy);
        }
      };
      var shiftTree = function shiftTree2(index2, offset) {
        var trees = _this3.hierarchical.trees;
        for (var nodeId in trees) {
          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {
            if (trees[nodeId] === index2) {
              _this3.direction.shift(nodeId, offset);
            }
          }
        }
      };
      var getTreeSizes = function getTreeSizes2() {
        var treeWidths = [];
        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
          treeWidths.push(_this3.direction.getTreeSize(i));
        }
        return treeWidths;
      };
      var getBranchNodes = function getBranchNodes2(source, map3) {
        if (map3[source.id]) {
          return;
        }
        map3[source.id] = true;
        if (_this3.hierarchical.childrenReference[source.id]) {
          var children2 = _this3.hierarchical.childrenReference[source.id];
          if (children2.length > 0) {
            for (var i = 0; i < children2.length; i++) {
              getBranchNodes2(_this3.body.nodes[children2[i]], map3);
            }
          }
        }
      };
      var getBranchBoundary = function getBranchBoundary2(branchMap) {
        var maxLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e9;
        var minSpace = 1e9;
        var maxSpace = 1e9;
        var min2 = 1e9;
        var max2 = -1e9;
        for (var branchNode in branchMap) {
          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {
            var node2 = _this3.body.nodes[branchNode];
            var level = _this3.hierarchical.levels[node2.id];
            var position = _this3.direction.getPosition(node2);
            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node2, branchMap), _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2), minSpaceNode = _this3$_getSpaceAroun2[0], maxSpaceNode = _this3$_getSpaceAroun2[1];
            minSpace = Math.min(minSpaceNode, minSpace);
            maxSpace = Math.min(maxSpaceNode, maxSpace);
            if (level <= maxLevel) {
              min2 = Math.min(position, min2);
              max2 = Math.max(position, max2);
            }
          }
        }
        return [min2, max2, minSpace, maxSpace];
      };
      var getCollisionLevel = function getCollisionLevel2(node1, node2) {
        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);
        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);
        return Math.min(maxLevel1, maxLevel2);
      };
      var shiftElementsCloser = function shiftElementsCloser2(callback, levels, centerParents) {
        var hier = _this3.hierarchical;
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = hier.distributionOrdering[level];
          if (levelNodes.length > 1) {
            for (var j2 = 0; j2 < levelNodes.length - 1; j2++) {
              var node1 = levelNodes[j2];
              var node2 = levelNodes[j2 + 1];
              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                callback(node1, node2, centerParents);
              }
            }
          }
        }
      };
      var branchShiftCallback = function branchShiftCallback2(node1, node2) {
        var centerParent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var pos1 = _this3.direction.getPosition(node1);
        var pos2 = _this3.direction.getPosition(node2);
        var diffAbs = Math.abs(pos2 - pos1);
        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;
        if (diffAbs > nodeSpacing) {
          var branchNodes1 = {};
          var branchNodes2 = {};
          getBranchNodes(node1, branchNodes1);
          getBranchNodes(node2, branchNodes2);
          var maxLevel = getCollisionLevel(node1, node2);
          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
          var max1 = branchNodeBoundary1[1];
          var min2 = branchNodeBoundary2[0];
          var minSpace2 = branchNodeBoundary2[2];
          var diffBranch = Math.abs(max1 - min2);
          if (diffBranch > nodeSpacing) {
            var offset = max1 - min2 + nodeSpacing;
            if (offset < -minSpace2 + nodeSpacing) {
              offset = -minSpace2 + nodeSpacing;
            }
            if (offset < 0) {
              _this3._shiftBlock(node2.id, offset);
              stillShifting = true;
              if (centerParent === true)
                _this3._centerParent(node2);
            }
          }
        }
      };
      var minimizeEdgeLength = function minimizeEdgeLength2(iterations, node2) {
        var nodeId = node2.id;
        var allEdges = node2.edges;
        var nodeLevel = _this3.hierarchical.levels[node2.id];
        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
        var referenceNodes = {};
        var aboveEdges = [];
        for (var i = 0; i < allEdges.length; i++) {
          var edge = allEdges[i];
          if (edge.toId != edge.fromId) {
            var otherNode = edge.toId == nodeId ? edge.from : edge.to;
            referenceNodes[allEdges[i].id] = otherNode;
            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
              aboveEdges.push(edge);
            }
          }
        }
        var getFx = function getFx2(point, edges) {
          var sum = 0;
          for (var _i2 = 0; _i2 < edges.length; _i2++) {
            if (referenceNodes[edges[_i2].id] !== void 0) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
              sum += a / Math.sqrt(a * a + C2);
            }
          }
          return sum;
        };
        var getDFx = function getDFx2(point, edges) {
          var sum = 0;
          for (var _i3 = 0; _i3 < edges.length; _i3++) {
            if (referenceNodes[edges[_i3].id] !== void 0) {
              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
              sum -= C2 * Math.pow(a * a + C2, -1.5);
            }
          }
          return sum;
        };
        var getGuess = function getGuess2(iterations2, edges) {
          var guess2 = _this3.direction.getPosition(node2);
          var guessMap = {};
          for (var _i4 = 0; _i4 < iterations2; _i4++) {
            var fx = getFx(guess2, edges);
            var dfx = getDFx(guess2, edges);
            var limit = 40;
            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
            guess2 = guess2 - ratio;
            if (guessMap[guess2] !== void 0) {
              break;
            }
            guessMap[guess2] = _i4;
          }
          return guess2;
        };
        var moveBranch = function moveBranch2(guess2) {
          var nodePosition = _this3.direction.getPosition(node2);
          if (branches[node2.id] === void 0) {
            var branchNodes = {};
            getBranchNodes(node2, branchNodes);
            branches[node2.id] = branchNodes;
          }
          var branchBoundary = getBranchBoundary(branches[node2.id]);
          var minSpaceBranch = branchBoundary[2];
          var maxSpaceBranch = branchBoundary[3];
          var diff = guess2 - nodePosition;
          var branchOffset = 0;
          if (diff > 0) {
            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          } else if (diff < 0) {
            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
          }
          if (branchOffset != 0) {
            _this3._shiftBlock(node2.id, branchOffset);
            stillShifting = true;
          }
        };
        var moveNode = function moveNode2(guess2) {
          var nodePosition = _this3.direction.getPosition(node2);
          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node2), _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2), minSpace = _this3$_getSpaceAroun4[0], maxSpace = _this3$_getSpaceAroun4[1];
          var diff = guess2 - nodePosition;
          var newPosition = nodePosition;
          if (diff > 0) {
            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess2);
          } else if (diff < 0) {
            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess2);
          }
          if (newPosition !== nodePosition) {
            _this3.direction.setPosition(node2, newPosition);
            stillShifting = true;
          }
        };
        var guess = getGuess(iterations, aboveEdges);
        moveBranch(guess);
        guess = getGuess(iterations, allEdges);
        moveNode(guess);
      };
      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp2(iterations) {
        var levels = _this3.hierarchical.getLevels();
        levels = _reverseInstanceProperty(levels).call(levels);
        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          for (var j2 = 0; j2 < levels.length; j2++) {
            var level = levels[j2];
            var levelNodes = _this3.hierarchical.distributionOrdering[level];
            for (var k = 0; k < levelNodes.length; k++) {
              minimizeEdgeLength(1e3, levelNodes[k]);
            }
          }
          if (stillShifting !== true) {
            break;
          }
        }
      };
      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp2(iterations) {
        var levels = _this3.hierarchical.getLevels();
        levels = _reverseInstanceProperty(levels).call(levels);
        for (var i = 0; i < iterations; i++) {
          stillShifting = false;
          shiftElementsCloser(branchShiftCallback, levels, true);
          if (stillShifting !== true) {
            break;
          }
        }
      };
      var centerAllParents = function centerAllParents2() {
        for (var nodeId in _this3.body.nodes) {
          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId))
            _this3._centerParent(_this3.body.nodes[nodeId]);
        }
      };
      var centerAllParentsBottomUp = function centerAllParentsBottomUp2() {
        var levels = _this3.hierarchical.getLevels();
        levels = _reverseInstanceProperty(levels).call(levels);
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          var levelNodes = _this3.hierarchical.distributionOrdering[level];
          for (var j2 = 0; j2 < levelNodes.length; j2++) {
            _this3._centerParent(levelNodes[j2]);
          }
        }
      };
      if (this.options.hierarchical.blockShifting === true) {
        shiftBranchesCloserBottomUp(5);
        centerAllParents();
      }
      if (this.options.hierarchical.edgeMinimization === true) {
        minimizeEdgeLengthBottomUp(20);
      }
      if (this.options.hierarchical.parentCentralization === true) {
        centerAllParentsBottomUp();
      }
      shiftTrees();
    }
    /**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     *
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */
  }, {
    key: "_getSpaceAroundNode",
    value: function _getSpaceAroundNode(node2, map3) {
      var useMap = true;
      if (map3 === void 0) {
        useMap = false;
      }
      var level = this.hierarchical.levels[node2.id];
      if (level !== void 0) {
        var index2 = this.hierarchical.distributionIndex[node2.id];
        var position = this.direction.getPosition(node2);
        var ordering = this.hierarchical.distributionOrdering[level];
        var minSpace = 1e9;
        var maxSpace = 1e9;
        if (index2 !== 0) {
          var prevNode = ordering[index2 - 1];
          if (useMap === true && map3[prevNode.id] === void 0 || useMap === false) {
            var prevPos = this.direction.getPosition(prevNode);
            minSpace = position - prevPos;
          }
        }
        if (index2 != ordering.length - 1) {
          var nextNode = ordering[index2 + 1];
          if (useMap === true && map3[nextNode.id] === void 0 || useMap === false) {
            var nextPos = this.direction.getPosition(nextNode);
            maxSpace = Math.min(maxSpace, nextPos - position);
          }
        }
        return [minSpace, maxSpace];
      } else {
        return [0, 0];
      }
    }
    /**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     *
     * @param {Node} node
     * @private
     */
  }, {
    key: "_centerParent",
    value: function _centerParent(node2) {
      if (this.hierarchical.parentReference[node2.id]) {
        var parents2 = this.hierarchical.parentReference[node2.id];
        for (var i = 0; i < parents2.length; i++) {
          var parentId = parents2[i];
          var parentNode = this.body.nodes[parentId];
          var children2 = this.hierarchical.childrenReference[parentId];
          if (children2 !== void 0) {
            var newPosition = this._getCenterPosition(children2);
            var position = this.direction.getPosition(parentNode);
            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode), _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2), minSpace = _this$_getSpaceAround2[0], maxSpace = _this$_getSpaceAround2[1];
            var diff = position - newPosition;
            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
              this.direction.setPosition(parentNode, newPosition);
            }
          }
        }
      }
    }
    /**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {object} distribution | obtained by the function this._getDistribution()
     * @private
     */
  }, {
    key: "_placeNodesByHierarchy",
    value: function _placeNodesByHierarchy(distribution) {
      this.positionedNodes = {};
      for (var level in distribution) {
        if (Object.prototype.hasOwnProperty.call(distribution, level)) {
          var _context;
          var nodeArray = _Object$keys(distribution[level]);
          nodeArray = this._indexArrayToNodes(nodeArray);
          _sortInstanceProperty(_context = this.direction).call(_context, nodeArray);
          var handledNodeCount = 0;
          for (var i = 0; i < nodeArray.length; i++) {
            var node2 = nodeArray[i];
            if (this.positionedNodes[node2.id] === void 0) {
              var spacing = this.options.hierarchical.nodeSpacing;
              var pos = spacing * handledNodeCount;
              if (handledNodeCount > 0) {
                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
              }
              this.direction.setPosition(node2, pos, level);
              this._validatePositionAndContinue(node2, level, pos);
              handledNodeCount++;
            }
          }
        }
      }
    }
    /**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */
  }, {
    key: "_placeBranchNodes",
    value: function _placeBranchNodes(parentId, parentLevel) {
      var _context2;
      var childRef = this.hierarchical.childrenReference[parentId];
      if (childRef === void 0) {
        return;
      }
      var childNodes = [];
      for (var i = 0; i < childRef.length; i++) {
        childNodes.push(this.body.nodes[childRef[i]]);
      }
      _sortInstanceProperty(_context2 = this.direction).call(_context2, childNodes);
      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
        var childNode = childNodes[_i5];
        var childNodeLevel = this.hierarchical.levels[childNode.id];
        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === void 0) {
          var spacing = this.options.hierarchical.nodeSpacing;
          var pos = void 0;
          if (_i5 === 0) {
            pos = this.direction.getPosition(this.body.nodes[parentId]);
          } else {
            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
          }
          this.direction.setPosition(childNode, pos, childNodeLevel);
          this._validatePositionAndContinue(childNode, childNodeLevel, pos);
        } else {
          return;
        }
      }
      var center = this._getCenterPosition(childNodes);
      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
    }
    /**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     *
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */
  }, {
    key: "_validatePositionAndContinue",
    value: function _validatePositionAndContinue(node2, level, pos) {
      if (!this.hierarchical.isTree)
        return;
      if (this.lastNodeOnLevel[level] !== void 0) {
        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);
        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node2.id);
          this._shiftBlock(sharedParent.withChild, diff);
        }
      }
      this.lastNodeOnLevel[level] = node2.id;
      this.positionedNodes[node2.id] = true;
      this._placeBranchNodes(node2.id, level);
    }
    /**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     *
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */
  }, {
    key: "_indexArrayToNodes",
    value: function _indexArrayToNodes(idArray) {
      var array2 = [];
      for (var i = 0; i < idArray.length; i++) {
        array2.push(this.body.nodes[idArray[i]]);
      }
      return array2;
    }
    /**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {object}
     * @private
     */
  }, {
    key: "_getDistribution",
    value: function _getDistribution() {
      var distribution = {};
      var nodeId, node2;
      for (nodeId in this.body.nodes) {
        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {
          node2 = this.body.nodes[nodeId];
          var level = this.hierarchical.levels[nodeId] === void 0 ? 0 : this.hierarchical.levels[nodeId];
          this.direction.fix(node2, level);
          if (distribution[level] === void 0) {
            distribution[level] = {};
          }
          distribution[level][nodeId] = node2;
        }
      }
      return distribution;
    }
    /**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */
  }, {
    key: "_getActiveEdges",
    value: function _getActiveEdges(node2) {
      var _this4 = this;
      var result = [];
      forEach$4(node2.edges, function(edge) {
        var _context3;
        if (_indexOfInstanceProperty(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {
          result.push(edge);
        }
      });
      return result;
    }
    /**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */
  }, {
    key: "_getHubSizes",
    value: function _getHubSizes() {
      var _this5 = this;
      var hubSizes = {};
      var nodeIds = this.body.nodeIndices;
      forEach$4(nodeIds, function(nodeId) {
        var node2 = _this5.body.nodes[nodeId];
        var hubSize = _this5._getActiveEdges(node2).length;
        hubSizes[hubSize] = true;
      });
      var result = [];
      forEach$4(hubSizes, function(size) {
        result.push(Number(size));
      });
      _sortInstanceProperty(result).call(result, function(a, b) {
        return b - a;
      });
      return result;
    }
    /**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */
  }, {
    key: "_determineLevelsByHubsize",
    value: function _determineLevelsByHubsize() {
      var _this6 = this;
      var levelDownstream = function levelDownstream2(nodeA, nodeB) {
        _this6.hierarchical.levelDownstream(nodeA, nodeB);
      };
      var hubSizes = this._getHubSizes();
      var _loop = function _loop2() {
        var hubSize = hubSizes[i];
        if (hubSize === 0)
          return 1;
        forEach$4(_this6.body.nodeIndices, function(nodeId) {
          var node2 = _this6.body.nodes[nodeId];
          if (hubSize === _this6._getActiveEdges(node2).length) {
            _this6._crawlNetwork(levelDownstream, nodeId);
          }
        });
      };
      for (var i = 0; i < hubSizes.length; ++i) {
        if (_loop())
          break;
      }
    }
    /**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */
  }, {
    key: "_determineLevelsCustomCallback",
    value: function _determineLevelsCustomCallback() {
      var _this7 = this;
      var minLevel = 1e5;
      var customCallback = function customCallback2(nodeA, nodeB, edge) {
      };
      var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
        var levelA = _this7.hierarchical.levels[nodeA.id];
        if (levelA === void 0) {
          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
        }
        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
        _this7.hierarchical.levels[nodeB.id] = levelA + diff;
      };
      this._crawlNetwork(levelByDirection);
      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */
  }, {
    key: "_determineLevelsDirected",
    value: function _determineLevelsDirected() {
      var _context4, _this8 = this;
      var nodes = _reduceInstanceProperty(_context4 = this.body.nodeIndices).call(_context4, function(acc, id2) {
        acc.set(id2, _this8.body.nodes[id2]);
        return acc;
      }, new _Map());
      if (this.options.hierarchical.shakeTowards === "roots") {
        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);
      } else {
        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);
      }
      this.hierarchical.setMinLevelToZero(this.body.nodes);
    }
    /**
     * Update the bookkeeping of parent and child.
     *
     * @private
     */
  }, {
    key: "_generateMap",
    value: function _generateMap() {
      var _this9 = this;
      var fillInRelations = function fillInRelations2(parentNode, childNode) {
        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
          _this9.hierarchical.addRelation(parentNode.id, childNode.id);
        }
      };
      this._crawlNetwork(fillInRelations);
      this.hierarchical.checkIfTree();
    }
    /**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     *
     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */
  }, {
    key: "_crawlNetwork",
    value: function _crawlNetwork() {
      var _this10 = this;
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      var startingNodeId = arguments.length > 1 ? arguments[1] : void 0;
      var progress = {};
      var crawler = function crawler2(node3, tree) {
        if (progress[node3.id] === void 0) {
          _this10.hierarchical.setTreeIndex(node3, tree);
          progress[node3.id] = true;
          var childNode;
          var edges = _this10._getActiveEdges(node3);
          for (var i2 = 0; i2 < edges.length; i2++) {
            var edge = edges[i2];
            if (edge.connected === true) {
              if (edge.toId == node3.id) {
                childNode = edge.from;
              } else {
                childNode = edge.to;
              }
              if (node3.id != childNode.id) {
                callback(node3, childNode, edge);
                crawler2(childNode, tree);
              }
            }
          }
        }
      };
      if (startingNodeId === void 0) {
        var treeIndex = 0;
        for (var i = 0; i < this.body.nodeIndices.length; i++) {
          var nodeId = this.body.nodeIndices[i];
          if (progress[nodeId] === void 0) {
            var node2 = this.body.nodes[nodeId];
            crawler(node2, treeIndex);
            treeIndex += 1;
          }
        }
      } else {
        var _node2 = this.body.nodes[startingNodeId];
        if (_node2 === void 0) {
          console.error("Node not found:", startingNodeId);
          return;
        }
        crawler(_node2);
      }
    }
    /**
     * Shift a branch a certain distance
     *
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */
  }, {
    key: "_shiftBlock",
    value: function _shiftBlock(parentId, diff) {
      var _this11 = this;
      var progress = {};
      var shifter = function shifter2(parentId2) {
        if (progress[parentId2]) {
          return;
        }
        progress[parentId2] = true;
        _this11.direction.shift(parentId2, diff);
        var childRef = _this11.hierarchical.childrenReference[parentId2];
        if (childRef !== void 0) {
          for (var i = 0; i < childRef.length; i++) {
            shifter2(childRef[i]);
          }
        }
      };
      shifter(parentId);
    }
    /**
     * Find a common parent between branches.
     *
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */
  }, {
    key: "_findCommonParent",
    value: function _findCommonParent(childA, childB) {
      var _this12 = this;
      var parents2 = {};
      var iterateParents = function iterateParents2(parents3, child) {
        var parentRef = _this12.hierarchical.parentReference[child];
        if (parentRef !== void 0) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent2 = parentRef[i];
            parents3[parent2] = true;
            iterateParents2(parents3, parent2);
          }
        }
      };
      var findParent = function findParent2(parents3, child) {
        var parentRef = _this12.hierarchical.parentReference[child];
        if (parentRef !== void 0) {
          for (var i = 0; i < parentRef.length; i++) {
            var parent2 = parentRef[i];
            if (parents3[parent2] !== void 0) {
              return {
                foundParent: parent2,
                withChild: child
              };
            }
            var branch = findParent2(parents3, parent2);
            if (branch.foundParent !== null) {
              return branch;
            }
          }
        }
        return {
          foundParent: null,
          withChild: child
        };
      };
      iterateParents(parents2, childA);
      return findParent(parents2, childB);
    }
    /**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */
  }, {
    key: "setDirectionStrategy",
    value: function setDirectionStrategy() {
      var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";
      if (isVertical) {
        this.direction = new VerticalStrategy(this);
      } else {
        this.direction = new HorizontalStrategy(this);
      }
    }
    /**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     *
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @returns {number}
     * @private
     */
  }, {
    key: "_getCenterPosition",
    value: function _getCenterPosition(childNodes) {
      var minPos = 1e9;
      var maxPos = -1e9;
      for (var i = 0; i < childNodes.length; i++) {
        var childNode = void 0;
        if (childNodes[i].id !== void 0) {
          childNode = childNodes[i];
        } else {
          var childNodeId = childNodes[i];
          childNode = this.body.nodes[childNodeId];
        }
        var position = this.direction.getPosition(childNode);
        minPos = Math.min(minPos, position);
        maxPos = Math.max(maxPos, position);
      }
      return 0.5 * (minPos + maxPos);
    }
  }]);
  return LayoutEngine2;
}();
var css_248z = "div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style: solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #ffffff),\n    color-stop(48%, #fcfcfc),\n    color-stop(50%, #fafafa),\n    color-stop(100%, #fcfcfc)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top: 4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode,\ndiv.vis-network button.vis-edit-mode {\n  position: absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network button.vis-close {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-color: transparent;\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  border: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network button.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button,\ndiv.vis-network div.vis-edit-mode button.vis-button {\n  float: left;\n  font-family: verdana;\n  font-size: 12px;\n  border: none;\n  box-sizing: content-box;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  background-color: transparent;\n  background-position: 0px 0px;\n  background-repeat: no-repeat;\n  height: 24px;\n  margin-left: 10px;\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.5);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-back {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n}\ndiv.vis-network div.vis-manipulation div.vis-none {\n  padding: 0px;\n  line-height: 23px;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-add {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float: left;\n  display: inline-block;\n  width: 1px;\n  height: 21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";
styleInject(css_248z);
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it3 = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
  if (!it3) {
    if (_Array$isArray(o) || (it3 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it3)
        o = it3;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it3 = it3.call(o);
  }, n: function n() {
    var step = it3.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it3.return != null)
        it3.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  var _context32;
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = _sliceInstanceProperty(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return _Array$from$1(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var ManipulationSystem = /* @__PURE__ */ function() {
  function ManipulationSystem2(body, canvas, selectionHandler, interactionHandler) {
    var _this = this, _context, _context2;
    _classCallCheck(this, ManipulationSystem2);
    this.body = body;
    this.canvas = canvas;
    this.selectionHandler = selectionHandler;
    this.interactionHandler = interactionHandler;
    this.editMode = false;
    this.manipulationDiv = void 0;
    this.editModeDiv = void 0;
    this.closeDiv = void 0;
    this._domEventListenerCleanupQueue = [];
    this.temporaryUIFunctions = {};
    this.temporaryEventFunctions = [];
    this.touchTime = 0;
    this.temporaryIds = {
      nodes: [],
      edges: []
    };
    this.guiEnabled = false;
    this.inMode = false;
    this.selectedControlNode = void 0;
    this.options = {};
    this.defaultOptions = {
      enabled: false,
      initiallyActive: false,
      addNode: true,
      addEdge: true,
      editNode: void 0,
      editEdge: true,
      deleteNode: true,
      deleteEdge: true,
      controlNodeStyle: {
        shape: "dot",
        size: 6,
        color: {
          background: "#ff0000",
          border: "#3c3c3c",
          highlight: {
            background: "#07f968",
            border: "#3c3c3c"
          }
        },
        borderWidth: 2,
        borderWidthSelected: 2
      }
    };
    _Object$assign(this.options, this.defaultOptions);
    this.body.emitter.on("destroy", function() {
      _this._clean();
    });
    this.body.emitter.on("_dataChanged", _bindInstanceProperty$1(_context = this._restore).call(_context, this));
    this.body.emitter.on("_resetData", _bindInstanceProperty$1(_context2 = this._restore).call(_context2, this));
  }
  _createClass(ManipulationSystem2, [{
    key: "_restore",
    value: function _restore() {
      if (this.inMode !== false) {
        if (this.options.initiallyActive === true) {
          this.enableEditMode();
        } else {
          this.disableEditMode();
        }
      }
    }
    /**
     * Set the Options
     *
     * @param {object} options
     * @param {object} allOptions
     * @param {object} globalOptions
     */
  }, {
    key: "setOptions",
    value: function setOptions(options, allOptions2, globalOptions) {
      if (allOptions2 !== void 0) {
        if (allOptions2.locale !== void 0) {
          this.options.locale = allOptions2.locale;
        } else {
          this.options.locale = globalOptions.locale;
        }
        if (allOptions2.locales !== void 0) {
          this.options.locales = allOptions2.locales;
        } else {
          this.options.locales = globalOptions.locales;
        }
      }
      if (options !== void 0) {
        if (typeof options === "boolean") {
          this.options.enabled = options;
        } else {
          this.options.enabled = true;
          deepExtend(this.options, options);
        }
        if (this.options.initiallyActive === true) {
          this.editMode = true;
        }
        this._setup();
      }
    }
    /**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */
  }, {
    key: "toggleEditMode",
    value: function toggleEditMode() {
      if (this.editMode === true) {
        this.disableEditMode();
      } else {
        this.enableEditMode();
      }
    }
    /**
     * Enables Edit Mode
     */
  }, {
    key: "enableEditMode",
    value: function enableEditMode() {
      this.editMode = true;
      this._clean();
      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        this.editModeDiv.style.display = "none";
        this.showManipulatorToolbar();
      }
    }
    /**
     * Disables Edit Mode
     */
  }, {
    key: "disableEditMode",
    value: function disableEditMode() {
      this.editMode = false;
      this._clean();
      if (this.guiEnabled === true) {
        this.manipulationDiv.style.display = "none";
        this.closeDiv.style.display = "none";
        this.editModeDiv.style.display = "block";
        this._createEditButton();
      }
    }
    /**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */
  }, {
    key: "showManipulatorToolbar",
    value: function showManipulatorToolbar() {
      this._clean();
      this.manipulationDOM = {};
      if (this.guiEnabled === true) {
        var _context3, _context4;
        this.editMode = true;
        this.manipulationDiv.style.display = "block";
        this.closeDiv.style.display = "block";
        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();
        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();
        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
        var locale = this.options.locales[this.options.locale];
        var needSeperator = false;
        if (this.options.addNode !== false) {
          this._createAddNodeButton(locale);
          needSeperator = true;
        }
        if (this.options.addEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(1);
          } else {
            needSeperator = true;
          }
          this._createAddEdgeButton(locale);
        }
        if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
          if (needSeperator === true) {
            this._createSeperator(2);
          } else {
            needSeperator = true;
          }
          this._createEditNodeButton(locale);
        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
          if (needSeperator === true) {
            this._createSeperator(3);
          } else {
            needSeperator = true;
          }
          this._createEditEdgeButton(locale);
        }
        if (selectedTotalCount !== 0) {
          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }
            this._createDeleteButton(locale);
          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
            if (needSeperator === true) {
              this._createSeperator(4);
            }
            this._createDeleteButton(locale);
          }
        }
        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context3 = this.toggleEditMode).call(_context3, this));
        this._temporaryBindEvent("select", _bindInstanceProperty$1(_context4 = this.showManipulatorToolbar).call(_context4, this));
      }
      this.body.emitter.emit("_redraw");
    }
    /**
     * Create the toolbar for adding Nodes
     */
  }, {
    key: "addNodeMode",
    value: function addNodeMode() {
      var _context6;
      if (this.editMode !== true) {
        this.enableEditMode();
      }
      this._clean();
      this.inMode = "addNode";
      if (this.guiEnabled === true) {
        var _context5;
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]);
        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context5 = this.toggleEditMode).call(_context5, this));
      }
      this._temporaryBindEvent("click", _bindInstanceProperty$1(_context6 = this._performAddNode).call(_context6, this));
    }
    /**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */
  }, {
    key: "editNode",
    value: function editNode() {
      var _this2 = this;
      if (this.editMode !== true) {
        this.enableEditMode();
      }
      this._clean();
      var node2 = this.selectionHandler.getSelectedNodes()[0];
      if (node2 !== void 0) {
        this.inMode = "editNode";
        if (typeof this.options.editNode === "function") {
          if (node2.isCluster !== true) {
            var data2 = deepExtend({}, node2.options, false);
            data2.x = node2.x;
            data2.y = node2.y;
            if (this.options.editNode.length === 2) {
              this.options.editNode(data2, function(finalizedData) {
                if (finalizedData !== null && finalizedData !== void 0 && _this2.inMode === "editNode") {
                  _this2.body.data.nodes.getDataSet().update(finalizedData);
                }
                _this2.showManipulatorToolbar();
              });
            } else {
              throw new Error("The function for edit does not support two arguments (data, callback)");
            }
          } else {
            alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
          }
        } else {
          throw new Error("No function has been configured to handle the editing of nodes.");
        }
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * create the toolbar to connect nodes
     */
  }, {
    key: "addEdgeMode",
    value: function addEdgeMode() {
      var _context8, _context9, _context10, _context11, _context12;
      if (this.editMode !== true) {
        this.enableEditMode();
      }
      this._clean();
      this.inMode = "addEdge";
      if (this.guiEnabled === true) {
        var _context7;
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]);
        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context7 = this.toggleEditMode).call(_context7, this));
      }
      this._temporaryBindUI("onTouch", _bindInstanceProperty$1(_context8 = this._handleConnect).call(_context8, this));
      this._temporaryBindUI("onDragEnd", _bindInstanceProperty$1(_context9 = this._finishConnect).call(_context9, this));
      this._temporaryBindUI("onDrag", _bindInstanceProperty$1(_context10 = this._dragControlNode).call(_context10, this));
      this._temporaryBindUI("onRelease", _bindInstanceProperty$1(_context11 = this._finishConnect).call(_context11, this));
      this._temporaryBindUI("onDragStart", _bindInstanceProperty$1(_context12 = this._dragStartEdge).call(_context12, this));
      this._temporaryBindUI("onHold", function() {
      });
    }
    /**
     * create the toolbar to edit edges
     */
  }, {
    key: "editEdgeMode",
    value: function editEdgeMode() {
      if (this.editMode !== true) {
        this.enableEditMode();
      }
      this._clean();
      this.inMode = "editEdge";
      if (_typeof$1(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];
        if (this.edgeBeingEditedId !== void 0) {
          var edge = this.body.edges[this.edgeBeingEditedId];
          this._performEditEdge(edge.from.id, edge.to.id);
          return;
        }
      }
      if (this.guiEnabled === true) {
        var _context13;
        var locale = this.options.locales[this.options.locale];
        this.manipulationDOM = {};
        this._createBackButton(locale);
        this._createSeperator();
        this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]);
        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context13 = this.toggleEditMode).call(_context13, this));
      }
      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];
      if (this.edgeBeingEditedId !== void 0) {
        var _context14, _context15, _context16, _context17;
        var _edge = this.body.edges[this.edgeBeingEditedId];
        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);
        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);
        this.temporaryIds.nodes.push(controlNodeFrom.id);
        this.temporaryIds.nodes.push(controlNodeTo.id);
        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
        this.body.nodeIndices.push(controlNodeFrom.id);
        this.body.nodes[controlNodeTo.id] = controlNodeTo;
        this.body.nodeIndices.push(controlNodeTo.id);
        this._temporaryBindUI("onTouch", _bindInstanceProperty$1(_context14 = this._controlNodeTouch).call(_context14, this));
        this._temporaryBindUI("onTap", function() {
        });
        this._temporaryBindUI("onHold", function() {
        });
        this._temporaryBindUI("onDragStart", _bindInstanceProperty$1(_context15 = this._controlNodeDragStart).call(_context15, this));
        this._temporaryBindUI("onDrag", _bindInstanceProperty$1(_context16 = this._controlNodeDrag).call(_context16, this));
        this._temporaryBindUI("onDragEnd", _bindInstanceProperty$1(_context17 = this._controlNodeDragEnd).call(_context17, this));
        this._temporaryBindUI("onMouseMove", function() {
        });
        this._temporaryBindEvent("beforeDrawing", function(ctx) {
          var positions = _edge.edgeType.findBorderPositions(ctx);
          if (controlNodeFrom.selected === false) {
            controlNodeFrom.x = positions.from.x;
            controlNodeFrom.y = positions.from.y;
          }
          if (controlNodeTo.selected === false) {
            controlNodeTo.x = positions.to.x;
            controlNodeTo.y = positions.to.y;
          }
        });
        this.body.emitter.emit("_redraw");
      } else {
        this.showManipulatorToolbar();
      }
    }
    /**
     * delete everything in the selection
     */
  }, {
    key: "deleteSelected",
    value: function deleteSelected() {
      var _this3 = this;
      if (this.editMode !== true) {
        this.enableEditMode();
      }
      this._clean();
      this.inMode = "delete";
      var selectedNodes = this.selectionHandler.getSelectedNodeIds();
      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();
      var deleteFunction = void 0;
      if (selectedNodes.length > 0) {
        for (var i = 0; i < selectedNodes.length; i++) {
          if (this.body.nodes[selectedNodes[i]].isCluster === true) {
            alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
            return;
          }
        }
        if (typeof this.options.deleteNode === "function") {
          deleteFunction = this.options.deleteNode;
        }
      } else if (selectedEdges.length > 0) {
        if (typeof this.options.deleteEdge === "function") {
          deleteFunction = this.options.deleteEdge;
        }
      }
      if (typeof deleteFunction === "function") {
        var data2 = {
          nodes: selectedNodes,
          edges: selectedEdges
        };
        if (deleteFunction.length === 2) {
          deleteFunction(data2, function(finalizedData) {
            if (finalizedData !== null && finalizedData !== void 0 && _this3.inMode === "delete") {
              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);
              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);
              _this3.body.emitter.emit("startSimulation");
              _this3.showManipulatorToolbar();
            } else {
              _this3.body.emitter.emit("startSimulation");
              _this3.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for delete does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().remove(selectedEdges);
        this.body.data.nodes.getDataSet().remove(selectedNodes);
        this.body.emitter.emit("startSimulation");
        this.showManipulatorToolbar();
      }
    }
    //********************************************** PRIVATE ***************************************//
    /**
     * draw or remove the DOM
     *
     * @private
     */
  }, {
    key: "_setup",
    value: function _setup() {
      if (this.options.enabled === true) {
        this.guiEnabled = true;
        this._createWrappers();
        if (this.editMode === false) {
          this._createEditButton();
        } else {
          this.showManipulatorToolbar();
        }
      } else {
        this._removeManipulationDOM();
        this.guiEnabled = false;
      }
    }
    /**
     * create the div overlays that contain the DOM
     *
     * @private
     */
  }, {
    key: "_createWrappers",
    value: function _createWrappers() {
      if (this.manipulationDiv === void 0) {
        this.manipulationDiv = document.createElement("div");
        this.manipulationDiv.className = "vis-manipulation";
        if (this.editMode === true) {
          this.manipulationDiv.style.display = "block";
        } else {
          this.manipulationDiv.style.display = "none";
        }
        this.canvas.frame.appendChild(this.manipulationDiv);
      }
      if (this.editModeDiv === void 0) {
        this.editModeDiv = document.createElement("div");
        this.editModeDiv.className = "vis-edit-mode";
        if (this.editMode === true) {
          this.editModeDiv.style.display = "none";
        } else {
          this.editModeDiv.style.display = "block";
        }
        this.canvas.frame.appendChild(this.editModeDiv);
      }
      if (this.closeDiv === void 0) {
        var _this$options$locales, _this$options$locales2;
        this.closeDiv = document.createElement("button");
        this.closeDiv.className = "vis-close";
        this.closeDiv.setAttribute("aria-label", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2["close"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales["en"]["close"]);
        this.closeDiv.style.display = this.manipulationDiv.style.display;
        this.canvas.frame.appendChild(this.closeDiv);
      }
    }
    /**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */
  }, {
    key: "_getNewTargetNode",
    value: function _getNewTargetNode(x2, y2) {
      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);
      controlNodeStyle.id = "targetNode" + v4();
      controlNodeStyle.hidden = false;
      controlNodeStyle.physics = false;
      controlNodeStyle.x = x2;
      controlNodeStyle.y = y2;
      var node2 = this.body.functions.createNode(controlNodeStyle);
      node2.shape.boundingBox = {
        left: x2,
        right: x2,
        top: y2,
        bottom: y2
      };
      return node2;
    }
    /**
     * Create the edit button
     */
  }, {
    key: "_createEditButton",
    value: function _createEditButton() {
      var _context18;
      this._clean();
      this.manipulationDOM = {};
      recursiveDOMDelete(this.editModeDiv);
      var locale = this.options.locales[this.options.locale];
      var button = this._createButton("editMode", "vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);
      this.editModeDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context18 = this.toggleEditMode).call(_context18, this));
    }
    /**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     *
     * @private
     */
  }, {
    key: "_clean",
    value: function _clean() {
      this.inMode = false;
      if (this.guiEnabled === true) {
        recursiveDOMDelete(this.editModeDiv);
        recursiveDOMDelete(this.manipulationDiv);
        this._cleanupDOMEventListeners();
      }
      this._cleanupTemporaryNodesAndEdges();
      this._unbindTemporaryUIs();
      this._unbindTemporaryEvents();
      this.body.emitter.emit("restorePhysics");
    }
    /**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     *
     * @private
     */
  }, {
    key: "_cleanupDOMEventListeners",
    value: function _cleanupDOMEventListeners() {
      var _context19;
      var _iterator = _createForOfIteratorHelper(_spliceInstanceProperty(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var callback = _step.value;
          callback();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Remove all DOM elements created by this module.
     *
     * @private
     */
  }, {
    key: "_removeManipulationDOM",
    value: function _removeManipulationDOM() {
      this._clean();
      recursiveDOMDelete(this.manipulationDiv);
      recursiveDOMDelete(this.editModeDiv);
      recursiveDOMDelete(this.closeDiv);
      if (this.manipulationDiv) {
        this.canvas.frame.removeChild(this.manipulationDiv);
      }
      if (this.editModeDiv) {
        this.canvas.frame.removeChild(this.editModeDiv);
      }
      if (this.closeDiv) {
        this.canvas.frame.removeChild(this.closeDiv);
      }
      this.manipulationDiv = void 0;
      this.editModeDiv = void 0;
      this.closeDiv = void 0;
    }
    /**
     * create a seperator line. the index is to differentiate in the manipulation dom
     *
     * @param {number} [index=1]
     * @private
     */
  }, {
    key: "_createSeperator",
    value: function _createSeperator() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      this.manipulationDOM["seperatorLineDiv" + index2] = document.createElement("div");
      this.manipulationDOM["seperatorLineDiv" + index2].className = "vis-separator-line";
      this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index2]);
    }
    // ----------------------    DOM functions for buttons    --------------------------//
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createAddNodeButton",
    value: function _createAddNodeButton(locale) {
      var _context20;
      var button = this._createButton("addNode", "vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context20 = this.addNodeMode).call(_context20, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createAddEdgeButton",
    value: function _createAddEdgeButton(locale) {
      var _context21;
      var button = this._createButton("addEdge", "vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context21 = this.addEdgeMode).call(_context21, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createEditNodeButton",
    value: function _createEditNodeButton(locale) {
      var _context22;
      var button = this._createButton("editNode", "vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context22 = this.editNode).call(_context22, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createEditEdgeButton",
    value: function _createEditEdgeButton(locale) {
      var _context23;
      var button = this._createButton("editEdge", "vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context23 = this.editEdgeMode).call(_context23, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createDeleteButton",
    value: function _createDeleteButton(locale) {
      var _context24;
      var deleteBtnClass;
      if (this.options.rtl) {
        deleteBtnClass = "vis-delete-rtl";
      } else {
        deleteBtnClass = "vis-delete";
      }
      var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context24 = this.deleteSelected).call(_context24, this));
    }
    /**
     *
     * @param {Locale} locale
     * @private
     */
  }, {
    key: "_createBackButton",
    value: function _createBackButton(locale) {
      var _context25;
      var button = this._createButton("back", "vis-back", locale["back"] || this.options.locales["en"]["back"]);
      this.manipulationDiv.appendChild(button);
      this._bindElementEvents(button, _bindInstanceProperty$1(_context25 = this.showManipulatorToolbar).call(_context25, this));
    }
    /**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: "_createButton",
    value: function _createButton(id2, className, label) {
      var labelClassName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vis-label";
      this.manipulationDOM[id2 + "Div"] = document.createElement("button");
      this.manipulationDOM[id2 + "Div"].className = "vis-button " + className;
      this.manipulationDOM[id2 + "Label"] = document.createElement("div");
      this.manipulationDOM[id2 + "Label"].className = labelClassName;
      this.manipulationDOM[id2 + "Label"].innerText = label;
      this.manipulationDOM[id2 + "Div"].appendChild(this.manipulationDOM[id2 + "Label"]);
      return this.manipulationDOM[id2 + "Div"];
    }
    /**
     *
     * @param {Label} label
     * @private
     */
  }, {
    key: "_createDescription",
    value: function _createDescription(label) {
      this.manipulationDOM["descriptionLabel"] = document.createElement("div");
      this.manipulationDOM["descriptionLabel"].className = "vis-none";
      this.manipulationDOM["descriptionLabel"].innerText = label;
      this.manipulationDiv.appendChild(this.manipulationDOM["descriptionLabel"]);
    }
    // -------------------------- End of DOM functions for buttons ------------------------------//
    /**
     * this binds an event until cleanup by the clean functions.
     *
     * @param {Event}  event   The event
     * @param {Function} newFunction
     * @private
     */
  }, {
    key: "_temporaryBindEvent",
    value: function _temporaryBindEvent(event, newFunction) {
      this.temporaryEventFunctions.push({
        event,
        boundFunction: newFunction
      });
      this.body.emitter.on(event, newFunction);
    }
    /**
     * this overrides an UI function until cleanup by the clean function
     *
     * @param {string} UIfunctionName
     * @param {Function} newFunction
     * @private
     */
  }, {
    key: "_temporaryBindUI",
    value: function _temporaryBindUI(UIfunctionName, newFunction) {
      if (this.body.eventListeners[UIfunctionName] !== void 0) {
        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
        this.body.eventListeners[UIfunctionName] = newFunction;
      } else {
        throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + _JSON$stringify(_Object$keys(this.body.eventListeners)));
      }
    }
    /**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */
  }, {
    key: "_unbindTemporaryUIs",
    value: function _unbindTemporaryUIs() {
      for (var functionName2 in this.temporaryUIFunctions) {
        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName2)) {
          this.body.eventListeners[functionName2] = this.temporaryUIFunctions[functionName2];
          delete this.temporaryUIFunctions[functionName2];
        }
      }
      this.temporaryUIFunctions = {};
    }
    /**
     * Unbind the events created by _temporaryBindEvent
     *
     * @private
     */
  }, {
    key: "_unbindTemporaryEvents",
    value: function _unbindTemporaryEvents() {
      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
        var eventName = this.temporaryEventFunctions[i].event;
        var boundFunction = this.temporaryEventFunctions[i].boundFunction;
        this.body.emitter.off(eventName, boundFunction);
      }
      this.temporaryEventFunctions = [];
    }
    /**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {Function} boundFunction
     */
  }, {
    key: "_bindElementEvents",
    value: function _bindElementEvents(domElement, boundFunction) {
      var hammer = new Hammer(domElement, {});
      onTouch(hammer, boundFunction);
      this._domEventListenerCleanupQueue.push(function() {
        hammer.destroy();
      });
      var keyupListener = function keyupListener2(_ref) {
        var keyCode = _ref.keyCode, key = _ref.key;
        if (key === "Enter" || key === " " || keyCode === 13 || keyCode === 32) {
          boundFunction();
        }
      };
      domElement.addEventListener("keyup", keyupListener, false);
      this._domEventListenerCleanupQueue.push(function() {
        domElement.removeEventListener("keyup", keyupListener, false);
      });
    }
    /**
     * Neatly clean up temporary edges and nodes
     *
     * @private
     */
  }, {
    key: "_cleanupTemporaryNodesAndEdges",
    value: function _cleanupTemporaryNodesAndEdges() {
      for (var i = 0; i < this.temporaryIds.edges.length; i++) {
        var _context26;
        this.body.edges[this.temporaryIds.edges[i]].disconnect();
        delete this.body.edges[this.temporaryIds.edges[i]];
        var indexTempEdge = _indexOfInstanceProperty(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);
        if (indexTempEdge !== -1) {
          var _context27;
          _spliceInstanceProperty(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);
        }
      }
      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
        var _context28;
        delete this.body.nodes[this.temporaryIds.nodes[_i]];
        var indexTempNode = _indexOfInstanceProperty(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);
        if (indexTempNode !== -1) {
          var _context29;
          _spliceInstanceProperty(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);
        }
      }
      this.temporaryIds = {
        nodes: [],
        edges: []
      };
    }
    // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//
    /**
     * the touch is used to get the position of the initial click
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "_controlNodeTouch",
    value: function _controlNodeTouch(event) {
      this.selectionHandler.unselectAll();
      this.lastTouch = this.body.functions.getPointer(event.center);
      this.lastTouch.translation = _Object$assign({}, this.body.view.translation);
    }
    /**
     * the drag start is used to mark one of the control nodes as selected.
     *
     * @private
     */
  }, {
    key: "_controlNodeDragStart",
    value: function _controlNodeDragStart() {
      var pointer2 = this.lastTouch;
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer2);
      var from3 = this.body.nodes[this.temporaryIds.nodes[0]];
      var to = this.body.nodes[this.temporaryIds.nodes[1]];
      var edge = this.body.edges[this.edgeBeingEditedId];
      this.selectedControlNode = void 0;
      var fromSelect = from3.isOverlappingWith(pointerObj);
      var toSelect = to.isOverlappingWith(pointerObj);
      if (fromSelect === true) {
        this.selectedControlNode = from3;
        edge.edgeType.from = from3;
      } else if (toSelect === true) {
        this.selectedControlNode = to;
        edge.edgeType.to = to;
      }
      if (this.selectedControlNode !== void 0) {
        this.selectionHandler.selectObject(this.selectedControlNode);
      }
      this.body.emitter.emit("_redraw");
    }
    /**
     * dragging the control nodes or the canvas
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "_controlNodeDrag",
    value: function _controlNodeDrag(event) {
      this.body.emitter.emit("disablePhysics");
      var pointer2 = this.body.functions.getPointer(event.center);
      var pos = this.canvas.DOMtoCanvas(pointer2);
      if (this.selectedControlNode !== void 0) {
        this.selectedControlNode.x = pos.x;
        this.selectedControlNode.y = pos.y;
      } else {
        this.interactionHandler.onDrag(event);
      }
      this.body.emitter.emit("_redraw");
    }
    /**
     * connecting or restoring the control nodes.
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "_controlNodeDragEnd",
    value: function _controlNodeDragEnd(event) {
      var pointer2 = this.body.functions.getPointer(event.center);
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer2);
      var edge = this.body.edges[this.edgeBeingEditedId];
      if (this.selectedControlNode === void 0) {
        return;
      }
      this.selectionHandler.unselectAll();
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node2 = void 0;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
          node2 = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }
      if (node2 !== void 0 && this.selectedControlNode !== void 0) {
        if (node2.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          var from3 = this.body.nodes[this.temporaryIds.nodes[0]];
          if (this.selectedControlNode.id === from3.id) {
            this._performEditEdge(node2.id, edge.to.id);
          } else {
            this._performEditEdge(edge.from.id, node2.id);
          }
        }
      } else {
        edge.updateEdgeType();
        this.body.emitter.emit("restorePhysics");
      }
      this.body.emitter.emit("_redraw");
    }
    // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
    /**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "_handleConnect",
    value: function _handleConnect(event) {
      if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 100) {
        this.lastTouch = this.body.functions.getPointer(event.center);
        this.lastTouch.translation = _Object$assign({}, this.body.view.translation);
        this.interactionHandler.drag.pointer = this.lastTouch;
        this.interactionHandler.drag.translation = this.lastTouch.translation;
        var pointer2 = this.lastTouch;
        var node2 = this.selectionHandler.getNodeAt(pointer2);
        if (node2 !== void 0) {
          if (node2.isCluster === true) {
            alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
          } else {
            var targetNode = this._getNewTargetNode(node2.x, node2.y);
            this.body.nodes[targetNode.id] = targetNode;
            this.body.nodeIndices.push(targetNode.id);
            var connectionEdge = this.body.functions.createEdge({
              id: "connectionEdge" + v4(),
              from: node2.id,
              to: targetNode.id,
              physics: false,
              smooth: {
                enabled: true,
                type: "continuous",
                roundness: 0.5
              }
            });
            this.body.edges[connectionEdge.id] = connectionEdge;
            this.body.edgeIndices.push(connectionEdge.id);
            this.temporaryIds.nodes.push(targetNode.id);
            this.temporaryIds.edges.push(connectionEdge.id);
          }
        }
        this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
      }
    }
    /**
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "_dragControlNode",
    value: function _dragControlNode(event) {
      var pointer2 = this.body.functions.getPointer(event.center);
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer2);
      var connectFromId = void 0;
      if (this.temporaryIds.edges[0] !== void 0) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      }
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node2 = void 0;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context30;
        if (_indexOfInstanceProperty(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {
          node2 = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }
      event.controlEdge = {
        from: connectFromId,
        to: node2 ? node2.id : void 0
      };
      this.selectionHandler.generateClickEvent("controlNodeDragging", event, pointer2);
      if (this.temporaryIds.nodes[0] !== void 0) {
        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]];
        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer2.x);
        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer2.y);
        this.body.emitter.emit("_redraw");
      } else {
        this.interactionHandler.onDrag(event);
      }
    }
    /**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     *
     * @param {Event}  event   The event
     * @private
     */
  }, {
    key: "_finishConnect",
    value: function _finishConnect(event) {
      var pointer2 = this.body.functions.getPointer(event.center);
      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer2);
      var connectFromId = void 0;
      if (this.temporaryIds.edges[0] !== void 0) {
        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
      }
      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
      var node2 = void 0;
      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
        var _context31;
        if (_indexOfInstanceProperty(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {
          node2 = this.body.nodes[overlappingNodeIds[i]];
          break;
        }
      }
      this._cleanupTemporaryNodesAndEdges();
      if (node2 !== void 0) {
        if (node2.isCluster === true) {
          alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
        } else {
          if (this.body.nodes[connectFromId] !== void 0 && this.body.nodes[node2.id] !== void 0) {
            this._performAddEdge(connectFromId, node2.id);
          }
        }
      }
      event.controlEdge = {
        from: connectFromId,
        to: node2 ? node2.id : void 0
      };
      this.selectionHandler.generateClickEvent("controlNodeDragEnd", event, pointer2);
      this.body.emitter.emit("_redraw");
    }
    /**
     *
     * @param {Event} event
     * @private
     */
  }, {
    key: "_dragStartEdge",
    value: function _dragStartEdge(event) {
      var pointer2 = this.lastTouch;
      this.selectionHandler.generateClickEvent("dragStart", event, pointer2, void 0, true);
    }
    // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
    // ------------------------------ Performing all the actual data manipulation ------------------------//
    /**
     * Adds a node on the specified location
     *
     * @param {object} clickData
     * @private
     */
  }, {
    key: "_performAddNode",
    value: function _performAddNode(clickData) {
      var _this4 = this;
      var defaultData = {
        id: v4(),
        x: clickData.pointer.canvas.x,
        y: clickData.pointer.canvas.y,
        label: "new"
      };
      if (typeof this.options.addNode === "function") {
        if (this.options.addNode.length === 2) {
          this.options.addNode(defaultData, function(finalizedData) {
            if (finalizedData !== null && finalizedData !== void 0 && _this4.inMode === "addNode") {
              _this4.body.data.nodes.getDataSet().add(finalizedData);
            }
            _this4.showManipulatorToolbar();
          });
        } else {
          this.showManipulatorToolbar();
          throw new Error("The function for add does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.nodes.getDataSet().add(defaultData);
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */
  }, {
    key: "_performAddEdge",
    value: function _performAddEdge(sourceNodeId, targetNodeId) {
      var _this5 = this;
      var defaultData = {
        from: sourceNodeId,
        to: targetNodeId
      };
      if (typeof this.options.addEdge === "function") {
        if (this.options.addEdge.length === 2) {
          this.options.addEdge(defaultData, function(finalizedData) {
            if (finalizedData !== null && finalizedData !== void 0 && _this5.inMode === "addEdge") {
              _this5.body.data.edges.getDataSet().add(finalizedData);
              _this5.selectionHandler.unselectAll();
              _this5.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for connect does not support two arguments (data,callback)");
        }
      } else {
        this.body.data.edges.getDataSet().add(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
    /**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */
  }, {
    key: "_performEditEdge",
    value: function _performEditEdge(sourceNodeId, targetNodeId) {
      var _this6 = this;
      var defaultData = {
        id: this.edgeBeingEditedId,
        from: sourceNodeId,
        to: targetNodeId,
        label: this.body.data.edges.get(this.edgeBeingEditedId).label
      };
      var eeFunct = this.options.editEdge;
      if (_typeof$1(eeFunct) === "object") {
        eeFunct = eeFunct.editWithoutDrag;
      }
      if (typeof eeFunct === "function") {
        if (eeFunct.length === 2) {
          eeFunct(defaultData, function(finalizedData) {
            if (finalizedData === null || finalizedData === void 0 || _this6.inMode !== "editEdge") {
              _this6.body.edges[defaultData.id].updateEdgeType();
              _this6.body.emitter.emit("_redraw");
              _this6.showManipulatorToolbar();
            } else {
              _this6.body.data.edges.getDataSet().update(finalizedData);
              _this6.selectionHandler.unselectAll();
              _this6.showManipulatorToolbar();
            }
          });
        } else {
          throw new Error("The function for edit does not support two arguments (data, callback)");
        }
      } else {
        this.body.data.edges.getDataSet().update(defaultData);
        this.selectionHandler.unselectAll();
        this.showManipulatorToolbar();
      }
    }
  }]);
  return ManipulationSystem2;
}();
var string = "string";
var bool = "boolean";
var number = "number";
var array = "array";
var object = "object";
var dom = "dom";
var any2 = "any";
var endPoints = ["arrow", "bar", "box", "circle", "crow", "curve", "diamond", "image", "inv_curve", "inv_triangle", "triangle", "vee"];
var nodeOptions = {
  borderWidth: {
    number
  },
  borderWidthSelected: {
    number,
    undefined: "undefined"
  },
  brokenImage: {
    string,
    undefined: "undefined"
  },
  chosen: {
    label: {
      boolean: bool,
      function: "function"
    },
    node: {
      boolean: bool,
      function: "function"
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  color: {
    border: {
      string
    },
    background: {
      string
    },
    highlight: {
      border: {
        string
      },
      background: {
        string
      },
      __type__: {
        object,
        string
      }
    },
    hover: {
      border: {
        string
      },
      background: {
        string
      },
      __type__: {
        object,
        string
      }
    },
    __type__: {
      object,
      string
    }
  },
  opacity: {
    number,
    undefined: "undefined"
  },
  fixed: {
    x: {
      boolean: bool
    },
    y: {
      boolean: bool
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  font: {
    align: {
      string
    },
    color: {
      string
    },
    size: {
      number
    },
    face: {
      string
    },
    background: {
      string
    },
    strokeWidth: {
      number
    },
    strokeColor: {
      string
    },
    vadjust: {
      number
    },
    multi: {
      boolean: bool,
      string
    },
    bold: {
      color: {
        string
      },
      size: {
        number
      },
      face: {
        string
      },
      mod: {
        string
      },
      vadjust: {
        number
      },
      __type__: {
        object,
        string
      }
    },
    boldital: {
      color: {
        string
      },
      size: {
        number
      },
      face: {
        string
      },
      mod: {
        string
      },
      vadjust: {
        number
      },
      __type__: {
        object,
        string
      }
    },
    ital: {
      color: {
        string
      },
      size: {
        number
      },
      face: {
        string
      },
      mod: {
        string
      },
      vadjust: {
        number
      },
      __type__: {
        object,
        string
      }
    },
    mono: {
      color: {
        string
      },
      size: {
        number
      },
      face: {
        string
      },
      mod: {
        string
      },
      vadjust: {
        number
      },
      __type__: {
        object,
        string
      }
    },
    __type__: {
      object,
      string
    }
  },
  group: {
    string,
    number,
    undefined: "undefined"
  },
  heightConstraint: {
    minimum: {
      number
    },
    valign: {
      string
    },
    __type__: {
      object,
      boolean: bool,
      number
    }
  },
  hidden: {
    boolean: bool
  },
  icon: {
    face: {
      string
    },
    code: {
      string
    },
    size: {
      number
    },
    color: {
      string
    },
    weight: {
      string,
      number
    },
    __type__: {
      object
    }
  },
  id: {
    string,
    number
  },
  image: {
    selected: {
      string,
      undefined: "undefined"
    },
    unselected: {
      string,
      undefined: "undefined"
    },
    __type__: {
      object,
      string
    }
  },
  imagePadding: {
    top: {
      number
    },
    right: {
      number
    },
    bottom: {
      number
    },
    left: {
      number
    },
    __type__: {
      object,
      number
    }
  },
  label: {
    string,
    undefined: "undefined"
  },
  labelHighlightBold: {
    boolean: bool
  },
  level: {
    number,
    undefined: "undefined"
  },
  margin: {
    top: {
      number
    },
    right: {
      number
    },
    bottom: {
      number
    },
    left: {
      number
    },
    __type__: {
      object,
      number
    }
  },
  mass: {
    number
  },
  physics: {
    boolean: bool
  },
  scaling: {
    min: {
      number
    },
    max: {
      number
    },
    label: {
      enabled: {
        boolean: bool
      },
      min: {
        number
      },
      max: {
        number
      },
      maxVisible: {
        number
      },
      drawThreshold: {
        number
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    customScalingFunction: {
      function: "function"
    },
    __type__: {
      object
    }
  },
  shadow: {
    enabled: {
      boolean: bool
    },
    color: {
      string
    },
    size: {
      number
    },
    x: {
      number
    },
    y: {
      number
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  shape: {
    string: ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]
  },
  ctxRenderer: {
    function: "function"
  },
  shapeProperties: {
    borderDashes: {
      boolean: bool,
      array
    },
    borderRadius: {
      number
    },
    interpolation: {
      boolean: bool
    },
    useImageSize: {
      boolean: bool
    },
    useBorderWithImage: {
      boolean: bool
    },
    coordinateOrigin: {
      string: ["center", "top-left"]
    },
    __type__: {
      object
    }
  },
  size: {
    number
  },
  title: {
    string,
    dom,
    undefined: "undefined"
  },
  value: {
    number,
    undefined: "undefined"
  },
  widthConstraint: {
    minimum: {
      number
    },
    maximum: {
      number
    },
    __type__: {
      object,
      boolean: bool,
      number
    }
  },
  x: {
    number
  },
  y: {
    number
  },
  __type__: {
    object
  }
};
var allOptions = {
  configure: {
    enabled: {
      boolean: bool
    },
    filter: {
      boolean: bool,
      string,
      array,
      function: "function"
    },
    container: {
      dom
    },
    showButton: {
      boolean: bool
    },
    __type__: {
      object,
      boolean: bool,
      string,
      array,
      function: "function"
    }
  },
  edges: {
    arrows: {
      to: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number
        },
        type: {
          string: endPoints
        },
        imageHeight: {
          number
        },
        imageWidth: {
          number
        },
        src: {
          string
        },
        __type__: {
          object,
          boolean: bool
        }
      },
      middle: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number
        },
        imageHeight: {
          number
        },
        src: {
          string
        },
        __type__: {
          object,
          boolean: bool
        }
      },
      from: {
        enabled: {
          boolean: bool
        },
        scaleFactor: {
          number
        },
        type: {
          string: endPoints
        },
        imageWidth: {
          number
        },
        imageHeight: {
          number
        },
        src: {
          string
        },
        __type__: {
          object,
          boolean: bool
        }
      },
      __type__: {
        string: ["from", "to", "middle"],
        object
      }
    },
    endPointOffset: {
      from: {
        number
      },
      to: {
        number
      },
      __type__: {
        object,
        number
      }
    },
    arrowStrikethrough: {
      boolean: bool
    },
    background: {
      enabled: {
        boolean: bool
      },
      color: {
        string
      },
      size: {
        number
      },
      dashes: {
        boolean: bool,
        array
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    chosen: {
      label: {
        boolean: bool,
        function: "function"
      },
      edge: {
        boolean: bool,
        function: "function"
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    color: {
      color: {
        string
      },
      highlight: {
        string
      },
      hover: {
        string
      },
      inherit: {
        string: ["from", "to", "both"],
        boolean: bool
      },
      opacity: {
        number
      },
      __type__: {
        object,
        string
      }
    },
    dashes: {
      boolean: bool,
      array
    },
    font: {
      color: {
        string
      },
      size: {
        number
      },
      face: {
        string
      },
      background: {
        string
      },
      strokeWidth: {
        number
      },
      strokeColor: {
        string
      },
      align: {
        string: ["horizontal", "top", "middle", "bottom"]
      },
      vadjust: {
        number
      },
      multi: {
        boolean: bool,
        string
      },
      bold: {
        color: {
          string
        },
        size: {
          number
        },
        face: {
          string
        },
        mod: {
          string
        },
        vadjust: {
          number
        },
        __type__: {
          object,
          string
        }
      },
      boldital: {
        color: {
          string
        },
        size: {
          number
        },
        face: {
          string
        },
        mod: {
          string
        },
        vadjust: {
          number
        },
        __type__: {
          object,
          string
        }
      },
      ital: {
        color: {
          string
        },
        size: {
          number
        },
        face: {
          string
        },
        mod: {
          string
        },
        vadjust: {
          number
        },
        __type__: {
          object,
          string
        }
      },
      mono: {
        color: {
          string
        },
        size: {
          number
        },
        face: {
          string
        },
        mod: {
          string
        },
        vadjust: {
          number
        },
        __type__: {
          object,
          string
        }
      },
      __type__: {
        object,
        string
      }
    },
    hidden: {
      boolean: bool
    },
    hoverWidth: {
      function: "function",
      number
    },
    label: {
      string,
      undefined: "undefined"
    },
    labelHighlightBold: {
      boolean: bool
    },
    length: {
      number,
      undefined: "undefined"
    },
    physics: {
      boolean: bool
    },
    scaling: {
      min: {
        number
      },
      max: {
        number
      },
      label: {
        enabled: {
          boolean: bool
        },
        min: {
          number
        },
        max: {
          number
        },
        maxVisible: {
          number
        },
        drawThreshold: {
          number
        },
        __type__: {
          object,
          boolean: bool
        }
      },
      customScalingFunction: {
        function: "function"
      },
      __type__: {
        object
      }
    },
    selectionWidth: {
      function: "function",
      number
    },
    selfReferenceSize: {
      number
    },
    selfReference: {
      size: {
        number
      },
      angle: {
        number
      },
      renderBehindTheNode: {
        boolean: bool
      },
      __type__: {
        object
      }
    },
    shadow: {
      enabled: {
        boolean: bool
      },
      color: {
        string
      },
      size: {
        number
      },
      x: {
        number
      },
      y: {
        number
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    smooth: {
      enabled: {
        boolean: bool
      },
      type: {
        string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"]
      },
      roundness: {
        number
      },
      forceDirection: {
        string: ["horizontal", "vertical", "none"],
        boolean: bool
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    title: {
      string,
      undefined: "undefined"
    },
    width: {
      number
    },
    widthConstraint: {
      maximum: {
        number
      },
      __type__: {
        object,
        boolean: bool,
        number
      }
    },
    value: {
      number,
      undefined: "undefined"
    },
    __type__: {
      object
    }
  },
  groups: {
    useDefaultGroups: {
      boolean: bool
    },
    __any__: nodeOptions,
    __type__: {
      object
    }
  },
  interaction: {
    dragNodes: {
      boolean: bool
    },
    dragView: {
      boolean: bool
    },
    hideEdgesOnDrag: {
      boolean: bool
    },
    hideEdgesOnZoom: {
      boolean: bool
    },
    hideNodesOnDrag: {
      boolean: bool
    },
    hover: {
      boolean: bool
    },
    keyboard: {
      enabled: {
        boolean: bool
      },
      speed: {
        x: {
          number
        },
        y: {
          number
        },
        zoom: {
          number
        },
        __type__: {
          object
        }
      },
      bindToWindow: {
        boolean: bool
      },
      autoFocus: {
        boolean: bool
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    multiselect: {
      boolean: bool
    },
    navigationButtons: {
      boolean: bool
    },
    selectable: {
      boolean: bool
    },
    selectConnectedEdges: {
      boolean: bool
    },
    hoverConnectedEdges: {
      boolean: bool
    },
    tooltipDelay: {
      number
    },
    zoomView: {
      boolean: bool
    },
    zoomSpeed: {
      number
    },
    __type__: {
      object
    }
  },
  layout: {
    randomSeed: {
      undefined: "undefined",
      number,
      string
    },
    improvedLayout: {
      boolean: bool
    },
    clusterThreshold: {
      number
    },
    hierarchical: {
      enabled: {
        boolean: bool
      },
      levelSeparation: {
        number
      },
      nodeSpacing: {
        number
      },
      treeSpacing: {
        number
      },
      blockShifting: {
        boolean: bool
      },
      edgeMinimization: {
        boolean: bool
      },
      parentCentralization: {
        boolean: bool
      },
      direction: {
        string: ["UD", "DU", "LR", "RL"]
      },
      sortMethod: {
        string: ["hubsize", "directed"]
      },
      shakeTowards: {
        string: ["leaves", "roots"]
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    __type__: {
      object
    }
  },
  manipulation: {
    enabled: {
      boolean: bool
    },
    initiallyActive: {
      boolean: bool
    },
    addNode: {
      boolean: bool,
      function: "function"
    },
    addEdge: {
      boolean: bool,
      function: "function"
    },
    editNode: {
      function: "function"
    },
    editEdge: {
      editWithoutDrag: {
        function: "function"
      },
      __type__: {
        object,
        boolean: bool,
        function: "function"
      }
    },
    deleteNode: {
      boolean: bool,
      function: "function"
    },
    deleteEdge: {
      boolean: bool,
      function: "function"
    },
    controlNodeStyle: nodeOptions,
    __type__: {
      object,
      boolean: bool
    }
  },
  nodes: nodeOptions,
  physics: {
    enabled: {
      boolean: bool
    },
    barnesHut: {
      theta: {
        number
      },
      gravitationalConstant: {
        number
      },
      centralGravity: {
        number
      },
      springLength: {
        number
      },
      springConstant: {
        number
      },
      damping: {
        number
      },
      avoidOverlap: {
        number
      },
      __type__: {
        object
      }
    },
    forceAtlas2Based: {
      theta: {
        number
      },
      gravitationalConstant: {
        number
      },
      centralGravity: {
        number
      },
      springLength: {
        number
      },
      springConstant: {
        number
      },
      damping: {
        number
      },
      avoidOverlap: {
        number
      },
      __type__: {
        object
      }
    },
    repulsion: {
      centralGravity: {
        number
      },
      springLength: {
        number
      },
      springConstant: {
        number
      },
      nodeDistance: {
        number
      },
      damping: {
        number
      },
      __type__: {
        object
      }
    },
    hierarchicalRepulsion: {
      centralGravity: {
        number
      },
      springLength: {
        number
      },
      springConstant: {
        number
      },
      nodeDistance: {
        number
      },
      damping: {
        number
      },
      avoidOverlap: {
        number
      },
      __type__: {
        object
      }
    },
    maxVelocity: {
      number
    },
    minVelocity: {
      number
    },
    solver: {
      string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"]
    },
    stabilization: {
      enabled: {
        boolean: bool
      },
      iterations: {
        number
      },
      updateInterval: {
        number
      },
      onlyDynamicEdges: {
        boolean: bool
      },
      fit: {
        boolean: bool
      },
      __type__: {
        object,
        boolean: bool
      }
    },
    timestep: {
      number
    },
    adaptiveTimestep: {
      boolean: bool
    },
    wind: {
      x: {
        number
      },
      y: {
        number
      },
      __type__: {
        object
      }
    },
    __type__: {
      object,
      boolean: bool
    }
  },
  //globals :
  autoResize: {
    boolean: bool
  },
  clickToUse: {
    boolean: bool
  },
  locale: {
    string
  },
  locales: {
    __any__: {
      any: any2
    },
    __type__: {
      object
    }
  },
  height: {
    string
  },
  width: {
    string
  },
  __type__: {
    object
  }
};
var configureOptions = {
  nodes: {
    borderWidth: [1, 0, 10, 1],
    borderWidthSelected: [2, 0, 10, 1],
    color: {
      border: ["color", "#2B7CE9"],
      background: ["color", "#97C2FC"],
      highlight: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      },
      hover: {
        border: ["color", "#2B7CE9"],
        background: ["color", "#D2E5FF"]
      }
    },
    opacity: [0, 0, 1, 0.1],
    fixed: {
      x: false,
      y: false
    },
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [0, 0, 50, 1],
      strokeColor: ["color", "#ffffff"]
    },
    //group: 'string',
    hidden: false,
    labelHighlightBold: true,
    //icon: {
    //  face: 'string',  //'FontAwesome',
    //  code: 'string',  //'\uf007',
    //  size: [50, 0, 200, 1],  //50,
    //  color: ['color','#2B7CE9']   //'#aa00ff'
    //},
    //image: 'string', // --> URL
    physics: true,
    scaling: {
      min: [10, 0, 200, 1],
      max: [30, 0, 200, 1],
      label: {
        enabled: false,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
    shapeProperties: {
      borderDashes: false,
      borderRadius: [6, 0, 20, 1],
      interpolation: true,
      useImageSize: false
    },
    size: [25, 0, 200, 1]
  },
  edges: {
    arrows: {
      to: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      middle: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      },
      from: {
        enabled: false,
        scaleFactor: [1, 0, 3, 0.05],
        type: "arrow"
      }
    },
    endPointOffset: {
      from: [0, -10, 10, 1],
      to: [0, -10, 10, 1]
    },
    arrowStrikethrough: true,
    color: {
      color: ["color", "#848484"],
      highlight: ["color", "#848484"],
      hover: ["color", "#848484"],
      inherit: ["from", "to", "both", true, false],
      opacity: [1, 0, 1, 0.05]
    },
    dashes: false,
    font: {
      color: ["color", "#343434"],
      size: [14, 0, 100, 1],
      face: ["arial", "verdana", "tahoma"],
      background: ["color", "none"],
      strokeWidth: [2, 0, 50, 1],
      strokeColor: ["color", "#ffffff"],
      align: ["horizontal", "top", "middle", "bottom"]
    },
    hidden: false,
    hoverWidth: [1.5, 0, 5, 0.1],
    labelHighlightBold: true,
    physics: true,
    scaling: {
      min: [1, 0, 100, 1],
      max: [15, 0, 100, 1],
      label: {
        enabled: true,
        min: [14, 0, 200, 1],
        max: [30, 0, 200, 1],
        maxVisible: [30, 0, 200, 1],
        drawThreshold: [5, 0, 20, 1]
      }
    },
    selectionWidth: [1.5, 0, 5, 0.1],
    selfReferenceSize: [20, 0, 200, 1],
    selfReference: {
      size: [20, 0, 200, 1],
      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],
      renderBehindTheNode: true
    },
    shadow: {
      enabled: false,
      color: "rgba(0,0,0,0.5)",
      size: [10, 0, 20, 1],
      x: [5, -30, 30, 1],
      y: [5, -30, 30, 1]
    },
    smooth: {
      enabled: true,
      type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
      forceDirection: ["horizontal", "vertical", "none"],
      roundness: [0.5, 0, 1, 0.05]
    },
    width: [1, 0, 30, 1]
  },
  layout: {
    //randomSeed: [0, 0, 500, 1],
    //improvedLayout: true,
    hierarchical: {
      enabled: false,
      levelSeparation: [150, 20, 500, 5],
      nodeSpacing: [100, 20, 500, 5],
      treeSpacing: [200, 20, 500, 5],
      blockShifting: true,
      edgeMinimization: true,
      parentCentralization: true,
      direction: ["UD", "DU", "LR", "RL"],
      sortMethod: ["hubsize", "directed"],
      shakeTowards: ["leaves", "roots"]
      // leaves, roots
    }
  },
  interaction: {
    dragNodes: true,
    dragView: true,
    hideEdgesOnDrag: false,
    hideEdgesOnZoom: false,
    hideNodesOnDrag: false,
    hover: false,
    keyboard: {
      enabled: false,
      speed: {
        x: [10, 0, 40, 1],
        y: [10, 0, 40, 1],
        zoom: [0.02, 0, 0.1, 5e-3]
      },
      bindToWindow: true,
      autoFocus: true
    },
    multiselect: false,
    navigationButtons: false,
    selectable: true,
    selectConnectedEdges: true,
    hoverConnectedEdges: true,
    tooltipDelay: [300, 0, 1e3, 25],
    zoomView: true,
    zoomSpeed: [1, 0.1, 2, 0.1]
  },
  manipulation: {
    enabled: false,
    initiallyActive: false
  },
  physics: {
    enabled: true,
    barnesHut: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-2e3, -3e4, 0, 50],
      centralGravity: [0.3, 0, 10, 0.05],
      springLength: [95, 0, 500, 5],
      springConstant: [0.04, 0, 1.2, 5e-3],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    forceAtlas2Based: {
      theta: [0.5, 0.1, 1, 0.05],
      gravitationalConstant: [-50, -500, 0, 1],
      centralGravity: [0.01, 0, 1, 5e-3],
      springLength: [95, 0, 500, 5],
      springConstant: [0.08, 0, 1.2, 5e-3],
      damping: [0.4, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    repulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [200, 0, 500, 5],
      springConstant: [0.05, 0, 1.2, 5e-3],
      nodeDistance: [100, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01]
    },
    hierarchicalRepulsion: {
      centralGravity: [0.2, 0, 10, 0.05],
      springLength: [100, 0, 500, 5],
      springConstant: [0.01, 0, 1.2, 5e-3],
      nodeDistance: [120, 0, 500, 5],
      damping: [0.09, 0, 1, 0.01],
      avoidOverlap: [0, 0, 1, 0.01]
    },
    maxVelocity: [50, 0, 150, 1],
    minVelocity: [0.1, 0.01, 0.5, 0.01],
    solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
    timestep: [0.5, 0.01, 1, 0.01],
    wind: {
      x: [0, -10, 10, 0.1],
      y: [0, -10, 10, 0.1]
    }
    //adaptiveTimestep: true
  }
};
var configuratorHideOption = function configuratorHideOption2(parentPath, optionName, options) {
  var _context;
  if (_includesInstanceProperty(parentPath).call(parentPath, "physics") && _includesInstanceProperty(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== "wind") {
    return true;
  }
  return false;
};
var FloydWarshall = /* @__PURE__ */ function() {
  function FloydWarshall2() {
    _classCallCheck(this, FloydWarshall2);
  }
  _createClass(FloydWarshall2, [{
    key: "getDistances",
    value: function getDistances(body, nodesArray, edgesArray) {
      var D_matrix = {};
      var edges = body.edges;
      for (var i = 0; i < nodesArray.length; i++) {
        var node2 = nodesArray[i];
        var cell = {};
        D_matrix[node2] = cell;
        for (var j2 = 0; j2 < nodesArray.length; j2++) {
          cell[nodesArray[j2]] = i == j2 ? 0 : 1e9;
        }
      }
      for (var _i = 0; _i < edgesArray.length; _i++) {
        var edge = edges[edgesArray[_i]];
        if (edge.connected === true && D_matrix[edge.fromId] !== void 0 && D_matrix[edge.toId] !== void 0) {
          D_matrix[edge.fromId][edge.toId] = 1;
          D_matrix[edge.toId][edge.fromId] = 1;
        }
      }
      var nodeCount = nodesArray.length;
      for (var k = 0; k < nodeCount; k++) {
        var knode = nodesArray[k];
        var kcolm = D_matrix[knode];
        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
          var inode = nodesArray[_i2];
          var icolm = D_matrix[inode];
          for (var _j = _i2 + 1; _j < nodeCount; _j++) {
            var jnode = nodesArray[_j];
            var jcolm = D_matrix[jnode];
            var val2 = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
            icolm[jnode] = val2;
            jcolm[inode] = val2;
          }
        }
      }
      return D_matrix;
    }
  }]);
  return FloydWarshall2;
}();
var KamadaKawai = /* @__PURE__ */ function() {
  function KamadaKawai2(body, edgeLength, edgeStrength) {
    _classCallCheck(this, KamadaKawai2);
    this.body = body;
    this.springLength = edgeLength;
    this.springConstant = edgeStrength;
    this.distanceSolver = new FloydWarshall();
  }
  _createClass(KamadaKawai2, [{
    key: "setOptions",
    value: function setOptions(options) {
      if (options) {
        if (options.springLength) {
          this.springLength = options.springLength;
        }
        if (options.springConstant) {
          this.springConstant = options.springConstant;
        }
      }
    }
    /**
     * Position the system
     *
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */
  }, {
    key: "solve",
    value: function solve(nodesArray, edgesArray) {
      var ignoreClusters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray);
      this._createL_matrix(D_matrix);
      this._createK_matrix(D_matrix);
      this._createE_matrix();
      var threshold = 0.01;
      var innerThreshold = 1;
      var iterations = 0;
      var maxIterations = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));
      var maxInnerIterations = 5;
      var maxEnergy = 1e9;
      var highE_nodeId = 0, dE_dx = 0, dE_dy = 0, delta_m = 0, subIterations = 0;
      while (maxEnergy > threshold && iterations < maxIterations) {
        iterations += 1;
        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);
        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);
        highE_nodeId = _this$_getHighestEner2[0];
        maxEnergy = _this$_getHighestEner2[1];
        dE_dx = _this$_getHighestEner2[2];
        dE_dy = _this$_getHighestEner2[3];
        delta_m = maxEnergy;
        subIterations = 0;
        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
          subIterations += 1;
          this._moveNode(highE_nodeId, dE_dx, dE_dy);
          var _this$_getEnergy = this._getEnergy(highE_nodeId);
          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);
          delta_m = _this$_getEnergy2[0];
          dE_dx = _this$_getEnergy2[1];
          dE_dy = _this$_getEnergy2[2];
        }
      }
    }
    /**
     * get the node with the highest energy
     *
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */
  }, {
    key: "_getHighestEnergyNode",
    value: function _getHighestEnergyNode(ignoreClusters) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var maxEnergy = 0;
      var maxEnergyNodeId = nodesArray[0];
      var dE_dx_max = 0, dE_dy_max = 0;
      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
        var m = nodesArray[nodeIdx];
        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {
          var _this$_getEnergy3 = this._getEnergy(m), _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3), delta_m = _this$_getEnergy4[0], dE_dx = _this$_getEnergy4[1], dE_dy = _this$_getEnergy4[2];
          if (maxEnergy < delta_m) {
            maxEnergy = delta_m;
            maxEnergyNodeId = m;
            dE_dx_max = dE_dx;
            dE_dy_max = dE_dy;
          }
        }
      }
      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
    }
    /**
     * calculate the energy of a single node
     *
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */
  }, {
    key: "_getEnergy",
    value: function _getEnergy(m) {
      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2), dE_dx = _this$E_sums$m[0], dE_dy = _this$E_sums$m[1];
      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
      return [delta_m, dE_dx, dE_dy];
    }
    /**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     *
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */
  }, {
    key: "_moveNode",
    value: function _moveNode(m, dE_dx, dE_dy) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var d2E_dx2 = 0;
      var d2E_dxdy = 0;
      var d2E_dy2 = 0;
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var km = this.K_matrix[m];
      var lm = this.L_matrix[m];
      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];
        if (i !== m) {
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var kmat = km[i];
          var lmat = lm[i];
          var denominator = 1 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
        }
      }
      var A2 = d2E_dx2, B = d2E_dxdy, C = dE_dx, D = d2E_dy2, E = dE_dy;
      var dy = (C / A2 + E / B) / (B / A2 - D / B);
      var dx = -(B * dy + C) / A2;
      nodes[m].x += dx;
      nodes[m].y += dy;
      this._updateE_matrix(m);
    }
    /**
     * Create the L matrix: edge length times shortest path
     *
     * @param {object} D_matrix
     * @private
     */
  }, {
    key: "_createL_matrix",
    value: function _createL_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeLength = this.springLength;
      this.L_matrix = [];
      for (var i = 0; i < nodesArray.length; i++) {
        this.L_matrix[nodesArray[i]] = {};
        for (var j2 = 0; j2 < nodesArray.length; j2++) {
          this.L_matrix[nodesArray[i]][nodesArray[j2]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j2]];
        }
      }
    }
    /**
     * Create the K matrix: spring constants times shortest path
     *
     * @param {object} D_matrix
     * @private
     */
  }, {
    key: "_createK_matrix",
    value: function _createK_matrix(D_matrix) {
      var nodesArray = this.body.nodeIndices;
      var edgeStrength = this.springConstant;
      this.K_matrix = [];
      for (var i = 0; i < nodesArray.length; i++) {
        this.K_matrix[nodesArray[i]] = {};
        for (var j2 = 0; j2 < nodesArray.length; j2++) {
          this.K_matrix[nodesArray[i]][nodesArray[j2]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j2]], -2);
        }
      }
    }
    /**
     *  Create matrix with all energies between nodes
     *
     *  @private
     */
  }, {
    key: "_createE_matrix",
    value: function _createE_matrix() {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      this.E_matrix = {};
      this.E_sums = {};
      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
        this.E_matrix[nodesArray[mIdx]] = [];
      }
      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
        var m = nodesArray[_mIdx];
        var x_m = nodes[m].x;
        var y_m = nodes[m].y;
        var dE_dx = 0;
        var dE_dy = 0;
        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
          var i = nodesArray[iIdx];
          if (i !== m) {
            var x_i = nodes[i].x;
            var y_i = nodes[i].y;
            var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
            dE_dx += this.E_matrix[m][iIdx][0];
            dE_dy += this.E_matrix[m][iIdx][1];
          }
        }
        this.E_sums[m] = [dE_dx, dE_dy];
      }
    }
    /**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */
  }, {
    key: "_updateE_matrix",
    value: function _updateE_matrix(m) {
      var nodesArray = this.body.nodeIndices;
      var nodes = this.body.nodes;
      var colm = this.E_matrix[m];
      var kcolm = this.K_matrix[m];
      var lcolm = this.L_matrix[m];
      var x_m = nodes[m].x;
      var y_m = nodes[m].y;
      var dE_dx = 0;
      var dE_dy = 0;
      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
        var i = nodesArray[iIdx];
        if (i !== m) {
          var cell = colm[iIdx];
          var oldDx = cell[0];
          var oldDy = cell[1];
          var x_i = nodes[i].x;
          var y_i = nodes[i].y;
          var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
          colm[iIdx] = [dx, dy];
          dE_dx += dx;
          dE_dy += dy;
          var sum = this.E_sums[i];
          sum[0] += dx - oldDx;
          sum[1] += dy - oldDy;
        }
      }
      this.E_sums[m] = [dE_dx, dE_dy];
    }
  }]);
  return KamadaKawai2;
}();
function Network(container, data2, options) {
  var _context, _context2, _context3, _context4, _this = this;
  if (!(this instanceof Network)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.options = {};
  this.defaultOptions = {
    locale: "en",
    locales,
    clickToUse: false
  };
  _Object$assign(this.options, this.defaultOptions);
  this.body = {
    container,
    // See comment above for following fields
    nodes: {},
    nodeIndices: [],
    edges: {},
    edgeIndices: [],
    emitter: {
      on: _bindInstanceProperty$1(_context = this.on).call(_context, this),
      off: _bindInstanceProperty$1(_context2 = this.off).call(_context2, this),
      emit: _bindInstanceProperty$1(_context3 = this.emit).call(_context3, this),
      once: _bindInstanceProperty$1(_context4 = this.once).call(_context4, this)
    },
    eventListeners: {
      onTap: function onTap() {
      },
      onTouch: function onTouch2() {
      },
      onDoubleTap: function onDoubleTap() {
      },
      onHold: function onHold() {
      },
      onDragStart: function onDragStart() {
      },
      onDrag: function onDrag() {
      },
      onDragEnd: function onDragEnd() {
      },
      onMouseWheel: function onMouseWheel() {
      },
      onPinch: function onPinch() {
      },
      onMouseMove: function onMouseMove() {
      },
      onRelease: function onRelease2() {
      },
      onContext: function onContext() {
      }
    },
    data: {
      nodes: null,
      // A DataSet or DataView
      edges: null
      // A DataSet or DataView
    },
    functions: {
      createNode: function createNode2() {
      },
      createEdge: function createEdge2() {
      },
      getPointer: function getPointer() {
      }
    },
    modules: {},
    view: {
      scale: 1,
      translation: {
        x: 0,
        y: 0
      }
    },
    selectionBox: {
      show: false,
      position: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      }
    }
  };
  this.bindEventListeners();
  this.images = new Images(function() {
    return _this.body.emitter.emit("_requestRedraw");
  });
  this.groups = new Groups();
  this.canvas = new Canvas(this.body);
  this.selectionHandler = new SelectionHandler(this.body, this.canvas);
  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler);
  this.view = new View(this.body, this.canvas);
  this.renderer = new CanvasRenderer(this.body, this.canvas);
  this.physics = new PhysicsEngine(this.body);
  this.layoutEngine = new LayoutEngine(this.body);
  this.clustering = new ClusterEngine(this.body);
  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler);
  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine);
  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups);
  this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05);
  this.body.modules["clustering"] = this.clustering;
  this.canvas._create();
  this.setOptions(options);
  this.setData(data2);
}
Emitter(Network.prototype);
Network.prototype.setOptions = function(options) {
  var _this2 = this;
  if (options === null) {
    options = void 0;
  }
  if (options !== void 0) {
    var errorFound2 = Validator.validate(options, allOptions);
    if (errorFound2 === true) {
      console.error("%cErrors have been found in the supplied options object.", VALIDATOR_PRINT_STYLE);
    }
    var fields = ["locale", "locales", "clickToUse"];
    selectiveDeepExtend(fields, this.options, options);
    if (options.locale !== void 0) {
      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);
    }
    options = this.layoutEngine.setOptions(options.layout, options);
    this.canvas.setOptions(options);
    this.groups.setOptions(options.groups);
    this.nodesHandler.setOptions(options.nodes);
    this.edgesHandler.setOptions(options.edges);
    this.physics.setOptions(options.physics);
    this.manipulation.setOptions(options.manipulation, options, this.options);
    this.interactionHandler.setOptions(options.interaction);
    this.renderer.setOptions(options.interaction);
    this.selectionHandler.setOptions(options.interaction);
    if (options.groups !== void 0) {
      this.body.emitter.emit("refreshNodes");
    }
    if ("configure" in options) {
      if (!this.configurator) {
        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);
      }
      this.configurator.setOptions(options.configure);
    }
    if (this.configurator && this.configurator.options.enabled === true) {
      var networkOptions = {
        nodes: {},
        edges: {},
        layout: {},
        interaction: {},
        manipulation: {},
        physics: {},
        global: {}
      };
      deepExtend(networkOptions.nodes, this.nodesHandler.options);
      deepExtend(networkOptions.edges, this.edgesHandler.options);
      deepExtend(networkOptions.layout, this.layoutEngine.options);
      deepExtend(networkOptions.interaction, this.selectionHandler.options);
      deepExtend(networkOptions.interaction, this.renderer.options);
      deepExtend(networkOptions.interaction, this.interactionHandler.options);
      deepExtend(networkOptions.manipulation, this.manipulation.options);
      deepExtend(networkOptions.physics, this.physics.options);
      deepExtend(networkOptions.global, this.canvas.options);
      deepExtend(networkOptions.global, this.options);
      this.configurator.setModuleOptions(networkOptions);
    }
    if (options.clickToUse !== void 0) {
      if (options.clickToUse === true) {
        if (this.activator === void 0) {
          this.activator = new Activator(this.canvas.frame);
          this.activator.on("change", function() {
            _this2.body.emitter.emit("activate");
          });
        }
      } else {
        if (this.activator !== void 0) {
          this.activator.destroy();
          delete this.activator;
        }
        this.body.emitter.emit("activate");
      }
    } else {
      this.body.emitter.emit("activate");
    }
    this.canvas.setSize();
    this.body.emitter.emit("startSimulation");
  }
};
Network.prototype._updateVisibleIndices = function() {
  var nodes = this.body.nodes;
  var edges = this.body.edges;
  this.body.nodeIndices = [];
  this.body.edgeIndices = [];
  for (var nodeId in nodes) {
    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {
      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
        this.body.nodeIndices.push(nodes[nodeId].id);
      }
    }
  }
  for (var edgeId in edges) {
    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {
      var edge = edges[edgeId];
      var fromNode = nodes[edge.fromId];
      var toNode = nodes[edge.toId];
      var edgeNodesPresent = fromNode !== void 0 && toNode !== void 0;
      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden
      toNode.options.hidden === false;
      if (isVisible) {
        this.body.edgeIndices.push(edge.id);
      }
    }
  }
};
Network.prototype.bindEventListeners = function() {
  var _this3 = this;
  this.body.emitter.on("_dataChanged", function() {
    _this3.edgesHandler._updateState();
    _this3.body.emitter.emit("_dataUpdated");
  });
  this.body.emitter.on("_dataUpdated", function() {
    _this3.clustering._updateState();
    _this3._updateVisibleIndices();
    _this3._updateValueRange(_this3.body.nodes);
    _this3._updateValueRange(_this3.body.edges);
    _this3.body.emitter.emit("startSimulation");
    _this3.body.emitter.emit("_requestRedraw");
  });
};
Network.prototype.setData = function(data2) {
  this.body.emitter.emit("resetPhysics");
  this.body.emitter.emit("_resetData");
  this.selectionHandler.unselectAll();
  if (data2 && data2.dot && (data2.nodes || data2.edges)) {
    throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');
  }
  this.setOptions(data2 && data2.options);
  if (data2 && data2.dot) {
    console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
    var dotData = DOTToGraph(data2.dot);
    this.setData(dotData);
    return;
  } else if (data2 && data2.gephi) {
    console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
    var gephiData = parseGephi(data2.gephi);
    this.setData(gephiData);
    return;
  } else {
    this.nodesHandler.setData(data2 && data2.nodes, true);
    this.edgesHandler.setData(data2 && data2.edges, true);
  }
  this.body.emitter.emit("_dataChanged");
  this.body.emitter.emit("_dataLoaded");
  this.body.emitter.emit("initPhysics");
};
Network.prototype.destroy = function() {
  this.body.emitter.emit("destroy");
  this.body.emitter.off();
  this.off();
  delete this.groups;
  delete this.canvas;
  delete this.selectionHandler;
  delete this.interactionHandler;
  delete this.view;
  delete this.renderer;
  delete this.physics;
  delete this.layoutEngine;
  delete this.clustering;
  delete this.manipulation;
  delete this.nodesHandler;
  delete this.edgesHandler;
  delete this.configurator;
  delete this.images;
  for (var nodeId in this.body.nodes) {
    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId))
      continue;
    delete this.body.nodes[nodeId];
  }
  for (var edgeId in this.body.edges) {
    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId))
      continue;
    delete this.body.edges[edgeId];
  }
  recursiveDOMDelete(this.body.container);
};
Network.prototype._updateValueRange = function(obj) {
  var id2;
  var valueMin = void 0;
  var valueMax = void 0;
  var valueTotal = 0;
  for (id2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, id2)) {
      var value = obj[id2].getValue();
      if (value !== void 0) {
        valueMin = valueMin === void 0 ? value : Math.min(value, valueMin);
        valueMax = valueMax === void 0 ? value : Math.max(value, valueMax);
        valueTotal += value;
      }
    }
  }
  if (valueMin !== void 0 && valueMax !== void 0) {
    for (id2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, id2)) {
        obj[id2].setValueRange(valueMin, valueMax, valueTotal);
      }
    }
  }
};
Network.prototype.isActive = function() {
  return !this.activator || this.activator.active;
};
Network.prototype.setSize = function() {
  return this.canvas.setSize.apply(this.canvas, arguments);
};
Network.prototype.canvasToDOM = function() {
  return this.canvas.canvasToDOM.apply(this.canvas, arguments);
};
Network.prototype.DOMtoCanvas = function() {
  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
};
Network.prototype.findNode = function() {
  return this.clustering.findNode.apply(this.clustering, arguments);
};
Network.prototype.isCluster = function() {
  return this.clustering.isCluster.apply(this.clustering, arguments);
};
Network.prototype.openCluster = function() {
  return this.clustering.openCluster.apply(this.clustering, arguments);
};
Network.prototype.cluster = function() {
  return this.clustering.cluster.apply(this.clustering, arguments);
};
Network.prototype.getNodesInCluster = function() {
  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
};
Network.prototype.clusterByConnection = function() {
  return this.clustering.clusterByConnection.apply(this.clustering, arguments);
};
Network.prototype.clusterByHubsize = function() {
  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
};
Network.prototype.updateClusteredNode = function() {
  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);
};
Network.prototype.getClusteredEdges = function() {
  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);
};
Network.prototype.getBaseEdge = function() {
  return this.clustering.getBaseEdge.apply(this.clustering, arguments);
};
Network.prototype.getBaseEdges = function() {
  return this.clustering.getBaseEdges.apply(this.clustering, arguments);
};
Network.prototype.updateEdge = function() {
  return this.clustering.updateEdge.apply(this.clustering, arguments);
};
Network.prototype.clusterOutliers = function() {
  return this.clustering.clusterOutliers.apply(this.clustering, arguments);
};
Network.prototype.getSeed = function() {
  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
};
Network.prototype.enableEditMode = function() {
  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
};
Network.prototype.disableEditMode = function() {
  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
};
Network.prototype.addNodeMode = function() {
  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
};
Network.prototype.editNode = function() {
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};
Network.prototype.editNodeMode = function() {
  console.warn("Deprecated: Please use editNode instead of editNodeMode.");
  return this.manipulation.editNode.apply(this.manipulation, arguments);
};
Network.prototype.addEdgeMode = function() {
  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
};
Network.prototype.editEdgeMode = function() {
  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
};
Network.prototype.deleteSelected = function() {
  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
};
Network.prototype.getPositions = function() {
  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
};
Network.prototype.getPosition = function() {
  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);
};
Network.prototype.storePositions = function() {
  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
};
Network.prototype.moveNode = function() {
  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
};
Network.prototype.getBoundingBox = function() {
  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
};
Network.prototype.getConnectedNodes = function(objectId) {
  if (this.body.nodes[objectId] !== void 0) {
    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
  } else {
    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
  }
};
Network.prototype.getConnectedEdges = function() {
  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
};
Network.prototype.startSimulation = function() {
  return this.physics.startSimulation.apply(this.physics, arguments);
};
Network.prototype.stopSimulation = function() {
  return this.physics.stopSimulation.apply(this.physics, arguments);
};
Network.prototype.stabilize = function() {
  return this.physics.stabilize.apply(this.physics, arguments);
};
Network.prototype.getSelection = function() {
  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
};
Network.prototype.setSelection = function() {
  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
};
Network.prototype.getSelectedNodes = function() {
  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);
};
Network.prototype.getSelectedEdges = function() {
  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);
};
Network.prototype.getNodeAt = function() {
  var node2 = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
  if (node2 !== void 0 && node2.id !== void 0) {
    return node2.id;
  }
  return node2;
};
Network.prototype.getEdgeAt = function() {
  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
  if (edge !== void 0 && edge.id !== void 0) {
    return edge.id;
  }
  return edge;
};
Network.prototype.selectNodes = function() {
  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
};
Network.prototype.selectEdges = function() {
  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
};
Network.prototype.unselectAll = function() {
  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);
  this.redraw();
};
Network.prototype.redraw = function() {
  return this.renderer.redraw.apply(this.renderer, arguments);
};
Network.prototype.getScale = function() {
  return this.view.getScale.apply(this.view, arguments);
};
Network.prototype.getViewPosition = function() {
  return this.view.getViewPosition.apply(this.view, arguments);
};
Network.prototype.fit = function() {
  return this.view.fit.apply(this.view, arguments);
};
Network.prototype.moveTo = function() {
  return this.view.moveTo.apply(this.view, arguments);
};
Network.prototype.focus = function() {
  return this.view.focus.apply(this.view, arguments);
};
Network.prototype.releaseNode = function() {
  return this.view.releaseNode.apply(this.view, arguments);
};
Network.prototype.getOptionsFromConfigurator = function() {
  var options = {};
  if (this.configurator) {
    options = this.configurator.getOptions.apply(this.configurator);
  }
  return options;
};
const _hoisted_1$2 = { class: "relative flex flex-col bg-[#F9FAFB] rounded-xl overflow-hidden" };
const _hoisted_2$2 = { class: "flex-none h-12 bg-[#F5F5F5] flex-center gap-5" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "vis",
  setup(__props) {
    const containerRef = ref(null);
    const network = ref(null);
    const zoomIn = () => {
      if (network.value) {
        const scale = network.value.getScale() * 1.2;
        network.value.moveTo({
          scale
        });
      }
    };
    const zoomOut = () => {
      if (network.value) {
        const scale = network.value.getScale() * 0.8;
        network.value.moveTo({
          scale
        });
      }
    };
    onMounted(() => {
      const groups = {
        center: { color: { background: "#9E9E9E", border: "#757575" }, shape: "circle" },
        blue: { color: { background: "#4285F4", border: "#3367D6" }, shape: "circle" },
        red: { color: { background: "#EA4335", border: "#C62828" }, shape: "circle" },
        green: { color: { background: "#34A853", border: "#2E7D32" }, shape: "circle" },
        orange: { color: { background: "#FBBC05", border: "#F57F17" }, shape: "circle" }
      };
      var nodes = new DataSet([
        { id: 1, label: "一页爆火的...", group: "center" },
        { id: 2, label: "应用案例", group: "red" },
        { id: 3, label: "规划需求", group: "red" },
        { id: 4, label: "部分问题", group: "red" },
        { id: 5, label: "流程步骤", group: "green" },
        { id: 6, label: "入境要求", group: "green" },
        { id: 7, label: "相关文件", group: "green" },
        { id: 8, label: "城市景点", group: "green" },
        { id: 9, label: "对应文件", group: "green" },
        { id: 10, label: "任务处理", group: "orange" },
        { id: 11, label: "求婚地点", group: "orange" },
        { id: 12, label: "旅行贴士", group: "orange" },
        { id: 13, label: "旅行手册", group: "orange" },
        { id: 14, label: "手册要求", group: "blue" },
        { id: 15, label: "规划需求", group: "blue" },
        { id: 16, label: "成果分析", group: "blue" }
      ]);
      var edges = new DataSet([
        { from: 1, to: 2 },
        { from: 1, to: 3, hidden: true },
        // 图中未显示此连接
        { from: 1, to: 5 },
        { from: 1, to: 10 },
        { from: 1, to: 16 },
        { from: 2, to: 4 },
        { from: 2, to: 3 },
        { from: 5, to: 6 },
        { from: 5, to: 7 },
        { from: 5, to: 8 },
        { from: 5, to: 9 },
        { from: 10, to: 11 },
        { from: 10, to: 12 },
        { from: 10, to: 13 },
        { from: 16, to: 14 },
        { from: 16, to: 15 }
      ]);
      var options = {
        groups,
        physics: {
          hierarchicalRepulsion: {
            nodeDistance: 150
          },
          stabilization: true
        },
        nodes: {
          size: 30,
          font: {
            size: 14,
            color: "#576D9C",
            face: "Arial",
            vadjust: 50
            // 垂直调整，使文字位于节点下方
          },
          borderWidth: 0
        },
        edges: {
          width: 2,
          color: {
            color: "#c8c8c8",
            highlight: "#848484"
          },
          smooth: {
            type: "continuous"
          }
        }
        // interaction: {
        //   hover: true,
        //   navigationButtons: true,
        //   keyboard: true
        // }
      };
      var data2 = {
        nodes,
        edges
      };
      network.value = new Network(containerRef.value, data2, options);
    });
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", {
          class: "flex-1 bg-[#F9FAFB]",
          ref_key: "containerRef",
          ref: containerRef
        }, null, 512),
        createBaseVNode("div", _hoisted_2$2, [
          createVNode(_component_el_icon, {
            class: "cursor-pointer",
            size: "18",
            onClick: zoomOut
          }, {
            default: withCtx(() => [
              createVNode(unref(zoom_out_default))
            ]),
            _: 1
          }),
          createVNode(_component_el_icon, {
            class: "cursor-pointer",
            size: "18",
            onClick: zoomIn
          }, {
            default: withCtx(() => [
              createVNode(unref(zoom_in_default))
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});
const _hoisted_1$1 = { class: "w-4/5 min-h-full mx-auto bg-white px-5 shadow-lg" };
const _hoisted_2$1 = { class: "py-10" };
const _hoisted_3$1 = { class: "flex items-center justify-end mt-6 space-x-3" };
const _hoisted_4$1 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_5 = { class: "text-sm" };
const _hoisted_6 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_7 = { class: "text-sm" };
const _hoisted_8 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_9 = { class: "text-sm" };
const _hoisted_10 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_11 = { class: "text-sm" };
const _hoisted_12 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_13 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_14 = {
  key: 0,
  class: "py-10"
};
const _hoisted_15 = { class: "flex items-center justify-end mt-6 space-x-3" };
const _hoisted_16 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_17 = { class: "text-sm" };
const _hoisted_18 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_19 = { class: "text-sm" };
const _hoisted_20 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_21 = { class: "text-sm" };
const _hoisted_22 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_23 = { class: "text-sm" };
const _hoisted_24 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_25 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_26 = {
  key: 1,
  class: "py-10"
};
const _hoisted_27 = { class: "flex items-center justify-end mt-6 space-x-3" };
const _hoisted_28 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_29 = { class: "text-sm" };
const _hoisted_30 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_31 = { class: "text-sm" };
const _hoisted_32 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_33 = { class: "text-sm" };
const _hoisted_34 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_35 = { class: "text-sm" };
const _hoisted_36 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_37 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_38 = {
  key: 2,
  class: "py-10"
};
const _hoisted_39 = { class: "flex items-center justify-end mt-6 space-x-3" };
const _hoisted_40 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_41 = { class: "text-sm" };
const _hoisted_42 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_43 = { class: "text-sm" };
const _hoisted_44 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_45 = { class: "text-sm" };
const _hoisted_46 = { class: "flex items-center gap-1.5 text-[#4F5052] px-1 cursor-pointer" };
const _hoisted_47 = { class: "text-sm" };
const _hoisted_48 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_49 = { class: "flex items-center text-[#4F5052] cursor-pointer" };
const _hoisted_50 = { class: "fixed left-1/2 -translate-x-1/2 bottom-6 h-[78px] px-[60px] bg-[#FFFFFF] rounded-lg flex items-center gap-5 shadow-md" };
const _hoisted_51 = { class: "w-[134px] h-11 flex-center gap-2.5 border rounded cursor-pointer" };
const _hoisted_52 = { class: "size-6 rounded-full flex-center bg-[#F0F3FA]" };
const _hoisted_53 = { class: "w-[134px] h-11 flex-center gap-2.5 border rounded cursor-pointer" };
const _hoisted_54 = { class: "size-6 rounded-full flex-center bg-[#FFF0F0]" };
const _hoisted_55 = { class: "w-[134px] h-11 flex-center gap-2.5 border rounded cursor-pointer" };
const _hoisted_56 = { class: "size-6 rounded-full flex-center bg-[#F3FBF5]" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "summarize",
  setup(__props) {
    const visibles = ref(["1", "2", "3"]);
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_svg_icon = resolveComponent("svg-icon");
      return openBlock(), createElementBlock(Fragment$1, null, [
        createBaseVNode("div", _hoisted_1$1, [
          createBaseVNode("div", _hoisted_2$1, [
            _cache[2] || (_cache[2] = createStaticVNode('<h3 class="mb-9 text-center"><span class="text-2xl font-semibold text-[#1D1E1F]">知识要点</span><div class="w-[96px] h-3 bg-[#E0EAFF] mx-auto -mt-2"></div></h3><ul class="space-y-4 text-gray-700"><li class="flex items-start"><div class="flex-shrink-0 mt-1"><div class="w-2 h-2 bg-blue-500 rounded-full"></div></div><p class="ml-3"> Manus 上线及效果惊人：Manus 咋晚 10 点上线，效果非常惊人，可通过案例看其实现效果。 </p></li><li class="flex items-start"><div class="flex-shrink-0 mt-1"><div class="w-2 h-2 bg-blue-500 rounded-full"></div></div><div class="ml-3"><p class="mb-2"> 用户需求：用户为自己和未婚妻制定 4 月 15 - 23 日从西雅图出发的日本 7 天行程，预算 2500 - 5000 美元，热爱历史遗迹、小众景点和日本文化（创造、茶道、美食）。希望参观奈良小鹿并能步行探索城市，计划深挖并需特殊场地推荐，要求提供详细行程安排及简易 HTML 版旅行手册，包含地图标注、景点说明、实用日语短语和全程旅行贴士。 </p></div></li><li class="flex items-start"><div class="flex-shrink-0 mt-1"><div class="w-2 h-2 bg-blue-500 rounded-full"></div></div><div class="ml-3"><p class="mb-2">Manus 执行任务的 8 步流程：</p><ol class="list-decimal ml-5 space-y-2"><li>研究日本旅游基础信息和人境要求，创建 japan_trip 文件夹及 todo.md 文件。</li><li>创建旅行准备清单，创建 japan_trip/todo.md 文件。</li><li> 研究与旅行者兴趣相匹配的城市和景点，对任务拆解，用多个关键词搜索和信息汇总，遇到 CAPTCHA 验证会询问用户，继续收集小众景点、历史遗迹等信息。 </li><li> 制定全面的 7 天行程规划，创建日本旅行 / 日本研究.md、编辑日本旅行 / 待办事项.md、创建日本旅行 / 7 天行程.md。 </li></ol></div></li><li class="flex items-start"><div class="flex-shrink-0 mt-1"><div class="w-2 h-2 bg-blue-500 rounded-full"></div></div><p class="ml-3"> 行程合理性分析：通过谷歌地图分析行程合理性，发现部分行程存在景点过多、距离远、路线规划不合理等问题，但总体来说 Manus 的表现还算十分惊人。 </p></li></ul>', 2)),
            createBaseVNode("div", _hoisted_3$1, [
              _cache[0] || (_cache[0] = createBaseVNode("div", { class: "flex-1 h-px bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_4$1, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(copy_document_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_5, toDisplayString(_ctx.$t("action.copy")), 1)
              ]),
              createBaseVNode("div", _hoisted_6, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(refresh_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_7, toDisplayString(_ctx.$t("chat.regenerate")), 1)
              ]),
              createBaseVNode("div", _hoisted_8, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(share_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_9, toDisplayString(_ctx.$t("action.share")), 1)
              ]),
              createBaseVNode("div", _hoisted_10, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(star_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_11, toDisplayString(_ctx.$t("action.favorite")), 1)
              ]),
              _cache[1] || (_cache[1] = createBaseVNode("div", { class: "w-px h-3 bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_12, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "like"
                })
              ]),
              createBaseVNode("div", _hoisted_13, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "dislike"
                })
              ])
            ])
          ]),
          visibles.value.includes("1") ? (openBlock(), createElementBlock("div", _hoisted_14, [
            _cache[5] || (_cache[5] = createStaticVNode('<h3 class="mb-9 text-center"><span class="text-2xl font-semibold text-[#1D1E1F]">Q&amp;A问答</span><div class="w-[96px] h-3 bg-[#E0EAFF] mx-auto -mt-2"></div></h3><div class="space-y-6"><div class="border-b pb-6"><div class="flex items-start mb-3"><div class="flex-none text-base bg-[#EEF3FE] text-[#2563EB] w-12 h-7 rounded flex-center mr-2"> 问题 </div><div class="text-base text-[#1D1E1F]"> 要上晚班吗? 每天工作几个小时? 每周休息几天? 每月休息几天? </div></div><div class="flex items-start"><div class="flex-none text-base bg-green-100 text-green-600 w-12 h-7 rounded flex-center mr-2"> 回答 </div><div class="text-base text-[#1D1E1F]"> 我们有长白班也有两班制，如果你不想上夜班也可以自己选择长白班，每天工作10-12小时，具体看部门安排，长白班加班的时长会多一点，但是也是自由加班的哦，不会强制性的，每工作两个小时可以休息十分钟，中午下午也各有一个小时的吃饭休息时间哦。 </div></div></div><div class="border-b pb-6"><div class="flex items-start mb-3"><div class="flex-none text-base bg-[#EEF3FE] text-[#2563EB] w-12 h-7 rounded flex-center mr-2"> 问题 </div><div class="text-base text-[#1D1E1F]"> 要上晚班吗? 每天工作几个小时? 每周休息几天? 每月休息几天? </div></div><div class="flex items-start"><div class="flex-none text-base bg-green-100 text-green-600 w-12 h-7 rounded flex-center mr-2"> 回答 </div><div class="text-base text-[#1D1E1F]"> 我们有长白班也有两班制，如果你不想上夜班也可以自己选择长白班，每天工作10-12小时，具体看部门安排，长白班加班的时长会多一点，但是也是自由加班的哦，不会强制性的，每工作两个小时可以休息十分钟，中午下午也各有一个小时的吃饭休息时间哦。 </div></div></div><div class=""><div class="flex items-start mb-3"><div class="flex-none text-base bg-[#EEF3FE] text-[#2563EB] px-2 py-1 rounded flex-center mr-2"> 问题 </div><div class="text-base text-[#1D1E1F]"> 要上晚班吗? 每天工作几个小时? 每周休息几天? 每月休息几天? </div></div><div class="flex items-start"><div class="flex-none bg-green-100 text-green-600 px-2 py-1 rounded text-base flex-center mr-2"> 回答 </div><div class="text-base text-[#1D1E1F]"> 我们有长白班也有两班制，如果你不想上夜班也可以自己选择长白班，每天工作10-12小时，具体看部门安排，长白班加班的时长会多一点，但是也是自由加班的哦，不会强制性的，每工作两个小时可以休息十分钟，中午下午也各有一个小时的吃饭休息时间哦。 </div></div></div></div>', 2)),
            createBaseVNode("div", _hoisted_15, [
              _cache[3] || (_cache[3] = createBaseVNode("div", { class: "flex-1 h-px bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_16, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(copy_document_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_17, toDisplayString(_ctx.$t("action.copy")), 1)
              ]),
              createBaseVNode("div", _hoisted_18, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(refresh_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_19, toDisplayString(_ctx.$t("chat.regenerate")), 1)
              ]),
              createBaseVNode("div", _hoisted_20, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(share_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_21, toDisplayString(_ctx.$t("action.share")), 1)
              ]),
              createBaseVNode("div", _hoisted_22, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(star_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_23, toDisplayString(_ctx.$t("action.favorite")), 1)
              ]),
              _cache[4] || (_cache[4] = createBaseVNode("div", { class: "w-px h-3 bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_24, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "like"
                })
              ]),
              createBaseVNode("div", _hoisted_25, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "dislike"
                })
              ])
            ])
          ])) : createCommentVNode("", true),
          visibles.value.includes("2") ? (openBlock(), createElementBlock("div", _hoisted_26, [
            _cache[8] || (_cache[8] = createBaseVNode("h3", { class: "mb-9 text-center" }, [
              createBaseVNode("span", { class: "text-2xl font-semibold text-[#1D1E1F]" }, "思维导图"),
              createBaseVNode("div", { class: "w-[96px] h-3 bg-[#E0EAFF] mx-auto -mt-2" })
            ], -1)),
            createVNode(MarkMap, { class: "h-[664px]" }),
            createBaseVNode("div", _hoisted_27, [
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "flex-1 h-px bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_28, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(copy_document_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_29, toDisplayString(_ctx.$t("action.copy")), 1)
              ]),
              createBaseVNode("div", _hoisted_30, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(refresh_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_31, toDisplayString(_ctx.$t("chat.regenerate")), 1)
              ]),
              createBaseVNode("div", _hoisted_32, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(share_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_33, toDisplayString(_ctx.$t("action.share")), 1)
              ]),
              createBaseVNode("div", _hoisted_34, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(star_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_35, toDisplayString(_ctx.$t("action.favorite")), 1)
              ]),
              _cache[7] || (_cache[7] = createBaseVNode("div", { class: "w-px h-3 bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_36, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "like"
                })
              ]),
              createBaseVNode("div", _hoisted_37, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "dislike"
                })
              ])
            ])
          ])) : createCommentVNode("", true),
          visibles.value.includes("3") ? (openBlock(), createElementBlock("div", _hoisted_38, [
            _cache[11] || (_cache[11] = createBaseVNode("h3", { class: "mb-9 text-center" }, [
              createBaseVNode("span", { class: "text-2xl font-semibold text-[#1D1E1F]" }, "知识图谱"),
              createBaseVNode("div", { class: "w-[96px] h-3 bg-[#E0EAFF] mx-auto -mt-2" })
            ], -1)),
            createVNode(_sfc_main$2, { class: "h-[684px]" }),
            createBaseVNode("div", _hoisted_39, [
              _cache[9] || (_cache[9] = createBaseVNode("div", { class: "flex-1 h-px bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_40, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(copy_document_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_41, toDisplayString(_ctx.$t("action.copy")), 1)
              ]),
              createBaseVNode("div", _hoisted_42, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(refresh_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_43, toDisplayString(_ctx.$t("chat.regenerate")), 1)
              ]),
              createBaseVNode("div", _hoisted_44, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(share_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_45, toDisplayString(_ctx.$t("action.share")), 1)
              ]),
              createBaseVNode("div", _hoisted_46, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    createVNode(unref(star_default))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", _hoisted_47, toDisplayString(_ctx.$t("action.favorite")), 1)
              ]),
              _cache[10] || (_cache[10] = createBaseVNode("div", { class: "w-px h-3 bg-[#E6E8EB]" }, null, -1)),
              createBaseVNode("div", _hoisted_48, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "like"
                })
              ]),
              createBaseVNode("div", _hoisted_49, [
                createVNode(_component_svg_icon, {
                  size: "18",
                  name: "dislike"
                })
              ])
            ])
          ])) : createCommentVNode("", true),
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "h-[122px]" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_50, [
          _cache[16] || (_cache[16] = createBaseVNode("div", { class: "text-base text-[#1D1E1F] whitespace-nowrap" }, "还可以这些操作：", -1)),
          createBaseVNode("div", _hoisted_51, [
            createBaseVNode("div", _hoisted_52, [
              createVNode(_component_svg_icon, {
                name: "question",
                color: "#2D6EFA"
              })
            ]),
            _cache[13] || (_cache[13] = createBaseVNode("span", { class: "text-base text-[#4F5052]" }, "Q&A 问答", -1))
          ]),
          createBaseVNode("div", _hoisted_53, [
            createBaseVNode("div", _hoisted_54, [
              createVNode(_component_svg_icon, {
                name: "sitemap",
                color: "#FF4D4D"
              })
            ]),
            _cache[14] || (_cache[14] = createBaseVNode("span", { class: "text-base text-[#4F5052]" }, "思维导图", -1))
          ]),
          createBaseVNode("div", _hoisted_55, [
            createBaseVNode("div", _hoisted_56, [
              createVNode(_component_svg_icon, {
                name: "live-photo",
                color: "#35BE57"
              })
            ]),
            _cache[15] || (_cache[15] = createBaseVNode("span", { class: "text-base text-[#4F5052]" }, "知识图谱", -1))
          ])
        ])
      ], 64);
    };
  }
});
const _hoisted_1 = { class: "h-full flex flex-col" };
const _hoisted_2 = { class: "flex-none h-16 flex-center bg-white" };
const _hoisted_3 = ["onClick"];
const _hoisted_4 = { class: "text-base" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    content: { default: "" }
  },
  setup(__props) {
    const menus = ref([
      {
        label: window.$t("clean.content"),
        value: "content"
      },
      {
        label: window.$t("clean.knowledge"),
        value: "knowledge"
      },
      {
        label: window.$t("clean.summarize"),
        value: "summarize"
      }
    ]);
    const type = ref("content");
    return (_ctx, _cache) => {
      const _component_svg_icon = resolveComponent("svg-icon");
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList(menus.value, (item) => {
            return openBlock(), createElementBlock("div", {
              key: item.value,
              class: normalizeClass(["h-9 rounded-full flex-center gap-2 px-6 cursor-pointer", [item.value === type.value ? "text-[#2563EB] shadow" : "text-[#4F5052]"]]),
              onClick: ($event) => type.value = item.value
            }, [
              createVNode(_component_svg_icon, {
                name: "inbox",
                size: "16"
              }),
              createBaseVNode("span", _hoisted_4, toDisplayString(item.label), 1)
            ], 10, _hoisted_3);
          }), 128))
        ]),
        createVNode(_sfc_main$7, {
          class: "flex-1 mt-5 overflow-y-auto",
          name: "content",
          value: type.value
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$6, { content: _ctx.content }, null, 8, ["content"])
          ]),
          _: 1
        }, 8, ["value"]),
        createVNode(_sfc_main$7, {
          class: "flex-1 mt-5 overflow-y-auto",
          name: "knowledge",
          value: type.value
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$4, {
              content: _ctx.content,
              type: "html"
            }, null, 8, ["content"])
          ]),
          _: 1
        }, 8, ["value"]),
        createVNode(_sfc_main$7, {
          class: "flex-1 mt-5 overflow-y-auto",
          name: "summarize",
          value: type.value
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$1, {
              content: _ctx.content,
              type: "html"
            }, null, 8, ["content"])
          ]),
          _: 1
        }, 8, ["value"])
      ]);
    };
  }
});
export {
  _sfc_main as default
};
